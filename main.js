/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ (function(module) {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/

module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ (function(module) {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ addLeadingZeros; }
/* harmony export */ });
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/assign/index.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/assign/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ assign; }
/* harmony export */ });
function assign(target, dirtyObject) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }

  dirtyObject = dirtyObject || {};

  for (var property in dirtyObject) {
    if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
      target[property] = dirtyObject[property];
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/formatters/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/formatters/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../_lib/getUTCDayOfYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js");
/* harmony import */ var _lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../_lib/getUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js");
/* harmony import */ var _lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../_lib/getUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js");
/* harmony import */ var _lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../_lib/getUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js");
/* harmony import */ var _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
/* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");
/* harmony import */ var _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lightFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js");







var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

var formatters = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function y(date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = (0,_lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = (0,_lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date); // Padding

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function M(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = (0,_lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = (0,_lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeek, token.length);
  },
  // Day of the month
  d: function d(date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = (0,_lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function a(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function h(date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].h(date, token);
  },
  // Hour [0-23]
  H: function H(date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
  },
  // Minute
  m: function m(date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].m(date, token);
  },
  // Second
  s: function s(date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].s(date, token);
  },
  // Fraction of second
  S: function S(date, token) {
    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.floor(absOffset / 60), 2);
  var minutes = (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

/* harmony default export */ __webpack_exports__["default"] = (formatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters = {
  // Year
  y: function y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fractionalSeconds, token.length);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (formatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/longFormatters/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
}

function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
}

function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
}

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
/* harmony default export */ __webpack_exports__["default"] = (longFormatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getTimezoneOffsetInMilliseconds; }
/* harmony export */ });
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getUTCDayOfYear; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCDayOfYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getUTCISOWeek; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
/* harmony import */ var _startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");




var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeek(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var diff = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date).getTime() - (0,_startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getUTCISOWeekYear; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeekYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCWeek/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getUTCWeek; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");




var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeek(dirtyDate, options) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var diff = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, options).getTime() - (0,_startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getUTCWeekYear; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");



 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeekYear(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeekOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/protectedTokens/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isProtectedDayOfYearToken": function() { return /* binding */ isProtectedDayOfYearToken; },
/* harmony export */   "isProtectedWeekYearToken": function() { return /* binding */ isProtectedWeekYearToken; },
/* harmony export */   "throwProtectedError": function() { return /* binding */ throwProtectedError; }
/* harmony export */ });
var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/requiredArgs/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ requiredArgs; }
/* harmony export */ });
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/setUTCDay/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/setUTCDay/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ setUTCDay; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  var day = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/setUTCISODay/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/setUTCISODay/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ setUTCISODay; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISODay(dirtyDate, dirtyDay) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var day = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ setUTCISOWeek; }
/* harmony export */ });
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../getUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var isoWeek = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyISOWeek);
  var diff = (0,_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/setUTCWeek/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/setUTCWeek/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ setUTCWeek; }
/* harmony export */ });
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../getUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var week = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyWeek);
  var diff = (0,_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ startOfUTCISOWeek; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");

 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeek(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var weekStartsOn = 1;
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ startOfUTCISOWeekYear; }
/* harmony export */ });
/* harmony import */ var _getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeekYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var year = (0,_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuary);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ startOfUTCWeek; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ startOfUTCWeekYear; }
/* harmony export */ });
/* harmony import */ var _getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");



 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.firstWeekContainsDate);
  var year = (0,_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeek, dirtyOptions);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/toInteger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/toInteger/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ toInteger; }
/* harmony export */ });
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/add/index.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/esm/add/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ add; }
/* harmony export */ });
/* harmony import */ var _addDays_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../addDays/index.js */ "./node_modules/date-fns/esm/addDays/index.js");
/* harmony import */ var _addMonths_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../addMonths/index.js */ "./node_modules/date-fns/esm/addMonths/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }






/**
 * @name add
 * @category Common Helpers
 * @summary Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @description
 * Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Duration} duration - the object with years, months, weeks, days, hours, minutes and seconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 *
 * | Key            | Description                        |
 * |----------------|------------------------------------|
 * | years          | Amount of years to be added        |
 * | months         | Amount of months to be added       |
 * | weeks          | Amount of weeks to be added        |
 * | days           | Amount of days to be added         |
 * | hours          | Amount of hours to be added        |
 * | minutes        | Amount of minutes to be added      |
 * | seconds        | Amount of seconds to be added      |
 *
 * All values default to 0
 *
 * @returns {Date} the new date with the seconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add the following duration to 1 September 2014, 10:19:50
 * const result = add(new Date(2014, 8, 1, 10, 19, 50), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30,
 * })
 * //=> Thu Jun 15 2017 15:29:20
 */

function add(dirtyDate, duration) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  if (!duration || _typeof(duration) !== 'object') return new Date(NaN);
  var years = duration.years ? (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(duration.years) : 0;
  var months = duration.months ? (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(duration.months) : 0;
  var weeks = duration.weeks ? (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(duration.weeks) : 0;
  var days = duration.days ? (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(duration.days) : 0;
  var hours = duration.hours ? (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(duration.hours) : 0;
  var minutes = duration.minutes ? (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(duration.minutes) : 0;
  var seconds = duration.seconds ? (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(duration.seconds) : 0; // Add years and months

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  var dateWithMonths = months || years ? (0,_addMonths_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, months + years * 12) : date; // Add weeks and days

  var dateWithDays = days || weeks ? (0,_addDays_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(dateWithMonths, days + weeks * 7) : dateWithMonths; // Add days, hours, minutes and seconds

  var minutesToAdd = minutes + hours * 60;
  var secondsToAdd = seconds + minutesToAdd * 60;
  var msToAdd = secondsToAdd * 1000;
  var finalDate = new Date(dateWithDays.getTime() + msToAdd);
  return finalDate;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/addDays/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/esm/addDays/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ addDays; }
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} - the new date with the days added
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */

function addDays(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  date.setDate(date.getDate() + amount);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/addMilliseconds/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/addMilliseconds/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ addMilliseconds; }
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var timestamp = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate).getTime();
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);
  return new Date(timestamp + amount);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/addMonths/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/addMonths/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ addMonths; }
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */

function addMonths(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.

  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();

  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/constants/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/constants/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "daysInWeek": function() { return /* binding */ daysInWeek; },
/* harmony export */   "maxTime": function() { return /* binding */ maxTime; },
/* harmony export */   "millisecondsInHour": function() { return /* binding */ millisecondsInHour; },
/* harmony export */   "millisecondsInMinute": function() { return /* binding */ millisecondsInMinute; },
/* harmony export */   "millisecondsInSecond": function() { return /* binding */ millisecondsInSecond; },
/* harmony export */   "minTime": function() { return /* binding */ minTime; },
/* harmony export */   "minutesInHour": function() { return /* binding */ minutesInHour; },
/* harmony export */   "monthsInQuarter": function() { return /* binding */ monthsInQuarter; },
/* harmony export */   "monthsInYear": function() { return /* binding */ monthsInYear; },
/* harmony export */   "quartersInYear": function() { return /* binding */ quartersInYear; },
/* harmony export */   "secondsInHour": function() { return /* binding */ secondsInHour; },
/* harmony export */   "secondsInMinute": function() { return /* binding */ secondsInMinute; }
/* harmony export */ });
/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
var daysInWeek = 7;
/**
 * Maximum allowed time.
 *
 * @name maxTime
 * @constant
 * @type {number}
 * @default
 */

var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInMinute = 60000;
/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInHour = 3600000;
/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInSecond = 1000;
/**
 * Minimum allowed time.
 *
 * @name minTime
 * @constant
 * @type {number}
 * @default
 */

var minTime = -maxTime;
/**
 * Minutes in 1 hour
 *
 * @name minutesInHour
 * @constant
 * @type {number}
 * @default
 */

var minutesInHour = 60;
/**
 * Months in 1 quarter
 *
 * @name monthsInQuarter
 * @constant
 * @type {number}
 * @default
 */

var monthsInQuarter = 3;
/**
 * Months in 1 year
 *
 * @name monthsInYear
 * @constant
 * @type {number}
 * @default
 */

var monthsInYear = 12;
/**
 * Quarters in 1 year
 *
 * @name quartersInYear
 * @constant
 * @type {number}
 * @default
 */

var quartersInYear = 4;
/**
 * Seconds in 1 hour
 *
 * @name secondsInHour
 * @constant
 * @type {number}
 * @default
 */

var secondsInHour = 3600;
/**
 * Seconds in 1 minute
 *
 * @name secondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var secondsInMinute = 60;

/***/ }),

/***/ "./node_modules/date-fns/esm/endOfDay/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/esm/endOfDay/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ endOfDay; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */

function endOfDay(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/format/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/format/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ format; }
/* harmony export */ });
/* harmony import */ var _isValid_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../isValid/index.js */ "./node_modules/date-fns/esm/isValid/index.js");
/* harmony import */ var _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../locale/en-US/index.js */ "./node_modules/date-fns/esm/locale/en-US/index.js");
/* harmony import */ var _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../subMilliseconds/index.js */ "./node_modules/date-fns/esm/subMilliseconds/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_lib/format/formatters/index.js */ "./node_modules/date-fns/esm/_lib/format/formatters/index.js");
/* harmony import */ var _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_lib/format/longFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js");
/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../_lib/getTimezoneOffsetInMilliseconds/index.js */ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js");
/* harmony import */ var _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_lib/protectedTokens/index.js */ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");









 // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The second argument is now required for the sake of explicitness.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   format(new Date(2016, 0, 1))
 *
 *   // v2.0.0 onward
 *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
 *   ```
 *
 * - New format string API for `format` function
 *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
 *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
 *
 * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale = options.locale || _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);

  if (!(0,_isValid_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = (0,_lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(originalDate);
  var utcDate = (0,_subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_7__["default"][firstCharacter];
      return longFormatter(substring, locale.formatLong, formatterOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }

    var formatter = _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_8__["default"][firstCharacter];

    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.isProtectedWeekYearToken)(substring)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.throwProtectedError)(substring, dirtyFormatStr, dirtyDate);
      }

      if (!options.useAdditionalDayOfYearTokens && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.isProtectedDayOfYearToken)(substring)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.throwProtectedError)(substring, dirtyFormatStr, dirtyDate);
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/***/ }),

/***/ "./node_modules/date-fns/esm/formatISO/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/formatISO/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ formatISO; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name formatISO
 * @category Common Helpers
 * @summary Format the date according to the ISO 8601 standard (https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
 *
 * @description
 * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {'extended'|'basic'} [options.format='extended'] - if 'basic', hide delimiters between date and time values.
 * @param {'complete'|'date'|'time'} [options.representation='complete'] - format date, time with local time zone, or both.
 * @returns {String} the formatted date string (in local time zone)
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.format` must be 'extended' or 'basic'
 * @throws {RangeError} `options.represenation` must be 'date', 'time' or 'complete'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601, short format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918T190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, date only:
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, time only (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52Z'
 */

function formatISO(date, options) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var originalDate = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date);

  if (isNaN(originalDate.getTime())) {
    throw new RangeError('Invalid time value');
  }

  var format = !(options !== null && options !== void 0 && options.format) ? 'extended' : String(options.format);
  var representation = !(options !== null && options !== void 0 && options.representation) ? 'complete' : String(options.representation);

  if (format !== 'extended' && format !== 'basic') {
    throw new RangeError("format must be 'extended' or 'basic'");
  }

  if (representation !== 'date' && representation !== 'time' && representation !== 'complete') {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }

  var result = '';
  var tzOffset = '';
  var dateDelimiter = format === 'extended' ? '-' : '';
  var timeDelimiter = format === 'extended' ? ':' : ''; // Representation is either 'date' or 'complete'

  if (representation !== 'time') {
    var day = (0,_lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(originalDate.getDate(), 2);
    var month = (0,_lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(originalDate.getMonth() + 1, 2);
    var year = (0,_lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(originalDate.getFullYear(), 4); // yyyyMMdd or yyyy-MM-dd.

    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  } // Representation is either 'time' or 'complete'


  if (representation !== 'date') {
    // Add the timezone.
    var offset = originalDate.getTimezoneOffset();

    if (offset !== 0) {
      var absoluteOffset = Math.abs(offset);
      var hourOffset = (0,_lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.floor(absoluteOffset / 60), 2);
      var minuteOffset = (0,_lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(absoluteOffset % 60, 2); // If less than 0, the sign is +, because it is ahead of time.

      var sign = offset < 0 ? '+' : '-';
      tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      tzOffset = 'Z';
    }

    var hour = (0,_lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(originalDate.getHours(), 2);
    var minute = (0,_lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(originalDate.getMinutes(), 2);
    var second = (0,_lib_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(originalDate.getSeconds(), 2); // If there's also date, separate it with time with 'T'

    var separator = result === '' ? '' : 'T'; // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.

    var time = [hour, minute, second].join(timeDelimiter); // HHmmss or HH:mm:ss.

    result = "".concat(result).concat(separator).concat(time).concat(tzOffset);
  }

  return result;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/getDay/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/getDay/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getDay; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name getDay
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {0|1|2|3|4|5|6} the day of week, 0 represents Sunday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * const result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */

function getDay(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var day = date.getDay();
  return day;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/getDaysInMonth/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/esm/getDaysInMonth/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getDaysInMonth; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the number of days in a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // How many days are in February 2000?
 * const result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */

function getDaysInMonth(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isBefore/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/esm/isBefore/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isBefore; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date that should be before the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */

function isBefore(dirtyDate, dirtyDateToCompare) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var dateToCompare = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isDate/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/isDate/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isDate; }
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }


/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  return value instanceof Date || _typeof(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isSameDay/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/isSameDay/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isSameDay; }
/* harmony export */ });
/* harmony import */ var _startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../startOfDay/index.js */ "./node_modules/date-fns/esm/startOfDay/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day (and year and month)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * var result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 * 
 * @example
 * // Are 4 September and 4 October in the same day?
 * var result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 * 
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * var result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */

function isSameDay(dirtyDateLeft, dirtyDateRight) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var dateLeftStartOfDay = (0,_startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft);
  var dateRightStartOfDay = (0,_startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isSameMonth/index.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/esm/isSameMonth/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isSameMonth; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month (and year)?
 *
 * @description
 * Are the given dates in the same month (and year)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same month (and year)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * var result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 *
 * @example
 * // Are 2 September 2014 and 25 September 2015 in the same month?
 * var result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
 * //=> false
 */

function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var dateLeft = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft);
  var dateRight = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isToday/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/esm/isToday/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isToday; }
/* harmony export */ });
/* harmony import */ var _isSameDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../isSameDay/index.js */ "./node_modules/date-fns/esm/isSameDay/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name isToday
 * @category Day Helpers
 * @summary Is the given date today?
 * @pure false
 *
 * @description
 * Is the given date today?
 *
 * >  Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is today
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 6 October 2014, is 6 October 14:00:00 today?
 * var result = isToday(new Date(2014, 9, 6, 14, 0))
 * //=> true
 */

function isToday(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  return (0,_isSameDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate, Date.now());
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isValid/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/esm/isValid/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isValid; }
/* harmony export */ });
/* harmony import */ var _isDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../isDate/index.js */ "./node_modules/date-fns/esm/isDate/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Now `isValid` doesn't throw an exception
 *   if the first argument is not an instance of Date.
 *   Instead, argument is converted beforehand using `toDate`.
 *
 *   Examples:
 *
 *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
 *   |---------------------------|---------------|---------------|
 *   | `new Date()`              | `true`        | `true`        |
 *   | `new Date('2016-01-01')`  | `true`        | `true`        |
 *   | `new Date('')`            | `false`       | `false`       |
 *   | `new Date(1488370835081)` | `true`        | `true`        |
 *   | `new Date(NaN)`           | `false`       | `false`       |
 *   | `'2016-01-01'`            | `TypeError`   | `false`       |
 *   | `''`                      | `TypeError`   | `false`       |
 *   | `1488370835081`           | `TypeError`   | `true`        |
 *   | `NaN`                     | `TypeError`   | `false`       |
 *
 *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
 *   that try to coerce arguments to the expected type
 *   (which is also the case with other *date-fns* functions).
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);

  if (!(0,_isDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  return !isNaN(Number(date));
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isWeekend/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/isWeekend/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isWeekend; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name isWeekend
 * @category Weekday Helpers
 * @summary Does the given date fall on a weekend?
 *
 * @description
 * Does the given date fall on a weekend?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date falls on a weekend
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Does 5 October 2014 fall on a weekend?
 * const result = isWeekend(new Date(2014, 9, 5))
 * //=> true
 */

function isWeekend(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var day = date.getDay();
  return day === 0 || day === 6;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ buildFormatLongFn; }
/* harmony export */ });
function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO: Remove String()

    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ buildLocalizeFn; }
/* harmony export */ });
function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ buildMatchFn; }
/* harmony export */ });
function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ buildMatchPatternFn; }
/* harmony export */ });
function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

/* harmony default export */ __webpack_exports__["default"] = (formatDistance);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildFormatLongFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js");

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ __webpack_exports__["default"] = (formatLong);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

/* harmony default export */ __webpack_exports__["default"] = (formatRelative);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildLocalizeFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js");

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ __webpack_exports__["default"] = (localize);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/buildMatchFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js");
/* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildMatchPatternFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js");


var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ __webpack_exports__["default"] = (match);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/formatDistance/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js");
/* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/formatLong/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js");
/* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/formatRelative/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js");
/* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/localize/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js");
/* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_lib/match/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js");





/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */

var locale = {
  code: 'en-US',
  formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
/* harmony default export */ __webpack_exports__["default"] = (locale);

/***/ }),

/***/ "./node_modules/date-fns/esm/nextDay/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/esm/nextDay/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ nextDay; }
/* harmony export */ });
/* harmony import */ var _addDays_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addDays/index.js */ "./node_modules/date-fns/esm/addDays/index.js");
/* harmony import */ var _getDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getDay/index.js */ "./node_modules/date-fns/esm/getDay/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name nextDay
 * @category Weekday Helpers
 * @summary When is the next day of the week?
 *
 * @description
 * When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @param {Date | number} date - the date to check
 * @param {Day} day - day of the week
 * @returns {Date} - the date is the next day of week
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // When is the next Monday after Mar, 20, 2020?
 * const result = nextDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 23 2020 00:00:00
 *
 * @example
 * // When is the next Tuesday after Mar, 21, 2020?
 * const result = nextDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 24 2020 00:00:00
 */

function nextDay(date, day) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var delta = day - (0,_getDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date);
  if (delta <= 0) delta += 7;
  return (0,_addDays_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, delta);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/parse/_lib/parsers/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/esm/parse/_lib/parsers/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
/* harmony import */ var _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../_lib/setUTCDay/index.js */ "./node_modules/date-fns/esm/_lib/setUTCDay/index.js");
/* harmony import */ var _lib_setUTCISODay_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../_lib/setUTCISODay/index.js */ "./node_modules/date-fns/esm/_lib/setUTCISODay/index.js");
/* harmony import */ var _lib_setUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../_lib/setUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js");
/* harmony import */ var _lib_setUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../_lib/setUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/setUTCWeek/index.js");
/* harmony import */ var _lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../_lib/startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
/* harmony import */ var _lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");







var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var MILLISECONDS_IN_SECOND = 1000;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);

  if (!matchResult) {
    return null;
  }

  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}

function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);

  if (!matchResult) {
    return null;
  } // Input is 'Z'


  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }

  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}

function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}

function parseNDigits(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);

    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
  }
}

function parseNDigitsSigned(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);

    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
  }
}

function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case 'morning':
      return 4;

    case 'evening':
      return 17;

    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;

    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}

function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;

  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // User for validation

function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */


var parsers = {
  // Era
  G: {
    priority: 140,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(string, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(string, {
            width: 'wide'
          }) || match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
      }
    },
    set: function set(date, flags, value, _options) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['R', 'u', 't', 'T']
  },
  // Year
  y: {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    priority: 130,
    parse: function parse(string, token, match, _options) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };

      switch (token) {
        case 'y':
          return parseNDigits(4, string, valueCallback);

        case 'yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });

        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function validate(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function set(date, flags, value, _options) {
      var currentYear = date.getUTCFullYear();

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  // Local week-numbering year
  Y: {
    priority: 130,
    parse: function parse(string, token, match, _options) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };

      switch (token) {
        case 'Y':
          return parseNDigits(4, string, valueCallback);

        case 'Yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });

        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function validate(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function set(date, flags, value, options) {
      var currentYear = (0,_lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date, options);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return (0,_lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, options);
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return (0,_lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  // ISO week-numbering year
  R: {
    priority: 130,
    parse: function parse(string, token, _match, _options) {
      if (token === 'R') {
        return parseNDigitsSigned(4, string);
      }

      return parseNDigitsSigned(token.length, string);
    },
    set: function set(_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return (0,_lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(firstWeekOfYear);
    },
    incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  // Extended year
  u: {
    priority: 130,
    parse: function parse(string, token, _match, _options) {
      if (token === 'u') {
        return parseNDigitsSigned(4, string);
      }

      return parseNDigitsSigned(token.length, string);
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  // Quarter
  Q: {
    priority: 120,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, string);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Stand-alone quarter
  q: {
    priority: 120,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, string);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Month
  M: {
    priority: 110,
    parse: function parse(string, token, match, _options) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return parseNDigits(2, string, valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Stand-alone month
  L: {
    priority: 110,
    parse: function parse(string, token, match, _options) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return parseNDigits(2, string, valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Local week of year
  w: {
    priority: 100,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, string);

        case 'wo':
          return match.ordinalNumber(string, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function set(date, _flags, value, options) {
      return (0,_lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_lib_setUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, value, options), options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  // ISO week of year
  I: {
    priority: 100,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, string);

        case 'Io':
          return match.ordinalNumber(string, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function set(date, _flags, value, options) {
      return (0,_lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_lib_setUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(date, value, options), options);
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  // Day of the month
  d: {
    priority: 90,
    subPriority: 1,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, string);

        case 'do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();

      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Day of year
  D: {
    priority: 90,
    subPriority: 1,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, string);

        case 'Do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);

      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']
  },
  // Day of week
  E: {
    priority: 90,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function set(date, _flags, value, options) {
      date = (0,_lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T']
  },
  // Local day of week
  e: {
    priority: 90,
    parse: function parse(string, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return parseNDigits(token.length, string, valueCallback);
        // 3rd

        case 'eo':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        // Tue

        case 'eee':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function set(date, _flags, value, options) {
      date = (0,_lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']
  },
  // Stand-alone local day of week
  c: {
    priority: 90,
    parse: function parse(string, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return parseNDigits(token.length, string, valueCallback);
        // 3rd

        case 'co':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        // Tue

        case 'ccc':
          return match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function set(date, _flags, value, options) {
      date = (0,_lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']
  },
  // ISO day of week
  i: {
    priority: 90,
    parse: function parse(string, token, match, _options) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }

        return value;
      };

      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, string);
        // 2nd

        case 'io':
          return match.ordinalNumber(string, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // T

        case 'iiiii':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // Tu

        case 'iiiiii':
          return match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // Tuesday

        case 'iiii':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function set(date, _flags, value, options) {
      date = (0,_lib_setUTCISODay_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']
  },
  // AM or PM
  a: {
    priority: 80,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaaa':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['b', 'B', 'H', 'k', 't', 'T']
  },
  // AM, PM, midnight
  b: {
    priority: 80,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbbb':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'B', 'H', 'k', 't', 'T']
  },
  // in the morning, in the afternoon, in the evening, at night
  B: {
    priority: 80,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBBB':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 't', 'T']
  },
  // Hour [1-12]
  h: {
    priority: 70,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, string);

        case 'ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function set(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    },
    incompatibleTokens: ['H', 'K', 'k', 't', 'T']
  },
  // Hour [0-23]
  H: {
    priority: 70,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, string);

        case 'Ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T']
  },
  // Hour [0-11]
  K: {
    priority: 70,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, string);

        case 'Ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function set(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    },
    incompatibleTokens: ['h', 'H', 'k', 't', 'T']
  },
  // Hour [1-24]
  k: {
    priority: 70,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, string);

        case 'ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function set(date, _flags, value, _options) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T']
  },
  // Minute
  m: {
    priority: 60,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, string);

        case 'mo':
          return match.ordinalNumber(string, {
            unit: 'minute'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Second
  s: {
    priority: 50,
    parse: function parse(string, token, match, _options) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, string);

        case 'so':
          return match.ordinalNumber(string, {
            unit: 'second'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function validate(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Fraction of second
  S: {
    priority: 30,
    parse: function parse(string, token, _match, _options) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };

      return parseNDigits(token.length, string, valueCallback);
    },
    set: function set(date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Timezone (ISO-8601. +00:00 is `'Z'`)
  X: {
    priority: 10,
    parse: function parse(string, token, _match, _options) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, string);

        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function set(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'x']
  },
  // Timezone (ISO-8601)
  x: {
    priority: 10,
    parse: function parse(string, token, _match, _options) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, string);

        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function set(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'X']
  },
  // Seconds timestamp
  t: {
    priority: 40,
    parse: function parse(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function set(_date, _flags, value, _options) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  },
  // Milliseconds timestamp
  T: {
    priority: 20,
    parse: function parse(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function set(_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  }
};
/* harmony default export */ __webpack_exports__["default"] = (parsers);

/***/ }),

/***/ "./node_modules/date-fns/esm/parse/index.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/esm/parse/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ parse; }
/* harmony export */ });
/* harmony import */ var _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../locale/en-US/index.js */ "./node_modules/date-fns/esm/locale/en-US/index.js");
/* harmony import */ var _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../subMilliseconds/index.js */ "./node_modules/date-fns/esm/subMilliseconds/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_assign_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_lib/assign/index.js */ "./node_modules/date-fns/esm/_lib/assign/index.js");
/* harmony import */ var _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_lib/format/longFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js");
/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_lib/getTimezoneOffsetInMilliseconds/index.js */ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js");
/* harmony import */ var _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../_lib/protectedTokens/index.js */ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _lib_parsers_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_lib/parsers/index.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");










var TIMEZONE_UNIT_PRIORITY = 10; // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Old `parse` was renamed to `toDate`.
 *   Now `parse` is a new function which parses a string using a provided format.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   parse('2016-01-01')
 *
 *   // v2.0.0 onward (toDate no longer accepts a string)
 *   toDate(1392098430000) // Unix to timestamp
 *   toDate(new Date(2014, 1, 11, 11, 30, 30)) // Cloning the date
 *   parse('2016-01-01', 'yyyy-MM-dd', new Date())
 *   ```
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale = options.locale || _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_1__["default"];

  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }

  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (formatString === '') {
    if (dateString === '') {
      return (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale
  }; // If timezone isn't specified, it will be set to the system timezone

  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    subPriority: -1,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i;
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_4__["default"][firstCharacter];
      return longFormatter(substring, locale.formatLong, subFnOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];

  for (i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (!options.useAdditionalWeekYearTokens && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_5__.isProtectedWeekYearToken)(token)) {
      (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_5__.throwProtectedError)(token, formatString, dirtyDateString);
    }

    if (!options.useAdditionalDayOfYearTokens && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_5__.isProtectedDayOfYearToken)(token)) {
      (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_5__.throwProtectedError)(token, formatString, dirtyDateString);
    }

    var firstCharacter = token[0];
    var parser = _lib_parsers_index_js__WEBPACK_IMPORTED_MODULE_6__["default"][firstCharacter];

    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;

      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;

        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;

          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }

        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === '*' && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
      }

      usedTokens.push({
        token: firstCharacter,
        fullToken: token
      });
      var parseResult = parser.parse(dateString, token, locale.match, subFnOptions);

      if (!parseResult) {
        return new Date(NaN);
      }

      setters.push({
        priority: parser.priority,
        subPriority: parser.subPriority || 0,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      } // Replace two single quote characters with one single quote character


      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      } // Cut token from string, or, if string doesn't match the token, return Invalid Date


      if (dateString.indexOf(token) === 0) {
        dateString = dateString.slice(token.length);
      } else {
        return new Date(NaN);
      }
    }
  } // Check if the remaining input contains something other than whitespace


  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyReferenceDate);

  if (isNaN(date)) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37


  var utcDate = (0,_subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(date, (0,_lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_8__["default"])(date));
  var flags = {};

  for (i = 0; i < uniquePrioritySetters.length; i++) {
    var setter = uniquePrioritySetters[i];

    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }

    var result = setter.set(utcDate, flags, setter.value, subFnOptions); // Result is tuple (date, flags)

    if (result[0]) {
      utcDate = result[0];
      (0,_lib_assign_index_js__WEBPACK_IMPORTED_MODULE_9__["default"])(flags, result[1]); // Result is date
    } else {
      utcDate = result;
    }
  }

  return utcDate;
}

function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }

  var convertedDate = new Date(0);
  convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/***/ }),

/***/ "./node_modules/date-fns/esm/parseISO/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/esm/parseISO/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ parseISO; }
/* harmony export */ });
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/index.js */ "./node_modules/date-fns/esm/constants/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");



/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The previous `parse` implementation was renamed to `parseISO`.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   parse('2016-01-01')
 *
 *   // v2.0.0 onward
 *   parseISO('2016-01-01')
 *   ```
 *
 * - `parseISO` now validates separate date and time values in ISO-8601 strings
 *   and returns `Invalid Date` if the date is invalid.
 *
 *   ```javascript
 *   parseISO('2018-13-32')
 *   //=> Invalid Date
 *   ```
 *
 * - `parseISO` now doesn't fall back to `new Date` constructor
 *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.
 *
 * @param {String} argument - the value to convert
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */

function parseISO(argument, dirtyOptions) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? 2 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.additionalDigits);

  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  }

  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    return new Date(NaN);
  }

  var dateStrings = splitDateString(argument);
  var date;

  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }

  var timestamp = date.getTime();
  var time = 0;
  var offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);

    if (isNaN(time)) {
      return new Date(NaN);
    }
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);

    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time); // js parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.

    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }

  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;

function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString; // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].

  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];

    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }

  if (timeString) {
    var token = patterns.timezone.exec(timeString);

    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
  var captures = dateString.match(regex); // Invalid ISO-formatted year

  if (!captures) return {
    year: NaN,
    restDateString: ''
  };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null; // either year or century is null, not both

  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);
  var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

  if (!captures) return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }

    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);

    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }

    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return hours * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInHour + minutes * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInMinute + seconds * 1000;
}

function parseTimeUnit(value) {
  return value && parseFloat(value.replace(',', '.')) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === 'Z') return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  var sign = captures[1] === '+' ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return sign * (hours * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInHour + minutes * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInMinute);
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
} // Validation functions
// February is null to handle the leap year (using ||)


var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/previousDay/index.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/esm/previousDay/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ previousDay; }
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _getDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getDay/index.js */ "./node_modules/date-fns/esm/getDay/index.js");
/* harmony import */ var _subDays_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../subDays/index.js */ "./node_modules/date-fns/esm/subDays/index.js");



/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @param {Date | number} date - the date to check
 * @param {number} day - day of the week
 * @returns {Date} - the date is the previous day of week
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */

function previousDay(date, day) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var delta = (0,_getDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date) - day;
  if (delta <= 0) delta += 7;
  return (0,_subDays_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, delta);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/startOfDay/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/esm/startOfDay/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ startOfDay; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/startOfMonth/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/date-fns/esm/startOfMonth/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ startOfMonth; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfMonth(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/startOfWeek/index.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/esm/startOfWeek/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ startOfWeek; }
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfWeek(dirtyDate, dirtyOptions) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/subDays/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/esm/subDays/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ subDays; }
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _addDays_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addDays/index.js */ "./node_modules/date-fns/esm/addDays/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @description
 * Subtract the specified number of days from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the days subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */

function subDays(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
  return (0,_addDays_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/subMilliseconds/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/subMilliseconds/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ subMilliseconds; }
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addMilliseconds/index.js */ "./node_modules/date-fns/esm/addMilliseconds/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
  return (0,_addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/toDate/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/toDate/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ toDate; }
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }


/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ (function(module) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;

/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

/***/ }),

/***/ "./node_modules/lodash/_arrayIncludes.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayIncludes.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */


function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

/***/ }),

/***/ "./node_modules/lodash/_arrayIncludesWith.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_arrayIncludesWith.js ***!
  \***************************************************/
/***/ (function(module) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

module.exports = arrayIncludesWith;

/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;

/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

module.exports = baseFindIndex;

/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIndexOf.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

module.exports = baseIsMatch;

/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsNaN.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

module.exports = baseIteratee;

/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),

/***/ "./node_modules/lodash/_baseRange.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseRange.js ***!
  \*******************************************/
/***/ (function(module) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;
/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */

function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }

  return result;
}

module.exports = baseRange;

/***/ }),

/***/ "./node_modules/lodash/_baseSortedIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSortedIndex.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseSortedIndexBy = __webpack_require__(/*! ./_baseSortedIndexBy */ "./node_modules/lodash/_baseSortedIndexBy.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for the maximum length and index of an array. */


var MAX_ARRAY_LENGTH = 4294967295,
    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
/**
 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
 * performs a binary search of `array` to determine the index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */

function baseSortedIndex(array, value, retHighest) {
  var low = 0,
      high = array == null ? low : array.length;

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1,
          computed = array[mid];

      if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }

    return high;
  }

  return baseSortedIndexBy(array, value, identity, retHighest);
}

module.exports = baseSortedIndex;

/***/ }),

/***/ "./node_modules/lodash/_baseSortedIndexBy.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_baseSortedIndexBy.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for the maximum length and index of an array. */


var MAX_ARRAY_LENGTH = 4294967295,
    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeFloor = Math.floor,
    nativeMin = Math.min;
/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */

function baseSortedIndexBy(array, value, iteratee, retHighest) {
  var low = 0,
      high = array == null ? 0 : array.length;

  if (high === 0) {
    return 0;
  }

  value = iteratee(value);
  var valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = isSymbol(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = isSymbol(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }

    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return nativeMin(high, MAX_ARRAY_INDEX);
}

module.exports = baseSortedIndexBy;

/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");
/** Used to match leading whitespace. */


var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

module.exports = baseTrim;

/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),

/***/ "./node_modules/lodash/_baseUniq.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseUniq.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"),
    createSet = __webpack_require__(/*! ./_createSet */ "./node_modules/lodash/_createSet.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);

    if (set) {
      return setToArray(set);
    }

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

module.exports = baseUniq;

/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/***/ (function(module) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/***/ (function(module) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used to convert symbols to primitives and strings. */


var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),

/***/ "./node_modules/lodash/_createRange.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_createRange.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseRange = __webpack_require__(/*! ./_baseRange */ "./node_modules/lodash/_baseRange.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");
/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */


function createRange(fromRight) {
  return function (start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    } // Ensure the sign of `-0` is preserved.


    start = toFinite(start);

    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }

    step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;

/***/ }),

/***/ "./node_modules/lodash/_createSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_createSet.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    noop = __webpack_require__(/*! ./noop */ "./node_modules/lodash/noop.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
module.exports = createSet;

/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;

/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof __webpack_require__.g === "undefined" ? "undefined" : _typeof(__webpack_require__.g)) == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
module.exports = freeGlobal;

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

module.exports = getMatchData;

/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;

/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/***/ (function(module) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/***/ (function(module) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;

/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = _typeof(value);

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/***/ (function(module) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/***/ (function(module) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/***/ (function(module) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/***/ (function(module) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ (function(module) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/***/ (function(module) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;

/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/***/ (function(module) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/***/ (function(module) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/***/ (function(module) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/***/ (function(module) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/***/ (function(module) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_strictIndexOf.js ***!
  \***********************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

module.exports = strictIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ (function(module) {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

module.exports = trimmedEndIndex;

/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */

function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ (function(module) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ (function(module) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ (function(module) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;

/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */

function isEmpty(value) {
  if (value == null) {
    return true;
  }

  if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }

  var tag = getTag(value);

  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }

  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }

  return true;
}

module.exports = isEmpty;

/***/ }),

/***/ "./node_modules/lodash/isEqual.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEqual.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");
/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */


function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ (function(module) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),

/***/ "./node_modules/lodash/noop.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/noop.js ***!
  \*************************************/
/***/ (function(module) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

module.exports = noop;

/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),

/***/ "./node_modules/lodash/range.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/range.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var createRange = __webpack_require__(/*! ./_createRange */ "./node_modules/lodash/_createRange.js");
/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */


var range = createRange();
module.exports = range;

/***/ }),

/***/ "./node_modules/lodash/sortedIndex.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/sortedIndex.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseSortedIndex = __webpack_require__(/*! ./_baseSortedIndex */ "./node_modules/lodash/_baseSortedIndex.js");
/**
 * Uses a binary search to determine the lowest index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedIndex([30, 50], 40);
 * // => 1
 */


function sortedIndex(array, value) {
  return baseSortedIndex(array, value);
}

module.exports = sortedIndex;

/***/ }),

/***/ "./node_modules/lodash/sortedIndexBy.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/sortedIndexBy.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseSortedIndexBy = __webpack_require__(/*! ./_baseSortedIndexBy */ "./node_modules/lodash/_baseSortedIndexBy.js");
/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
 * // => 0
 */


function sortedIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee, 2));
}

module.exports = sortedIndexBy;

/***/ }),

/***/ "./node_modules/lodash/sortedLastIndex.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/sortedLastIndex.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseSortedIndex = __webpack_require__(/*! ./_baseSortedIndex */ "./node_modules/lodash/_baseSortedIndex.js");
/**
 * This method is like `_.sortedIndex` except that it returns the highest
 * index at which `value` should be inserted into `array` in order to
 * maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
 * // => 4
 */


function sortedLastIndex(array, value) {
  return baseSortedIndex(array, value, true);
}

module.exports = sortedLastIndex;

/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/***/ (function(module) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ (function(module) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),

/***/ "./node_modules/lodash/toFinite.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toFinite.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = toNumber(value);

  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}

module.exports = toFinite;

/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),

/***/ "./node_modules/lodash/uniq.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/uniq.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js");
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */


function uniq(array) {
  return array && array.length ? baseUniq(array) : [];
}

module.exports = uniq;

/***/ }),

/***/ "./node_modules/lodash/uniqWith.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/uniqWith.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js");
/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The order of result values is
 * determined by the order they occur in the array.The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */


function uniqWith(array, comparator) {
  comparator = typeof comparator == 'function' ? comparator : undefined;
  return array && array.length ? baseUniq(array, undefined, comparator) : [];
}

module.exports = uniqWith;

/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
 // A linked list to keep track of recently-used-ness

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js");

var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

var naiveLength = function naiveLength() {
  return 1;
}; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


var LRUCache = /*#__PURE__*/function () {
  function LRUCache(options) {
    _classCallCheck(this, LRUCache);

    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    var max = this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  _createClass(LRUCache, [{
    key: "max",
    get: function get() {
      return this[MAX];
    },
    set: function set(mL) {
      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
      this[MAX] = mL || Infinity;
      trim(this);
    }
  }, {
    key: "allowStale",
    get: function get() {
      return this[ALLOW_STALE];
    },
    set: function set(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
  }, {
    key: "maxAge",
    get: function get() {
      return this[MAX_AGE];
    } // resize the cache when the lengthCalculator changes.
    ,
    set: function set(mA) {
      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
      this[MAX_AGE] = mA;
      trim(this);
    }
  }, {
    key: "lengthCalculator",
    get: function get() {
      return this[LENGTH_CALCULATOR];
    },
    set: function set(lC) {
      var _this = this;

      if (typeof lC !== 'function') lC = naiveLength;

      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(function (hit) {
          hit.length = _this[LENGTH_CALCULATOR](hit.value, hit.key);
          _this[LENGTH] += hit.length;
        });
      }

      trim(this);
    }
  }, {
    key: "length",
    get: function get() {
      return this[LENGTH];
    }
  }, {
    key: "itemCount",
    get: function get() {
      return this[LRU_LIST].length;
    }
  }, {
    key: "rforEach",
    value: function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
  }, {
    key: "keys",
    value: function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    }
  }, {
    key: "values",
    value: function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this2 = this;

      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this2[DISPOSE](hit.key, hit.value);
        });
      }

      this[CACHE] = new Map(); // hash of items by key

      this[LRU_LIST] = new Yallist(); // list of items in order of use recency

      this[LENGTH] = 0; // length of items in the list
    }
  }, {
    key: "dump",
    value: function dump() {
      var _this3 = this;

      return this[LRU_LIST].map(function (hit) {
        return isStale(_this3, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    }
  }, {
    key: "dumpLru",
    value: function dumpLru() {
      return this[LRU_LIST];
    }
  }, {
    key: "set",
    value: function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));

          return false;
        }

        var node = this[CACHE].get(key);
        var item = node.value; // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking

        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }

      var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
  }, {
    key: "get",
    value: function get(key) {
      return _get(this, key, true);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      return _get(this, key, false);
    }
  }, {
    key: "pop",
    value: function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;

      _del(this, node);

      return node.value;
    }
  }, {
    key: "del",
    value: function del(key) {
      _del(this, this[CACHE].get(key));
    }
  }, {
    key: "load",
    value: function load(arr) {
      // reset the cache
      this.reset();
      var now = Date.now(); // A previous serialized cache has the most recent items first

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now; // dont add already expired items

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
  }, {
    key: "prune",
    value: function prune() {
      var _this4 = this;

      this[CACHE].forEach(function (value, key) {
        return _get(_this4, key, false);
      });
    }
  }]);

  return LRUCache;
}();

var _get = function _get(self, key, doUse) {
  var node = self[CACHE].get(key);

  if (node) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

var isStale = function isStale(self, hit) {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

var trim = function trim(self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;

      _del(self, walker);

      walker = prev;
    }
  }
};

var _del = function _del(self, node) {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

var Entry = /*#__PURE__*/_createClass(function Entry(key, value, length, now, maxAge) {
  _classCallCheck(this, Entry);

  this.key = key;
  this.value = value;
  this.length = length;
  this.now = now;
  this.maxAge = maxAge || 0;
});

var forEachStep = function forEachStep(self, fn, node, thisp) {
  var hit = node.value;

  if (isStale(self, hit)) {
    _del(self, node);

    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

/***/ }),

/***/ "./node_modules/ordinal/index.js":
/*!***************************************!*\
  !*** ./node_modules/ordinal/index.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var indicator = __webpack_require__(/*! ./indicator */ "./node_modules/ordinal/indicator.js");

function ordinal(i) {
  if (typeof i !== 'number') throw new TypeError('Expected Number, got ' + _typeof(i) + ' ' + i);
  if (!Number.isFinite(i)) return i;
  return i + indicator(i);
}

ordinal.indicator = indicator;
module.exports = ordinal;

/***/ }),

/***/ "./node_modules/ordinal/indicator.js":
/*!*******************************************!*\
  !*** ./node_modules/ordinal/indicator.js ***!
  \*******************************************/
/***/ (function(module) {

module.exports = function indicator(i) {
  i = Math.abs(i);
  var cent = i % 100;
  if (cent >= 10 && cent <= 20) return 'th';
  var dec = i % 10;
  if (dec === 1) return 'st';
  if (dec === 2) return 'nd';
  if (dec === 3) return 'rd';
  return 'th';
};

/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var ANY = Symbol('SemVer ANY'); // hoisted class for cyclic dependency

var Comparator = /*#__PURE__*/function () {
  function Comparator(comp, options) {
    _classCallCheck(this, Comparator);

    options = parseOptions(options);

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }

    debug('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    debug('comp', this);
  }

  _createClass(Comparator, [{
    key: "parse",
    value: function parse(comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError("Invalid comparator: ".concat(comp));
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      } // if it literally is just '>' or '' then allow anything.


      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.value;
    }
  }, {
    key: "test",
    value: function test(version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY || version === ANY) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp(version, this.operator, this.semver, this.options);
    }
  }, {
    key: "intersects",
    value: function intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || _typeof(options) !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        return new Range(this.value, options).test(comp.semver);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  }], [{
    key: "ANY",
    get: function get() {
      return ANY;
    }
  }]);

  return Comparator;
}();

module.exports = Comparator;

var parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js");

var _require = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
    re = _require.re,
    t = _require.t;

var cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/semver/functions/cmp.js");

var debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js");

var SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js");

var Range = __webpack_require__(/*! ./range */ "./node_modules/semver/classes/range.js");

/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// hoisted class for cyclic dependency
var Range = /*#__PURE__*/function () {
  function Range(range, options) {
    var _this = this;

    _classCallCheck(this, Range);

    options = parseOptions(options);

    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value;
      this.set = [[range]];
      this.format();
      return this;
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

    this.raw = range;
    this.set = range.split('||') // map the range to a 2d array of comparators
    .map(function (r) {
      return _this.parseRange(r.trim());
    }) // throw out any comparator lists that are empty
    // this generally means that it was not a valid range, which is allowed
    // in loose mode, but will still throw if the WHOLE range is invalid.
    .filter(function (c) {
      return c.length;
    });

    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: ".concat(range));
    } // if we have any that are not the null set, throw out null sets.


    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      var first = this.set[0];
      this.set = this.set.filter(function (c) {
        return !isNullSet(c[0]);
      });

      if (this.set.length === 0) {
        this.set = [first];
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        var _iterator = _createForOfIteratorHelper(this.set),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var c = _step.value;

            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }

    this.format();
  }

  _createClass(Range, [{
    key: "format",
    value: function format() {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.range;
    }
  }, {
    key: "parseRange",
    value: function parseRange(range) {
      var _this2 = this;

      range = range.trim(); // memoize range parsing for performance.
      // this is a very hot path, and fully deterministic.

      var memoOpts = Object.keys(this.options).join(',');
      var memoKey = "parseRange:".concat(memoOpts, ":").concat(range);
      var cached = cache.get(memoKey);

      if (cached) {
        return cached;
      }

      var loose = this.options.loose; // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range); // `~ 1.2.3` => `~1.2.3`

      range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

      range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces

      range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
      // ready to be split into comparators.

      var rangeList = range.split(' ').map(function (comp) {
        return parseComparator(comp, _this2.options);
      }).join(' ').split(/\s+/) // >=0.0.0 is equivalent to *
      .map(function (comp) {
        return replaceGTE0(comp, _this2.options);
      });

      if (loose) {
        // in loose mode, throw out any that are not valid comparators
        rangeList = rangeList.filter(function (comp) {
          debug('loose invalid filter', comp, _this2.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }

      debug('range list', rangeList); // if any comparators are the null set, then replace with JUST null set
      // if more than one comparator, remove any * comparators
      // also, don't include the same comparator more than once

      var rangeMap = new Map();
      var comparators = rangeList.map(function (comp) {
        return new Comparator(comp, _this2.options);
      });

      var _iterator2 = _createForOfIteratorHelper(comparators),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var comp = _step2.value;

          if (isNullSet(comp)) {
            return [comp];
          }

          rangeMap.set(comp.value, comp);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (rangeMap.size > 1 && rangeMap.has('')) {
        rangeMap.delete('');
      }

      var result = _toConsumableArray(rangeMap.values());

      cache.set(memoKey, result);
      return result;
    }
  }, {
    key: "intersects",
    value: function intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    } // if ANY of the sets match ALL of its comparators, then pass

  }, {
    key: "test",
    value: function test(version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    }
  }]);

  return Range;
}();

module.exports = Range;

var LRU = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");

var cache = new LRU({
  max: 1000
});

var parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js");

var Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/semver/classes/comparator.js");

var debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js");

var SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js");

var _require = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
    re = _require.re,
    t = _require.t,
    comparatorTrimReplace = _require.comparatorTrimReplace,
    tildeTrimReplace = _require.tildeTrimReplace,
    caretTrimReplace = _require.caretTrimReplace;

var isNullSet = function isNullSet(c) {
  return c.value === '<0.0.0-0';
};

var isAny = function isAny(c) {
  return c.value === '';
}; // take a set of comparators and determine whether there
// exists a version which can satisfy it


var isSatisfiable = function isSatisfiable(comparators, options) {
  var result = true;
  var remainingComparators = comparators.slice();
  var testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }

  return result;
}; // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


var parseComparator = function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
};

var isX = function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}; // ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0


var replaceTildes = function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (c) {
    return replaceTilde(c, options);
  }).join(' ');
};

var replaceTilde = function replaceTilde(comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
    }

    debug('tilde return', ret);
    return ret;
  });
}; // ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0


var replaceCarets = function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (c) {
    return replaceCaret(c, options);
  }).join(' ');
};

var replaceCaret = function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
  var z = options.includePrerelease ? '-0' : '';
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
    } else if (isX(p)) {
      if (M === '0') {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
      } else {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
        }
      } else {
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
      }
    } else {
      debug('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
        }
      } else {
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
      }
    }

    debug('caret return', ret);
    return ret;
  });
};

var replaceXRanges = function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (c) {
    return replaceXRange(c, options);
  }).join(' ');
};

var replaceXRange = function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    } // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value


    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      if (gtlt === '<') {
        pr = '-0';
      }

      ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
    } else if (xm) {
      ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
    } else if (xp) {
      ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
    }

    debug('xRange return', ret);
    return ret;
  });
}; // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


var replaceStars = function replaceStars(comp, options) {
  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  return comp.trim().replace(re[t.STAR], '');
};

var replaceGTE0 = function replaceGTE0(comp, options) {
  debug('replaceGTE0', comp, options);
  return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
}; // This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0


var hyphenReplace = function hyphenReplace(incPr) {
  return function ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = '';
    } else if (isX(fm)) {
      from = ">=".concat(fM, ".0.0").concat(incPr ? '-0' : '');
    } else if (isX(fp)) {
      from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? '-0' : '');
    } else if (fpr) {
      from = ">=".concat(from);
    } else {
      from = ">=".concat(from).concat(incPr ? '-0' : '');
    }

    if (isX(tM)) {
      to = '';
    } else if (isX(tm)) {
      to = "<".concat(+tM + 1, ".0.0-0");
    } else if (isX(tp)) {
      to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
    } else if (tpr) {
      to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
    } else if (incPr) {
      to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
    } else {
      to = "<=".concat(to);
    }

    return "".concat(from, " ").concat(to).trim();
  };
};

var testSet = function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var _i = 0; _i < set.length; _i++) {
      debug(set[_i].semver);

      if (set[_i].semver === Comparator.ANY) {
        continue;
      }

      if (set[_i].semver.prerelease.length > 0) {
        var allowed = set[_i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    return false;
  }

  return true;
};

/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js");

var _require = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js"),
    MAX_LENGTH = _require.MAX_LENGTH,
    MAX_SAFE_INTEGER = _require.MAX_SAFE_INTEGER;

var _require2 = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
    re = _require2.re,
    t = _require2.t;

var parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js");

var _require3 = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/semver/internal/identifiers.js"),
    compareIdentifiers = _require3.compareIdentifiers;

var SemVer = /*#__PURE__*/function () {
  function SemVer(version, options) {
    _classCallCheck(this, SemVer);

    options = parseOptions(options);

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError("Invalid Version: ".concat(version));
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose; // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.

    this.includePrerelease = !!options.includePrerelease;
    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

    if (!m) {
      throw new TypeError("Invalid Version: ".concat(version));
    }

    this.raw = version; // these are actually numbers

    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    } // numberify any prerelease numeric ids


    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;

          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }

        return id;
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  _createClass(SemVer, [{
    key: "format",
    value: function format() {
      this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);

      if (this.prerelease.length) {
        this.version += "-".concat(this.prerelease.join('.'));
      }

      return this.version;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.version;
    }
  }, {
    key: "compare",
    value: function compare(other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }

        other = new SemVer(other, this.options);
      }

      if (other.version === this.version) {
        return 0;
      }

      return this.compareMain(other) || this.comparePre(other);
    }
  }, {
    key: "compareMain",
    value: function compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
  }, {
    key: "comparePre",
    value: function comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      } // NOT having a prerelease is > having one


      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
  }, {
    key: "compareBuild",
    value: function compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    } // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.

  }, {
    key: "inc",
    value: function inc(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              // didn't increment anything
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error("invalid increment argument: ".concat(release));
      }

      this.format();
      this.raw = this.version;
      return this;
    }
  }]);

  return SemVer;
}();

module.exports = SemVer;

/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");

var clean = function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
};

module.exports = clean;

/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js");

var neq = __webpack_require__(/*! ./neq */ "./node_modules/semver/functions/neq.js");

var gt = __webpack_require__(/*! ./gt */ "./node_modules/semver/functions/gt.js");

var gte = __webpack_require__(/*! ./gte */ "./node_modules/semver/functions/gte.js");

var lt = __webpack_require__(/*! ./lt */ "./node_modules/semver/functions/lt.js");

var lte = __webpack_require__(/*! ./lte */ "./node_modules/semver/functions/lte.js");

var cmp = function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (_typeof(a) === 'object') {
        a = a.version;
      }

      if (_typeof(b) === 'object') {
        b = b.version;
      }

      return a === b;

    case '!==':
      if (_typeof(a) === 'object') {
        a = a.version;
      }

      if (_typeof(b) === 'object') {
        b = b.version;
      }

      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt(a, b, loose);

    case '>=':
      return gte(a, b, loose);

    case '<':
      return lt(a, b, loose);

    case '<=':
      return lte(a, b, loose);

    default:
      throw new TypeError("Invalid operator: ".concat(op));
  }
};

module.exports = cmp;

/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");

var _require = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
    re = _require.re,
    t = _require.t;

var coerce = function coerce(version, options) {
  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null;
  }

  options = options || {};
  var match = null;

  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next;

    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }

      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    } // leave it in a clean state


    re[t.COERCERTL].lastIndex = -1;
  }

  if (match === null) {
    return null;
  }

  return parse("".concat(match[2], ".").concat(match[3] || '0', ".").concat(match[4] || '0'), options);
};

module.exports = coerce;

/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var compareBuild = function compareBuild(a, b, loose) {
  var versionA = new SemVer(a, loose);
  var versionB = new SemVer(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};

module.exports = compareBuild;

/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");

var compareLoose = function compareLoose(a, b) {
  return compare(a, b, true);
};

module.exports = compareLoose;

/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var compare = function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
};

module.exports = compare;

/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");

var eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js");

var diff = function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var hasPre = v1.prerelease.length || v2.prerelease.length;
    var prefix = hasPre ? 'pre' : '';
    var defaultResult = hasPre ? 'prerelease' : '';

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
};

module.exports = diff;

/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");

var eq = function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
};

module.exports = eq;

/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");

var gt = function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
};

module.exports = gt;

/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");

var gte = function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
};

module.exports = gte;

/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var inc = function inc(version, release, options, identifier) {
  if (typeof options === 'string') {
    identifier = options;
    options = undefined;
  }

  try {
    return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};

module.exports = inc;

/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");

var lt = function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
};

module.exports = lt;

/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");

var lte = function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
};

module.exports = lte;

/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var major = function major(a, loose) {
  return new SemVer(a, loose).major;
};

module.exports = major;

/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var minor = function minor(a, loose) {
  return new SemVer(a, loose).minor;
};

module.exports = minor;

/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");

var neq = function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
};

module.exports = neq;

/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _require = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js"),
    MAX_LENGTH = _require.MAX_LENGTH;

var _require2 = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js"),
    re = _require2.re,
    t = _require2.t;

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js");

var parse = function parse(version, options) {
  options = parseOptions(options);

  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
};

module.exports = parse;

/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var patch = function patch(a, loose) {
  return new SemVer(a, loose).patch;
};

module.exports = patch;

/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");

var prerelease = function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};

module.exports = prerelease;

/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js");

var rcompare = function rcompare(a, b, loose) {
  return compare(b, a, loose);
};

module.exports = rcompare;

/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js");

var rsort = function rsort(list, loose) {
  return list.sort(function (a, b) {
    return compareBuild(b, a, loose);
  });
};

module.exports = rsort;

/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");

var satisfies = function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
};

module.exports = satisfies;

/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js");

var sort = function sort(list, loose) {
  return list.sort(function (a, b) {
    return compareBuild(a, b, loose);
  });
};

module.exports = sort;

/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js");

var valid = function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
};

module.exports = valid;

/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// just pre-load all the stuff that index.js lazily exports
var internalRe = __webpack_require__(/*! ./internal/re */ "./node_modules/semver/internal/re.js");

module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: (__webpack_require__(/*! ./internal/constants */ "./node_modules/semver/internal/constants.js").SEMVER_SPEC_VERSION),
  SemVer: __webpack_require__(/*! ./classes/semver */ "./node_modules/semver/classes/semver.js"),
  compareIdentifiers: (__webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js").compareIdentifiers),
  rcompareIdentifiers: (__webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js").rcompareIdentifiers),
  parse: __webpack_require__(/*! ./functions/parse */ "./node_modules/semver/functions/parse.js"),
  valid: __webpack_require__(/*! ./functions/valid */ "./node_modules/semver/functions/valid.js"),
  clean: __webpack_require__(/*! ./functions/clean */ "./node_modules/semver/functions/clean.js"),
  inc: __webpack_require__(/*! ./functions/inc */ "./node_modules/semver/functions/inc.js"),
  diff: __webpack_require__(/*! ./functions/diff */ "./node_modules/semver/functions/diff.js"),
  major: __webpack_require__(/*! ./functions/major */ "./node_modules/semver/functions/major.js"),
  minor: __webpack_require__(/*! ./functions/minor */ "./node_modules/semver/functions/minor.js"),
  patch: __webpack_require__(/*! ./functions/patch */ "./node_modules/semver/functions/patch.js"),
  prerelease: __webpack_require__(/*! ./functions/prerelease */ "./node_modules/semver/functions/prerelease.js"),
  compare: __webpack_require__(/*! ./functions/compare */ "./node_modules/semver/functions/compare.js"),
  rcompare: __webpack_require__(/*! ./functions/rcompare */ "./node_modules/semver/functions/rcompare.js"),
  compareLoose: __webpack_require__(/*! ./functions/compare-loose */ "./node_modules/semver/functions/compare-loose.js"),
  compareBuild: __webpack_require__(/*! ./functions/compare-build */ "./node_modules/semver/functions/compare-build.js"),
  sort: __webpack_require__(/*! ./functions/sort */ "./node_modules/semver/functions/sort.js"),
  rsort: __webpack_require__(/*! ./functions/rsort */ "./node_modules/semver/functions/rsort.js"),
  gt: __webpack_require__(/*! ./functions/gt */ "./node_modules/semver/functions/gt.js"),
  lt: __webpack_require__(/*! ./functions/lt */ "./node_modules/semver/functions/lt.js"),
  eq: __webpack_require__(/*! ./functions/eq */ "./node_modules/semver/functions/eq.js"),
  neq: __webpack_require__(/*! ./functions/neq */ "./node_modules/semver/functions/neq.js"),
  gte: __webpack_require__(/*! ./functions/gte */ "./node_modules/semver/functions/gte.js"),
  lte: __webpack_require__(/*! ./functions/lte */ "./node_modules/semver/functions/lte.js"),
  cmp: __webpack_require__(/*! ./functions/cmp */ "./node_modules/semver/functions/cmp.js"),
  coerce: __webpack_require__(/*! ./functions/coerce */ "./node_modules/semver/functions/coerce.js"),
  Comparator: __webpack_require__(/*! ./classes/comparator */ "./node_modules/semver/classes/comparator.js"),
  Range: __webpack_require__(/*! ./classes/range */ "./node_modules/semver/classes/range.js"),
  satisfies: __webpack_require__(/*! ./functions/satisfies */ "./node_modules/semver/functions/satisfies.js"),
  toComparators: __webpack_require__(/*! ./ranges/to-comparators */ "./node_modules/semver/ranges/to-comparators.js"),
  maxSatisfying: __webpack_require__(/*! ./ranges/max-satisfying */ "./node_modules/semver/ranges/max-satisfying.js"),
  minSatisfying: __webpack_require__(/*! ./ranges/min-satisfying */ "./node_modules/semver/ranges/min-satisfying.js"),
  minVersion: __webpack_require__(/*! ./ranges/min-version */ "./node_modules/semver/ranges/min-version.js"),
  validRange: __webpack_require__(/*! ./ranges/valid */ "./node_modules/semver/ranges/valid.js"),
  outside: __webpack_require__(/*! ./ranges/outside */ "./node_modules/semver/ranges/outside.js"),
  gtr: __webpack_require__(/*! ./ranges/gtr */ "./node_modules/semver/ranges/gtr.js"),
  ltr: __webpack_require__(/*! ./ranges/ltr */ "./node_modules/semver/ranges/ltr.js"),
  intersects: __webpack_require__(/*! ./ranges/intersects */ "./node_modules/semver/ranges/intersects.js"),
  simplifyRange: __webpack_require__(/*! ./ranges/simplify */ "./node_modules/semver/ranges/simplify.js"),
  subset: __webpack_require__(/*! ./ranges/subset */ "./node_modules/semver/ranges/subset.js")
};

/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ (function(module) {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
var SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

var MAX_SAFE_COMPONENT_LENGTH = 16;
module.exports = {
  SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
};

/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var debug = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
  var _console;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
} : function () {};
module.exports = debug;

/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ (function(module) {

var numeric = /^[0-9]+$/;

var compareIdentifiers = function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};

var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
};

module.exports = {
  compareIdentifiers: compareIdentifiers,
  rcompareIdentifiers: rcompareIdentifiers
};

/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/semver/internal/parse-options.js ***!
  \*******************************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
var opts = ['includePrerelease', 'loose', 'rtl'];

var parseOptions = function parseOptions(options) {
  return !options ? {} : _typeof(options) !== 'object' ? {
    loose: true
  } : opts.filter(function (k) {
    return options[k];
  }).reduce(function (o, k) {
    o[k] = true;
    return o;
  }, {});
};

module.exports = parseOptions;

/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(/*! ./constants */ "./node_modules/semver/internal/constants.js"),
    MAX_SAFE_COMPONENT_LENGTH = _require.MAX_SAFE_COMPONENT_LENGTH;

var debug = __webpack_require__(/*! ./debug */ "./node_modules/semver/internal/debug.js");

exports = module.exports = {}; // The actual regexps go on exports.re

var re = exports.re = [];
var src = exports.src = [];
var t = exports.t = {};
var R = 0;

var createToken = function createToken(name, value, isGlobal) {
  var index = R++;
  debug(name, index, value);
  t[name] = index;
  src[index] = value;
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
}; // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.


createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+'); // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*'); // ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")"));
createToken('MAINVERSIONLOOSE', "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")")); // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', "(?:".concat(src[t.NUMERICIDENTIFIER], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
createToken('PRERELEASEIDENTIFIERLOOSE', "(?:".concat(src[t.NUMERICIDENTIFIERLOOSE], "|").concat(src[t.NONNUMERICIDENTIFIER], ")")); // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', "(?:-(".concat(src[t.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIER], ")*))"));
createToken('PRERELEASELOOSE', "(?:-?(".concat(src[t.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIERLOOSE], ")*))")); // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+'); // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', "(?:\\+(".concat(src[t.BUILDIDENTIFIER], "(?:\\.").concat(src[t.BUILDIDENTIFIER], ")*))")); // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', "v?".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE], "?").concat(src[t.BUILD], "?"));
createToken('FULL', "^".concat(src[t.FULLPLAIN], "$")); // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

createToken('LOOSEPLAIN', "[v=\\s]*".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE], "?").concat(src[t.BUILD], "?"));
createToken('LOOSE', "^".concat(src[t.LOOSEPLAIN], "$"));
createToken('GTLT', '((?:<|>)?=?)'); // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

createToken('XRANGEIDENTIFIERLOOSE', "".concat(src[t.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
createToken('XRANGEIDENTIFIER', "".concat(src[t.NUMERICIDENTIFIER], "|x|X|\\*"));
createToken('XRANGEPLAIN', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t.PRERELEASE], ")?").concat(src[t.BUILD], "?") + ")?)?");
createToken('XRANGEPLAINLOOSE', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t.PRERELEASELOOSE], ")?").concat(src[t.BUILD], "?") + ")?)?");
createToken('XRANGE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAIN], "$"));
createToken('XRANGELOOSE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAINLOOSE], "$")); // Coercion.
// Extract anything that could conceivably be a part of a valid semver

createToken('COERCE', "".concat('(^|[^\\d])' + '(\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:$|[^\\d])");
createToken('COERCERTL', src[t.COERCE], true); // Tilde ranges.
// Meaning is "reasonably at or greater than"

createToken('LONETILDE', '(?:~>?)');
createToken('TILDETRIM', "(\\s*)".concat(src[t.LONETILDE], "\\s+"), true);
exports.tildeTrimReplace = '$1~';
createToken('TILDE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN], "$"));
createToken('TILDELOOSE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE], "$")); // Caret ranges.
// Meaning is "at least and backwards compatible with"

createToken('LONECARET', '(?:\\^)');
createToken('CARETTRIM', "(\\s*)".concat(src[t.LONECARET], "\\s+"), true);
exports.caretTrimReplace = '$1^';
createToken('CARET', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN], "$"));
createToken('CARETLOOSE', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE], "$")); // A simple gt/lt/eq thing, or just "" to indicate "any version"

createToken('COMPARATORLOOSE', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], ")$|^$"));
createToken('COMPARATOR', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.FULLPLAIN], ")$|^$")); // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

createToken('COMPARATORTRIM', "(\\s*)".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], "|").concat(src[t.XRANGEPLAIN], ")"), true);
exports.comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

createToken('HYPHENRANGE', "^\\s*(".concat(src[t.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAIN], ")") + "\\s*$");
createToken('HYPHENRANGELOOSE', "^\\s*(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s*$"); // Star ranges basically just allow anything at all.

createToken('STAR', '(<|>)?=?\\s*\\*'); // >=0.0.0 is like a star

createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');

/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Determine if version is greater than all the versions possible in the range.
var outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js");

var gtr = function gtr(version, range, options) {
  return outside(version, range, '>', options);
};

module.exports = gtr;

/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");

var intersects = function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2);
};

module.exports = intersects;

/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js"); // Determine if version is less than all the versions possible in the range


var ltr = function ltr(version, range, options) {
  return outside(version, range, '<', options);
};

module.exports = ltr;

/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");

var maxSatisfying = function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;
  var rangeObj = null;

  try {
    rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
};

module.exports = maxSatisfying;

/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");

var minSatisfying = function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;
  var rangeObj = null;

  try {
    rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
};

module.exports = minSatisfying;

/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");

var gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js");

var minVersion = function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  var _loop = function _loop(i) {
    var comparators = range.set[i];
    var setMin = null;
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        default:
          throw new Error("Unexpected operation: ".concat(comparator.operator));
      }
    });

    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin;
    }
  };

  for (var i = 0; i < range.set.length; ++i) {
    _loop(i);
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
};

module.exports = minVersion;

/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js");

var Comparator = __webpack_require__(/*! ../classes/comparator */ "./node_modules/semver/classes/comparator.js");

var ANY = Comparator.ANY;

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");

var satisfies = __webpack_require__(/*! ../functions/satisfies */ "./node_modules/semver/functions/satisfies.js");

var gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js");

var lt = __webpack_require__(/*! ../functions/lt */ "./node_modules/semver/functions/lt.js");

var lte = __webpack_require__(/*! ../functions/lte */ "./node_modules/semver/functions/lte.js");

var gte = __webpack_require__(/*! ../functions/gte */ "./node_modules/semver/functions/gte.js");

var outside = function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisfies the range it is not outside


  if (satisfies(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  var _loop = function _loop(i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    if (high.operator === comp || high.operator === ecomp) {
      return {
        v: false
      };
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return {
        v: false
      };
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return {
        v: false
      };
    }
  };

  for (var i = 0; i < range.set.length; ++i) {
    var _ret = _loop(i);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return true;
};

module.exports = outside;

/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
var satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js");

var compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js");

module.exports = function (versions, range, options) {
  var set = [];
  var first = null;
  var prev = null;
  var v = versions.sort(function (a, b) {
    return compare(a, b, options);
  });

  var _iterator = _createForOfIteratorHelper(v),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var version = _step.value;
      var included = satisfies(version, range, options);

      if (included) {
        prev = version;

        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }

        prev = null;
        first = null;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (first) {
    set.push([first, null]);
  }

  var ranges = [];

  for (var _i = 0, _set = set; _i < _set.length; _i++) {
    var _set$_i = _slicedToArray(_set[_i], 2),
        min = _set$_i[0],
        max = _set$_i[1];

    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push('*');
    } else if (!max) {
      ranges.push(">=".concat(min));
    } else if (min === v[0]) {
      ranges.push("<=".concat(max));
    } else {
      ranges.push("".concat(min, " - ").concat(max));
    }
  }

  var simplified = ranges.join(' || ');
  var original = typeof range.raw === 'string' ? range.raw : String(range);
  return simplified.length < original.length ? simplified : range;
};

/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Range = __webpack_require__(/*! ../classes/range.js */ "./node_modules/semver/classes/range.js");

var Comparator = __webpack_require__(/*! ../classes/comparator.js */ "./node_modules/semver/classes/comparator.js");

var ANY = Comparator.ANY;

var satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js");

var compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js"); // Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true


var subset = function subset(sub, dom) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (sub === dom) {
    return true;
  }

  sub = new Range(sub, options);
  dom = new Range(dom, options);
  var sawNonNull = false;

  var _iterator = _createForOfIteratorHelper(sub.set),
      _step;

  try {
    OUTER: for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var simpleSub = _step.value;

      var _iterator2 = _createForOfIteratorHelper(dom.set),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var simpleDom = _step2.value;
          var isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;

          if (isSub) {
            continue OUTER;
          }
        } // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.

      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (sawNonNull) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return true;
};

var simpleSubset = function simpleSubset(sub, dom, options) {
  if (sub === dom) {
    return true;
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = [new Comparator('>=0.0.0-0')];
    } else {
      sub = [new Comparator('>=0.0.0')];
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = [new Comparator('>=0.0.0')];
    }
  }

  var eqSet = new Set();
  var gt, lt;

  var _iterator3 = _createForOfIteratorHelper(sub),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var c = _step3.value;

      if (c.operator === '>' || c.operator === '>=') {
        gt = higherGT(gt, c, options);
      } else if (c.operator === '<' || c.operator === '<=') {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  if (eqSet.size > 1) {
    return null;
  }

  var gtltComp;

  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options);

    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null;
    }
  } // will iterate one or zero times


  var _iterator4 = _createForOfIteratorHelper(eqSet),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var eq = _step4.value;

      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }

      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }

      var _iterator6 = _createForOfIteratorHelper(dom),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _c = _step6.value;

          if (!satisfies(eq, String(_c), options)) {
            return false;
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return true;
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  var higher, lower;
  var hasDomLT, hasDomGT; // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset

  var needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
  var needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false; // exception: <1.2.3-0 is the same as <1.2.3

  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }

  var _iterator5 = _createForOfIteratorHelper(dom),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _c2 = _step5.value;
      hasDomGT = hasDomGT || _c2.operator === '>' || _c2.operator === '>=';
      hasDomLT = hasDomLT || _c2.operator === '<' || _c2.operator === '<=';

      if (gt) {
        if (needDomGTPre) {
          if (_c2.semver.prerelease && _c2.semver.prerelease.length && _c2.semver.major === needDomGTPre.major && _c2.semver.minor === needDomGTPre.minor && _c2.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }

        if (_c2.operator === '>' || _c2.operator === '>=') {
          higher = higherGT(gt, _c2, options);

          if (higher === _c2 && higher !== gt) {
            return false;
          }
        } else if (gt.operator === '>=' && !satisfies(gt.semver, String(_c2), options)) {
          return false;
        }
      }

      if (lt) {
        if (needDomLTPre) {
          if (_c2.semver.prerelease && _c2.semver.prerelease.length && _c2.semver.major === needDomLTPre.major && _c2.semver.minor === needDomLTPre.minor && _c2.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }

        if (_c2.operator === '<' || _c2.operator === '<=') {
          lower = lowerLT(lt, _c2, options);

          if (lower === _c2 && lower !== lt) {
            return false;
          }
        } else if (lt.operator === '<=' && !satisfies(lt.semver, String(_c2), options)) {
          return false;
        }
      }

      if (!_c2.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    } // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0

  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false;
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false;
  } // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple


  if (needDomGTPre || needDomLTPre) {
    return false;
  }

  return true;
}; // >=1.2.3 is lower than >1.2.3


var higherGT = function higherGT(a, b, options) {
  if (!a) {
    return b;
  }

  var comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
}; // <=1.2.3 is higher than <1.2.3


var lowerLT = function lowerLT(a, b, options) {
  if (!a) {
    return b;
  }

  var comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
};

module.exports = subset;

/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js"); // Mostly just for testing and legacy API reasons


var toComparators = function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
};

module.exports = toComparators;

/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js");

var validRange = function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
};

module.exports = validRange;

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ rng; }
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ __webpack_exports__["default"] = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ __webpack_exports__["default"] = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ __webpack_exports__["default"] = (validate);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ __webpack_exports__["default"] = (version);

/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ (function(module) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var walker;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;

          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return walker.value;

          case 4:
            walker = walker.next;
            _context.next = 1;
            break;

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
};

/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
    walker = insert(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(/*! ./iterator.js */ "./node_modules/yallist/iterator.js")(Yallist);
} catch (er) {}

/***/ }),

/***/ "./src/modules/app.js":
/*!****************************!*\
  !*** ./src/modules/app.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/add/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfDay/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/endOfDay/index.js");
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _styles_reset_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/reset.css */ "./src/styles/reset.css");
/* harmony import */ var _styles_main_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/main.css */ "./src/styles/main.css");
/* harmony import */ var _modals_addProjectModal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modals/addProjectModal */ "./src/modules/modals/addProjectModal.js");
/* harmony import */ var _modals_addTaskModal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modals/addTaskModal */ "./src/modules/modals/addTaskModal.js");
/* harmony import */ var _modals_confirmModal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modals/confirmModal */ "./src/modules/modals/confirmModal.js");
/* harmony import */ var _modals_dataModal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modals/dataModal */ "./src/modules/modals/dataModal.js");
/* harmony import */ var _filterMenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filterMenu */ "./src/modules/filterMenu.js");
/* harmony import */ var _modals_infoModal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modals/infoModal */ "./src/modules/modals/infoModal.js");
/* harmony import */ var _modalStack__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modalStack */ "./src/modules/modalStack.js");
/* harmony import */ var _popupMenu__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./popupMenu */ "./src/modules/popupMenu.js");
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./project */ "./src/modules/project.js");
/* harmony import */ var _projectList__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./projectList */ "./src/modules/projectList.js");
/* harmony import */ var _recurringDate__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./recurringDate */ "./src/modules/recurringDate.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./settings */ "./src/modules/settings.js");
/* harmony import */ var _modals_settingsModal__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modals/settingsModal */ "./src/modules/modals/settingsModal.js");
/* harmony import */ var _task__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./task */ "./src/modules/task.js");
/* harmony import */ var _taskDisplay__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./taskDisplay */ "./src/modules/taskDisplay.js");
/* harmony import */ var _taskList__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./taskList */ "./src/modules/taskList.js");
/* harmony import */ var _utility_dates__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utility/dates */ "./src/modules/utility/dates.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utility/dom */ "./src/modules/utility/dom.js");
/* harmony import */ var _utility_storage__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utility/storage */ "./src/modules/utility/storage.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Defines the [App]{@link module:app~App} class.
 * @module app
 */























var APP_NAME = 'Task It Up';
var APP_AUTHOR = "Greg Kikola";
var APP_AUTHOR_WEBSITE = "https://www.gregkikola.com/";
var APP_COPYRIGHT_YEARS = '2021-2022';
var APP_VERSION = "1.0.0";
var APP_STORAGE_PREFIX = "task-it-up";
var NARROW_LAYOUT_CUTOFF = 700;
/**
 * Object holding private members for the [App]{@link module:app~App} class.
 * @typedef {Object} module:app~App~privates
 * @property {module:taskList~TaskList} tasks Holds the task container.
 * @property {module:projectList~ProjectList} projects Holds the project
 *   container.
 * @property {module:modalStack~ModalStack} modalStack The stack of modal
 *   dialogs.
 * @property {module:filterMenu~FilterMenu} filterMenu The menu of task filters
 *   in the side panel.
 * @property {module:filterMenu~FilterMenu~filterInfo} currentFilter Holds the
 *   task filter that is currently being displayed in the main panel.
 * @property {module:taskDisplay~TaskDisplay} taskDisplay Holds the task
 *   display panel.
 * @property {module:settings~Settings} settings Holds user app settings.
 * @property {HTMLElement} appContainer Holds a reference to the DOM node
 *   holding the page elements for the app.
 * @property {HTMLElement} sidePanel Holds a reference to the side panel
 *   element in the DOM.
 * @property {HTMLElement} resizer Holds a reference to the resizing bar
 *   element for the side panel.
 * @property {HTMLElement} mainPanel Holds a reference to the main panel
 *   element in the DOM.
 * @property {module:popupMenu~PopupMenu} mainPanelMenu The popup menu that is
 *   shown when the user clicks the 'more' button in the main panel.
 * @property {boolean} narrowScreen Indicates whether the screen size is
 *   narrow. This should be true when the viewport width is less than or equal
 *   to NARROW_LAYOUT_CUTOFF.
 */

/**
 * Holds private data for the [App]{@link module:app~App} class.
 * @type {WeakMap}
 * @see module:app~App~privates
 */

var privateMembers = new WeakMap();

function addRandomData(instance, taskCount, projCount) {
  var getRandom = function getRandom(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  };

  var passCheck = function passCheck(probability) {
    return Math.random() < probability;
  };

  var sentences = ['Call me Ishmael.', 'It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair.', 'It is a truth universally acknowledged, that a single man in possession of a good fortune, must be in want of a wife.', 'In my younger and more vulnerable years my father gave me some advice that I\'ve been turning over in my mind ever since.', 'It was a bright cold day in April, and the clocks were striking thirteen.', 'It was a pleasure to burn.', 'As Gregor Samsa awoke one morning from uneasy dreams he found himself transformed in his bed into an enormous insect.', 'Far out in the uncharted backwaters of the unfashionable end of the western spiral arm of the Galaxy lies a small, unregarded yellow sun.', 'All happy families are alike; each unhappy family is unhappy in its own way', 'Whether I shall turn out to be the hero of my own life, or whether that station will be held by anybody else, these pages must show.'];

  var randomSentence = function randomSentence() {
    return sentences[getRandom(0, sentences.length - 1)];
  };

  var randomDate = function randomDate() {
    var today = new Date();
    return (0,date_fns__WEBPACK_IMPORTED_MODULE_22__["default"])(today, {
      days: getRandom(-5, 40)
    });
  };

  var randomRecurrence = function randomRecurrence() {
    var random = Math.random();
    var unit;
    if (random < 0.25) unit = 'day';else if (random < 0.5) unit = 'week';else if (random < 0.75) unit = 'month';else unit = 'year';
    return new _recurringDate__WEBPACK_IMPORTED_MODULE_13__["default"](unit, {
      intervalLength: passCheck(0.5) ? 1 : getRandom(2, 10),
      startDate: passCheck(0.5) ? randomDate() : null,
      baseOnCompletion: passCheck(0.25)
    });
  };

  var privates = privateMembers.get(instance);
  var projects = [];

  for (var i = 0; i < projCount; i += 1) {
    var project = new _project__WEBPACK_IMPORTED_MODULE_11__["default"]("Project ".concat(i + 1), {
      description: passCheck(0.5) ? randomSentence() : null
    });
    projects.push(privates.projects.addProject(project));
  }

  var randomProject = function randomProject() {
    return projects[getRandom(0, projects.length - 1)];
  };

  for (var _i = 0; _i < taskCount; _i += 1) {
    var task = new _task__WEBPACK_IMPORTED_MODULE_16__["default"]("Task ".concat(_i + 1), {
      dueDate: passCheck(0.5) ? randomDate() : null,
      completionDate: passCheck(0.1) ? new Date() : null,
      priority: getRandom(-2, 2),
      description: passCheck(0.5) ? randomSentence() : null,
      recurringDate: passCheck(0.5) ? randomRecurrence() : null,
      project: passCheck(0.5) ? randomProject() : null
    });
    privates.tasks.addTask(task);
  }
}
/**
 * Open the side panel, so that the filter menu is visible.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function openSidePanel(instance) {
  var privates = privateMembers.get(instance);
  privates.sidePanel.classList.remove('closed');
  privates.resizer.classList.remove('closed');
}
/**
 * Close the side panel, so that the filter menu is hidden.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function closeSidePanel(instance) {
  var privates = privateMembers.get(instance);
  privates.sidePanel.classList.add('closed');
  privates.resizer.classList.add('closed');
}
/**
 * Toggle the side panel's visibility.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function toggleSidePanel(instance) {
  var privates = privateMembers.get(instance);
  var closed = privates.sidePanel.classList.toggle('closed');
  if (closed) privates.resizer.classList.add('closed');else privates.resizer.classList.remove('closed');
}
/**
 * Update the menu items in the popup menu for the main panel based on the
 * selected filter.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function updateMainPanelMenu(instance) {
  var privates = privateMembers.get(instance);
  var _privates$currentFilt = privates.currentFilter,
      group = _privates$currentFilt.group,
      filter = _privates$currentFilt.filter;
  var filterOptions = privates.settings.getFilterOptions(group);
  var GROUP_ICON = 'category';
  var SORT_ICON = 'sort';
  var groupBy = filterOptions.groupBy,
      sortBy = filterOptions.sortBy,
      sortDescending = filterOptions.sortDescending,
      showCompleted = filterOptions.showCompleted;
  var optionItems = [{
    label: 'Add Task...',
    id: 'add-task',
    iconType: 'add'
  }, {
    label: 'Add Project...',
    id: 'add-project',
    iconType: 'add'
  }];
  var groupByItems = [];
  var sortByItems = [];

  if (group === 'projects' && filter !== 'none') {
    optionItems.push({
      label: 'Edit Project...',
      id: 'edit-project',
      iconType: 'edit'
    });
    optionItems.push({
      label: 'Delete Project...',
      id: 'delete-project',
      iconType: 'delete'
    });
  }

  optionItems.push({
    label: showCompleted ? 'Hide Completed Tasks' : 'Show Completed Tasks',
    id: showCompleted ? 'hide-completed' : 'show-completed',
    iconType: 'done'
  }, {
    label: sortDescending ? 'Sort Ascending' : 'Sort Descending',
    id: sortDescending ? 'sort-ascending' : 'sort-descending',
    iconType: 'swap_vert'
  });

  if (groupBy !== 'default') {
    groupByItems.push({
      label: 'Use Default Grouping',
      id: 'group-by-default',
      iconType: GROUP_ICON
    });
  }

  if (groupBy !== 'none') {
    groupByItems.push({
      label: 'Do Not Group Tasks',
      id: 'group-by-none',
      iconType: GROUP_ICON
    });
  }

  if (sortBy !== 'create-date') {
    sortByItems.push({
      label: 'Sort by Date Added',
      id: 'sort-by-create-date',
      iconType: SORT_ICON
    });
  }

  if ((group !== 'dates' || filter !== 'past-due') && groupBy !== 'due-date') {
    groupByItems.push({
      label: 'Group by Due Date',
      id: 'group-by-due-date',
      iconType: GROUP_ICON
    });

    if (sortBy !== 'due-date') {
      sortByItems.push({
        label: 'Sort by Due Date',
        id: 'sort-by-due-date',
        iconType: SORT_ICON
      });
    }
  }

  if (group !== 'projects' && groupBy !== 'project') {
    groupByItems.push({
      label: 'Group by Project',
      id: 'group-by-project',
      iconType: GROUP_ICON
    });

    if (sortBy !== 'project') {
      sortByItems.push({
        label: 'Sort by Project',
        id: 'sort-by-project',
        iconType: SORT_ICON
      });
    }
  }

  if (group !== 'priorities' && groupBy !== 'priority') {
    groupByItems.push({
      label: 'Group by Priority',
      id: 'group-by-priority',
      iconType: GROUP_ICON
    });

    if (sortBy !== 'priority') {
      sortByItems.push({
        label: 'Sort by Priority',
        id: 'sort-by-priority',
        iconType: SORT_ICON
      });
    }
  }

  var menuItems = [].concat(optionItems, groupByItems, sortByItems);
  privates.mainPanelMenu.setMenuItems(menuItems);
}
/**
 * Update the heading in the main panel.
 * @param {string} heading The new heading to display.
 * @param {string} [subheading] The new subheading to display, if any.
 */


function updateMainHeading(heading, subheading) {
  var headingElem = document.getElementById('main-panel-heading');
  var subheadingElem = document.getElementById('main-panel-subheading');
  headingElem.textContent = heading;

  if (subheading) {
    subheadingElem.textContent = subheading;
    subheadingElem.style.display = 'block';
  } else {
    subheadingElem.textContent = '';
    subheadingElem.style.display = 'none';
  }
}
/**
 * Refresh the main panel.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {Object} [options={}] An object holding options for the main panel.
 * @param {boolean} [options.resetScroll=true] If set to true (the default),
 *   then the panel's scroll position will be reset back to the top. Otherwise
 *   the scroll position will not be changed.
 */


function updateMainPanel(instance) {
  var _options$resetScroll;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var privates = privateMembers.get(instance);
  var _privates$currentFilt2 = privates.currentFilter,
      group = _privates$currentFilt2.group,
      filter = _privates$currentFilt2.filter;
  var heading = null;
  var subheading = null;
  var displayOptions = {
    groupBy: 'none',
    resetScroll: (_options$resetScroll = options.resetScroll) !== null && _options$resetScroll !== void 0 ? _options$resetScroll : true,
    dateFormat: privates.settings.dateFormat
  };
  var filterOptions;

  switch (group) {
    case 'dates':
      {
        filterOptions = privates.settings.getFilterOptions('dates');
        var today = (0,date_fns__WEBPACK_IMPORTED_MODULE_23__["default"])(new Date());
        var todayEnd = (0,date_fns__WEBPACK_IMPORTED_MODULE_24__["default"])(today);
        var duration = {};

        switch (filter) {
          case 'today':
            heading = 'Today';
            subheading = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_19__.formatDate)(today, 'eeee, MMMM d, yyyy');
            break;

          case 'week':
            heading = 'This Week';
            displayOptions.groupBy = 'due-date';
            duration.weeks = 1;
            duration.days = -1;
            break;

          case 'month':
            heading = 'This Month';
            displayOptions.groupBy = 'due-date';
            duration.months = 1;
            duration.days = -1;
            break;

          case 'past-due':
            heading = 'Past Due';
            duration.days = -1;
            displayOptions.requireDueDate = true;
            break;

          default:
            break;
        }

        displayOptions.endDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_22__["default"])(todayEnd, duration);

        if (filter !== 'today' && filter !== 'past-due') {
          var dateFormat = privates.settings.dateFormat.outputPattern;
          var startStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_19__.formatDate)(today, dateFormat);
          var endStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_19__.formatDate)(displayOptions.endDate, dateFormat);
          subheading = "".concat(startStr, " to ").concat(endStr);
        }

        break;
      }

    case 'projects':
      filterOptions = privates.settings.getFilterOptions('projects');
      displayOptions.project = filter;

      if (filter === 'none') {
        heading = 'Uncategorized';
      } else {
        var project = privates.projects.getProject(filter);
        heading = project.name;
        subheading = project.description || null;
      }

      break;

    case 'priorities':
      {
        filterOptions = privates.settings.getFilterOptions('priorities');
        var priority = _task__WEBPACK_IMPORTED_MODULE_16__["default"].convertStringToPriority(filter);
        displayOptions.priority = priority;
        heading = "".concat(_task__WEBPACK_IMPORTED_MODULE_16__["default"].convertPriorityToPrettyString(priority), " Priority");
        break;
      }

    case 'default':
    default:
      filterOptions = privates.settings.getFilterOptions('default');
      heading = 'All Tasks';
      break;
  } // Override grouping if needed


  if (filterOptions.groupBy !== 'default') {
    displayOptions.groupBy = filterOptions.groupBy;
  }

  displayOptions.sortBy = filterOptions.sortBy;
  displayOptions.completed = filterOptions.showCompleted;
  displayOptions.sortDescending = filterOptions.sortDescending;
  updateMainHeading(heading, subheading);
  privates.taskDisplay.update(displayOptions);
  updateMainPanelMenu(instance);
}
/**
 * Refresh the list of projects in the filter menu.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function updateProjectFilters(instance) {
  var privates = privateMembers.get(instance);
  var selection = privates.filterMenu.getSelection();
  privates.filterMenu.removeAllFilters('projects');
  privates.filterMenu.addFilter('projects', 'none', 'Uncategorized');
  privates.projects.forEach(function (entry) {
    privates.filterMenu.addFilter('projects', entry.id, entry.project.name);
  }); // Restore selection

  if (selection.group === 'projects') {
    var filter = selection.filter;

    if (privates.filterMenu.hasFilter('projects', filter)) {
      privates.filterMenu.selectFilter('projects', filter);
    } else {
      privates.filterMenu.selectFilter('projects', 'none');
    }
  }
}
/**
 * Export app data to a JSON file.
 * @param {module:app~App} instance The [App]{@link module:app~App} instance
 *   whose data is to be exported.
 * @param {Object} [options={}] An object holding additional file options.
 * @param {string} [options.newlineSequence] The character sequence to use for
 *   newlines.
 */


function exportToJson(instance) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var output = "".concat(JSON.stringify(instance, null, 2), "\n");

  if (options.newlineSequence) {
    output = output.replace(/\n/g, options.newlineSequence);
  }

  (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.generateFile)(output, 'tasks.json', 'application/json');
}
/**
 * Export app data to a CSV file.
 * @param {module:app~App} instance The [App]{@link module:app~App} instance
 *   whose data is to be exported.
 * @param {Object} [options={}] An object holding additional file options.
 * @param {string} [options.newlineSequence] The character sequence to use for
 *   newlines.
 */


function exportToCsv(instance) {
  var _options$newlineSeque;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _privateMembers$get = privateMembers.get(instance),
      tasks = _privateMembers$get.tasks,
      projects = _privateMembers$get.projects;

  var output = tasks.toCsv({
    newlineSequence: (_options$newlineSeque = options.newlineSequence) !== null && _options$newlineSeque !== void 0 ? _options$newlineSeque : '\r\n',
    projectList: projects
  });
  (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.generateFile)(output, 'tasks.csv', 'text/csv');
}
/**
 * Import app data from a string in JSON format.
 * @param {module:app~App} instance The [App]{@link module:app~App} instance in
 *   which to import the data.
 * @param {string} data The app data in JSON format.
 * @returns {module:app~App~importStatus} An object holding information about
 *   the status of the import.
 */


function importFromJson(instance, data) {
  var privates = privateMembers.get(instance);
  var taskCounts = {
    added: 0,
    updated: 0,
    failed: 0,
    total: 0
  };

  var projectCounts = _objectSpread({}, taskCounts);

  var errors = [];

  try {
    var _JSON$parse = JSON.parse(data),
        app = _JSON$parse.app,
        settings = _JSON$parse.settings,
        tasks = _JSON$parse.tasks,
        projects = _JSON$parse.projects;

    if ((app === null || app === void 0 ? void 0 : app.name) !== APP_NAME || !semver__WEBPACK_IMPORTED_MODULE_0___default().valid(app === null || app === void 0 ? void 0 : app.version)) {
      errors.push('Warning: Imported data does not follow the expected schema. The data may have been created by a different application, or may have been altered.');
    } else if (semver__WEBPACK_IMPORTED_MODULE_0___default().gt(app.version, APP_VERSION)) {
      errors.push('Warning: Imported data seems to have been created by a newer version of the application. Some information might not be imported or might be imported incorrectly.');
    }

    if (settings != null) {
      var result = privates.settings.importFromJson(settings);
      errors.push.apply(errors, _toConsumableArray(result.errors));
    }

    if (projects != null) {
      var _result = privates.projects.importFromJson(projects);

      Object.assign(projectCounts, _result.projects);
      errors.push.apply(errors, _toConsumableArray(_result.errors));
    }

    if (tasks != null) {
      var _result2 = privates.tasks.importFromJson(tasks, {
        projectList: privates.projects
      });

      Object.assign(taskCounts, _result2.tasks);
      errors.push.apply(errors, _toConsumableArray(_result2.errors));
    }

    return {
      successful: true,
      format: 'json',
      tasks: taskCounts,
      projects: projectCounts,
      errors: errors
    };
  } catch (e) {
    if (e instanceof SyntaxError) {
      return {
        successful: false,
        format: 'json',
        tasks: taskCounts,
        projects: projectCounts,
        errors: ["Fatal Error: ".concat(e.message)]
      };
    }

    throw e;
  }
}
/**
 * Import app data from a CSV string.
 * @param {module:app~App} instance The [App]{@link module:app~App} instance in
 *   which to import the data.
 * @param {string} data The app data in CSV format.
 * @returns {module:app~App~importStatus} An object holding information about
 *   the status of the import.
 */


function importFromCsv(instance, data) {
  var privates = privateMembers.get(instance);
  var taskCounts = {
    added: 0,
    updated: 0,
    failed: 0,
    total: 0
  };

  var projectCounts = _objectSpread({}, taskCounts);

  var errors = [];
  var parsedData = (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.parseCsv)(data);
  var result;
  result = privates.projects.importFromCsv(parsedData);
  Object.assign(projectCounts, result.projects);
  errors.push.apply(errors, _toConsumableArray(result.errors));
  result = privates.tasks.importFromCsv(parsedData, {
    projectList: privates.projects
  });
  Object.assign(taskCounts, result.tasks);
  errors.push.apply(errors, _toConsumableArray(result.errors));
  return {
    successful: true,
    format: 'csv',
    tasks: taskCounts,
    projects: projectCounts,
    errors: errors
  };
}
/**
 * Import app data from a file. This function will attempt to determine whether
 * the file is in JSON or CSV format, first using the file extension and,
 * failing that, by examining the contents.
 * @param {module:app~App} instance The [App]{@link module:app~App} instance in
 *   which to import the data.
 * @param {string} content The contents of the file being imported.
 * @param {string} [name] The name of the file being imported.
 * @returns {module:app~App~importStatus} An object holding information about
 *   the status of the import.
 */


function importFromFile(instance, content, name) {
  var fileExt = name ? (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.getFileExtension)(name).toLowerCase() : '';

  switch (fileExt) {
    case '.json':
      return importFromJson(instance, content);

    case '.csv':
      return importFromCsv(instance, content);

    default:
      {
        var result = importFromJson(instance, content);

        if (!result.successful) {
          result = importFromCsv(instance, content);

          if (!result.successful) {
            var counts = {
              added: 0,
              updated: 0,
              failed: 0,
              total: 0
            };
            return {
              successful: false,
              format: 'unknown',
              tasks: _objectSpread({}, counts),
              projects: _objectSpread({}, counts),
              errors: ['Fatal Error: Unable to determine file format. Imported data must be in either JSON or CSV format.']
            };
          }
        }

        return result;
      }
  }
}
/**
 * Delete all user data.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function deleteAllData(instance) {
  var privates = privateMembers.get(instance);
  privates.settings.resetToDefault();
  privates.tasks.deleteAll();
  privates.projects.deleteAll();
  updateProjectFilters(instance);
  updateMainPanel(instance);
}
/**
 * Display a modal confirmation dialog.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {string} message The message to display to the user.
 * @param {Function} [onConfirm] A callback function to be invoked when the
 *   user confirms the modal.
 * @param {Function} [onCancel] A callback function to be invoked when the user
 *   cancels the modal.
 */


function showConfirmation(instance, message, onConfirm, onCancel) {
  var privates = privateMembers.get(instance);
  var modal = new _modals_confirmModal__WEBPACK_IMPORTED_MODULE_5__["default"](message, {
    confirm: onConfirm || null,
    cancel: onCancel || null
  });
  privates.modalStack.showModal(modal);
}
/**
 * Display the modal dialog for adding or editing a task. After the user
 * confirms the dialog, the task is added to the task list.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {Object} [options={}] An object holding options for creating the
 *   modal.
 * @param {string} [options.taskId] The identifier for the task to edit, if
 *   any.
 * @param {string} [options.projectId] The identifier for the default project
 *   that the task should be assigned to, if any. If a task id was given,
 *   then this option is ignored.
 * @param {number} [options.priority=0] The default priority for the task. If
 *   a task id was given, then this option is ignored.
 */


function showAddTaskModal(instance) {
  var _options$priority;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var privates = privateMembers.get(instance);
  var modal = new _modals_addTaskModal__WEBPACK_IMPORTED_MODULE_4__["default"](privates.tasks, privates.projects, {
    taskId: options.taskId || null,
    projectId: options.projectId || null,
    priority: (_options$priority = options.priority) !== null && _options$priority !== void 0 ? _options$priority : 0,
    dateFormat: privates.settings.dateFormat,
    confirm: function confirm() {
      return updateMainPanel(instance, {
        resetScroll: false
      });
    },
    newProject: function newProject() {
      return updateProjectFilters(instance);
    }
  });
  privates.modalStack.showModal(modal);
}
/**
 * Display the modal dialog for adding or editing a project. After the user
 * confirms the dialog, the project is added to the project list.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {Object} [options={}] An object holding options for creating the
 *   modal.
 * @param {string} [options.projectId] The identifier for the project to
 *   edit, if any. If not given, a new project is created.
 */


function showAddProjectModal(instance) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var privates = privateMembers.get(instance);
  var projectToUpdate = null;

  if (options.projectId) {
    projectToUpdate = privates.projects.getProject(options.projectId);
  }

  var modal = new _modals_addProjectModal__WEBPACK_IMPORTED_MODULE_3__["default"]({
    confirm: function confirm(project) {
      var newId = null;

      if (options.projectId) {
        privates.projects.updateProject(options.projectId, project);
      } else {
        newId = privates.projects.addProject(project);
      }

      updateProjectFilters(instance);
      if (newId) privates.filterMenu.selectFilter('projects', newId);
    },
    project: projectToUpdate
  });
  privates.modalStack.showModal(modal);
}
/**
 * Display the modal dialog for modifying user settings.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function showSettingsModal(instance) {
  var privates = privateMembers.get(instance);
  var modal = new _modals_settingsModal__WEBPACK_IMPORTED_MODULE_15__["default"](privates.settings, {
    confirm: function confirm() {
      return updateMainPanel(instance, {
        resetScroll: false
      });
    }
  });
  privates.modalStack.showModal(modal);
}
/**
 * Display the modal dialog for managing user data.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function showDataModal(instance) {
  var privates = privateMembers.get(instance);
  var modal = new _modals_dataModal__WEBPACK_IMPORTED_MODULE_6__["default"]({
    importData: function importData(content, _ref) {
      var name = _ref.name;
      var result = importFromFile(instance, content, name);
      if (result.projects.total > 0) updateProjectFilters(instance);

      if (result.tasks.total > 0) {
        updateMainPanel(instance, {
          resetScroll: false
        });
      }

      var container = document.createElement('div');
      var statusMsg = document.createElement('div');
      statusMsg.classList.add('data-import-results');
      container.appendChild(statusMsg);

      if (result.successful) {
        statusMsg.textContent = ['Data import succeeded.', "Processed ".concat(result.tasks.total, " ").concat(result.tasks.total !== 1 ? 'tasks' : 'task', ": ").concat(result.tasks.added, " added, ").concat(result.tasks.updated, " updated, ").concat(result.tasks.failed, " failed."), "Processed ".concat(result.projects.total, " ").concat(result.projects.total !== 1 ? 'projects' : 'project', ": ").concat(result.projects.added, " added, ").concat(result.projects.updated, " updated, ").concat(result.projects.failed, " failed.")].join('\n');
      } else {
        statusMsg.textContent = 'Data import failed.';
      }

      if (result.errors.length > 0) {
        var errorList = document.createElement('ul');
        errorList.classList.add('data-import-error-list');
        result.errors.forEach(function (error) {
          var listItem = document.createElement('li');
          listItem.classList.add('data-import-results');
          listItem.textContent = error;
          errorList.appendChild(listItem);
        });
        container.appendChild(errorList);
      }

      var infoModal = new _modals_infoModal__WEBPACK_IMPORTED_MODULE_8__["default"](container, {
        title: 'Import Status'
      });
      privates.modalStack.showModal(infoModal);
    },
    exportData: function exportData(fileType, fileOptions) {
      if (fileType === 'csv') exportToCsv(instance, fileOptions);else exportToJson(instance, fileOptions);
    },
    deleteAll: function deleteAll() {
      return deleteAllData(instance);
    }
  });
  privates.modalStack.showModal(modal);
}
/**
 * Respond to a selection in the main panel menu.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {string} itemId The identifier for the menu item that was selected.
 */


function handleMainPanelMenuSelection(instance, itemId) {
  var privates = privateMembers.get(instance);
  var _privates$currentFilt3 = privates.currentFilter,
      group = _privates$currentFilt3.group,
      filter = _privates$currentFilt3.filter;
  var filterOptions = privates.settings.getFilterOptions(group);
  var needPanelUpdate = true;
  var needFilterOptionUpdate = true;

  switch (itemId) {
    case 'add-task':
      {
        var modalOptions = {};

        if (group === 'projects' && filter !== 'none') {
          modalOptions.projectId = filter;
        } else if (group === 'priorities') {
          modalOptions.priority = _task__WEBPACK_IMPORTED_MODULE_16__["default"].convertStringToPriority(filter);
        }

        showAddTaskModal(instance, modalOptions);
        needPanelUpdate = false;
        needFilterOptionUpdate = false;
        break;
      }

    case 'add-project':
      showAddProjectModal(instance);
      needPanelUpdate = false;
      needFilterOptionUpdate = false;
      break;

    case 'edit-project':
      showAddProjectModal(instance, {
        projectId: filter
      });
      needFilterOptionUpdate = false;
      break;

    case 'delete-project':
      {
        var project = privates.projects.getProject(filter);
        if (!project) break;
        showConfirmation(instance, "Are you sure you want to delete the project '".concat(project.name, "'?"), function () {
          privates.tasks.clearProject(filter);
          privates.projects.deleteProject(filter);
          updateProjectFilters(instance);
        });
        needPanelUpdate = false;
        needFilterOptionUpdate = false;
        break;
      }

    case 'show-completed':
      filterOptions.showCompleted = true;
      break;

    case 'hide-completed':
      filterOptions.showCompleted = false;
      break;

    case 'sort-ascending':
      filterOptions.sortDescending = false;
      break;

    case 'sort-descending':
      filterOptions.sortDescending = true;
      break;

    case 'group-by-default':
      filterOptions.groupBy = 'default';
      break;

    case 'group-by-none':
      filterOptions.groupBy = 'none';
      break;

    case 'group-by-due-date':
      filterOptions.groupBy = 'due-date';
      break;

    case 'group-by-project':
      filterOptions.groupBy = 'project';
      break;

    case 'group-by-priority':
      filterOptions.groupBy = 'priority';
      break;

    case 'sort-by-create-date':
      filterOptions.sortBy = 'create-date';
      break;

    case 'sort-by-due-date':
      filterOptions.sortBy = 'due-date';
      break;

    case 'sort-by-project':
      filterOptions.sortBy = 'project';
      break;

    case 'sort-by-priority':
      filterOptions.sortBy = 'priority';
      break;

    default:
      break;
  }

  if (needFilterOptionUpdate) {
    privates.settings.setFilterOptions(group, filterOptions);
  }

  if (needPanelUpdate) updateMainPanel(instance, {
    resetScroll: false
  });
}
/**
 * Complete a task in the task list.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {string} id The unique identifier of the task to complete.
 */


function completeTask(instance, id) {
  var _privateMembers$get2 = privateMembers.get(instance),
      taskList = _privateMembers$get2.tasks;

  var task = taskList.getTask(id);
  var now = new Date();

  if (task.recurringDate) {
    var baseDate = now;

    if (task.dueDate && !task.recurringDate.baseOnCompletion) {
      baseDate = task.dueDate;
    }

    var newDueDate = task.recurringDate.getNextOccurrence(baseDate);

    if (!newDueDate) {
      task.markComplete();
      task.recurringDate = null;
    } else {
      task.markIncomplete();
      task.recurringDate.advance();
      task.dueDate = newDueDate;
    }
  } else {
    task.markComplete();
  }

  taskList.updateTask(id, task);
}
/**
 * Respond to an action that the user performed on a task.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {string} type The type of action being performed: 'mark-complete',
 *   'mark-incomplete', 'edit', or 'delete'.
 * @param {string} id The unique identifier of the task being updated.
 * @param {module:task~Task} task The task being updated.
 */


function handleTaskUpdate(instance, type, id, task) {
  var privates = privateMembers.get(instance);
  var needUpdate = true;

  switch (type) {
    case 'mark-complete':
      completeTask(instance, id);
      break;

    case 'mark-incomplete':
      task.markIncomplete();
      privates.tasks.updateTask(id, task);
      break;

    case 'edit':
      showAddTaskModal(instance, {
        taskId: id
      });
      needUpdate = false;
      break;

    case 'clone':
      privates.tasks.addTask(task);
      break;

    case 'delete':
      showConfirmation(instance, "Are you sure you want to delete the task '".concat(task.name, "'?"), function () {
        privates.tasks.deleteTask(id);
        updateMainPanel(instance, {
          resetScroll: false
        });
      });
      needUpdate = false;
      break;

    case 'go-to-project':
      privates.filterMenu.selectFilter('projects', task.project || 'none');
      needUpdate = false;
      break;

    default:
      needUpdate = false;
      break;
  }

  if (needUpdate) updateMainPanel(instance, {
    resetScroll: false
  });
}
/**
 * Respond to a change in the filter menu selection.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {Object} event The event object.
 * @param {string} [event.groupId] The identifier for the group containing the
 *   filter that was selected, if any.
 * @param {string} [event.filterId] The identifier for the filter that was
 *   selected, if any.
 * @param {string} [event.filterLabel] The displayed label for the selected
 *   filter, if any.
 */


function handleFilterChange(instance, event) {
  if (!event.groupId || !event.filterId) return;
  var privates = privateMembers.get(instance);
  privates.currentFilter.group = event.groupId;
  privates.currentFilter.filter = event.filterId;
  updateMainPanel(instance);
}
/**
 * Respond to a selection in the User menu.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {string} itemId The identifier of the menu item that was selected.
 */


function handleUserMenuSelection(instance, itemId) {
  switch (itemId) {
    case 'settings':
      showSettingsModal(instance);
      break;

    case 'data':
      showDataModal(instance);
      break;

    case 'about':
      break;

    default:
      break;
  }
}
/**
 * Make sure app information and settings are stored in local storage if
 * needed.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function initializeStorage(instance) {
  (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, 'app.version', APP_VERSION);
  var storageMethod = (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.retrieveData)(APP_STORAGE_PREFIX, 'setting.storageMethod');
  if (storageMethod && storageMethod !== 'local') return; // Store any settings that are not already in local storage

  privateMembers.get(instance).settings.forEach(function (name, value) {
    var key = "setting.".concat(name);

    if (!(0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.retrieveData)(APP_STORAGE_PREFIX, key)) {
      (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, key, value);
    }
  });
}
/**
 * Load all items from local storage into the app.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function loadAllStorageData(instance) {
  var privates = privateMembers.get(instance);
  (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.forEachDataItem)(APP_STORAGE_PREFIX, function (key, value) {
    var dotIndex = key.indexOf('.');
    var type = key.substring(0, dotIndex);
    var id = key.substring(dotIndex + 1);

    switch (type) {
      case 'task':
        privates.tasks.addOrUpdateTask(id, _task__WEBPACK_IMPORTED_MODULE_16__["default"].fromJson(value));
        break;

      case 'project':
        privates.projects.addOrUpdateProject(id, _project__WEBPACK_IMPORTED_MODULE_11__["default"].fromJson(value));
        break;

      case 'setting':
        privates.settings.setSetting(id, value);
        break;

      default:
        break;
    }
  });
}
/**
 * Store all user data in local storage.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 */


function storeAllData(instance) {
  var privates = privateMembers.get(instance);
  (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, 'app.version', APP_VERSION);

  if (privates.settings.storageMethod === 'local') {
    privates.tasks.forEach(function (_ref2) {
      var id = _ref2.id,
          task = _ref2.task;
      (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, "task.".concat(id), task);
    });
    privates.projects.forEach(function (_ref3) {
      var id = _ref3.id,
          project = _ref3.project;
      (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, "project.".concat(id), project);
    });
    privates.settings.forEach(function (name, value) {
      (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, "setting.".concat(name), value);
    });
  } else {
    (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, 'setting.storageMethod', 'none');
  }
}
/**
 * Update local storage after data has been changed.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {string} type The type of data that was changed: 'setting', 'task',
 *   or 'project'.
 * @param {Object} eventData The event object specifying the data that was
 *   changed.
 */


function updateStorage(instance, type, eventData) {
  var privates = privateMembers.get(instance); // If storage method is changing, we need to delete or restore everything

  if (type === 'setting' && eventData.name === 'storageMethod') {
    if (eventData.value !== 'local') (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.clearData)(APP_STORAGE_PREFIX);
    storeAllData(instance);
    return;
  }

  if (privates.settings.storageMethod !== 'local') return;

  switch (type) {
    case 'task':
      {
        var eventType = eventData.type,
            id = eventData.id,
            task = eventData.task;
        var key = "task.".concat(id);

        switch (eventType) {
          case 'add-task':
          case 'update-task':
            (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, key, task);
            break;

          case 'delete-task':
            (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.removeData)(APP_STORAGE_PREFIX, key);
            break;

          default:
            break;
        }

        break;
      }

    case 'project':
      {
        var _eventType = eventData.type,
            _id = eventData.id,
            project = eventData.project;

        var _key = "project.".concat(_id);

        switch (_eventType) {
          case 'add-project':
          case 'update-project':
            (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, _key, project);
            break;

          case 'delete-project':
            (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.removeData)(APP_STORAGE_PREFIX, _key);
            break;

          default:
            break;
        }

        break;
      }

    case 'setting':
      {
        var name = eventData.name,
            value = eventData.value;
        (0,_utility_storage__WEBPACK_IMPORTED_MODULE_21__.storeData)(APP_STORAGE_PREFIX, "setting.".concat(name), value);
        break;
      }

    default:
      break;
  }
}
/**
 * Create the app's task filter menu.
 * @param {module:app~App} instance The class instances on which to apply the
 *   function.
 */


function createFilterMenu(instance) {
  var privates = privateMembers.get(instance);
  var filterGroups = [{
    id: 'default',
    label: null
  }, {
    id: 'dates',
    label: 'Dates'
  }, {
    id: 'projects',
    label: 'Projects'
  }, {
    id: 'priorities',
    label: 'Priorities'
  }];
  var filterMenu = new _filterMenu__WEBPACK_IMPORTED_MODULE_7__["default"](privates.sidePanel, filterGroups);
  var filters = [{
    groupId: 'default',
    filterId: 'all',
    label: 'All Tasks'
  }, {
    groupId: 'dates',
    filterId: 'today',
    label: 'Today'
  }, {
    groupId: 'dates',
    filterId: 'week',
    label: 'This Week'
  }, {
    groupId: 'dates',
    filterId: 'month',
    label: 'This Month'
  }, {
    groupId: 'dates',
    filterId: 'past-due',
    label: 'Past Due'
  }, {
    groupId: 'priorities',
    filterId: 'very-high',
    label: 'Very High'
  }, {
    groupId: 'priorities',
    filterId: 'high',
    label: 'High'
  }, {
    groupId: 'priorities',
    filterId: 'medium',
    label: 'Medium'
  }, {
    groupId: 'priorities',
    filterId: 'low',
    label: 'Low'
  }, {
    groupId: 'priorities',
    filterId: 'very-low',
    label: 'Very Low'
  }];
  filters.forEach(function (filter) {
    filterMenu.addFilter(filter.groupId, filter.filterId, filter.label);
  });
  filterMenu.addEventListener('select-filter', function (e) {
    handleFilterChange(instance, e);
  });
  filterMenu.addGroupIconButton('projects', 'add', {
    callback: function callback() {
      return showAddProjectModal(instance);
    }
  });
  privates.filterMenu = filterMenu;
  updateProjectFilters(instance);
}
/**
 * Create the app's header.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {HTMLElement} parent The parent element under which the header
 *   should be inserted.
 */


function createHeader(instance, parent) {
  // const privates = privateMembers.get(instance);
  var header = document.createElement('header');
  header.id = 'header';
  var titleContainer = document.createElement('div');
  titleContainer.classList.add('title-container');
  titleContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_20__.createIconButton)('menu'));
  var title = document.createElement('p');
  title.classList.add('title');
  title.textContent = APP_NAME;
  titleContainer.appendChild(title);
  header.appendChild(titleContainer);
  var toolContainer = document.createElement('div');
  toolContainer.classList.add('tools');
  toolContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_20__.createIconButton)('account_circle'));
  header.appendChild(toolContainer);
  parent.appendChild(header);
}
/**
 * Create the app's side panel.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {HTMLElement} parent The parent element under which the side panel
 *   should be inserted.
 */


function createSidePanel(instance, parent) {
  var privates = privateMembers.get(instance);
  privates.sidePanel = document.createElement('aside');
  privates.sidePanel.id = 'side-panel';
  createFilterMenu(instance);
  parent.appendChild(privates.sidePanel);
}
/**
 * Create the resizing bar for the side panel.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {HTMLElement} parent The parent element under which the resizer is
 *   to be inserted.
 */


function createResizer(instance, parent) {
  var privates = privateMembers.get(instance);
  privates.resizer = document.createElement('div');
  privates.resizer.classList.add('resizer');

  var handler = function handler(e) {
    var size = "".concat(e.x, "px");
    privates.sidePanel.style.width = size;
    e.preventDefault();
  };

  privates.resizer.addEventListener('mousedown', function (e) {
    // Check for left-click
    if (e.button === 0) {
      document.addEventListener('mousemove', handler);
      e.target.classList.add('dragging');
      e.preventDefault();
    }
  });
  document.addEventListener('mouseup', function (e) {
    if (e.button === 0) {
      document.removeEventListener('mousemove', handler);
      privates.resizer.classList.remove('dragging');
    }
  });
  parent.appendChild(privates.resizer);
}
/**
 * Create the app's main panel.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {HTMLElement} parent The parent element under which the main panel
 *   is to be inserted.
 */


function createMainPanel(instance, parent) {
  var privates = privateMembers.get(instance);
  privates.mainPanel = document.createElement('div');
  privates.mainPanel.id = 'main-panel';
  var header = document.createElement('div');
  header.id = 'main-panel-header';
  var headingContainer = document.createElement('div');
  headingContainer.id = 'main-panel-heading-container';
  header.appendChild(headingContainer);
  var heading = document.createElement('h2');
  heading.id = 'main-panel-heading';
  headingContainer.appendChild(heading);
  var subheading = document.createElement('h3');
  subheading.id = 'main-panel-subheading';
  headingContainer.appendChild(subheading);
  var menu = new _popupMenu__WEBPACK_IMPORTED_MODULE_10__["default"]({
    closeIfScrolled: privates.mainPanel
  });
  privates.mainPanelMenu = menu;
  var iconContainer = document.createElement('div');
  iconContainer.classList.add('icon-container');
  iconContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_20__.createIconButton)('add'));
  iconContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_20__.createIconButton)('more_horiz'));
  header.appendChild(iconContainer);
  privates.mainPanel.appendChild(header);
  var taskDisplayOptions = {
    taskCallback: function taskCallback(type, id, task) {
      handleTaskUpdate(instance, type, id, task);
    }
  };
  privates.taskDisplay = new _taskDisplay__WEBPACK_IMPORTED_MODULE_17__["default"](privates.mainPanel, privates.tasks, privates.projects, taskDisplayOptions);
  parent.appendChild(privates.mainPanel);
}
/**
 * Create the app's footer.
 * @param {HTMLElement} parent The parent element under which the footer is
 *   to be inserted.
 */


function createFooter(parent) {
  var footer = document.createElement('footer');
  footer.id = 'footer';
  var copyright = document.createElement('div');
  copyright.classList.add('copyright');
  copyright.innerHTML = "Copyright &copy; ".concat(APP_COPYRIGHT_YEARS, " ") + "<a href=\"".concat(APP_AUTHOR_WEBSITE, "\" target=\"_blank\">") + "".concat(APP_AUTHOR, "</a>");
  footer.appendChild(copyright);
  parent.appendChild(footer);
}
/**
 * Create the DOM elements for the page content.
 * @param {module:app~App} instance The class instance on which to apply the
 *   function.
 * @param {HTMLElement} parent The container element under which the page
 *   elements should be inserted.
 */


function createPageElements(instance, parent) {
  var privates = privateMembers.get(instance);
  var container = document.createElement('div');
  container.id = 'app';
  privates.appContainer = container;
  createHeader(instance, container);
  var middleContainer = document.createElement('div');
  middleContainer.id = 'middle-container';
  createSidePanel(instance, middleContainer);
  createResizer(instance, middleContainer);
  createMainPanel(instance, middleContainer);
  container.appendChild(middleContainer);
  createFooter(container);
  parent.appendChild(container);
  privates.modalStack = new _modalStack__WEBPACK_IMPORTED_MODULE_9__["default"](parent, container);
}
/**
 * Class responsible for creating the DOM elements for the app and running the
 * event-driven logic.
 */


var App = /*#__PURE__*/function () {
  /**
   * An object holding information about the status of a data import, including
   * whether or not the import was successful and any errors that were
   * encountered.
   * @typedef {Object} module:app~App~importStatus
   * @property {boolean} successful Will be true if data was imported, or false
   *   if data could not be imported due to a fatal error.
   * @property {string} format The format of the data string that was imported.
   *   Will be 'json', 'csv', or 'unknown'. A value of 'unknown' indicates that
   *   the format could not be automatically determined.
   * @property {Object} tasks An object holding information about the number of
   *   tasks that were imported.
   * @property {number} tasks.added The number of new tasks that were added to
   *   the task list.
   * @property {number} tasks.updated The number of existing tasks in the task
   *   list that were updated.
   * @property {number} tasks.failed The number of tasks that failed to import.
   * @property {number} tasks.total The total number of tasks that were
   *   processed.
   * @property {Object} projects An object holding information about the number
   *   of projects that were imported.
   * @property {number} projects.added The number of new projects that were
   *   added to the project list.
   * @property {number} projects.updated The number of existing projects in the
   *   project list that were updated.
   * @property {number} projects.failed The number of projects that failed to
   *   import.
   * @property {number} projects.total The total number of projects that were
   *   processed.
   * @property {string[]} errors An array of error messages describing any
   *   errors that occurred during the import.
   */

  /**
   * Append the DOM elements for the app to the given parent node.
   * @param {HTMLElement} parent The DOM node where the app elements should be
   *   appended.
   */
  function App(parent) {
    _classCallCheck(this, App);

    var privates = {
      tasks: new _taskList__WEBPACK_IMPORTED_MODULE_18__["default"](),
      projects: new _projectList__WEBPACK_IMPORTED_MODULE_12__["default"](),
      modalStack: null,
      filterMenu: null,
      currentFilter: {
        group: null,
        filter: null
      },
      taskDisplay: null,
      settings: new _settings__WEBPACK_IMPORTED_MODULE_14__["default"](),
      appContainer: null,
      sidePanel: null,
      resizer: null,
      mainPanel: null,
      mainPanelMenu: null,
      narrowScreen: false
    };
    privateMembers.set(this, privates);
    createPageElements(this, parent);
  }
  /**
   * Run the app. This method sets up the event handlers and performs
   * high-level logic. This should not be called until the page elements have
   * been added to the DOM.
   */


  _createClass(App, [{
    key: "run",
    value: function run() {
      var _this = this;

      var privates = privateMembers.get(this);
      window.addEventListener('resize', function () {
        var width = document.documentElement.clientWidth;
        var narrow = width <= NARROW_LAYOUT_CUTOFF; // Adjust side panel if screen changes from narrow to wide or vice versa

        if (narrow && !privates.narrowScreen) {
          closeSidePanel(_this);
        } else if (!narrow && privates.narrowScreen) {
          openSidePanel(_this);
        }

        privates.narrowScreen = narrow;
      });
      privates.filterMenu.expandGroup('dates');
      privates.filterMenu.expandGroup('projects');
      privates.filterMenu.selectFilter('dates', 'today');
      var menuSelector = '.title-container .icon[data-icon-type="menu"]';
      var menuIcon = document.querySelector(menuSelector);
      menuIcon.addEventListener('click', function () {
        return toggleSidePanel(_this);
      });
      var userMenu = new _popupMenu__WEBPACK_IMPORTED_MODULE_10__["default"]({
        menuItems: [{
          label: 'Settings...',
          id: 'settings',
          iconType: 'settings'
        }, {
          label: 'Data Management...',
          id: 'data',
          iconType: 'save'
        }, {
          label: 'About...',
          id: 'about',
          iconType: 'info'
        }]
      });
      var userIcon = document.querySelector('#header .icon[data-icon-type="account_circle"]');
      userIcon.addEventListener('click', function () {
        userMenu.open(function (itemId) {
          return handleUserMenuSelection(_this, itemId);
        }, {
          referenceElement: userIcon
        });
      });
      var mainPanelHeader = document.getElementById('main-panel-header');
      var addTaskIcon = mainPanelHeader.querySelector('.icon[data-icon-type="add"]');
      addTaskIcon.addEventListener('click', function () {
        handleMainPanelMenuSelection(_this, 'add-task');
      });
      var moreIcon = mainPanelHeader.querySelector('.icon[data-icon-type="more_horiz"]');
      moreIcon.addEventListener('click', function () {
        privates.mainPanelMenu.open(function (item) {
          return handleMainPanelMenuSelection(_this, item);
        }, {
          referenceElement: moreIcon
        });
      });
      initializeStorage(this);
      loadAllStorageData(this);

      var taskCallback = function taskCallback(event) {
        return updateStorage(_this, 'task', event);
      };

      privates.tasks.addEventListener('add-task', taskCallback);
      privates.tasks.addEventListener('update-task', taskCallback);
      privates.tasks.addEventListener('delete-task', taskCallback);

      var projCallback = function projCallback(event) {
        return updateStorage(_this, 'project', event);
      };

      privates.projects.addEventListener('add-project', projCallback);
      privates.projects.addEventListener('update-project', projCallback);
      privates.projects.addEventListener('delete-project', projCallback);

      var settingsCallback = function settingsCallback(event) {
        return updateStorage(_this, 'setting', event);
      };

      privates.settings.addEventListener('update-setting', settingsCallback);
      /* Add random task and project data for testing */
      // TODO: remove

      addRandomData(this, 0, 0);
      updateProjectFilters(this);
      privates.filterMenu.selectFilter('default', 'all');
    }
    /**
     * Convert data to an object suitable for serialization.
     * @returns {Object} An object representing serializable data for the class.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var privates = privateMembers.get(this);
      return {
        app: {
          name: APP_NAME,
          version: APP_VERSION
        },
        settings: privates.settings,
        tasks: privates.tasks,
        projects: privates.projects
      };
    }
  }]);

  return App;
}();

/* harmony default export */ __webpack_exports__["default"] = (App);

/***/ }),

/***/ "./src/modules/collapsible.js":
/*!************************************!*\
  !*** ./src/modules/collapsible.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [Collapsible]{@link module:collapsible~Collapsible} class.
 * @module collapsible
 */
var FOCUSABLE_SELECTOR = ['a[href]', 'input', 'select', 'textarea', 'button'].join(', ');
/**
 * Object holding private members for the
 * [Collapsible]{@link module:collapsible~Collapsible} class.
 * @typedef {Object} module:collapsible~Collapsible~privates
 * @property {HTMLElement} container The collapsible element.
 * @property {HTMLElement} content The inner container holding the collapsible
 *   contents.
 * @property {boolean} collapsed Indicates whether the container is currently
 *   collapsed or not.
 */

/**
 * Holds private data for the
 * [Collapsible]{@link module:collapsible~Collapsible} class.
 * @type {WeakMap}
 * @see module:collapsible~Collapsible~privates
 */

var privateMembers = new WeakMap();
/**
 * A container on the page that can be expanded or collapsed.
 */

var Collapsible = /*#__PURE__*/function () {
  /**
   * Create a collapsible panel and add it to the DOM.
   * @param {HTMLElement} parent The parent node under which the collapsible is
   *   to be inserted.
   * @param {HTMLElement} [referenceNode=null] The child node before which the
   *   collapsible should be inserted. If not given, the collapsible will be
   *   appended at the end of the parent's child nodes.
   * @param {Object} [options={}] Specifies additional options for the modal.
   * @param {string} [options.id] The identifier for the collapsible container.
   * @param {string[]} [options.classList] An array of class names to be
   *   applied to the collapsible container.
   * @param {boolean} [options.collapsed] Specifies whether the panel should be
   *   initially collapsed.
   */
  function Collapsible(parent) {
    var _container$classList;

    var referenceNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Collapsible);

    var container = document.createElement('div');
    if (options.id) container.id = options.id;
    container.classList.add('collapsible');
    if (options.classList) (_container$classList = container.classList).add.apply(_container$classList, _toConsumableArray(options.classList));
    var innerContainer = document.createElement('div');
    innerContainer.classList.add('collapsible-content');
    container.appendChild(innerContainer);
    parent.insertBefore(container, referenceNode);
    var privates = {
      container: container,
      content: innerContainer,
      collapsed: false
    };
    privateMembers.set(this, privates);
    if ('collapsed' in options && options.collapsed) this.collapse();else this.expand();
  }
  /**
   * Determines whether the container is currently collapsed.
   * @type {boolean}
   */


  _createClass(Collapsible, [{
    key: "collapsed",
    get: function get() {
      return privateMembers.get(this).collapsed;
    },
    set: function set(collapsed) {
      if (collapsed) this.collapse();else this.expand();
    }
    /**
     * The inner container element holding the panel's content.
     * @type {HTMLElement}
     */

  }, {
    key: "content",
    get: function get() {
      return privateMembers.get(this).content;
    }
    /**
     * Expand the panel, so that its contents are visible.
     */

  }, {
    key: "expand",
    value: function expand() {
      var privates = privateMembers.get(this);

      if (privates.collapsed) {
        privates.collapsed = false;
        privates.container.classList.remove('collapsed');
        privates.container.removeAttribute('aria-hidden');
        privates.container.querySelectorAll(FOCUSABLE_SELECTOR).forEach(function (elem) {
          elem.removeAttribute('tabindex');
        });
        this.update();
      }
    }
    /**
     * Collapse the panel, so that its contents are hidden.
     */

  }, {
    key: "collapse",
    value: function collapse() {
      var privates = privateMembers.get(this);

      if (!privates.collapsed) {
        privates.collapsed = true;
        privates.container.classList.add('collapsed');
        privates.container.setAttribute('aria-hidden', 'true');
        privates.container.querySelectorAll(FOCUSABLE_SELECTOR).forEach(function (elem) {
          elem.setAttribute('tabindex', '-1');
        });
        this.update();
      }
    }
    /**
     * Toggle the collapsed state of the panel.
     * @returns {boolean} True if the panel is in the collapsed state after the
     *   toggle, and false otherwise.
     */

  }, {
    key: "toggle",
    value: function toggle() {
      var privates = privateMembers.get(this);
      if (privates.collapsed) this.expand();else this.collapse();
      return privates.collapsed;
    }
    /**
     * Update the collapsible container to account for changes to its content.
     * This will recalculate the height of the container and should be called
     * whenever the panel's content is altered.
     */

  }, {
    key: "update",
    value: function update() {
      var privates = privateMembers.get(this);
      var height = privates.collapsed ? '0' : "".concat(privates.content.offsetHeight, "px");
      privates.container.style.height = height;
    }
  }]);

  return Collapsible;
}();

/* harmony default export */ __webpack_exports__["default"] = (Collapsible);

/***/ }),

/***/ "./src/modules/datePicker.js":
/*!***********************************!*\
  !*** ./src/modules/datePicker.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfMonth/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfWeek/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/add/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isBefore/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isSameDay/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isToday/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isSameMonth/index.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utility/dom */ "./src/modules/utility/dom.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [DatePicker]{@link module:datePicker~DatePicker} class.
 * @module datePicker
 */


var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
/**
 * Object holding private members for the
 * [DatePicker]{@link module:datePicker~DatePicker} class.
 * @typedef {Object} module:datePicker~DatePicker~privates
 * @property {number} year The year that is currently selected.
 * @property {number} month The month that is currently selected, represented
 *   as a value from 0 to 11.
 * @property {number} day The day of the month that is currently selected,
 *   represented as a value from 1 to 31.
 * @property {number} displayedMonth The month that is currently being
 *   displayed in the calendar grid.
 * @property {number} displayedYear The year that is currently being displayed
 *   in the calendar grid.
 * @property {HTMLElement} monthInput The select box element that is shown in
 *   the header and is used to select the month.
 * @property {HTMLElement} yearInput The input element that is shown in the
 *   header and is used to select the year.
 * @property {HTMLElement} dayGrid The container element holding the grid of
 *   calendar days.
 */

/**
 * Holds private data for the [DatePicker]{@link module:datePicker~DatePicker}
 * class.
 * @type {WeakMap}
 * @see module:datePicker~DatePicker~privates
 */

var privateMembers = new WeakMap();
/**
 * Clear the grid of calendar days and rebuild it using the current display
 * month and display year.
 * @param {module:datePicker~DatePicker} instance The class instance on which
 *   to apply the function.
 */

function updateDayGrid(instance) {
  var privates = privateMembers.get(instance);
  privates.dayGrid.innerHTML = '';
  var date = new Date(privates.displayedYear, privates.displayedMonth, 1);

  if (privates.displayedYear < 100) {
    // Fix for two-digit years
    date.setFullYear(privates.displayedYear);
  }

  var selected = instance.date;
  var monthStart = (0,date_fns__WEBPACK_IMPORTED_MODULE_1__["default"])(date);
  var start = (0,date_fns__WEBPACK_IMPORTED_MODULE_2__["default"])(monthStart);
  var end = (0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(start, {
    weeks: 5,
    days: 6,
    hours: 11
  });
  ['S', 'M', 'T', 'W', 'T', 'F', 'S'].forEach(function (label) {
    var dayLabel = document.createElement('span');
    dayLabel.classList.add('date-picker-day-header');
    dayLabel.textContent = label;
    privates.dayGrid.appendChild(dayLabel);
  });
  var currentDay = start;

  while ((0,date_fns__WEBPACK_IMPORTED_MODULE_4__["default"])(currentDay, end)) {
    var dayElem = document.createElement('button');
    dayElem.classList.add('date-picker-day');
    if ((0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(selected, currentDay)) dayElem.classList.add('selected');else if ((0,date_fns__WEBPACK_IMPORTED_MODULE_6__["default"])(currentDay)) dayElem.classList.add('today');

    if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_7__["default"])(date, currentDay)) {
      dayElem.classList.add('different-month');
    }

    dayElem.textContent = currentDay.getDate();
    dayElem.dataset.year = currentDay.getFullYear();
    dayElem.dataset.month = currentDay.getMonth();
    dayElem.dataset.day = currentDay.getDate();
    privates.dayGrid.appendChild(dayElem);
    currentDay = (0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(currentDay, {
      days: 1
    });
  }
}
/**
 * Update the month and year input controls to match the selected date.
 * @param {module:datePicker~DatePicker} instance The class instance on which
 *   to apply the function.
 */


function updateInputs(instance) {
  var privates = privateMembers.get(instance);
  privates.monthInput.value = privates.displayedMonth.toString();
  privates.yearInput.value = privates.displayedYear.toString();
}
/**
 * Create the form elements for the date picker.
 * @param {module:datePicker~DatePicker} instance The class instance on which
 *   to apply the function.
 * @param {HTMLElement} parent The parent DOM node under which the form
 *   should be inserted.
 */


function createFormElements(instance, parent) {
  var privates = privateMembers.get(instance);
  var heading = document.createElement('div');
  heading.classList.add('date-picker-heading');
  var menuItems = MONTHS.map(function (month, index) {
    return {
      value: index.toString(),
      label: month
    };
  });
  privates.monthInput = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createFormControl)({
    type: 'select',
    id: 'date-picker-month-select',
    name: 'date-picker-month-select',
    classList: ['form-select-inline'],
    menuItems: menuItems
  });
  privates.yearInput = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createFormControl)({
    type: 'number',
    id: 'date-picker-year-input',
    name: 'date-picker-year-input',
    classList: ['form-input-inline', 'form-input-count']
  });
  var monthYearContainer = document.createElement('div');
  monthYearContainer.appendChild(privates.monthInput);
  var spacer = document.createElement('span');
  spacer.classList.add('form-input-label-inline');
  spacer.textContent = ' ';
  monthYearContainer.appendChild(spacer);
  monthYearContainer.appendChild(privates.yearInput);
  heading.appendChild(monthYearContainer);
  var buttonContainer = document.createElement('div');
  var backButton = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createIconButton)('navigate_before');
  var todayButton = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createIconButton)('today');
  var forwardButton = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createIconButton)('navigate_next');
  buttonContainer.appendChild(backButton);
  buttonContainer.appendChild(todayButton);
  buttonContainer.appendChild(forwardButton);
  heading.appendChild(buttonContainer);
  parent.appendChild(heading);
  var grid = document.createElement('div');
  grid.classList.add('date-picker-grid');
  parent.appendChild(grid);
  privates.dayGrid = grid;
  updateInputs(instance);
  updateDayGrid(instance);
  backButton.addEventListener('click', function () {
    return instance.goToPreviousMonth();
  });
  todayButton.addEventListener('click', function () {
    return instance.goToThisMonth();
  });
  forwardButton.addEventListener('click', function () {
    return instance.goToNextMonth();
  });
  privates.monthInput.addEventListener('change', function (e) {
    privates.displayedMonth = Number(e.target.value);
    updateDayGrid(instance);
  });

  var yearListener = function yearListener(e) {
    if (e.type === 'change' || e.target.value.length === 4) {
      var value = Number(e.target.value);

      if (e.target.value.length > 0 && Number.isInteger(value)) {
        if (privates.displayedYear !== value) {
          privates.displayedYear = value;
          updateDayGrid(instance);
        }
      } else if (e.type === 'change') {
        e.target.value = privates.displayedYear.toString();
      }
    }
  };

  privates.yearInput.addEventListener('input', yearListener);
  privates.yearInput.addEventListener('change', yearListener);
  privates.dayGrid.addEventListener('click', function (e) {
    var elem = e.target;

    if (elem.classList.contains('date-picker-day')) {
      privates.year = Number(elem.dataset.year);
      privates.month = Number(elem.dataset.month);
      privates.day = Number(elem.dataset.day);

      if (privates.displayedMonth !== privates.month || privates.displayedYear !== privates.year) {
        privates.displayedMonth = privates.month;
        privates.displayedYear = privates.year;
        updateInputs(instance);
      }

      updateDayGrid(instance);
    }
  });
}
/**
 * Controls a form that the user can use to select a calendar date.
 */


var DatePicker = /*#__PURE__*/function () {
  /**
   * Create the date picker form.
   * @param {HTMLElement} parent The parent DOM node under which the form
   *   should be inserted.
   * @param {Date} [startDate] The date that will be initially selected. If not
   *   given, then the present date is used.
   */
  function DatePicker(parent, startDate) {
    _classCallCheck(this, DatePicker);

    var date = startDate || new Date();
    var privates = {
      year: date.getFullYear(),
      month: date.getMonth(),
      day: date.getDate(),
      displayedMonth: date.getMonth(),
      displayedYear: date.getFullYear(),
      monthInput: null,
      yearInput: null,
      dayGrid: null
    };
    privateMembers.set(this, privates);
    createFormElements(this, parent);
  }
  /**
   * The date that is currently selected in the form.
   * @type {Date}
   */


  _createClass(DatePicker, [{
    key: "date",
    get: function get() {
      var privates = privateMembers.get(this);
      var value = new Date(privates.year, privates.month, privates.day);

      if (privates.year < 100) {
        // Fix for two-digit years
        value.setFullYear(privates.year);
      }

      return value;
    }
    /**
     * The year that is currently selected in the form. For four-digit years,
     * this will be a four-digit number.
     * @type {number}
     */

  }, {
    key: "year",
    get: function get() {
      return privateMembers.get(this).year;
    }
    /**
     * The month that is currently selected in the form, as a number between 0
     * and 11, with January corresponding to a value of 0.
     * @type {number}
     */

  }, {
    key: "month",
    get: function get() {
      return privateMembers.get(this).month;
    }
    /**
     * The day of the month that is currently selected in the form, as a number
     * between 1 and 31.
     * @type {number}
     */

  }, {
    key: "day",
    get: function get() {
      return privateMembers.get(this).day;
    }
    /**
     * Switch to the present month.
     */

  }, {
    key: "goToThisMonth",
    value: function goToThisMonth() {
      var privates = privateMembers.get(this);
      var now = new Date();
      privates.displayedYear = now.getFullYear();
      privates.displayedMonth = now.getMonth();
      updateInputs(this);
      updateDayGrid(this);
    }
    /**
     * Switch to the previous month.
     */

  }, {
    key: "goToPreviousMonth",
    value: function goToPreviousMonth() {
      var privates = privateMembers.get(this);

      if (privates.displayedMonth > 0) {
        privates.displayedMonth -= 1;
      } else {
        privates.displayedYear -= 1;
        privates.displayedMonth = 11;
      }

      updateInputs(this);
      updateDayGrid(this);
    }
    /**
     * Switch to the next month.
     */

  }, {
    key: "goToNextMonth",
    value: function goToNextMonth() {
      var privates = privateMembers.get(this);

      if (privates.displayedMonth < 11) {
        privates.displayedMonth += 1;
      } else {
        privates.displayedYear += 1;
        privates.displayedMonth = 0;
      }

      updateInputs(this);
      updateDayGrid(this);
    }
  }]);

  return DatePicker;
}();

/* harmony default export */ __webpack_exports__["default"] = (DatePicker);

/***/ }),

/***/ "./src/modules/filterMenu.js":
/*!***********************************!*\
  !*** ./src/modules/filterMenu.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _collapsible__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collapsible */ "./src/modules/collapsible.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utility/dom */ "./src/modules/utility/dom.js");


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }




var ICON_EXPANDED = 'expand_more';
var ICON_COLLAPSED = 'chevron_right';
/**
 * Object holding private members for the
 * [FilterMenu]{@link module:filterMenu~FilterMenu} class.
 * @typedef {Object} module:filterMenu~FilterMenu~privates
 * @property {HTMLElement} container The DOM element that contains the menu.
 * @property {module:filterMenu~FilterMenu~filterInfo} selectedFilter Describes
 *   the currently selected task filter, if any.
 * @property {Map} groupElements A map associating filter group identifiers to
 *   [groupElements]{@link module:filterMenu~FilterMenu~groupElements} objects.
 * @property {EventEmitter} eventEmitter Holds the event emitter. The event
 *   emitter dispatches events to any attached event listeners.
 */

/**
 * Holds privates data for the [FilterMenu]{@link module:filterMenu~FilterMenu}
 * class.
 * @type {WeakMap}
 * @see module:filterMenu~FilterMenu~privates
 */

var privateMembers = new WeakMap();
/**
 * Get the [groupElements]{@link module:filterMenu~FilterMenu~groupElements}
 * object associated with a filter group.
 * @param {module:filterMenu~FilterMenu} instance The class instance on which
 *   to apply the function.
 * @param {string} groupId The identifier for the group whose elements are to
 *   be retrieved.
 * @return {module:filterMenu~FilterMenu~groupElements} The object containing
 *   the group's DOM elements.
 * @throws {RangeError} If the given group identifier is invalid.
 */

function getGroupElements(instance, groupId) {
  var elements = privateMembers.get(instance).groupElements.get(groupId);

  if (!elements) {
    throw new RangeError("Cannot locate filter group \"".concat(groupId, "\""));
  }

  return elements;
}
/**
 * Get the list item element in the DOM belonging to a particular filter.
 * @param {module:filterMenu~FilterMenu} instance The class instance on which
 *   to apply the function.
 * @param {string} groupId The identifier for the group containing the
 *   filter.
 * @param {string} filterId The identifier for the filter.
 * @returns {HTMLElement} The list item element for the filter.
 * @throws {RangeError} If either the group or filter identifiers are
 *   invalid.
 */


function getFilterItemElement(instance, groupId, filterId) {
  var item = getGroupElements(instance, groupId).filterItems.get(filterId);

  if (!item) {
    throw new RangeError("Cannot locate filter \"".concat(filterId, "\" in group ") + "\"".concat(groupId, "\""));
  }

  return item;
}
/**
 * Clear the filter selection, but do so without firing any events.
 * @param {module:filterMenu~FilterMenu} instance The class instance on which
 *   to apply the function.
 */


function silentClearSelection(instance) {
  var privates = privateMembers.get(instance);

  if (privates.selectedFilter.group && privates.selectedFilter.filter) {
    var listItem = getFilterItemElement(instance, privates.selectedFilter.group, privates.selectedFilter.filter);
    listItem.classList.remove('selected');
  }

  privates.selectedFilter.group = null;
  privates.selectedFilter.filter = null;
}
/**
 * A customizable menu of task filters.
 */


var FilterMenu = /*#__PURE__*/function () {
  /**
   * Event that is fired when a filter item is selected, or when the selection
   * is cleared.
   * @event module:filterMenu~FilterMenu~selectFilter
   * @type {Object}
   * @property {string} type The event type: select-filter.
   * @property {module:filterMenu~FilterMenu} target The filter menu that fired
   *   the event.
   * @property {string} [groupId] The identifier for the filter group
   *   containing the selected filter, if any.
   * @property {string} [filterId] The identifier for the filter that was
   *   selected, if any.
   * @property {string} [filterLabel] The displayed label for the filter that
   *   was selected, if any.
   */

  /**
   * Identifies a task filter in the menu.
   * @typedef {Object} module:filterMenu~FilterMenu~filterInfo
   * @property {string} [group] The identifier for the filter group
   *   containing the filter.
   * @property {string} [filter] The identifier for the filter.
   */

  /**
   * Holds references to DOM elements related to a particular filter group in
   * the filter menu.
   * @typedef {Object} module:filterMenu~FilterMenu~groupElements
   * @property {HTMLElement} container The container element for the group.
   * @property {HTMLElement} [expandIcon] The expand/collapse icon element in
   *   the group heading (if any).
   * @property {module:collapsible~Collapsible} [collapsible] The collapsible
   *   panel containing the group's filter list. If the group cannot be
   *   collapsed, this should be null.
   * @property {HTMLElement} filterList The list element containing the
   *   filter items belonging to the group.
   * @property {Map} filterItems A map associating filter identifiers to the
   *   list item elements in the DOM belonging to each filter item in the
   *   group.
   */

  /**
   * Create a filter menu and add it to the DOM.
   * @param {HTMLElement} parent The parent DOM node that will contain the
   *   menu.
   * @param {Object[]} [groups] An array of filter groups to add to the menu.
   * @param {string} groups[].id The identifier of the filter group.
   * @param {string} [groups[].label] The displayed label for the filter group.
   *   If not given, the group will have no heading and will not be
   *   collapsible.
   */
  function FilterMenu(parent, groups) {
    var _this = this;

    _classCallCheck(this, FilterMenu);

    var privates = {
      container: null,
      selectedFilter: {
        group: null,
        filter: null
      },
      groupElements: new Map(),
      eventEmitter: new (events__WEBPACK_IMPORTED_MODULE_1___default())()
    };
    privateMembers.set(this, privates);
    privates.container = document.createElement('div');
    privates.container.classList.add('filter-menu');

    if (groups) {
      groups.forEach(function (group) {
        return _this.addGroup(group.id, group.label);
      });
    }

    parent.appendChild(privates.container);
  }
  /**
   * Add a filter group to the menu.
   * @param {string} id The unique identifier of the group.
   * @param {string} [label] The displayed label for the group. If not given,
   *   the group will have no heading and will not be collapsible.
   */


  _createClass(FilterMenu, [{
    key: "addGroup",
    value: function addGroup(id, label) {
      var _this2 = this;

      var privates = privateMembers.get(this);
      var groupContainer = document.createElement('div');
      groupContainer.classList.add('filter-group');
      groupContainer.dataset.groupId = id;
      var toggle = null;
      var arrow = null;

      if (label) {
        var heading = document.createElement('div');
        heading.classList.add('filter-group-heading');
        groupContainer.appendChild(heading);
        toggle = document.createElement('button');
        toggle.classList.add('filter-group-toggle');
        heading.appendChild(toggle);
        var iconContainer = document.createElement('div');
        iconContainer.classList.add('icon-container');
        heading.appendChild(iconContainer);
        arrow = document.createElement('span');
        arrow.classList.add('icon', 'material-icons', 'filter-group-expand-icon');
        arrow.textContent = ICON_COLLAPSED;
        toggle.appendChild(arrow);
        var text = document.createElement('span');
        text.classList.add('filter-group-label');
        text.textContent = label;
        toggle.appendChild(text);
      }

      var collapsible;
      var listContainer;

      if (label) {
        collapsible = new _collapsible__WEBPACK_IMPORTED_MODULE_2__["default"](groupContainer, null, {
          collapsed: true
        });
        listContainer = collapsible.content;
      } else {
        collapsible = null;
        listContainer = groupContainer;
      }

      var list = document.createElement('ul');
      list.classList.add('filter-list');
      listContainer.appendChild(list);
      privates.groupElements.set(id, {
        container: groupContainer,
        expandIcon: arrow,
        collapsible: collapsible,
        filterList: list,
        filterItems: new Map()
      });
      if (toggle) toggle.addEventListener('click', function () {
        return _this2.toggleGroup(id);
      });
      privates.container.appendChild(groupContainer);
    }
    /**
     * Add a filter to the menu.
     * @param {string} groupId The identifier of the group in which to insert the
     *   filter.
     * @param {string} filterId The identifier for the filter.
     * @param {string} label The displayed label for the filter.
     * @param {Object} [options={}] An object holding options controlling the
     *   filter insertion.
     * @param {number} [options.count=0] The number of tasks matching the filter.
     * @param {string} [options.insertBefore] The identifier for the filter
     *   before which the new filter should be inserted. If not given, then the
     *   filter will be inserted at the end of the list.
     * @throws {RangeError} If the group identifier is invalid.
     */

  }, {
    key: "addFilter",
    value: function addFilter(groupId, filterId, label) {
      var _groupElements$collap,
          _this3 = this;

      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var groupElements = getGroupElements(this, groupId);
      var item = document.createElement('li');
      item.classList.add('filter-item');
      item.dataset.filterId = filterId;
      item.dataset.filterLabel = label;
      var button = document.createElement('button');
      button.classList.add('filter-item-selector');
      item.appendChild(button);
      var labelElem = document.createElement('span');
      labelElem.classList.add('filter-item-label');
      labelElem.textContent = label;
      button.appendChild(labelElem);
      var countElem = document.createElement('span');
      countElem.classList.add('filter-item-count');
      countElem.textContent = options.count || '';
      button.appendChild(countElem);
      var referenceNode = null;

      if (options.insertBefore) {
        referenceNode = getFilterItemElement(this, groupId, options.insertBefore);
      }

      groupElements.filterList.insertBefore(item, referenceNode);
      groupElements.filterItems.set(filterId, item);
      (_groupElements$collap = groupElements.collapsible) === null || _groupElements$collap === void 0 ? void 0 : _groupElements$collap.update();
      button.addEventListener('click', function () {
        _this3.selectFilter(groupId, filterId);
      });
    }
    /**
     * Remove a filter from the menu.
     * @param {string} groupId The identifier of the group containing the filter.
     * @param {string} filterId The identifier of the filter to remove.
     * @throws {RangeError} If either the group or filter identifiers are
     *   invalid.
     */

  }, {
    key: "removeFilter",
    value: function removeFilter(groupId, filterId) {
      var _groupElements$collap2;

      var privates = privateMembers.get(this); // If filter is selected, clear selection

      if (privates.selectedFilter.group === groupId && privates.selectedFilter.filter === filterId) {
        this.clearSelection();
      }

      var groupElements = getGroupElements(this, groupId);
      var item = getFilterItemElement(this, groupId, filterId);
      groupElements.filterList.removeChild(item);
      groupElements.filterItems.delete(filterId);
      (_groupElements$collap2 = groupElements.collapsible) === null || _groupElements$collap2 === void 0 ? void 0 : _groupElements$collap2.update();
    }
    /**
     * Remove all the filters in a filter group.
     * @param {string} id The identifier for the group to empty.
     * @throws {RangeError} If the group identifier is invalid.
     */

  }, {
    key: "removeAllFilters",
    value: function removeAllFilters(id) {
      var _groupElements$collap3;

      // If a filter in the group is selected, clear selection
      if (privateMembers.get(this).selectedFilter.group === id) {
        this.clearSelection();
      }

      var groupElements = getGroupElements(this, id);
      var list = groupElements.filterList;
      groupElements.filterItems.forEach(function (item) {
        return list.removeChild(item);
      });
      groupElements.filterItems.clear();
      (_groupElements$collap3 = groupElements.collapsible) === null || _groupElements$collap3 === void 0 ? void 0 : _groupElements$collap3.update();
    }
    /**
     * Determine whether or not a filter exists in a filter group. This method
     * will return false if either the group does not exist, or if the filter
     * does not exist within the group.
     * @param {string} groupId The identifier of the group containing the filter.
     * @param {string} filterId The identifier of the filter to test.
     * @returns {boolean} True if the given group and filter exist in the filter
     *   menu.
     */

  }, {
    key: "hasFilter",
    value: function hasFilter(groupId, filterId) {
      var groupElements = privateMembers.get(this).groupElements.get(groupId);
      return groupElements ? groupElements.filterItems.has(filterId) : false;
    }
    /**
     * Expand a filter group, so that its filter items are visible.
     * @param {string} id The identifier for the group to be expanded.
     * @throws {RangeError} If the group identifier is invalid.
     */

  }, {
    key: "expandGroup",
    value: function expandGroup(id) {
      var elements = getGroupElements(this, id);
      var collapsible = elements.collapsible;

      if (collapsible) {
        collapsible.expand();
        elements.expandIcon.textContent = ICON_EXPANDED;
      }
    }
    /**
     * Collapse a filter group, so that its filter items are hidden.
     * @param {string} id The identifier for the group to be collapsed.
     * @throws {RangeError} If the group identifier is invalid.
     */

  }, {
    key: "collapseGroup",
    value: function collapseGroup(id) {
      var elements = getGroupElements(this, id);
      var collapsible = elements.collapsible;

      if (collapsible) {
        collapsible.collapse();
        elements.expandIcon.textContent = ICON_COLLAPSED;
      }
    }
    /**
     * Toggle the collapsed state of a filter group. If the group is collapsed,
     * it will be expanded and vice versa.
     * @param {string} id The identifier for the group to expand or collapse.
     * @throws {RangeError} If the group identifier is invalid.
     */

  }, {
    key: "toggleGroup",
    value: function toggleGroup(id) {
      var elements = getGroupElements(this, id);
      var collapsible = elements.collapsible;

      if (collapsible) {
        if (collapsible.collapsed) this.expandGroup(id);else this.collapseGroup(id);
      }
    }
    /**
     * Add an icon button to a group heading.
     * @param {string} groupId The identifier of the group in which to insert the
     *   icon button.
     * @param {string} iconType The type of icon to display.
     * @param {Object} [options={}] An object holding configuration options for
     *   the button.
     * @param {string} [id] The identifier for the button.
     * @param {string} [title] The title of the button, usually displayed by the
     *   browser as a tooltip.
     * @param {Function} [callback] A callback function that will be invoked when
     *   the button is clicked. The function will receive the standard Event
     *   object as an argument when invoked.
     * @throws {RangeError} If the group identifier is invalid.
     */

  }, {
    key: "addGroupIconButton",
    value: function addGroupIconButton(groupId, iconType) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _getGroupElements = getGroupElements(this, groupId),
          container = _getGroupElements.container;

      var iconContainer = container.querySelector('.icon-container');
      var button = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_3__.createIconButton)(iconType, {
        id: options.id || null,
        title: options.title || null
      });
      if (options.callback) button.addEventListener('click', options.callback);
      iconContainer.appendChild(button);
    }
    /**
     * Select a filter in the menu.
     * @param {string} groupId The identifier for the group containing the filter
     *   to be selected.
     * @param {string} filterId The identifier for the filter to be selected.
     * @fires module:filterMenu~FilterMenu~selectFilter
     */

  }, {
    key: "selectFilter",
    value: function selectFilter(groupId, filterId) {
      var privates = privateMembers.get(this);
      silentClearSelection(this); // Expand the containing group if it is not already

      this.expandGroup(groupId);
      var listItem = getFilterItemElement(this, groupId, filterId);
      listItem.classList.add('selected');
      privates.selectedFilter.group = groupId;
      privates.selectedFilter.filter = filterId;
      var filterLabel = listItem.dataset.filterLabel;
      privates.eventEmitter.emit('select-filter', {
        type: 'select-filter',
        target: this,
        groupId: groupId,
        filterId: filterId,
        filterLabel: filterLabel
      });
    }
    /**
     * Clear the filter selection, so that none of the filters in the menu are
     * selected.
     * @fires module:filterMenu~FilterMenu~selectFilter
     */

  }, {
    key: "clearSelection",
    value: function clearSelection() {
      silentClearSelection(this);
      privateMembers.get(this).eventEmitter.emit('select-filter', {
        type: 'select-filter',
        target: this,
        groupId: null,
        filterId: null,
        filterLabel: null
      });
    }
    /**
     * Retrieve the task filter that is currently selected in the menu, if any.
     * @returns {module:filterMenu~FilterMenu~filterInfo} An object describing
     *   the selected filter.
     */

  }, {
    key: "getSelection",
    value: function getSelection() {
      return lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(privateMembers.get(this).selectedFilter);
    }
    /**
     * Add an event listener to the menu.
     * @param {string} type The type of event to listen for.
     * @param {Function} listener The event listener to be called when the event
     *   is fired.
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      privateMembers.get(this).eventEmitter.on(type, listener);
    }
  }]);

  return FilterMenu;
}();

/* harmony default export */ __webpack_exports__["default"] = (FilterMenu);

/***/ }),

/***/ "./src/modules/modalStack.js":
/*!***********************************!*\
  !*** ./src/modules/modalStack.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utility/dom */ "./src/modules/utility/dom.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [ModalStack]{@link module:modalStack~ModalStack} class.
 * @module modalStack
 */

var FOCUSABLE_SELECTOR = ['a[href]', 'input', 'select', 'textarea', 'button'].join(', ');
var Z_INDEX_START = 500;
var Z_INDEX_STEP = 100;
var Z_INDEX_OVERLAY_STEP = 50;
/**
 * Interface for classes that represent a modal dialog.
 * @interface Modal
 */

/**
 * The title of the modal.
 * @member {string} module:modalStack~Modal#title
 */

/**
 * The label that should be used for the confirm button, shown at the bottom of
 * the modal.
 * @member {string} module:modalStack~Modal#confirmLabel
 * @default Okay
 */

/**
 * The label that should be used for the cancel button, shown at the bottom of
 * the modal.
 * @member {string} module:modalStack~Modal#cancelLabel
 * @default Cancel
 */

/**
 * Indicates whether to show the cancel button in the modal window. If set to
 * true, then the button should not be displayed.
 * @member {boolean} module:modalStack~Modal#noCancelButton
 * @default false
 */

/**
 * Indicates which element to focus after the modal has been opened. This
 * property can either give the element itself, or can be a string with one of
 * the following options: 'confirm' will focus the Confirm button in the modal,
 * 'cancel' will focus the Cancel button, and 'none' will focus nothing.
 * @member {HTMLElement|string} module:modalStack~Modal#initFocus
 * @default confirm
 */

/**
 * Create and display the modal's main content.
 * @function module:modalStack~Modal#addContent
 * @param {HTMLElement} parent The parent DOM node under which the modal's main
 *   content will be inserted.
 * @param {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal is being inserted.
 */

/**
 * Confirm the modal. This method should be invoked when the modal is
 * succesfully confirmed by the user.
 * @function module:modalStack~Modal#confirm
 */

/**
 * Cancel the modal. This method should be invoked when the modal is canceled
 * by the user.
 * @function module:modalStack~Modal#cancel
 */

/**
 * Validate the modal. This method should be invoked when the user attempts to
 * confirm the modal.
 * @function module:modalStack~Modal#validate
 * @returns {boolean} True if the user's selections have passed validation, and
 *   false otherwise.
 */

/**
 * Object holding private members for the
 * [ModalStack]{@link module:modalStack~ModalStack} class.
 * @typedef {Object} module:modalStack~ModalStack~privates
 * @property {HTMLElement} overlay The screen overlay element in the DOM.
 * @property {HTMLElement} parent The parent element under which modals should
 *   be inserted.
 * @property {HTMLElement} [background] Container holding background elements
 *   that should be hidden when a modal is open.
 * @property {module:modalStack~ModalStack~modalInfo[]} modals The stack of
 *   modal dialogs.
 */

/**
 * Holds private data for the [ModalStack]{@link module:modalStack~ModalStack}
 * class.
 * @type {WeakMap}
 * @see module:modalStack~ModalStack~privates
 */

var privateMembers = new WeakMap();
/**
 * Calculate the z-index for a modal dialog.
 * @param {number} index The index of the dialog in the stack.
 * @returns {number} The z-index that the modal should be set to.
 */

function getZIndex(index) {
  return Z_INDEX_START + (index - 1) * Z_INDEX_STEP;
}
/**
 * Update the modal overlay. The overlay will be shown or hidden depending on
 * whether any modals are open, and its z-index will be adjusted to sit below
 * the topmost modal.
 * @param {module:modalStack~ModalStack} instance The class instance on which
 *   to apply the function.
 */


function updateOverlay(instance) {
  var privates = privateMembers.get(instance);
  var count = privates.modals.length;

  if (count > 0) {
    var zIndex = getZIndex(count) - Z_INDEX_OVERLAY_STEP;
    privates.overlay.style.zIndex = zIndex.toString();
    privates.overlay.classList.remove('closed');
  } else {
    privates.overlay.classList.add('closed');
  }
}
/**
 * Show the modal overlay and hide any background elements.
 * @param {module:modalStack~ModalStack} instance The class instance on which
 *   to apply the function.
 */


function hideBackground(instance) {
  var privates = privateMembers.get(instance);
  var toHide = null; // If this is the first modal, hide page background

  if (privates.modals.length <= 1) {
    toHide = privates.background;
  } else {
    // Otherwise, hide the modal below the topmost one
    toHide = privates.modals[privates.modals.length - 2].wrapper;
  }

  if (toHide) {
    toHide.setAttribute('aria-hidden', 'true');
    var oldTabIndex = privates.modals[privates.modals.length - 1].oldTabIndex;
    toHide.querySelectorAll(FOCUSABLE_SELECTOR).forEach(function (elem) {
      var tabIndex = elem.hasAttribute('tabindex') ? elem.tabIndex : null;
      oldTabIndex.push({
        element: elem,
        tabIndex: tabIndex
      });
      elem.setAttribute('tabindex', '-1');
    });
  }

  updateOverlay(instance);
}
/**
 * Restore background element visibility. If there are still modals open,
 * only the topmost modal's elements will become visible. If all modals are
 * closed, then the overlay will be hidden.
 * @param {module:modalStack~ModalStack} instance The class instance on which
 *   to apply the function.
 * @param {module:modalStack~ModalStack~elemTabIndex[]} oldTabIndex An array of
 *   objects specifying elements whose tabindex attributes need to be restored.
 */


function restoreBackground(instance, oldTabIndex) {
  var privates = privateMembers.get(instance);
  var toRestore = null; // If no modals remain open, restore the page background

  if (privates.modals.length === 0) {
    toRestore = privates.background;
  } else {
    toRestore = privates.modals[privates.modals.length - 1].wrapper;
  }

  if (toRestore) {
    toRestore.removeAttribute('aria-hidden');
    oldTabIndex.forEach(function (entry) {
      var element = entry.element,
          tabIndex = entry.tabIndex;
      if (tabIndex !== null) element.tabIndex = tabIndex;else element.removeAttribute('tabindex');
    });
  }

  updateOverlay(instance);
}
/**
 * Manages and displays a stack of modal dialog windows.
 */


var ModalStack = /*#__PURE__*/function () {
  /**
   * Holds information about an element's tab index, used for changing and
   * restoring tab order when modals are opened or closed.
   * @typedef {Object} module:modalStack~ModalStack~elemTabIndex
   * @property {HTMLElement} element An element in the DOM.
   * @property {number} [tabIndex] The tab index of the element, or null if it
   *   is not set.
   */

  /**
   * Holds information about a modal dialog in the stack.
   * @typedef {Object} module:modalStack~ModalStack~modalInfo
   * @property {module:modalStack~Modal} modal The modal instance.
   * @property {HTMLElement} wrapper The outer wrapper node which contains the
   *   modal window container.
   * @property {HTMLElement} container The container node holding the modal
   *   dialog.
   * @property {HTMLElement} content The DOM node holding the main contents of
   *   the modal dialog.
   * @property {HTMLElement} [oldActive] The element that had keyboard focus
   *   before the modal was opened, if any.
   * @property {module:modalStack~ModalStack~elemTabIndex[]} oldTabIndex An
   *   array of objects specifying elements whose tabindex attributes need to
   *   be restored after the modal is closed.
   */

  /**
   * Initialize the modal stack. A hidden overlay will be inserted into the
   * DOM.
   * @param {HTMLElement} [parent=document.body] The parent node under which
   *   the modal overlay is to be inserted.
   * @param {HTMLElement} [background] A DOM node containing elements that
   *   should be hidden from screen readers and made unfocusable while a modal
   *   is open.
   */
  function ModalStack() {
    var _this = this;

    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;
    var background = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, ModalStack);

    var overlay = document.createElement('div');
    overlay.classList.add('modal-overlay', 'closed');
    parent.appendChild(overlay);
    var privates = {
      overlay: overlay,
      parent: parent,
      background: background || null,
      modals: []
    };
    privateMembers.set(this, privates);
    document.addEventListener('keydown', function (e) {
      if (privates.modals.length > 0 && (e.key === 'Escape' || e.key === 'Esc')) {
        _this.cancelModal();

        e.preventDefault();
      }
    });
  }
  /**
   * Display a modal dialog.
   * @param {module:modalStack~Modal} modal The modal dialog to show.
   */


  _createClass(ModalStack, [{
    key: "showModal",
    value: function showModal(modal) {
      var _this2 = this;

      var privates = privateMembers.get(this);
      var oldActive = document.activeElement;
      if (oldActive) oldActive.blur();
      var wrapper = document.createElement('div');
      wrapper.classList.add('modal-wrapper');
      wrapper.style.zIndex = getZIndex(privates.modals.length + 1);
      var container = document.createElement('div');
      container.classList.add('modal');
      wrapper.appendChild(container);
      var titleBar = document.createElement('div');
      titleBar.classList.add('modal-title-bar');
      container.appendChild(titleBar);
      var titleText = document.createElement('div');
      titleText.classList.add('modal-title');
      titleText.textContent = modal.title;
      titleBar.appendChild(titleText);
      var closeIcon = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createIconButton)('close');
      closeIcon.addEventListener('click', function () {
        return _this2.cancelModal();
      });
      titleBar.appendChild(closeIcon);
      var content = document.createElement('div');
      content.classList.add('modal-content');
      modal.addContent(content, this);
      container.appendChild(content);
      var buttonContainer = document.createElement('div');
      buttonContainer.classList.add('modal-button-container');
      container.appendChild(buttonContainer);
      var cancelButton = null;

      if (!modal.noCancelButton) {
        cancelButton = document.createElement('button');
        cancelButton.classList.add('modal-button');
        cancelButton.textContent = modal.cancelLabel || 'Cancel';
        cancelButton.addEventListener('click', function () {
          return _this2.cancelModal();
        });
        buttonContainer.appendChild(cancelButton);
      }

      var okayButton = document.createElement('button');
      okayButton.classList.add('modal-button', 'modal-okay');
      okayButton.textContent = modal.confirmLabel || 'Okay';
      okayButton.addEventListener('click', function () {
        return _this2.confirmModal();
      });
      buttonContainer.appendChild(okayButton);
      var modalInfo = {
        modal: modal,
        wrapper: wrapper,
        container: container,
        content: content,
        oldActive: oldActive,
        oldTabIndex: []
      };
      privates.modals.push(modalInfo);
      privates.parent.appendChild(wrapper);
      hideBackground(this);

      if (typeof modal.initFocus === 'string') {
        switch (modal.initFocus) {
          case 'confirm':
            okayButton.focus();
            break;

          case 'cancel':
            if (cancelButton) cancelButton.focus();
            break;

          case 'none':
          default:
            break;
        }
      } else if (modal.initFocus) {
        modal.initFocus.focus();
      } else {
        okayButton.focus();
      }
    }
    /**
     * Close the topmost modal dialog. This will not invoke the associated
     * callback function.
     */

  }, {
    key: "closeModal",
    value: function closeModal() {
      var privates = privateMembers.get(this);
      var modalInfo = privates.modals.pop();

      if (modalInfo) {
        privates.parent.removeChild(modalInfo.wrapper);
        restoreBackground(this, modalInfo.oldTabIndex);
        if (modalInfo.oldActive) modalInfo.oldActive.focus();
      }
    }
    /**
     * Attempt to confirm the topmost modal dialog. The modal's
     * [validate]{@link module:modalStack~Modal#validate} method will first be
     * invoked. If the modal passes validation, then its
     * [confirm]{@link module:modalStack~Modal#confirm} method is invoked, and
     * then the modal is closed.
     * @returns {boolean} True if the modal was successfully confirmed, and false
     *   if the modal failed validation.
     */

  }, {
    key: "confirmModal",
    value: function confirmModal() {
      var privates = privateMembers.get(this);
      if (privates.modals.length === 0) return false;
      var modal = privates.modals[privates.modals.length - 1].modal;
      if (!modal.validate()) return false;
      modal.confirm();
      this.closeModal();
      return true;
    }
    /**
     * Cancel the topmost modal dialog. This will invoke the modal's
     * [cancel]{@link module:modalStack~Modal#cancel} method, and then the modal
     * will be closed.
     * @returns {boolean} This method will return false if it is called when
     *   there are no modals in the stack. Otherwise it returns true.
     */

  }, {
    key: "cancelModal",
    value: function cancelModal() {
      var privates = privateMembers.get(this);
      if (privates.modals.length === 0) return false;
      privates.modals[privates.modals.length - 1].modal.cancel();
      this.closeModal();
      return true;
    }
  }]);

  return ModalStack;
}();

/* harmony default export */ __webpack_exports__["default"] = (ModalStack);

/***/ }),

/***/ "./src/modules/modals/addProjectModal.js":
/*!***********************************************!*\
  !*** ./src/modules/modals/addProjectModal.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../project */ "./src/modules/project.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility/dom */ "./src/modules/utility/dom.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [AddProjectModal]{@link module:addProjectModal~AddProjectModal}
 * class.
 * @module addProjectModal
 */


/**
 * Object holding private members for the
 * [AddProjectModal]{@link module:addProjectModal~AddProjectModal} class.
 * @typedef {Object} module:addProjectModal~AddProjectModal~privates
 * @property {module:project~Project} [project] The project being edited, if
 *   any.
 * @property {string} mode Indicates the status of the project being entered.
 *   If set to 'add', a new project is being created, and if set to 'edit',
 *   then an existing project is being updated.
 * @property {Object} callbacks An object holding callback functions.
 * @property {Function} [callbacks.confirm] A callback function that will be
 *   invoked when the user successfully confirms the modal.
 * @property {Function} [callbacks.cancel] A callback function that will be
 *   invoked when the user cancels the modal.
 * @property {Object} controls An object holding the form input elements for
 *   the modal.
 * @property {HTMLElement} controls.name The text input element for the project
 *   name.
 * @property {HTMLElement} controls.description The textarea element for the
 *   project description.
 */

/**
 * Holds private data for the
 * [AddProjectModal]{@link module:addProjectModal~AddProjectModal} class.
 * @type {WeakMap}
 * @see module:addProjectModal~AddProjectModal~privates
 */

var privateMembers = new WeakMap();
/**
 * Initialize the values of the form elements based on the initial project that
 * was passed to the constructor, if any.
 * @param {module:addProjectModal~AddProjectModal} instance The class instance
 *   on which to apply the function.
 */

function initFormValues(instance) {
  var _privateMembers$get = privateMembers.get(instance),
      project = _privateMembers$get.project,
      controls = _privateMembers$get.controls;

  if (project) {
    controls.name.value = project.name || '';
    controls.description.value = project.description || '';
  }
}
/**
 * A modal dialog for adding or editing a project.
 * @implements {module:modalStack~Modal}
 */


var AddProjectModal = /*#__PURE__*/function () {
  /**
   * Specifies options for the modal.
   * @typedef {Object} module:addProjectModal~AddProjectModal~options
   * @property {Function} [confirm] A callback function that will be invoked
   *   when the user successfully confirms the modal. The function will be
   *   passed the new (or modified) project.
   * @property {Function} [cancel] A callback function that will be invoked
   *   when the user cancels the modal.
   * @property {module:project~Project} [project] The project to edit. If not
   *   given, then a new project is created.
   */

  /**
   * Initialize the modal.
   * @param {module:addProjectModal~AddProjectModal~options} [options={}] An
   *   object holding configuration options for the modal.
   */
  function AddProjectModal() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AddProjectModal);

    var privates = {
      project: options.project || null,
      mode: options.project ? 'edit' : 'add',
      callbacks: {
        confirm: options.confirm || null,
        cancel: options.cancel || null
      },
      controls: {
        name: null,
        description: null
      }
    };
    privateMembers.set(this, privates);
  }

  _createClass(AddProjectModal, [{
    key: "title",
    get: function get() {
      var privates = privateMembers.get(this);
      return privates.mode === 'edit' ? 'Edit Project' : 'Add Project';
    }
  }, {
    key: "confirmLabel",
    get: function get() {
      var privates = privateMembers.get(this);
      return privates.mode === 'edit' ? 'Update' : 'Add';
    }
  }, {
    key: "initFocus",
    get: function get() {
      return privateMembers.get(this).controls.name;
    }
  }, {
    key: "addContent",
    value: function addContent(parent) {
      var containerType = {
        classList: ['form-input-container']
      };

      var labelType = function labelType(value) {
        return {
          value: value,
          classList: ['form-input-label']
        };
      };

      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_1__.createFormControl)({
        type: 'text',
        id: 'project-name',
        name: 'project-name',
        classList: ['form-input'],
        required: true,
        label: labelType('Name'),
        container: containerType
      }));
      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_1__.createFormControl)({
        type: 'textarea',
        id: 'project-description',
        name: 'project-description',
        classList: ['form-textarea'],
        label: labelType('Description'),
        container: containerType,
        size: {
          rows: 4,
          cols: 20
        }
      }));
      privateMembers.get(this).controls = {
        name: parent.querySelector('#project-name'),
        description: parent.querySelector('#project-description')
      };
      initFormValues(this);
    }
  }, {
    key: "confirm",
    value: function confirm() {
      var privates = privateMembers.get(this);
      var controls = privates.controls;
      var project = new _project__WEBPACK_IMPORTED_MODULE_0__["default"](controls.name.value, {
        description: controls.description.value || null
      });
      if (privates.callbacks.confirm) privates.callbacks.confirm(project);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var privates = privateMembers.get(this);
      if (privates.callbacks.cancel) privates.callbacks.cancel();
    }
  }, {
    key: "validate",
    value: function validate() {
      if (!privateMembers.get(this).controls.name.reportValidity()) return false;
      return true;
    }
  }]);

  return AddProjectModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (AddProjectModal);

/***/ }),

/***/ "./src/modules/modals/addTaskModal.js":
/*!********************************************!*\
  !*** ./src/modules/modals/addTaskModal.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _addProjectModal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addProjectModal */ "./src/modules/modals/addProjectModal.js");
/* harmony import */ var _datePickerModal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datePickerModal */ "./src/modules/modals/datePickerModal.js");
/* harmony import */ var _recurrenceModal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./recurrenceModal */ "./src/modules/modals/recurrenceModal.js");
/* harmony import */ var _recurringDate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../recurringDate */ "./src/modules/recurringDate.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../settings */ "./src/modules/settings.js");
/* harmony import */ var _task__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../task */ "./src/modules/task.js");
/* harmony import */ var _utility_dates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utility/dates */ "./src/modules/utility/dates.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utility/dom */ "./src/modules/utility/dom.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [AddTaskModal]{@link module:addTaskModal~AddTaskModal} class.
 * @module addTaskModal
 */








/**
 * Object holding private members for the
 * [AddTaskModal]{@link module:addTaskModal~AddTaskModal} class.
 * @typedef {Object} module:addTaskModal~AddTaskModal~privates
 * @property {module:taskList~TaskList} tasks The task list to update.
 * @property {module:projectList~ProjectList} projects The project list to use
 *   for the Project field.
 * @property {string} [taskId] The unique identifier for the task being edited,
 *   if any.
 * @property {string} [projectId] The unique identifier for the default
 *   project, if any.
 * @property {number} priority The default priority.
 * @property {string} mode Indicates the status of the task being entered. If
 *   set to 'add', a new task is being created, and if set to 'edit', then an
 *   existing task is being updated.
 * @property {module:recurringDate~RecurringDate} [customRecurrence] The custom
 *   recurrence that the user added, if any.
 * @property {module:settings~Settings~dateFormat} dateFormat An object holding
 *   date format information.
 * @property {Object} callbacks An object holding callback functions.
 * @property {Function} [callbacks.confirm] A callback function that will be
 *   invoked when the user successfully confirms the modal.
 * @property {Function} [callbacks.cancel] A callback function that will be
 *   invoked when the user cancels the modal.
 * @property {Function} [callbacks.newProject] A callback function that will be
 *   invoked when the user adds a new project.
 * @property {Object} controls An object holding the form input elements for
 *   the modal.
 * @property {HTMLElement} controls.name The text input element for the task
 *   name.
 * @property {HTMLElement} controls.dueDate The text input element for the task
 *   due date.
 * @property {HTMLElement} controls.recurringDate The select element for the
 *   task recurring date.
 * @property {HTMLElement} controls.priority The select element for the task
 *   priority.
 * @property {HTMLElement} controls.project The select element for the task's
 *   containing project.
 * @property {HTMLElement} controls.description The textarea element for the
 *   task description.
 */

/**
 * Holds private data for the
 * [AddTaskModal]{@link module:addTaskModal~AddTaskModal} class.
 * @type {WeakMap}
 * @see module:addTaskModal~AddTaskModal~privates
 */

var privateMembers = new WeakMap();
/**
 * Update the project select box options.
 * @param {module:addTaskModal~AddTaskModal} instance The class instance on
 *   which to apply the function.
 */

function updateProjects(instance) {
  var privates = privateMembers.get(instance);
  var projectItems = [{
    value: 'none',
    label: 'None'
  }];
  privates.projects.forEach(function (entry) {
    projectItems.push({
      value: entry.id,
      label: entry.project.name
    });
  });
  projectItems.push({
    value: 'new',
    label: 'New Project...'
  });
  var selectBox = privates.controls.project;
  selectBox.innerHTML = '';
  projectItems.forEach(function (entry) {
    var optElem = document.createElement('option');
    optElem.value = entry.value;
    optElem.textContent = entry.label;
    selectBox.appendChild(optElem);
  });
}
/**
 * Initialize the values of the form elements based on the initial task that
 * was passed to the constructor, if any.
 * @param {module:addTaskModal~AddTaskModal} instance The class instance on
 *   which to apply the function.
 */


function initFormValues(instance) {
  var _task, _task2, _task3, _task4, _task5, _task6;

  updateProjects(instance);
  var privates = privateMembers.get(instance);
  var controls = privates.controls;
  var task = null;
  if (privates.taskId) task = privates.tasks.getTask(privates.taskId);
  if ((_task = task) !== null && _task !== void 0 && _task.name) controls.name.value = task.name;

  if ((_task2 = task) !== null && _task2 !== void 0 && _task2.dueDate) {
    controls.dueDate.value = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_6__.formatDate)(task.dueDate, privates.dateFormat.outputPattern);
  }

  if ((_task3 = task) !== null && _task3 !== void 0 && _task3.recurringDate) {
    var value;

    if (task.recurringDate.isDefault()) {
      switch (task.recurringDate.intervalUnit) {
        case 'day':
          value = 'daily';
          break;

        case 'week':
          value = 'weekly';
          break;

        case 'month':
          value = 'monthly';
          break;

        case 'year':
          value = 'annually';
          break;

        default:
          value = 'custom';
          break;
      }
    } else {
      value = 'custom';
    }

    controls.recurringDate.value = value;
    if (value === 'custom') privates.customRecurrence = task.recurringDate;
  }

  if ((_task4 = task) !== null && _task4 !== void 0 && _task4.priorityString && task.priorityString !== 'unknown') {
    controls.priority.value = task.priorityString;
  } else {
    controls.priority.value = _task__WEBPACK_IMPORTED_MODULE_5__["default"].convertPriorityToString(privates.priority);
  }

  var projectId = privates.projectId;
  if ((_task5 = task) !== null && _task5 !== void 0 && _task5.project) projectId = task.project;
  if (projectId) controls.project.value = projectId;
  if ((_task6 = task) !== null && _task6 !== void 0 && _task6.description) controls.description.value = task.description;
}
/**
 * Opens a date picker and updates the due date field.
 * @param {module:addTaskModal~AddTaskModal} instance The class instance on
 *   which to apply the function.
 * @param {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal has been inserted.
 */


function pickDueDate(instance, modalStack) {
  var privates = privateMembers.get(instance);
  var input = privates.controls.dueDate;
  var startDate = null;

  if (input.value) {
    startDate = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_6__.parseDate)(input.value, privates.dateFormat.inputPatterns);
  }

  modalStack.showModal(new _datePickerModal__WEBPACK_IMPORTED_MODULE_1__["default"]({
    confirm: function confirm(date) {
      input.value = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_6__.formatDate)(date, privates.dateFormat.outputPattern);
      input.setCustomValidity('');
    },
    startDate: startDate,
    title: 'Select Due Date'
  }));
}
/**
 * Add the event listeners to the form controls in the modal.
 * @param {module:addTaskModal~AddTaskModal} instance The class instance on
 *   which to apply the function.
 * @param {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal is being inserted.
 */


function addListeners(instance, modalStack) {
  var privates = privateMembers.get(instance);
  var controls = privates.controls,
      dateFormat = privates.dateFormat; // Handle recurrence selection

  var recurringDate = controls.recurringDate;
  var recurrenceValue = recurringDate.value;

  var processRecurrence = function processRecurrence(recurrence) {
    privates.customRecurrence = recurrence;
    var newValue = 'custom-result';

    if (recurrence.isDefault()) {
      switch (recurrence.intervalUnit) {
        case 'day':
          newValue = 'daily';
          break;

        case 'week':
          newValue = 'weekly';
          break;

        case 'month':
          newValue = 'monthly';
          break;

        case 'year':
          newValue = 'annually';
          break;

        default:
          break;
      }
    } // Update select box options


    var selector = 'option[value="custom-result"]';
    var optElem = recurringDate.querySelector(selector);

    if (optElem && newValue !== 'custom-result') {
      recurringDate.removeChild(optElem);
    } else if (newValue === 'custom-result') {
      if (!optElem) {
        optElem = document.createElement('option');
        optElem.value = 'custom-result';
        recurringDate.insertBefore(optElem, recurringDate.lastChild);
      }

      var dateFormatStr = dateFormat.outputPattern;
      optElem.textContent = recurrence.toStringVerbose(dateFormatStr);
    }

    recurringDate.value = newValue;
    recurrenceValue = newValue;
  };

  if (privates.customRecurrence) processRecurrence(privates.customRecurrence);

  var cancelRecurrence = function cancelRecurrence() {
    recurringDate.value = recurrenceValue;
  };

  recurringDate.addEventListener('change', function (e) {
    if (e.target.value === 'custom') {
      // Get due date, if any
      var dateInput = controls.dueDate;
      var baseDate = null;

      if (dateInput.value) {
        baseDate = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_6__.parseDate)(dateInput.value, dateFormat.inputPatterns);
      }

      var modal = new _recurrenceModal__WEBPACK_IMPORTED_MODULE_2__["default"]({
        confirm: processRecurrence,
        cancel: cancelRecurrence,
        initial: privates.customRecurrence,
        baseDate: baseDate,
        dateFormat: dateFormat
      });
      modalStack.showModal(modal);
    } else {
      recurrenceValue = e.target.value;
    }
  }); // Handle project selection

  var projectValue = controls.project.value;
  controls.project.addEventListener('change', function (e) {
    if (e.target.value === 'new') {
      var modal = new _addProjectModal__WEBPACK_IMPORTED_MODULE_0__["default"]({
        confirm: function confirm(project) {
          var id = privates.projects.addProject(project);
          updateProjects(instance);
          controls.project.value = id;
          projectValue = id;
          if (privates.callbacks.newProject) privates.callbacks.newProject(id);
        },
        cancel: function cancel() {
          controls.project.value = projectValue;
        }
      });
      modalStack.showModal(modal);
    } else {
      projectValue = e.target.value;
    }
  }); // Check date validity

  controls.dueDate.addEventListener('change', function (e) {
    var value = e.target.value;

    if (value.length > 0) {
      var message = '';

      if (!(0,_utility_dates__WEBPACK_IMPORTED_MODULE_6__.parseDate)(value, dateFormat.inputPatterns)) {
        var format = dateFormat.visualPattern;
        message = "Please enter a valid date in ".concat(format, " format.");
      }

      e.target.setCustomValidity(message);
    }
  });
}
/**
 * A modal dialog for adding or editing a task.
 * @implements {module:modalStack~Modal}
 */


var AddTaskModal = /*#__PURE__*/function () {
  /**
   * Specifies options for the modal.
   * @typedef {Object} module:addTaskModal~AddTaskModal~options
   * @property {Function} [confirm] A callback function that will be invoked
   *   when the user successfully confirms the modal. The function will be
   *   passed the unique identifier of the task that was inserted into the task
   *   list (or the identifier of the existing task that was modified).
   * @property {Function} [cancel] A callback function that will be invoked
   *   when the user cancels the modal.
   * @property {Function} [newProject] A callback function that will be invoked
   *   when the user adds a new project to the project list. The unique
   *   identifier for the project will be passed to the function as an
   *   argument.
   * @property {string} [taskId] The unique identifier for the task that is
   *   being edited, if any. If not provided, then a new task will be created.
   * @property {string} [projectId] The unique identifier for the project to
   *   use as the default selection in the Project field. If not provided, then
   *   the task will default to having no project. This property is ignored if
   *   an existing task is being edited.
   * @property {number} [priority=0] The default priority to use for the task.
   *   This is ignored if an existing task is being edited.
   * @property {module:settings~Settings~dateFormat} [dateFormat] An object
   *   holding information about the calendar date format to use for date
   *   fields. If not given, then the browser default is used.
   */

  /**
   * Initialize the modal.
   * @param {module:taskList~TaskList} taskList The task list in which the new
   *   task should be inserted.
   * @param {module:projectList~ProjectList} projectList The project list that
   *   will be used to populate the Project select box. The user can also
   *   create a new project, which will be added to the list.
   * @param {module:addTaskModal~AddTaskModal~options} [options={}] Holds
   *   configuration options for the modal.
   */
  function AddTaskModal(taskList, projectList) {
    var _options$priority;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, AddTaskModal);

    var privates = {
      tasks: taskList,
      projects: projectList,
      taskId: options.taskId || null,
      projectId: options.projectId || null,
      priority: (_options$priority = options.priority) !== null && _options$priority !== void 0 ? _options$priority : 0,
      mode: options.taskId ? 'edit' : 'add',
      customRecurrence: null,
      dateFormat: options.dateFormat || _settings__WEBPACK_IMPORTED_MODULE_4__["default"].lookupDateFormat(),
      callbacks: {
        confirm: options.confirm || null,
        cancel: options.cancel || null,
        newProject: options.newProject || null
      },
      controls: {
        name: null,
        dueDate: null,
        recurringDate: null,
        priority: null,
        project: null,
        description: null
      }
    };
    privateMembers.set(this, privates);
  }

  _createClass(AddTaskModal, [{
    key: "title",
    get: function get() {
      var privates = privateMembers.get(this);
      return privates.mode === 'edit' ? 'Edit Task' : 'Add Task';
    }
  }, {
    key: "confirmLabel",
    get: function get() {
      var privates = privateMembers.get(this);
      return privates.mode === 'edit' ? 'Update' : 'Add';
    }
  }, {
    key: "initFocus",
    get: function get() {
      return privateMembers.get(this).controls.name;
    }
  }, {
    key: "addContent",
    value: function addContent(parent, modalStack) {
      var _dateContainer$classL,
          _this = this;

      var privates = privateMembers.get(this);
      var containerType = {
        classList: ['form-input-container']
      };

      var labelType = function labelType(value) {
        return {
          value: value,
          classList: ['form-input-label']
        };
      };

      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_7__.createFormControl)({
        type: 'text',
        id: 'task-name',
        name: 'task-name',
        classList: ['form-input'],
        required: true,
        label: labelType('Name'),
        container: containerType
      }));
      var dateContainer = document.createElement('div');

      (_dateContainer$classL = dateContainer.classList).add.apply(_dateContainer$classL, _toConsumableArray(containerType.classList));

      var dateLabel = document.createElement('label');
      dateLabel.textContent = 'Due Date';
      dateLabel.htmlFor = 'task-due-date';
      dateLabel.classList.add('form-input-label');
      dateContainer.appendChild(dateLabel);
      dateContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_7__.createDateInputField)({
        id: 'task-due-date',
        name: 'task-due-date',
        placeholder: privates.dateFormat.visualPattern,
        classList: ['form-input-inline'],
        container: {
          classList: ['form-input-date-container']
        },
        button: {
          classList: ['form-button'],
          callback: function callback() {
            return pickDueDate(_this, modalStack);
          }
        }
      }));
      parent.appendChild(dateContainer);
      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_7__.createFormControl)({
        type: 'select',
        id: 'task-recurring-date',
        name: 'task-recurring-date',
        classList: ['form-select'],
        label: labelType('Recurring Date'),
        container: containerType,
        menuItems: [{
          value: 'none',
          label: 'Never Repeat',
          selected: true
        }, {
          value: 'daily',
          label: 'Repeat Daily'
        }, {
          value: 'weekly',
          label: 'Repeat Weekly'
        }, {
          value: 'monthly',
          label: 'Repeat Monthly'
        }, {
          value: 'annually',
          label: 'Repeat Annually'
        }, {
          value: 'custom',
          label: 'Custom Recurrence...'
        }]
      }));
      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_7__.createFormControl)({
        type: 'select',
        id: 'task-priority',
        name: 'task-priority',
        classList: ['form-select'],
        label: labelType('Priority'),
        container: containerType,
        menuItems: [{
          value: 'very-high',
          label: 'Very High'
        }, {
          value: 'high',
          label: 'High'
        }, {
          value: 'medium',
          label: 'Medium',
          selected: true
        }, {
          value: 'low',
          label: 'Low'
        }, {
          value: 'very-low',
          label: 'Very Low'
        }]
      }));
      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_7__.createFormControl)({
        type: 'select',
        id: 'task-project',
        name: 'task-project',
        classList: ['form-select'],
        label: labelType('Project'),
        container: containerType,
        menuItems: [{
          value: 'none',
          label: 'None'
        }]
      }));
      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_7__.createFormControl)({
        type: 'textarea',
        id: 'task-description',
        name: 'task-description',
        classList: ['form-textarea'],
        label: labelType('Description'),
        container: containerType,
        size: {
          rows: 4,
          cols: 20
        }
      }));
      privates.controls = {
        name: parent.querySelector('#task-name'),
        dueDate: parent.querySelector('#task-due-date'),
        recurringDate: parent.querySelector('#task-recurring-date'),
        priority: parent.querySelector('#task-priority'),
        project: parent.querySelector('#task-project'),
        description: parent.querySelector('#task-description')
      };
      initFormValues(this);
      addListeners(this, modalStack);
    }
  }, {
    key: "confirm",
    value: function confirm() {
      var privates = privateMembers.get(this);
      var controls = privates.controls,
          dateFormat = privates.dateFormat;
      var dueDate = null;

      if (controls.dueDate.value) {
        dueDate = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_6__.parseDate)(controls.dueDate.value, dateFormat.inputPatterns);
      }

      var creationDate = null;
      var completionDate = null;

      if (privates.taskId) {
        var _task7 = privates.tasks.getTask(privates.taskId);

        creationDate = _task7.creationDate;
        completionDate = _task7.completionDate;
      }

      var recurringDate = null;

      switch (controls.recurringDate.value) {
        case 'daily':
          recurringDate = new _recurringDate__WEBPACK_IMPORTED_MODULE_3__["default"]('day');
          break;

        case 'weekly':
          recurringDate = new _recurringDate__WEBPACK_IMPORTED_MODULE_3__["default"]('week');
          break;

        case 'monthly':
          recurringDate = new _recurringDate__WEBPACK_IMPORTED_MODULE_3__["default"]('month');
          break;

        case 'annually':
          recurringDate = new _recurringDate__WEBPACK_IMPORTED_MODULE_3__["default"]('year');
          break;

        case 'custom-result':
          recurringDate = privates.customRecurrence;
          break;

        default:
          break;
      }

      var project = null;

      switch (controls.project.value) {
        case 'none':
        case 'new':
          break;

        default:
          project = controls.project.value;
          break;
      }

      var task = new _task__WEBPACK_IMPORTED_MODULE_5__["default"](controls.name.value, {
        dueDate: dueDate,
        creationDate: creationDate,
        completionDate: completionDate,
        priority: controls.priority.value,
        description: controls.description.value || null,
        recurringDate: recurringDate,
        project: project
      });
      var id;

      if (privates.taskId) {
        id = privates.taskId;
        privates.tasks.updateTask(id, task);
      } else {
        id = privates.tasks.addTask(task);
      }

      if (privates.callbacks.confirm) privates.callbacks.confirm(id);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var _privateMembers$get = privateMembers.get(this),
          callbacks = _privateMembers$get.callbacks;

      if (callbacks.cancel) callbacks.cancel();
    }
  }, {
    key: "validate",
    value: function validate() {
      var _privateMembers$get2 = privateMembers.get(this),
          controls = _privateMembers$get2.controls;

      if (!controls.name.reportValidity()) return false;
      if (!controls.dueDate.reportValidity()) return false;
      return true;
    }
  }]);

  return AddTaskModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (AddTaskModal);

/***/ }),

/***/ "./src/modules/modals/confirmModal.js":
/*!********************************************!*\
  !*** ./src/modules/modals/confirmModal.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utility/dom */ "./src/modules/utility/dom.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [ConfirmModal]{@link module:confirmModal~ConfirmModal} class.
 * @module confirmModal
 */

/**
 * Object holding the private members for the
 * [ConfirmModal]{@link module:confirmModal~ConfirmModal} class.
 * @typedef {Object} module:confirmModal~ConfirmModal~privates
 * @property {string} title The title for the modal.
 * @property {string} message The message to be displayed in the content of the
 *   modal.
 * @property {string} confirmLabel The label to be used for the confirm button.
 * @property {string} cancelLabel The label to be used for the cancel button.
 * @property {string} initFocus Which button to give initial keyboard focus:
 *   'confirm', 'cancel', or 'none'.
 * @property {module:confirmModal~ConfirmModal~confirmBox} [confirmBox] Holds
 *   options controlling text that the user must enter to confirm the modal.
 * @property {Object} callbacks An object holding callback functions.
 * @property {Function} [callbacks.confirm] A callback function that will be
 *   invoked when the user successfully confirms the modal.
 * @property {Function} [callbacks.cancel] A callback function that will be
 *   invoked when the user cancels the modal.
 * @property {Object} controls An object holding the form input elements for
 *   the modal.
 * @property {HTMLElement} [controls.confirmBox] The text input element for the
 *   confirmation text that the user must enter, if applicable.
 */

/**
 * Holds private data for the
 * [ConfirmModal]{@link module:confirmModal~ConfirmModal} class.
 * @type {WeakMap}
 * @see module:confirmModal~ConfirmModal~privates
 */

var privateMembers = new WeakMap();
/**
 * Initialize the form elements for the modal.
 * @param {module:confirmModal~ConfirmModal} instance The class instance on
 *   which to apply the function.
 */

function initFormControls(instance) {
  var privates = privateMembers.get(instance);
  var controls = privates.controls;

  if (controls.confirmBox) {
    var confirmBox = privates.confirmBox;
    controls.confirmBox.value = '';
    controls.confirmBox.addEventListener('change', function (e) {
      var value = e.target.value;

      if (value.length > 0) {
        var message = '';
        if (value !== confirmBox.value) message = confirmBox.errorMessage;
        e.target.setCustomValidity(message);
      }
    });
  }
}
/**
 * A modal dialog prompting the user for confirmation.
 * @implements {module:modalStack~Modal}
 */


var ConfirmModal = /*#__PURE__*/function () {
  /**
   * Specifies options for text that the user must enter to confirm the action.
   * @typedef {Object} module:confirmModal~ConfirmModal~confirmBox
   * @property {string} [value=confirm] A value that the user must enter in a
   *   text box in order to confirm the action.
   * @property {string} [label] The label for the text box. If not given, a
   *   generic label is created.
   * @property {string} [errorMessage] The validation message that should be
   *   displayed when the user tries to confirm the modal without entering the
   *   correct value. If not given, a generic message is used.
   */

  /**
   * Specifies options for the modal.
   * @typedef {Object} module:confirmModal~ConfirmModal~options
   * @property {string} [title=Confirm] The title for the modal.
   * @property {string} [confirmLabel=Yes] The label to be used for the confirm
   *   button.
   * @property {string} [cancelLabel=No] The label to be used for the cancel
   *   button.
   * @property {string} [initFocus=cancel] Which element to give initial
   *   keyboard focus: 'confirm' (the Confirm button), 'cancel' (the Cancel
   *   button), 'confirm-box' (the confirmation text box), or 'none'.
   * @property {module:confirmModal~ConfirmModal~confirmBox} [confirmBox] An
   *   object specifying options for text that the user must enter in order to
   *   confirm the action. If this property is provided, then a textbox will be
   *   displayed and the user will be required to type in the given value
   *   before confirming the modal.
   * @property {Function} [confirm] A callback function that will be invoked
   *   when the user successfully confirms the modal.
   * @property {Function} [cancel] A callback function that will be invoked
   *   when the user cancels the modal.
   */

  /**
   * Initialize the modal.
   * @param {string} message The message that should be displayed to the user.
   * @param {module:confirmModal~ConfirmModal~options} [options={}] Holds
   *   configuration options for the modal.
   */
  function ConfirmModal(message) {
    var _options$title;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ConfirmModal);

    var privates = {
      title: (_options$title = options.title) !== null && _options$title !== void 0 ? _options$title : 'Confirm',
      message: message,
      confirmLabel: options.confirmLabel || 'Yes',
      cancelLabel: options.cancelLabel || 'No',
      initFocus: options.initFocus || 'cancel',
      confirmBox: null,
      callbacks: {
        confirm: options.confirm || null,
        cancel: options.cancel || null
      },
      controls: {
        confirmBox: null
      }
    };
    var confirmBox = options.confirmBox;

    if (options.confirmBox) {
      privates.confirmBox = {
        value: confirmBox.value || 'confirm',
        label: confirmBox.label || "Please enter '".concat(confirmBox.value, "':"),
        errorMessage: confirmBox.errorMessage || "Please enter '".concat(confirmBox.value, "'.")
      };
    }

    privateMembers.set(this, privates);
  }

  _createClass(ConfirmModal, [{
    key: "title",
    get: function get() {
      return privateMembers.get(this).title;
    }
  }, {
    key: "confirmLabel",
    get: function get() {
      return privateMembers.get(this).confirmLabel;
    }
  }, {
    key: "cancelLabel",
    get: function get() {
      return privateMembers.get(this).cancelLabel;
    }
  }, {
    key: "initFocus",
    get: function get() {
      var privates = privateMembers.get(this);

      if (privates.initFocus === 'confirm-box') {
        return privates.controls.confirmBox || 'none';
      }

      return privates.initFocus;
    }
  }, {
    key: "addContent",
    value: function addContent(parent) {
      var privates = privateMembers.get(this);
      var message = privates.message,
          confirmBox = privates.confirmBox;
      var label = document.createElement('p');
      label.classList.add('form-input-label-inline');
      label.textContent = message;
      parent.appendChild(label);

      if (confirmBox) {
        label = document.createElement('p');
        label.classList.add('form-input-label-inline');
        label.textContent = ' ';
        parent.appendChild(label);
        parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createFormControl)({
          type: 'text',
          id: 'confirmation-box',
          name: 'confirmation-box',
          classList: ['form-input', 'confirmation-box'],
          required: true,
          placeholder: confirmBox.value,
          label: {
            value: confirmBox.label,
            classList: ['form-input-label-inline']
          },
          container: {
            classList: ['form-input-container']
          }
        }));
        privates.controls.confirmBox = parent.querySelector('#confirmation-box');
      }

      initFormControls(this);
    }
  }, {
    key: "confirm",
    value: function confirm() {
      var confirm = privateMembers.get(this).callbacks.confirm;
      if (confirm) confirm();
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var cancel = privateMembers.get(this).callbacks.cancel;
      if (cancel) cancel();
    }
  }, {
    key: "validate",
    value: function validate() {
      var _privateMembers$get = privateMembers.get(this),
          controls = _privateMembers$get.controls;

      if (controls.confirmBox && !controls.confirmBox.reportValidity()) {
        return false;
      }

      return true;
    }
  }]);

  return ConfirmModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (ConfirmModal);

/***/ }),

/***/ "./src/modules/modals/dataModal.js":
/*!*****************************************!*\
  !*** ./src/modules/modals/dataModal.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _confirmModal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./confirmModal */ "./src/modules/modals/confirmModal.js");
/* harmony import */ var _exportModal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exportModal */ "./src/modules/modals/exportModal.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utility/dom */ "./src/modules/utility/dom.js");
/* harmony import */ var _utility_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utility/storage */ "./src/modules/utility/storage.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [DataModal]{@link module:dataModal~dataModal} class.
 * @module dataModal
 */




/**
 * Object holding the private members for the
 * [DataModal]{@link module:dataModal~dataModal} class.
 * @typedef {Object} module:dataModal~DataModal~privates
 * @property {Object} callbacks An object holding callback functions.
 * @property {module:dataModal~DataModal~importData} [callbacks.importData] A
 *   callback function that will be invoked if the user chooses to import data
 *   from a file.
 * @property {module:dataModal~DataModal~exportData} [callbacks.exportData] A
 *   callback function that will be invoked if the user chooses to export data
 *   to a file.
 * @property {Function} [callbacks.deleteAll] A callback function that will be
 *   invoked if the user chooses to delete all data.
 * @property {Function} [callbacks.close] A callback function that will be
 *   invoked when the user closes the modal.
 * @property {Object} controls An object holding the form controls in the modal
 *   content.
 * @property {HTMLElement} controls.fileSelector The file input control.
 * @property {HTMLElement} controls.importButton The import button.
 * @property {HTMLElement} controls.exportButton The export button.
 * @property {HTMLElement} controls.deleteButton The delete button.
 */

/**
 * Holds private data for the [DataModal]{@link module:dataModal~dataModal}
 * class.
 * @type {WeakMap}
 * @see module:dataModal~DataModal~privates
 */

var privateMembers = new WeakMap();
/**
 * Perform a data import that was requested by the user.
 * @param {module:dataModal~DataModal} instance The class instance on which to
 *   apply the function.
 * @param {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal is being inserted.
 * @param {Blob} file The file that the user selected for import.
 */

function doImport(instance, modalStack, file) {
  (0,_utility_storage__WEBPACK_IMPORTED_MODULE_3__.readFile)(file, function (content) {
    if (content) {
      modalStack.closeModal();
      var callback = privateMembers.get(instance).callbacks.importData;

      if (callback) {
        var fileInfo = {
          name: file.name,
          size: file.size,
          type: file.type || null
        };
        callback(content, fileInfo);
      }
    }
  });
}
/**
 * Perform a data export that was requested by the user.
 * @param {module:dataModal~DataModal} instance The class instance on which to
 *   apply the function.
 * @param {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal is being inserted.
 * @param {string} fileType A string specifying the file format to use for
 *   export: 'json' or 'csv'.
 * @param {Object} fileOptions An object specifying additional file options.
 */


function doExport(instance, modalStack, fileType, fileOptions) {
  // Use setTimeout to wait for export modal to finish
  setTimeout(function () {
    modalStack.closeModal();
    var callback = privateMembers.get(instance).callbacks.exportData;
    if (callback) callback(fileType, fileOptions);
  });
}
/**
 * Perform a data deletion operation that was requested by the user.
 * @param {module:dataModal~DataModal} instance The class instance on which to
 *   apply the function.
 * @param {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal is being inserted.
 */


function doDelete(instance, modalStack) {
  var callback = privateMembers.get(instance).callbacks.deleteAll;
  if (callback) callback(); // Close the data modal (using setTimeout to wait for confirm modal to close)

  setTimeout(function () {
    return modalStack.closeModal();
  });
}
/**
 * Add the event listeners to the buttons in the modal.
 * @param {module:dataModal~DataModal} instance The class instance on which to
 *   apply the function.
 * @param {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal is being inserted.
 */


function addListeners(instance, modalStack) {
  var _privateMembers$get = privateMembers.get(instance),
      controls = _privateMembers$get.controls;

  controls.importButton.addEventListener('click', function () {
    controls.fileSelector.click();
  });
  controls.exportButton.addEventListener('click', function () {
    var modal = new _exportModal__WEBPACK_IMPORTED_MODULE_1__["default"]({
      confirm: function confirm(fileType, options) {
        doExport(instance, modalStack, fileType, options);
      }
    });
    modalStack.showModal(modal);
  });
  controls.deleteButton.addEventListener('click', function () {
    var modal = new _confirmModal__WEBPACK_IMPORTED_MODULE_0__["default"]('Are you sure you want to delete all user data? This will erase all tasks and projects, and will also reset app settings.', {
      initFocus: 'confirm-box',
      confirmBox: {
        value: 'delete',
        label: 'This action cannot be undone. Please confirm your intention by typing the word \'delete\' (without quotes) in the box:',
        errorMessage: 'Please enter the word \'delete\'.'
      },
      confirm: function confirm() {
        return doDelete(instance, modalStack);
      }
    });
    modalStack.showModal(modal);
  });
  controls.fileSelector.addEventListener('change', function (e) {
    var files = e.target.files;
    if (files.length > 0) doImport(instance, modalStack, files[0]);
  });
}
/**
 * A modal dialog for managing user data.
 * @implements {module:modalStack~Modal}
 */


var DataModal = /*#__PURE__*/function () {
  /**
   * A callback function that will be invoked when the user chooses to import
   * data from a file and the file is read successfully.
   * @callback module:dataModal~DataModal~importData
   * @param {string} content The contents of the file.
   * @param {Object} [info] An object specifying additional file information.
   * @param {string} [info.name] The name of the file.
   * @param {number} [info.size] The size of the file in bytes.
   * @param {string} [info.type] The media type of the file, or null if the
   *   browser could not determine a media type.
   */

  /**
   * A callback function that will be invoked when the user chooses to export
   * data to a file.
   * @callback module:dataModal~DataModal~exportData
   * @param {string} fileType A string specifying the file format to use for
   *   export. This can be either 'json' or 'csv'.
   * @param {Object} [options] An object specifying additional file options.
   * @param {string} [options.newlineSequence] The character sequence to use
   *   for newlines.
   */

  /**
   * Specifies options for the modal.
   * @typedef {Object} module:dataModal~DataModal~options
   * @property {module:dataModal~DataModal~importData} [importData] A callback
   *   function that will be invoked when the user chooses to import data from
   *   a file and the file is read successfully.
   * @property {module:dataModal~DataModal~exportData} [exportData] A callback
   *   function that will be invoked when the user chooses to export data to a
   *   file.
   * @property {Function} [deleteAll] A callback function that will be invoked
   *   when the user chooses (and confirms the choice) to delete all data.
   * @property {Function} [close] A callback function that will be invoked when
   *   the user closes the modal. This will not be invoked if the modal is
   *   automatically closed following a data management operation.
   */

  /**
   * Initialize the modal.
   * @param {module:dataModal~DataModal~options} [options={}] Holds
   *   configuration options for the modal.
   */
  function DataModal() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DataModal);

    var privates = {
      callbacks: {
        importData: options.importData || null,
        exportData: options.exportData || null,
        deleteAll: options.deleteAll || null,
        close: options.close || null
      },
      controls: {
        fileSelector: null,
        importButton: null,
        exportButton: null,
        deleteButton: null
      }
    };
    privateMembers.set(this, privates);
  }
  /* eslint-disable class-methods-use-this --
   * We need to set these properties to conform to the Modal interface, but
   * setting them directly in the constructor would allow external
   * modification.
   */


  _createClass(DataModal, [{
    key: "title",
    get: function get() {
      return 'Manage Data';
    }
  }, {
    key: "confirmLabel",
    get: function get() {
      return 'Close';
    }
  }, {
    key: "noCancelButton",
    get: function get() {
      return true;
    }
  }, {
    key: "initFocus",
    get: function get() {
      return 'confirm';
    }
    /* eslint-enable class-methods-use-this */

  }, {
    key: "addContent",
    value: function addContent(parent, modalStack) {
      var addContainer = function addContainer() {
        var container = document.createElement('div');
        container.classList.add('form-input-container');
        parent.appendChild(container);
        return container;
      };

      var addHeading = function addHeading(label, container) {
        var labelElem = document.createElement('div');
        labelElem.classList.add('form-input-label');
        labelElem.textContent = label;
        container.appendChild(labelElem);
      };

      var addButton = function addButton(label, container) {
        var button = document.createElement('button');
        button.classList.add('form-button');
        button.textContent = label;
        container.appendChild(button);
        return button;
      };

      var _privateMembers$get2 = privateMembers.get(this),
          controls = _privateMembers$get2.controls;

      var container = addContainer();
      addHeading('Import/Export', container);
      var buttonContainer = document.createElement('div');
      buttonContainer.classList.add('form-button-container');
      container.appendChild(buttonContainer);
      controls.importButton = addButton('Import from File...', buttonContainer);
      controls.exportButton = addButton('Export to File...', buttonContainer);
      container = addContainer();
      addHeading('Delete Data', container);
      controls.deleteButton = addButton('Erase All Data...', container);
      controls.fileSelector = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_2__.createFormControl)({
        type: 'file',
        id: 'data-import-file-select',
        name: 'data-import-file-select',
        classList: ['form-input-hidden'],
        accept: ['.json', '.csv', 'application/json', 'text/csv']
      });
      addListeners(this, modalStack);
    }
  }, {
    key: "confirm",
    value: function confirm() {
      this.cancel();
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var close = privateMembers.get(this).callbacks.close;
      if (close) close();
    }
    /* eslint-disable-next-line class-methods-use-this --
     * Necessary since modal must have validate function in order to satisfy
     * Modal interface.
     */

  }, {
    key: "validate",
    value: function validate() {
      return true;
    }
  }]);

  return DataModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (DataModal);

/***/ }),

/***/ "./src/modules/modals/datePickerModal.js":
/*!***********************************************!*\
  !*** ./src/modules/modals/datePickerModal.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _datePicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../datePicker */ "./src/modules/datePicker.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [DatePickerModal]{@link module:datePickerModal~DatePickerModal}
 * class.
 * @module datePickerModal
 */

/**
 * Object holding private members for the
 * [DatePickerModal]{@link module:datePickerModal~DatePickerModal} class.
 * @typedef {Object} module:datePickerModal~DatePickerModal~privates
 * @property {Object} callbacks An object holding callback functions.
 * @property {Function} [callbacks.confirm] A callback function that will be
 *   invoked when the user successfully confirms the modal.
 * @property {Function} [callbacks.cancel] A callback function that will be
 *   invoked when the user cancels the modal.
 * @property {Date} [stateDate] The default date that is selected when the
 *   modal is opened, if different from today.
 * @property {string} title The title of the modal.
 * @property {module:datePicker~DatePicker} picker The date picker instance.
 */

/**
 * Holds private data for the
 * [DatePickerModal]{@link module:datePickerModal~DatePickerModal} class.
 * @type {WeakMap}
 * @see module:datePickerModal~DatePickerModal~privates
 */

var privateMembers = new WeakMap();
/**
 * A modal dialog for choosing a calendar date.
 * @implements {module:modalStack~Modal}
 */

var DatePickerModal = /*#__PURE__*/function () {
  /**
   * Initialize the modal.
   * @param {Object} [options={}] Holds configuration options for the modal.
   * @param {Function} [options.confirm] A callback function that will be
   *   invoked when the user successfully confirms the modal. The selected date
   *   will be passed to the function as an argument.
   * @param {Function} [options.cancel] A callback function that will be
   *   invoked when the user cancels the modal.
   * @param {Date} [options.startDate] The date that will be initially
   *   selected. If not given, then the present date is used.
   * @param {string} [options.title=Select Date] The title of the modal.
   */
  function DatePickerModal() {
    var _options$title;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DatePickerModal);

    var privates = {
      callbacks: {
        confirm: options.confirm || null,
        cancel: options.cancel || null
      },
      startDate: options.startDate || null,
      title: (_options$title = options.title) !== null && _options$title !== void 0 ? _options$title : 'Select Date',
      picker: null
    };
    privateMembers.set(this, privates);
  }

  _createClass(DatePickerModal, [{
    key: "title",
    get: function get() {
      return privateMembers.get(this).title;
    }
  }, {
    key: "addContent",
    value: function addContent(parent) {
      var privates = privateMembers.get(this);
      privates.picker = new _datePicker__WEBPACK_IMPORTED_MODULE_0__["default"](parent, privates.startDate);
    }
  }, {
    key: "confirm",
    value: function confirm() {
      var _privateMembers$get = privateMembers.get(this),
          callbacks = _privateMembers$get.callbacks,
          picker = _privateMembers$get.picker;

      if (callbacks.confirm) callbacks.confirm(picker.date);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var _privateMembers$get2 = privateMembers.get(this),
          callbacks = _privateMembers$get2.callbacks;

      if (callbacks.cancel) callbacks.cancel();
    }
    /* eslint-disable-next-line class-methods-use-this --
     * Necessary since modal must have validate function in order to satisfy
     * Modal interface.
     */

  }, {
    key: "validate",
    value: function validate() {
      return true;
    }
  }]);

  return DatePickerModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (DatePickerModal);

/***/ }),

/***/ "./src/modules/modals/exportModal.js":
/*!*******************************************!*\
  !*** ./src/modules/modals/exportModal.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utility/dom */ "./src/modules/utility/dom.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [ExportModal]{@link module:exportModal~ExportModal} class.
 * @module exportModal
 */

/**
 * Object holding private members for the
 * [ExportModal]{@link module:exportModal~ExportModal} class.
 * @typedef {Object} module:exportModal~ExportModal~privates
 * @property {Object} callbacks An object holding callback functions.
 * @property {Function} [callbacks.confirm] A callback function that will be
 *   invoked when the user successfully confirms the modal.
 * @property {Function} [callbacks.cancel] A callback function that will be
 *   invoked when the user cancels the modal.
 * @property {Object} controls An object holding the form input elements for
 *   the modal.
 * @property {HTMLElement} controls.exportJson The radio button for selecting
 *   the JSON file format.
 * @property {HTMLElement} controls.exportCsv The radio button for selecting
 *   the CSV file format.
 * @property {HTMLElement} controls.newlineSequence The select box for choosing
 *   the newline style.
 */

/**
 * Holds private data for the
 * [ExportModal]{@link module:exportModal~ExportModal} class.
 * @type {WeakMap}
 * @see module:exportModal~ExportModal~privates
 */

var privateMembers = new WeakMap();
/**
 * A modal dialog for exporting data to a file.
 * @implements {module:modalStack~Modal}
 */

var ExportModal = /*#__PURE__*/function () {
  /**
   * A callback function that will be invoked when the user chooses to export
   * data to a file.
   * @callback module:exportModal~ExportModal~exportCallback
   * @param {string} fileType A string specifying the file format to use for
   *   export. This can be either 'json' or 'csv'.
   * @param {Object} [options] An object specifying additional file options.
   * @param {string} [options.newlineSequence] The character sequence to use
   *   for newlines.
   */

  /**
   * Specifies options for the modal.
   * @typedef {Object} module:exportModal~ExportModal~options
   * @property {module:exportModal~ExportModal~exportCallback} [confirm] A
   *   callback function that will be invoked when the user successfully
   *   confirms the modal.
   * @property {Function} [cancel] A callback function that will be invoked
   *   when the user cancels the modal.
   */

  /**
   * Initialize the modal.
   * @param {module:exportModal~ExportModal~options} [options={}] Holds
   *   configuration options for the modal.
   */
  function ExportModal() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ExportModal);

    var privates = {
      callbacks: {
        confirm: options.confirm || null,
        cancel: options.cancel || null
      },
      controls: {
        exportJson: null,
        exportCsv: null,
        newlineSequence: null
      }
    };
    privateMembers.set(this, privates);
  }
  /* eslint-disable class-methods-use-this --
   * We need to set these properties to conform to the Modal interface, but
   * setting them directly in the constructor would allow external
   * modification.
   */


  _createClass(ExportModal, [{
    key: "title",
    get: function get() {
      return 'Export Data';
    }
  }, {
    key: "confirmLabel",
    get: function get() {
      return 'Export...';
    }
    /* eslint-enable class-methods-use-this */

  }, {
    key: "addContent",
    value: function addContent(parent) {
      var radioLabel = function radioLabel(value) {
        return {
          value: value,
          classList: ['form-input-label-inline']
        };
      };

      var container = document.createElement('div');
      container.classList.add('form-input-container');
      var label = document.createElement('div');
      label.classList.add('form-input-label');
      label.textContent = 'File Format';
      container.appendChild(label);
      container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createFormControl)({
        type: 'radio',
        id: 'export-format-json',
        name: 'export-format',
        value: 'json',
        checked: true,
        label: radioLabel('Export all data to JSON format'),
        container: {
          classList: ['form-input-item-container']
        }
      }));
      container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createFormControl)({
        type: 'radio',
        id: 'export-format-csv',
        name: 'export-format',
        value: 'csv',
        label: radioLabel('Export tasks to CSV format'),
        container: {
          classList: ['form-input-item-container']
        }
      }));
      parent.appendChild(container);
      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_0__.createFormControl)({
        type: 'select',
        id: 'export-line-ending',
        name: 'export-line-ending',
        classList: ['form-select'],
        label: {
          value: 'Line Ending Style',
          classList: ['form-input-label']
        },
        container: {
          classList: ['form-input-container']
        },
        menuItems: [{
          value: 'crlf',
          label: 'Windows Standard: CRLF',
          selected: true
        }, {
          value: 'lf',
          label: 'Unix Standard: LF'
        }, {
          value: 'cr',
          label: 'Classic Mac OS Standard (Before OS X): CR'
        }]
      }));

      var _privateMembers$get = privateMembers.get(this),
          controls = _privateMembers$get.controls;

      controls.exportJson = parent.querySelector('#export-format-json');
      controls.exportCsv = parent.querySelector('#export-format-csv');
      controls.newlineSequence = parent.querySelector('#export-line-ending');
    }
  }, {
    key: "confirm",
    value: function confirm() {
      var _privateMembers$get2 = privateMembers.get(this),
          callbacks = _privateMembers$get2.callbacks,
          controls = _privateMembers$get2.controls;

      if (callbacks.confirm) {
        var fileType = controls.exportJson.checked ? 'json' : 'csv';
        var newlineSequence;

        switch (controls.newlineSequence.value) {
          case 'lf':
            newlineSequence = '\n';
            break;

          case 'cr':
            newlineSequence = '\r';
            break;

          case 'crlf':
          default:
            newlineSequence = '\r\n';
            break;
        }

        callbacks.confirm(fileType, {
          newlineSequence: newlineSequence
        });
      }
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var callback = privateMembers.get(this).callbacks.cancel;
      if (callback) callback();
    }
    /* eslint-disable-next-line class-methods-use-this --
     * Necessary since modal must have validate function in order to satisfy
     * Modal interface.
     */

  }, {
    key: "validate",
    value: function validate() {
      return true;
    }
  }]);

  return ExportModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (ExportModal);

/***/ }),

/***/ "./src/modules/modals/infoModal.js":
/*!*****************************************!*\
  !*** ./src/modules/modals/infoModal.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [InfoModal]{@link module:infoModal~InfoModal} class.
 * @module infoModal
 */

/**
 * Object holding the private members for the
 * [InfoModal]{@link module:infoModal~InfoModal} class.
 * @typedef {Object} module:infoModal~InfoModal~privates
 * @property {string} title The title for the modal.
 * @property {string} confirmLabel The label to be used for the confirm button.
 * @property {HTMLElement} content The custom content to display in the modal.
 * @property {Object} callbacks An object holding callback functions.
 * @property {Function} [callbacks.close] A callback function that will be
 *   invoked when the user closes the modal.
 */

/**
 * Holds private data for the [InfoModal]{@link module:infoModal~InfoModal}
 * class.
 * @type {WeakMap}
 * @see module:infoModal~InfoModal~privates
 */
var privateMembers = new WeakMap();
/**
 * A modal dialog displaying custom informational content.
 * @implements {module:modalStack~Modal}
 */

var InfoModal = /*#__PURE__*/function () {
  /**
   * Specifies options for the modal.
   * @typedef {Object} module:infoModal~InfoModal~options
   * @property {string} [title=Alert] The title for the modal.
   * @property {string} [confirmLabel=Okay] The label to be used for the
   *   confirm button.
   * @property {Function} [close] A callback function that will be invoked when
   *   the user closes the modal.
   */

  /**
   * Initialize the modal.
   * @param {string|string[]|HTMLElement} content The content that will be
   *   displayed in the modal. This can either be a string specifying a
   *   message, an array of strings each specifying a paragraph of text, or a
   *   custom element that will be inserted into the modal content area.
   * @param {module:infoModal~InfoModal~options} [options={}] Holds
   *   configuration options for the modal.
   */
  function InfoModal(content) {
    var _options$title;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, InfoModal);

    var privates = {
      title: (_options$title = options.title) !== null && _options$title !== void 0 ? _options$title : 'Alert',
      confirmLabel: options.confirmLabel || 'Okay',
      content: null,
      callbacks: {
        close: options.close || null
      }
    };

    if (content instanceof Node) {
      privates.content = content;
    } else {
      var container = document.createElement('div');
      container.classList.add('info-modal-content-container');
      var paragraphs = Array.isArray(content) ? content : [content];
      paragraphs.forEach(function (paragraph) {
        var pElem = document.createElement('p');
        pElem.classList.add('info-modal-content-paragraph');
        pElem.textContent = paragraph;
        container.appendChild(pElem);
      });
      privates.content = container;
    }

    privateMembers.set(this, privates);
  }

  _createClass(InfoModal, [{
    key: "title",
    get: function get() {
      return privateMembers.get(this).title;
    }
  }, {
    key: "confirmLabel",
    get: function get() {
      return privateMembers.get(this).confirmLabel;
    }
    /* eslint-disable class-methods-use-this --
     * We need to set these properties to conform to the Modal interface, but
     * setting them directly in the constructor would allow external
     * modification.
     */

  }, {
    key: "noCancelButton",
    get: function get() {
      return true;
    }
  }, {
    key: "initFocus",
    get: function get() {
      return 'confirm';
    }
    /* eslint-enable class-methods-use-this */

  }, {
    key: "addContent",
    value: function addContent(parent) {
      parent.appendChild(privateMembers.get(this).content);
    }
  }, {
    key: "confirm",
    value: function confirm() {
      var callback = privateMembers.get(this).callbacks.close;
      if (callback) callback();
    }
  }, {
    key: "cancel",
    value: function cancel() {
      this.confirm();
    }
    /* eslint-disable-next-line class-methods-use-this --
     * Necessary since modal must have validate function in order to satisfy
     * Modal interface.
     */

  }, {
    key: "validate",
    value: function validate() {
      return true;
    }
  }]);

  return InfoModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (InfoModal);

/***/ }),

/***/ "./src/modules/modals/recurrenceModal.js":
/*!***********************************************!*\
  !*** ./src/modules/modals/recurrenceModal.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/range */ "./node_modules/lodash/range.js");
/* harmony import */ var lodash_range__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_range__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ordinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ordinal */ "./node_modules/ordinal/index.js");
/* harmony import */ var ordinal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ordinal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _datePickerModal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./datePickerModal */ "./src/modules/modals/datePickerModal.js");
/* harmony import */ var _recurringDate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../recurringDate */ "./src/modules/recurringDate.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../settings */ "./src/modules/settings.js");
/* harmony import */ var _utility_dates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utility/dates */ "./src/modules/utility/dates.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utility/dom */ "./src/modules/utility/dom.js");


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }







var UNITS = [{
  value: 'day',
  singular: 'Day',
  plural: 'Days'
}, {
  value: 'week',
  singular: 'Week',
  plural: 'Weeks'
}, {
  value: 'month',
  singular: 'Month',
  plural: 'Months'
}, {
  value: 'year',
  singular: 'Year',
  plural: 'Years'
}];
/**
 * Object holding private members for the
 * [RecurrenceModal]{@link module:recurrenceModal~RecurrenceModal} class.
 * @typedef {Object} module:recurrenceModal~RecurrenceModal~privates
 * @property {module:recurringDate~RecurringDate} [initialRecurrence] The
 *   recurring date to use as a default when initializing the form controls, if
 *   any.
 * @property {Date} baseDate The date to use when initializing certain input
 *   fields.
 * @property {module:settings~Settings~dateFormat} dateFormat An object holding
 *   date format information.
 * @property {Object} callbacks An object holding callback functions.
 * @property {Function} [callbacks.confirm] A callback function that will be
 *   invoked when the user successfully confirms the modal.
 * @property {Function} [callbacks.cancel] A callback function that will be
 *   invoked when the user cancels the modal.
 * @property {Object} containers An object holding the various container
 *   elements used in the modal's contents.
 * @property {HTMLElement} containers.parent The parent container element
 *   holding all the form elements.
 * @property {HTMLElement} containers.context The container element holding
 *   context-sensitive options that depend on the selected interval unit.
 * @property {HTMLElement} containers.weekOptions The container element holding
 *   the form elements specific to weekly recurrences.
 * @property {HTMLElement} containers.monthOptions The container element
 *   holding the form elements specific to monthly recurrences.
 * @property {HTMLElement} containers.yearOptions The container element holding
 *   the form elements specific to yearly recurrences.
 * @property {string} title The title of the modal.
 */

/**
 * Holds private data for the
 * [RecurrenceModal]{@link module:recurrenceModal~RecurrenceModal} class.
 * @type {WeakMap}
 * @see module:recurrenceModal~RecurrenceModal~privates
 */

var privateMembers = new WeakMap();
/**
 * Create the form elements for the context options for weekly recurrences.
 * @returns {HTMLElement} The container element holding the form elements.
 */

function createWeekContextForm() {
  var container = document.createElement('div');
  container.classList.add('form-input-container');
  var label = document.createElement('div');
  label.classList.add('form-input-label-inline');
  label.textContent = 'Repeat on';
  container.appendChild(label);
  container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'radio',
    id: 'recurring-date-week-type-previous',
    name: 'recurring-date-week-type',
    value: 'use-previous',
    checked: true,
    label: {
      value: 'The same day of the week as before',
      classList: ['form-input-label-inline']
    },
    container: {
      classList: ['form-input-item-container']
    }
  }));
  var optionContainer = document.createElement('div');
  optionContainer.classList.add('form-input-item-container');
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'radio',
    id: 'recurring-date-week-type-select-days',
    name: 'recurring-date-week-type',
    value: 'select-days'
  }));
  label = document.createElement('label');
  label.classList.add('form-input-label-inline');
  label.textContent = 'These days: ';
  label.htmlFor = 'recurring-date-week-type-select-days';
  optionContainer.appendChild(label);

  lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(7).map(function (index) {
    var name = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getWeekdayName)(index);
    return {
      value: name.toLowerCase(),
      label: name.slice(0, 1)
    };
  }).forEach(function (day) {
    optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createToggleButton)(day.label, {
      id: "recurring-date-weekday-".concat(day.value),
      name: 'recurring-date-weekday',
      value: day.value,
      classList: ['toggle-button', 'form-weekday-button']
    }));
  });

  container.appendChild(optionContainer);
  return container;
}
/**
 * Create the form elements for the context options for monthly recurrences.
 * @returns {HTMLElement} The container element holding the form elements.
 */


function createMonthContextForm() {
  var container = document.createElement('div');
  container.classList.add('form-input-container');
  var label;
  var optionContainer;
  var selectItems;
  label = document.createElement('div');
  label.classList.add('form-input-label-inline');
  label.textContent = 'Repeat on';
  container.appendChild(label);
  container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'radio',
    id: 'recurring-date-month-type-previous',
    name: 'recurring-date-month-type',
    value: 'use-previous',
    checked: true,
    label: {
      value: 'The same day of the month as before',
      classList: ['form-input-label-inline']
    },
    container: {
      classList: ['form-input-item-container']
    }
  }));
  optionContainer = document.createElement('div');
  optionContainer.classList.add('form-input-item-container');
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'radio',
    id: 'recurring-date-month-type-day',
    name: 'recurring-date-month-type',
    value: 'day-of-month'
  }));
  label = document.createElement('label');
  label.classList.add('form-input-label-inline');
  label.htmlFor = 'recurring-date-month-type-day';
  label.textContent = 'The ';
  optionContainer.appendChild(label);
  selectItems = lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(1, 32).map(function (day) {
    return {
      value: day.toString(),
      label: ordinal__WEBPACK_IMPORTED_MODULE_1___default()(day)
    };
  });
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'select',
    id: 'recurring-date-month-day',
    name: 'recurring-date-month-day',
    classList: ['form-select-inline'],
    menuItems: selectItems
  }));
  label = document.createElement('label');
  label.classList.add('form-input-label-inline');
  label.htmlFor = 'recurring-date-month-day';
  label.textContent = ' day of the month';
  optionContainer.appendChild(label);
  container.appendChild(optionContainer);
  optionContainer = document.createElement('div');
  optionContainer.classList.add('form-input-item-container');
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'radio',
    id: 'recurring-date-month-type-week',
    name: 'recurring-date-month-type',
    value: 'week-of-month'
  }));
  label = document.createElement('label');
  label.classList.add('form-input-label-inline');
  label.htmlFor = 'recurring-date-month-type-week';
  label.textContent = 'The ';
  optionContainer.appendChild(label);
  selectItems = lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(1, 6).map(function (week) {
    return {
      value: week.toString(),
      label: week < 5 ? ordinal__WEBPACK_IMPORTED_MODULE_1___default()(week) : 'last'
    };
  });
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'select',
    id: 'recurring-date-month-week-number',
    name: 'recurring-date-month-week-number',
    classList: ['form-select-inline'],
    menuItems: selectItems
  }));
  label = document.createElement('span');
  label.classList.add('form-input-label-inline');
  label.textContent = ' ';
  optionContainer.appendChild(label);
  selectItems = lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(7).map(function (index) {
    var day = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getWeekdayName)(index);
    return {
      value: day.toLowerCase(),
      label: day
    };
  });
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'select',
    id: 'recurring-date-month-week-day',
    name: 'recurring-date-month-week-day',
    classList: ['form-select-inline'],
    menuItems: selectItems
  }));
  label = document.createElement('label');
  label.classList.add('form-input-label-inline');
  label.htmlFor = 'recurring-date-month-week-day';
  label.textContent = ' of the month';
  optionContainer.appendChild(label);
  container.appendChild(optionContainer);
  return container;
}
/**
 * Create the form elements for the context options for yearly recurrences.
 * @returns {HTMLElement} The container element holding the form elements.
 */


function createYearContextForm() {
  var container = document.createElement('div');
  container.classList.add('form-input-container');
  var label;
  var selectItems;
  label = document.createElement('div');
  label.classList.add('form-input-label-inline');
  label.textContent = 'Repeat on';
  container.appendChild(label);
  container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'radio',
    id: 'recurring-date-year-type-previous',
    name: 'recurring-date-year-type',
    value: 'use-previous',
    checked: true,
    label: {
      value: 'The same month and day as before',
      classList: ['form-input-label-inline']
    },
    container: {
      classList: ['form-input-item-container']
    }
  }));
  var optionContainer = document.createElement('div');
  optionContainer.classList.add('form-input-item-container');
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'radio',
    id: 'recurring-date-year-type-day',
    name: 'recurring-date-year-type',
    value: 'month-and-day'
  }));
  label = document.createElement('label');
  label.classList.add('form-input-label-inline');
  label.htmlFor = 'recurring-date-year-type-day';
  label.textContent = 'The ';
  optionContainer.appendChild(label);
  selectItems = lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(1, 32).map(function (day) {
    return {
      value: day.toString(),
      label: ordinal__WEBPACK_IMPORTED_MODULE_1___default()(day)
    };
  });
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'select',
    id: 'recurring-date-year-day',
    name: 'recurring-date-year-day',
    classList: ['form-select-inline'],
    menuItems: selectItems
  }));
  label = document.createElement('span');
  label.classList.add('form-input-label-inline');
  label.textContent = ' day of ';
  optionContainer.appendChild(label);
  selectItems = lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(12).map(function (index) {
    var name = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getMonthName)(index);
    return {
      value: name.toLowerCase(),
      label: name
    };
  });
  optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
    type: 'select',
    id: 'recurring-date-year-month',
    name: 'recurring-date-year-month',
    classList: ['form-select-inline'],
    menuItems: selectItems
  }));
  container.appendChild(optionContainer);
  return container;
}
/**
 * Select a form control in the modal.
 * @param {module:recurrenceModal~RecurrenceModal} instance The class instance
 *   on which to apply the function.
 * @param {string} idSuffix The identifier of the control to retrieve,
 *   without the 'recurring-date-' prefix.
 * @param {string} [container] The container in which to look for the
 *   control. If not given, then the modal content container is used.
 * @returns {HTMLElement} The requested element, or undefined if not found.
 */


function getControl(instance, idSuffix, container) {
  var parent = container || privateMembers.get(instance).containers.parent;
  return parent.querySelector("#recurring-date-".concat(idSuffix));
}
/**
 * Initialize the values of the form elements based on the initial recurrence
 * that was passed to the constructor, if any.
 * @param {module:recurrenceModal~RecurrenceModal} instance The class instance
 *   on which to apply the function.
 */


function initFormValues(instance) {
  var privates = privateMembers.get(instance);
  var _privates$containers = privates.containers,
      weekOptions = _privates$containers.weekOptions,
      monthOptions = _privates$containers.monthOptions,
      yearOptions = _privates$containers.yearOptions;
  var initial = privates.initialRecurrence;

  if (initial) {
    getControl(instance, 'interval-length').value = initial.intervalLength;
    getControl(instance, 'interval-unit').value = initial.intervalUnit;
    var context;

    switch (initial.intervalUnit) {
      case 'week':
        context = weekOptions;

        if (initial.daysOfWeek) {
          getControl(instance, 'week-type-select-days', context).checked = true;
          initial.daysOfWeek.forEach(function (day) {
            var id = "weekday-".concat((0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getWeekdayName)(day).toLowerCase());
            var button = getControl(instance, id, context);
            if (button) button.classList.add('active');
          });
        } else {
          getControl(instance, 'week-type-previous', context).checked = true;
        }

        break;

      case 'month':
        context = monthOptions;

        if (initial.dayOfMonth) {
          getControl(instance, 'month-type-day', context).checked = true;
          getControl(instance, 'month-day', context).value = initial.dayOfMonth;
        } else if (initial.weekNumber && initial.daysOfWeek && initial.daysOfWeek.length === 1) {
          getControl(instance, 'month-type-week', context).checked = true;
          var weekSelect = getControl(instance, 'month-week-number', context);
          var daySelect = getControl(instance, 'month-week-day', context);
          weekSelect.value = initial.weekNumber;
          daySelect.value = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getWeekdayName)(initial.daysOfWeek[0]).toLowerCase();
        } else {
          getControl(instance, 'month-type-previous', context).checked = true;
        }

        break;

      case 'year':
        context = yearOptions;

        if (Number.isInteger(initial.month) && initial.dayOfMonth) {
          getControl(instance, 'year-type-day', context).checked = true;
          var monthSelect = getControl(instance, 'year-month', context);

          var _daySelect = getControl(instance, 'year-day', context);

          monthSelect.value = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getMonthName)(initial.month).toLowerCase();
          _daySelect.value = initial.dayOfMonth;
        } else {
          getControl(instance, 'year-type-previous', context).checked = true;
        }

        break;

      default:
        break;
    }

    if (initial.endDate) {
      getControl(instance, 'end-type-date').checked = true;
      var input = getControl(instance, 'end-date');
      input.value = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.formatDate)(initial.endDate, privates.dateFormat.outputPattern);
    } else if (initial.maxCount) {
      getControl(instance, 'end-type-count').checked = true;
      getControl(instance, 'end-count').value = initial.maxCount;
    } else {
      getControl(instance, 'end-type-never').checked = true;
    }

    if (initial.startDate) {
      getControl(instance, 'use-start-date').checked = true;

      var _input = getControl(instance, 'start-date');

      _input.value = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.formatDate)(initial.startDate, privates.dateFormat.outputPattern);
    }

    if (initial.baseOnCompletion) {
      getControl(instance, 'base-on-completion').checked = true;
    }

    if (initial.onWeekend !== 'no-change') {
      getControl(instance, 'no-weekend').checked = true;
      getControl(instance, 'weekend-select').value = initial.onWeekend;
    }
  }

  var date = privates.baseDate;
  var dayOfWeek = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getWeekdayName)(date.getDay()).toLowerCase();
  var dayOfMonth = date.getDate();
  var month = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getMonthName)(date.getMonth()).toLowerCase();
  var weekNumber = Math.floor((dayOfMonth - 1) / 7) + 1;

  if (!initial || initial.intervalUnit !== 'week' || !initial.daysOfWeek) {
    var dayButton = getControl(instance, "weekday-".concat(dayOfWeek), weekOptions);
    dayButton.classList.add('active');
  }

  if (!initial || initial.intervalUnit !== 'month' || !initial.dayOfMonth) {
    var monthDaySelect = getControl(instance, 'month-day', monthOptions);
    monthDaySelect.value = dayOfMonth.toString();
  }

  if (!initial || initial.intervalUnit !== 'month' || !initial.weekNumber) {
    var monthWeekNumSelect = getControl(instance, 'month-week-number', monthOptions);
    var monthWeekDaySelect = getControl(instance, 'month-week-day', monthOptions);
    monthWeekNumSelect.value = weekNumber.toString();
    monthWeekDaySelect.value = dayOfWeek;
  }

  if (!initial || initial.intervalUnit !== 'year' || !Number.isInteger(initial.month)) {
    var yearMonthSelect = getControl(instance, 'year-month', yearOptions);
    var yearDaySelect = getControl(instance, 'year-day', yearOptions);
    yearMonthSelect.value = month;
    yearDaySelect.value = dayOfMonth.toString();
  }
}
/**
 * Opens a date picker and updates the given input field with the selected
 * date.
 * @param {module:recurrenceModal~RecurrenceModal} instance The class instance
 *   on which to apply the function.
 * @param {HTMLElement} input The text input field where the date is being
 *   entered.
 * @param {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal has been inserted.
 */


function pickDate(instance, input, modalStack) {
  var privates = privateMembers.get(instance);
  var startDate = null;

  if (input.value) {
    startDate = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.parseDate)(input.value, privates.dateFormat.inputPatterns);
  }

  var title = null;

  switch (input.id) {
    case 'recurring-date-start-date':
      title = 'Select Start Date';
      break;

    case 'recurring-date-end-date':
      title = 'Select End Date';
      break;

    default:
      break;
  }

  var field = input;
  modalStack.showModal(new _datePickerModal__WEBPACK_IMPORTED_MODULE_2__["default"]({
    confirm: function confirm(date) {
      field.value = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.formatDate)(date, privates.dateFormat.outputPattern);
      field.setCustomValidity('');
    },
    startDate: startDate,
    title: title
  }));
}
/**
 * Update the contents of the container holding context-sensitive options,
 * based on the selected interval unit.
 * @param {module:recurrenceModal~RecurrenceModal} instance The class instance
 *   on which to apply the function.
 */


function updateContextContainer(instance) {
  var _privateMembers$get = privateMembers.get(instance),
      containers = _privateMembers$get.containers;

  var contextContainer = containers.context;

  while (contextContainer.firstChild) {
    contextContainer.removeChild(contextContainer.firstChild);
  }

  switch (getControl(instance, 'interval-unit').value) {
    case 'week':
      contextContainer.appendChild(containers.weekOptions);
      break;

    case 'month':
      contextContainer.appendChild(containers.monthOptions);
      break;

    case 'year':
      contextContainer.appendChild(containers.yearOptions);
      break;

    default:
      break;
  }
}
/**
 * Add the event listeners to the form controls in the modal.
 * @param {module:recurrenceModal~RecurrenceModal} instance The class instance
 *   on which to apply the function.
 */


function addListeners(instance) {
  var privates = privateMembers.get(instance);
  var parent = privates.containers.parent;

  var fireEvent = function fireEvent(input) {
    return input.dispatchEvent(new Event('change'));
  }; // Make units singular or plural based on length


  var lengthSelect = getControl(instance, 'interval-length');
  var unitSelect = getControl(instance, 'interval-unit');
  lengthSelect.addEventListener('change', function (e) {
    var length = Number(e.target.value);

    if (e.target.value.length > 0 && Number.isFinite(length)) {
      var plural = length !== 1;
      UNITS.forEach(function (unit) {
        var selector = "option[value=\"".concat(unit.value, "\"]");
        var option = unitSelect.querySelector(selector);
        var label = plural ? unit.plural : unit.singular;
        if (option.textContent !== label) option.textContent = label;
      });
    }
  });
  fireEvent(lengthSelect);
  unitSelect.addEventListener('change', function () {
    updateContextContainer(instance);
  });
  fireEvent(unitSelect);
  var radioSelector = 'input[type="radio"]';
  var _privates$containers2 = privates.containers,
      weekOptions = _privates$containers2.weekOptions,
      monthOptions = _privates$containers2.monthOptions,
      yearOptions = _privates$containers2.yearOptions; // Conditionally enable/disable controls for weekly recurrences

  var weekTypeListener = function weekTypeListener(e) {
    var buttons = weekOptions.querySelectorAll('.form-weekday-button');
    var enable = e.target.value === 'select-days';
    buttons.forEach(function (button) {
      var elem = button;
      elem.disabled = !enable;
    });
  };

  weekOptions.querySelectorAll(radioSelector).forEach(function (radio) {
    radio.addEventListener('change', weekTypeListener);
    if (radio.checked) fireEvent(radio);
  }); // Conditionally enable/disable controls for monthly recurrences

  var monthTypeListener = function monthTypeListener(e) {
    var daySelect = getControl(instance, 'month-day', monthOptions);
    var weekNumberSelect = getControl(instance, 'month-week-number', monthOptions);
    var weekDaySelect = getControl(instance, 'month-week-day', monthOptions);
    daySelect.disabled = e.target.value !== 'day-of-month';
    weekNumberSelect.disabled = e.target.value !== 'week-of-month';
    weekDaySelect.disabled = e.target.value !== 'week-of-month';
  };

  monthOptions.querySelectorAll(radioSelector).forEach(function (radio) {
    radio.addEventListener('change', monthTypeListener);
    if (radio.checked) fireEvent(radio);
  }); // Conditionally enable/disable controls for yearly recurrences

  var yearTypeListener = function yearTypeListener(e) {
    var selectBoxes = yearOptions.querySelectorAll('select');
    var enable = e.target.value === 'month-and-day';
    selectBoxes.forEach(function (select) {
      var elem = select;
      elem.disabled = !enable;
    });
  };

  yearOptions.querySelectorAll(radioSelector).forEach(function (radio) {
    radio.addEventListener('change', yearTypeListener);
    if (radio.checked) fireEvent(radio);
  }); // Update day select box based on the number of days in the selected month

  var yearMonthSelect = getControl(instance, 'year-month', yearOptions);
  var yearDaySelect = getControl(instance, 'year-day', yearOptions);

  var yearMonthListener = function yearMonthListener(e) {
    var month = lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(12).findIndex(function (monthIndex) {
      return (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getMonthName)(monthIndex).toLowerCase() === e.target.value;
    });

    var oldValue = Number(yearDaySelect.value);
    yearDaySelect.innerHTML = '';
    var maxDays = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getDaysInMonth)(month);

    lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(1, maxDays + 1).forEach(function (day) {
      var opt = document.createElement('option');
      opt.value = day.toString();
      opt.textContent = ordinal__WEBPACK_IMPORTED_MODULE_1___default()(day);
      yearDaySelect.appendChild(opt);
    });

    if (oldValue <= maxDays) yearDaySelect.value = oldValue;else yearDaySelect.value = maxDays;
  };

  yearMonthSelect.addEventListener('change', yearMonthListener);
  fireEvent(yearMonthSelect); // Make end count label singular/plural based on value

  var endCount = getControl(instance, 'end-count');
  endCount.addEventListener('change', function (e) {
    var count = Number(e.target.value);

    if (e.target.value.length > 0 && Number.isFinite(count)) {
      var label = count === 1 ? ' occurrence' : ' occurrences';
      getControl(instance, 'end-count-label').textContent = label;
    }
  });
  fireEvent(endCount); // Conditionally enable/disable recurrence end controls

  var endRadioSelector = 'input[name="recurring-date-end-type"]';

  var endTypeListener = function endTypeListener(e) {
    var dateInput = getControl(instance, 'end-date');
    var dateButton = getControl(instance, 'end-date-button');
    var countInput = getControl(instance, 'end-count');
    dateInput.disabled = e.target.value !== 'date';
    dateButton.disabled = e.target.value !== 'date';
    countInput.disabled = e.target.value !== 'count';
  };

  parent.querySelectorAll(endRadioSelector).forEach(function (radio) {
    radio.addEventListener('change', endTypeListener);
    if (radio.checked) fireEvent(radio);
  }); // Conditionally enable/disable controls for checkbox options

  var useDateCheckbox = getControl(instance, 'use-start-date');
  useDateCheckbox.addEventListener('change', function (e) {
    var enable = e.target.checked;
    getControl(instance, 'start-date').disabled = !enable;
    getControl(instance, 'start-date-button').disabled = !enable;
  });
  fireEvent(useDateCheckbox);
  var noWeekendCheckbox = getControl(instance, 'no-weekend');
  noWeekendCheckbox.addEventListener('change', function (e) {
    getControl(instance, 'weekend-select').disabled = !e.target.checked;
  });
  fireEvent(noWeekendCheckbox); // Check date validity

  var dateListener = function dateListener(e) {
    var value = e.target.value;

    if (value.length > 0) {
      var message = '';

      if (!(0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.parseDate)(value, privates.dateFormat.inputPatterns)) {
        var format = privates.dateFormat.visualPattern;
        message = "Please enter a valid date in ".concat(format, " format.");
      }

      e.target.setCustomValidity(message);
    }
  };

  getControl(instance, 'end-date').addEventListener('change', dateListener);
  getControl(instance, 'start-date').addEventListener('change', dateListener);
}
/**
 * A modal dialog for selecting a recurring date.
 * @implements {module:modalStack~Modal}
 */


var RecurrenceModal = /*#__PURE__*/function () {
  /**
   * Initialize the modal.
   * @param {Object} [options={}] Holds configuration options for the modal.
   * @param {Function} [options.confirm] A callback function that will be
   *   invoked when the user successfully confirms the modal. The function will
   *   be passed the recurring date that was selected.
   * @param {Function} [options.cancel] A callback function that will be
   *   invoked when the user cancels the modal.
   * @param {module:recurringDate~RecurringDate} [options.initial] A recurring
   *   date to use as a default when initializing the form controls.
   * @param {Date} [options.baseDate] The date to use as a default for
   *   initializing certain fields. If not given, then the present date is
   *   used.
   * @param {module:settings~Settings~dateFormat} [options.dateFormat] An
   *   object holding information about the calendar date format to use for
   *   date fields. If not given, then the browser default is used.
   */
  function RecurrenceModal() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, RecurrenceModal);

    var privates = {
      initialRecurrence: options.initial || null,
      baseDate: options.baseDate || new Date(),
      dateFormat: options.dateFormat || _settings__WEBPACK_IMPORTED_MODULE_4__["default"].lookupDateFormat(),
      callbacks: {
        confirm: options.confirm || null,
        cancel: options.cancel || null
      },
      containers: {
        parent: null,
        context: null,
        weekOptions: null,
        monthOptions: null,
        yearOptions: null
      },
      title: 'Edit Recurring Date'
    };
    privateMembers.set(this, privates);
  }

  _createClass(RecurrenceModal, [{
    key: "title",
    get: function get() {
      return privateMembers.get(this).title;
    }
  }, {
    key: "addContent",
    value: function addContent(parent, modalStack) {
      var _this = this;

      var privates = privateMembers.get(this);
      var container = document.createElement('div');
      container.classList.add('form-input-container');
      container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'number',
        id: 'recurring-date-interval-length',
        name: 'recurring-date-interval-length',
        value: '1',
        classList: ['form-input-inline', 'form-input-count'],
        required: true,
        min: 1,
        container: {
          inline: true
        },
        label: {
          value: 'Repeat every ',
          classList: ['form-input-label-inline']
        }
      }));
      var label = document.createElement('span');
      label.classList.add('form-input-label-inline');
      label.textContent = ' ';
      container.appendChild(label);
      container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'select',
        id: 'recurring-date-interval-unit',
        name: 'recurring-date-interval-unit',
        classList: ['form-select-inline'],
        menuItems: UNITS.map(function (unit) {
          var selected = unit.value === 'week';
          return {
            value: unit.value,
            label: unit.singular,
            selected: selected
          };
        })
      }));
      parent.appendChild(container);
      var contextContainer = document.createElement('div');
      parent.appendChild(contextContainer);
      container = document.createElement('div');
      container.classList.add('form-input-container');
      label = document.createElement('div');
      label.classList.add('form-input-label-inline');
      label.textContent = 'Stop repeating';
      container.appendChild(label);
      container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'radio',
        id: 'recurring-date-end-type-never',
        name: 'recurring-date-end-type',
        value: 'never',
        checked: true,
        label: {
          value: 'Never',
          classList: ['form-input-label-inline']
        },
        container: {
          classList: ['form-input-item-container']
        }
      }));
      var optionContainer = document.createElement('div');
      optionContainer.classList.add('form-input-item-container');
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'radio',
        id: 'recurring-date-end-type-date',
        name: 'recurring-date-end-type',
        value: 'date'
      }));
      label = document.createElement('label');
      label.classList.add('form-input-label-inline');
      label.htmlFor = 'recurring-date-end-type-date';
      label.textContent = 'On date ';
      optionContainer.appendChild(label);
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createDateInputField)({
        id: 'recurring-date-end-date',
        name: 'recurring-date-end-date',
        placeholder: privates.dateFormat.visualPattern,
        classList: ['form-input-inline'],
        required: true,
        container: {
          classList: ['form-input-date-container-inline'],
          inline: true
        },
        button: {
          id: 'recurring-date-end-date-button',
          classList: ['form-button'],
          callback: function callback(input) {
            return pickDate(_this, input, modalStack);
          }
        }
      }));
      container.appendChild(optionContainer);
      optionContainer = document.createElement('div');
      optionContainer.classList.add('form-input-item-container');
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'radio',
        id: 'recurring-date-end-type-count',
        name: 'recurring-date-end-type',
        value: 'count'
      }));
      label = document.createElement('label');
      label.classList.add('form-input-label-inline');
      label.htmlFor = 'recurring-date-end-type-count';
      label.textContent = 'After ';
      optionContainer.appendChild(label);
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'number',
        id: 'recurring-date-end-count',
        name: 'recurring-date-end-count',
        value: '1',
        classList: ['form-input-inline', 'form-input-count'],
        required: true,
        min: 1
      }));
      label = document.createElement('label');
      label.id = 'recurring-date-end-count-label';
      label.classList.add('form-input-label-inline');
      label.htmlFor = 'recurring-date-end-count';
      label.textContent = ' occurrences';
      optionContainer.appendChild(label);
      container.appendChild(optionContainer);
      parent.appendChild(container);
      container = document.createElement('div');
      container.classList.add('form-input-container');
      label = document.createElement('div');
      label.classList.add('form-input-label-inline');
      label.textContent = 'Additional options:';
      container.appendChild(label);
      optionContainer = document.createElement('div');
      optionContainer.classList.add('form-input-item-container');
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'checkbox',
        id: 'recurring-date-use-start-date',
        name: 'recurring-date-additional-options',
        value: 'use-start-date'
      }));
      label = document.createElement('label');
      label.classList.add('form-input-label-inline');
      label.htmlFor = 'recurring-date-use-start-date';
      label.textContent = 'Start on ';
      optionContainer.appendChild(label);
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createDateInputField)({
        id: 'recurring-date-start-date',
        name: 'recurring-date-start-date',
        placeholder: privates.dateFormat.visualPattern,
        classList: ['form-input-inline'],
        required: true,
        container: {
          classList: ['form-input-date-container-inline'],
          inline: true
        },
        button: {
          id: 'recurring-date-start-date-button',
          classList: ['form-button'],
          callback: function callback(input) {
            return pickDate(_this, input, modalStack);
          }
        }
      }));
      container.appendChild(optionContainer);
      container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'checkbox',
        id: 'recurring-date-base-on-completion',
        name: 'recurring-date-additional-options',
        value: 'base-on-completion',
        label: {
          value: 'Repeat from completion date',
          classList: ['form-input-label-inline']
        },
        container: {
          classList: ['form-input-item-container']
        }
      }));
      optionContainer = document.createElement('div');
      optionContainer.classList.add('form-input-item-container');
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'checkbox',
        id: 'recurring-date-no-weekend',
        name: 'recurring-date-additional-options',
        value: 'no-weekend'
      }));
      label = document.createElement('label');
      label.classList.add('form-input-label-inline');
      label.htmlFor = 'recurring-date-no-weekend';
      label.textContent = 'On weekends, use ';
      optionContainer.appendChild(label);
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_6__.createFormControl)({
        type: 'select',
        id: 'recurring-date-weekend-select',
        name: 'recurring-date-weekend-select',
        classList: ['form-select-inline'],
        menuItems: [{
          value: 'nearest-weekday',
          label: 'nearest',
          selected: true
        }, {
          value: 'previous-weekday',
          label: 'previous'
        }, {
          value: 'next-weekday',
          label: 'next'
        }]
      }));
      label = document.createElement('label');
      label.classList.add('form-input-label-inline');
      label.htmlFor = 'recurring-date-weekend-select';
      label.textContent = ' weekday';
      optionContainer.appendChild(label);
      container.appendChild(optionContainer);
      parent.appendChild(container);
      var weekOptions = createWeekContextForm();
      var monthOptions = createMonthContextForm();
      var yearOptions = createYearContextForm();
      privates.containers = {
        parent: parent,
        context: contextContainer,
        weekOptions: weekOptions,
        monthOptions: monthOptions,
        yearOptions: yearOptions
      };
      initFormValues(this);
      addListeners(this);
    }
  }, {
    key: "confirm",
    value: function confirm() {
      var privates = privateMembers.get(this);

      if (privates.callbacks.confirm) {
        var unit = getControl(this, 'interval-unit').value;
        var options = {};
        var lengthInput = getControl(this, 'interval-length');
        options.intervalLength = Number(lengthInput.value);
        var context;

        var getDayIndex = function getDayIndex(day) {
          return lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(7).findIndex(function (dayIndex) {
            return day === (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getWeekdayName)(dayIndex).toLowerCase();
          });
        };

        switch (unit) {
          case 'week':
            context = privates.containers.weekOptions;

            if (getControl(this, 'week-type-select-days', context).checked) {
              var daysOfWeek = [];
              context.querySelectorAll('.form-weekday-button').forEach(function (button) {
                if (button.classList.contains('active')) {
                  daysOfWeek.push(getDayIndex(button.value));
                }
              });
              if (daysOfWeek.length > 0) options.daysOfWeek = daysOfWeek;
            }

            break;

          case 'month':
            context = privates.containers.monthOptions;

            if (getControl(this, 'month-type-day', context).checked) {
              var daySelect = getControl(this, 'month-day', context);
              options.dayOfMonth = Number(daySelect.value);
            } else if (getControl(this, 'month-type-week', context).checked) {
              var weekSelect = getControl(this, 'month-week-number', context);

              var _daySelect2 = getControl(this, 'month-week-day', context);

              options.weekNumber = Number(weekSelect.value);
              options.daysOfWeek = [getDayIndex(_daySelect2.value)];
            }

            break;

          case 'year':
            context = privates.containers.yearOptions;

            if (getControl(this, 'year-type-day', context).checked) {
              var monthSelect = getControl(this, 'year-month', context);

              var _daySelect3 = getControl(this, 'year-day', context);

              options.month = lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(12).findIndex(function (monthIndex) {
                return (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.getMonthName)(monthIndex).toLowerCase() === monthSelect.value;
              });
              options.dayOfMonth = Number(_daySelect3.value);
            }

            break;

          default:
            break;
        }

        if (getControl(this, 'end-type-date').checked) {
          var input = getControl(this, 'end-date');
          options.endDate = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.parseDate)(input.value, privates.dateFormat.inputPatterns);
        } else if (getControl(this, 'end-type-count').checked) {
          var _input2 = getControl(this, 'end-count');

          options.maxCount = Number(_input2.value);
        }

        if (getControl(this, 'use-start-date').checked) {
          var _input3 = getControl(this, 'start-date');

          options.startDate = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_5__.parseDate)(_input3.value, privates.dateFormat.inputPatterns);
        }

        options.baseOnCompletion = getControl(this, 'base-on-completion').checked;

        if (getControl(this, 'no-weekend').checked) {
          options.onWeekend = getControl(this, 'weekend-select').value;
        }

        privates.callbacks.confirm(new _recurringDate__WEBPACK_IMPORTED_MODULE_3__["default"](unit, options));
      }
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var _privateMembers$get2 = privateMembers.get(this),
          callbacks = _privateMembers$get2.callbacks;

      if (callbacks.cancel) callbacks.cancel();
    }
  }, {
    key: "validate",
    value: function validate() {
      if (!getControl(this, 'interval-length').reportValidity()) return false;

      if (getControl(this, 'end-type-date').checked) {
        if (!getControl(this, 'end-date').reportValidity()) return false;
      }

      if (getControl(this, 'end-type-count').checked) {
        if (!getControl(this, 'end-count').reportValidity()) return false;
      }

      if (getControl(this, 'use-start-date').checked) {
        if (!getControl(this, 'start-date').reportValidity()) return false;
      }

      return true;
    }
  }]);

  return RecurrenceModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (RecurrenceModal);

/***/ }),

/***/ "./src/modules/modals/settingsModal.js":
/*!*********************************************!*\
  !*** ./src/modules/modals/settingsModal.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _confirmModal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./confirmModal */ "./src/modules/modals/confirmModal.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings */ "./src/modules/settings.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utility/dom */ "./src/modules/utility/dom.js");
/* harmony import */ var _utility_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utility/storage */ "./src/modules/utility/storage.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [SettingsModal]{@link module:settingsModal~SettingsModal} class.
 * @module settingsModal
 */




/**
 * Object holding private members for the
 * [SettingsModal]{@link module:settingsModal~SettingsModal} class.
 * @typedef {Object} module:settingsModal~SettingsModal~privates
 * @property {module:settings~Settings} settings The app settings being
 *   modified.
 * @property {module:modalStack~ModalStack} modalStack The modal stack in which
 *   the modal was inserted.
 * @property {boolean} confirmNoStorage If true, then the user should be asked
 *   for confirmation when disabling local storage.
 * @property {Object} callbacks An object holding callback functions.
 * @property {Function} [callbacks.confirm] A callback function that will be
 *   invoked when the user successfully confirms the modal.
 * @property {Function} [callbacks.cancel] A callback function that will be
 *   invoked when the user cancels the modal.
 * @property {Object} [controls] An object holding the form input elements for
 *   the modal.
 * @property {HTMLElement} controls.saveLocal The radio button element for
 *   indicating that data should be saved to local storage.
 * @property {HTMLElement} controls.saveNever The radio button element for
 *   indicating that data should not be saved.
 * @property {HTMLElement} controls.dateFormat The select element for the date
 *   format.
 * @property {HTMLElement} controls.deleteOld The checkbox element indicating
 *   whether to delete old completed tasks.
 * @property {HTMLElement} controls.deleteAfter The input element for entering
 *   the number of days after which to delete completed tasks.
 * @property {HTMLElement} controls.deleteAfterLabel The label element for the
 *   deleteAfter control.
 */

/**
 * Holds private data for the
 * [SettingsModal]{@link module:settingsModal~SettingsModal} class.
 * @type {WeakMap}
 * @see module:settingsModal~SettingsModal~privates
 */

var privateMembers = new WeakMap();
/**
 * Initialize the values of the form elements based on current settings.
 * @param {module:settingsModal~SettingsModal} instance The class instance on
 *   which to apply the function.
 */

function initFormValues(instance) {
  var privates = privateMembers.get(instance);
  var controls = privates.controls,
      settings = privates.settings;

  switch (settings.storageMethod) {
    case 'none':
      privates.confirmNoStorage = false;
      controls.saveNever.checked = true;
      break;

    case 'local':
    default:
      privates.confirmNoStorage = true;
      controls.saveLocal.checked = true;
      break;
  }

  controls.dateFormat.value = settings.dateFormat.type;
  var deleteOld = settings.deleteAfter !== null;
  controls.deleteOld.checked = deleteOld;
  if (deleteOld) controls.deleteAfter.value = settings.deleteAfter.toString(); // Disable storage options if local storage is unsupported or disabled

  if (!(0,_utility_storage__WEBPACK_IMPORTED_MODULE_3__.isLocalStorageSupported)()) {
    controls.saveNever.disabled = true;
    controls.saveLocal.disabled = true;
  }
}
/**
 * Add the event listeners to the form controls in the modal.
 * @param {module:settingsModal~SettingsModal} instance The class instance on
 *   which to apply the function.
 */


function addListeners(instance) {
  var _privateMembers$get = privateMembers.get(instance),
      controls = _privateMembers$get.controls;

  var fireEvent = function fireEvent(input) {
    return input.dispatchEvent(new Event('change'));
  };

  controls.deleteOld.addEventListener('change', function (e) {
    controls.deleteAfter.disabled = !e.target.checked;
  });
  fireEvent(controls.deleteOld); // Make delete-after label singular/plural based on value

  controls.deleteAfter.addEventListener('change', function (e) {
    var count = Number(e.target.value);

    if (e.target.value.length > 0 && Number.isFinite(count)) {
      var label = count === 1 ? ' day' : ' days';
      controls.deleteAfterLabel.textContent = label;
    }
  });
  fireEvent(controls.deleteAfter);
}
/**
 * A modal dialog for modifying user settings.
 * @implements {module:modalStack~Modal}
 */


var SettingsModal = /*#__PURE__*/function () {
  /**
   * Specifies options for the modal.
   * @typedef {Object} module:settingsModal~SettingsModal~options
   * @property {Function} [confirm] A callback function that will be invoked
   *   when the user successfully confirms the modal. The function will be
   *   passed a reference to the modified [Settings]{module:settings~Settings}
   *   instance.
   * @property {Function} [cancel] A callback function that will be invoked
   *   when the user cancels the modal.
   */

  /**
   * Initialize the modal.
   * @param {module:settings~Settings} settings The app settings being
   *   modified.
   * @param {module:settingsModal~SettingsModal~options} [options={}] Holds
   *   configuration options for the modal.
   */
  function SettingsModal(settings) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, SettingsModal);

    var privates = {
      settings: settings,
      modalStack: null,
      confirmNoStorage: true,
      callbacks: {
        confirm: options.confirm || null,
        cancel: options.cancel || null
      },
      controls: {
        saveLocal: null,
        saveNever: null,
        dateFormat: null,
        deleteOld: null,
        deleteAfter: null,
        deleteAfterLabel: null
      }
    };
    privateMembers.set(this, privates);
  }
  /* eslint-disable-next-line class-methods-use-this --
   * Need to set title to conform to Modal interface, but setting property
   * directly in constructor would allow external modification.
   */


  _createClass(SettingsModal, [{
    key: "title",
    get: function get() {
      return 'Edit Settings';
    }
  }, {
    key: "addContent",
    value: function addContent(parent, modalStack) {
      var container = document.createElement('div');
      container.classList.add('form-input-container');
      var label = document.createElement('div');
      label.classList.add('form-input-label');
      label.textContent = 'Data Storage';
      container.appendChild(label);
      container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_2__.createFormControl)({
        type: 'radio',
        id: 'settings-save-local',
        name: 'settings-save-method',
        value: 'local',
        label: {
          value: 'Save data in browser\'s local storage area',
          classList: ['form-input-label-inline']
        },
        container: {
          classList: ['form-input-item-container']
        }
      }));
      container.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_2__.createFormControl)({
        type: 'radio',
        id: 'settings-save-never',
        name: 'settings-save-method',
        value: 'never',
        label: {
          value: 'Do not save data',
          classList: ['form-input-label-inline']
        },
        container: {
          classList: ['form-input-item-container']
        }
      }));
      parent.appendChild(container);
      var dateFormats = ['local', 'iso', 'month-day-year', 'day-month-year', 'year-month-day'].map(function (value) {
        var format = _settings__WEBPACK_IMPORTED_MODULE_1__["default"].lookupDateFormat(value).visualPattern;
        var description;

        switch (value) {
          case 'local':
            description = 'Local Format';
            break;

          case 'iso':
            description = 'ISO';
            break;

          case 'month-day-year':
            description = 'Month/Day/Year';
            break;

          case 'day-month-year':
            description = 'Day/Month/Year';
            break;

          case 'year-month-day':
            description = 'Year/Month/Day';
            break;

          default:
            break;
        }

        return {
          value: value,
          label: "".concat(description, ": ").concat(format)
        };
      });
      parent.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_2__.createFormControl)({
        type: 'select',
        id: 'settings-date-format',
        name: 'settings-date-format',
        classList: ['form-select'],
        label: {
          value: 'Date Format',
          classList: ['form-input-label']
        },
        container: {
          classList: ['form-input-container']
        },
        menuItems: dateFormats
      }));
      container = document.createElement('div');
      container.classList.add('form-input-container');
      label = document.createElement('div');
      label.classList.add('form-input-label');
      label.textContent = 'Additional Options';
      container.appendChild(label);
      var optionContainer = document.createElement('div');
      optionContainer.classList.add('form-input-item-container');
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_2__.createFormControl)({
        type: 'checkbox',
        id: 'settings-delete-old-tasks',
        name: 'settings-delete-tasks',
        value: 'delete-old'
      }));
      label = document.createElement('label');
      label.classList.add('form-input-label-inline');
      label.htmlFor = 'settings-delete-old-tasks';
      label.textContent = 'Delete completed tasks after ';
      optionContainer.appendChild(label);
      optionContainer.appendChild((0,_utility_dom__WEBPACK_IMPORTED_MODULE_2__.createFormControl)({
        type: 'number',
        id: 'settings-delete-after',
        name: 'settings-delete-after',
        value: '14',
        classList: ['form-input-inline', 'form-input-count'],
        required: true,
        min: 0
      }));
      label = document.createElement('label');
      label.id = 'settings-delete-after-label';
      label.classList.add('form-input-label-inline');
      label.htmlFor = 'settings-delete-after';
      label.textContent = ' days';
      optionContainer.appendChild(label);
      container.appendChild(optionContainer);
      parent.appendChild(container);
      var privates = privateMembers.get(this);
      privates.modalStack = modalStack;
      var controls = privates.controls;
      controls.saveLocal = parent.querySelector('#settings-save-local');
      controls.saveNever = parent.querySelector('#settings-save-never');
      controls.dateFormat = parent.querySelector('#settings-date-format');
      controls.deleteOld = parent.querySelector('#settings-delete-old-tasks');
      controls.deleteAfter = parent.querySelector('#settings-delete-after');
      controls.deleteAfterLabel = parent.querySelector('#settings-delete-after-label');
      initFormValues(this);
      addListeners(this);
    }
  }, {
    key: "confirm",
    value: function confirm() {
      var _privateMembers$get2 = privateMembers.get(this),
          callbacks = _privateMembers$get2.callbacks,
          controls = _privateMembers$get2.controls,
          settings = _privateMembers$get2.settings;

      if (!controls.saveLocal.disabled) {
        settings.storageMethod = controls.saveLocal.checked ? 'local' : 'none';
      }

      settings.setDateFormat(controls.dateFormat.value);

      if (controls.deleteOld.checked) {
        settings.deleteAfter = Number(controls.deleteAfter.value);
      } else {
        settings.deleteAfter = null;
      }

      if (callbacks.confirm) callbacks.confirm(settings);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var _privateMembers$get3 = privateMembers.get(this),
          callbacks = _privateMembers$get3.callbacks;

      if (callbacks.cancel) callbacks.cancel();
    }
  }, {
    key: "validate",
    value: function validate() {
      var privates = privateMembers.get(this);
      var controls = privates.controls,
          modalStack = privates.modalStack;

      if (controls.deleteOld.checked) {
        if (!controls.deleteAfter.reportValidity()) return false;
      } // Ask for confirmation when disabling local storage


      if (privates.confirmNoStorage && !controls.saveNever.disabled && controls.saveNever.checked) {
        var modal = new _confirmModal__WEBPACK_IMPORTED_MODULE_0__["default"]('Are you sure you want to disable local storage? Your data will not be saved in the browser and will be lost after you leave this page.', {
          confirm: function confirm() {
            privates.confirmNoStorage = false; // Close settings modal
            // Using setTimeout will let us wait for the confirm modal to close

            setTimeout(function () {
              return modalStack.confirmModal();
            });
          },
          cancel: function cancel() {
            controls.saveLocal.checked = true;
          }
        });
        modalStack.showModal(modal);
        return false;
      }

      return true;
    }
  }]);

  return SettingsModal;
}();

/* harmony default export */ __webpack_exports__["default"] = (SettingsModal);

/***/ }),

/***/ "./src/modules/popupMenu.js":
/*!**********************************!*\
  !*** ./src/modules/popupMenu.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [PopupMenu]{@link module:popupMenu~PopupMenu} class.
 * @module popupMenu
 */

/**
 * Object holding private members for the
 * [PopupMenu]{@link module:popupMenu~PopupMenu} class.
 * @typedef {Object} module:popupMenu~PopupMenu~privates
 * @property {HTMLElement} parent The parent element in the DOM under which the
 *   popup menu should be inserted.
 * @property {module:popupMenu~PopupMenu~menuItem[]} menuItems An array of
 *   objects specifying the items in the menu.
 * @property {number} [activeItem] Holds the index of the active (focused) menu
 *   item, if any.
 * @property {HTMLElement} [container] The container element holding the menu.
 *   Will be null when the menu is hidden.
 * @property {HTMLElement} [overlay] The element that will overlay the
 *   background of the menu. Will be null when the menu is hidden.
 * @property {module:popupMenu~PopupMenu~selectionCallback} [callback] Holds
 *   the function to be invoked when the user selects a menu item. This will be
 *   null when the menu is closed.
 * @property {Function} eventListener An event listener to monitor
 *   document-wide mouse and keyboard events. Needs to be stored so that it can
 *   be later removed.
 * @property {number} [scrollTimeout] An identifier for a timeout used to
 *   debounce scroll events for better performance.
 * @property {HTMLElement} [scrollTarget] An element to monitor for scroll
 *   events. If the element is scrolled, then the popup menu will be closed.
 */

/**
 * Holds private data for the [PopupMenu]{@link module:popupMenu~PopupMenu}
 * class.
 * @type {WeakMap}
 * @see module:popupMenu~PopupMenu~privates
 */
var privateMembers = new WeakMap();
/**
 * Position the popup menu at a particular location.
 * @param {module:popupMenu~PopupMenu} instance The class instance on which to
 *   apply the function.
 * @param {module:popupMenu~PopupMenu~position} [position={}] An object
 *   specifying the position in the document at which to place the menu.
 */

function positionMenu(instance) {
  var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _privateMembers$get = privateMembers.get(instance),
      container = _privateMembers$get.container;

  var width = container.offsetWidth;
  var height = container.offsetHeight;
  var left = 0;
  var top = 0;

  if (position.referenceElement) {
    var rect = position.referenceElement.getBoundingClientRect();
    left = rect.left;
    top = rect.top + rect.height;
  } else {
    if ('left' in position) left = position.left;
    if ('top' in position) top = position.top;
  }

  var MARGIN = 4;
  var bodyWidth = document.body.offsetWidth;
  var bodyHeight = document.body.offsetHeight;
  if (left + width + MARGIN > bodyWidth) left = bodyWidth - (width + MARGIN);
  if (top + height + MARGIN > bodyHeight) top = bodyHeight - (height + MARGIN);
  if (left < 0) left = 0;
  if (top < 0) top = 0;
  container.style.left = "".concat(left, "px");
  container.style.top = "".concat(top, "px");
}
/**
 * Select an item in the menu.
 * @param {module:popupMenu~PopupMenu} instance The class instance on which to
 *   apply the function.
 * @param {number} index The index of the menu item.
 */


function selectItem(instance, index) {
  var privates = privateMembers.get(instance);
  privates.callback(privates.menuItems[index].id, index);
  instance.close();
}
/**
 * Get the list item HTML element for a menu item.
 * @param {module:popupMenu~PopupMenu} instance The class instance on which to
 *   apply the function.
 * @param {number} index The index of the menu item to find.
 * @returns {?HTMLElement} The list item element if it exists, or null if it
 *   does not.
 */


function getItem(instance, index) {
  var selector = ".popup-menu-item[data-index=\"".concat(index, "\"]");
  return privateMembers.get(instance).container.querySelector(selector);
}
/**
 * Focus an item in the menu.
 * @param {module:popupMenu~PopupMenu} instance The class instance on which to
 *   apply the function.
 * @param {?number} index The index of the menu item to focus. If set to null,
 *   then no focus will be set and any existing focus is cleared.
 */


function focusItem(instance, index) {
  var privates = privateMembers.get(instance);
  if (index === privates.activeItem) return;

  if (privates.activeItem !== null) {
    var item = getItem(instance, privates.activeItem);
    if (item) item.classList.remove('active');
    privates.activeItem = null;
  }

  if (typeof index === 'number') {
    var _item = getItem(instance, index);

    if (_item) {
      privates.activeItem = index;

      _item.classList.add('active');
    }
  }
}
/**
 * Handle a mouse or keyboard event.
 * @param {module:popupMenu~PopupMenu} instance The class instance on which to
 *   apply the function.
 * @param {Event} event An object describing the event that occurred.
 */


function handleEvent(instance, event) {
  var privates = privateMembers.get(instance);

  switch (event.type) {
    case 'mousedown':
      // Close popup if mouse was clicked outside
      if (!privates.container.contains(event.target)) instance.close();
      break;

    case 'keydown':
      {
        var preventDefault = true;

        switch (event.key) {
          case 'Escape':
          case 'Esc':
          case 'Tab':
            instance.close();
            break;

          case 'Enter':
          case ' ':
          case 'Spacebar':
            if (privates.activeItem !== null) {
              selectItem(instance, privates.activeItem);
            }

            break;

          case 'ArrowUp':
          case 'Up':
            {
              var active = privates.activeItem;
              var itemCount = privates.menuItems.length;
              var index = null;
              if (active !== null) index = active > 0 ? active - 1 : itemCount - 1;else if (itemCount > 0) index = itemCount - 1;
              focusItem(instance, index);
              break;
            }

          case 'ArrowDown':
          case 'Down':
            {
              var _active = privates.activeItem;
              var _itemCount = privates.menuItems.length;
              var _index = null;
              if (_active !== null) _index = _active < _itemCount - 1 ? _active + 1 : 0;else if (_itemCount > 0) _index = 0;
              focusItem(instance, _index);
              break;
            }

          default:
            preventDefault = false;
            break;
        }

        if (preventDefault) event.preventDefault();
        break;
      }

    case 'scroll':
      {
        if (privates.scrollTimeout) clearTimeout(privates.scrollTimeout);
        privates.scrollTimeout = setTimeout(function () {
          privates.scrollTimeout = null;
          if (event.target.contains(privates.scrollTarget)) instance.close();
        }, 100);
        break;
      }

    default:
      break;
  }
}
/**
 * A popup menu.
 */


var PopupMenu = /*#__PURE__*/function () {
  /**
   * An object holding configuration options for the popup menu.
   * @typedef {Object} module:popupMenu~PopupMenu~options
   * @property {HTMLElement} [parent=document.body] The parent element in the
   *   DOM under which the popup should be inserted.
   * @property {module:popupMenu~PopupMenu~menuItem[]} [menuItems] An array of
   *   objects specifying the items in the menu.
   * @property {HTMLElement} [closeIfScrolled] If provided, the popup menu will
   *   be closed when the given element or one of its ancestors is scrolled.
   */

  /**
   * A menu item in the popup.
   * @typedef {Object} module:popupMenu~PopupMenu~menuItem
   * @property {string} label The text label that will be displayed in the
   *   menu.
   * @property {string} id An identifier for the menu item. This will be passed
   *   to callbacks.
   * @property {string} [iconType] The type of icon to display. This indicates
   *   the icon to use from the Google Material Icons font.
   */

  /**
   * An object describing how the popup should be positioned.
   * @typedef {Object} module:popupMenu~PopupMenu~position
   * @property {number} [left=0] The position of the left side of the popup, in
   *   pixels, relative to the left edge of the document. This property is
   *   ignored if the referenceElement property is set.
   * @property {number} [top=0] The position of the top of the popup, in
   *   pixels, relative to the top of the document. This property is ignored if
   *   the referenceElement property is set.
   * @property {HTMLElement} [referenceElement] An element in the DOM whose
   *   position is to be used for determining the position of the popup. If
   *   given, the popup will be positioned just underneath the element.
   */

  /**
   * A callback function that will be invoked when the user selects a menu
   * item.
   * @callback module:popupMenu~PopupMenu~selectionCallback
   * @param itemId The identifier of the menu item that was selected.
   * @param index The index of the menu item that was selected.
   */

  /**
   * Create a popup menu.
   * @param {module:popupMenu~PopupMenu~options} [options={}] An object holding
   *   additional options for the popup menu.
   */
  function PopupMenu() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PopupMenu);

    var privates = {
      parent: options.parent || document.body,
      menuItems: options.menuItems || [],
      activeItem: null,
      container: null,
      overlay: null,
      callback: null,
      eventListener: function eventListener(e) {
        return handleEvent(_this, e);
      },
      scrollTimeout: null,
      scrollTarget: options.closeIfScrolled || null
    };
    privateMembers.set(this, privates);
  }
  /**
   * Determine whether or not the popup menu is currently open.
   * @returns {boolean} True if the popup menu is open, or false if it is
   *   closed.
   */


  _createClass(PopupMenu, [{
    key: "isOpen",
    value: function isOpen() {
      return privateMembers.get(this).container !== null;
    }
    /**
     * Open the popup menu at a particular position.
     * @param {module:popupMenu~PopupMenu~selectionCallback} callback A callback
     *   function that will be invoked when the user chooses a menu item.
     * @param {module:popupMenu~PopupMenu~position} [position] An object
     *   specifying the position in the document at which to place the menu. If
     *   not given, the upper-left corner of the document will be used.
     */

  }, {
    key: "open",
    value: function open(callback, position) {
      var _this2 = this;

      var privates = privateMembers.get(this);
      if (privates.container) this.close();
      if (privates.menuItems.length === 0) return;
      var overlay = document.createElement('div');
      overlay.classList.add('popup-menu-overlay');
      privates.parent.appendChild(overlay);
      privates.overlay = overlay;
      var menu = document.createElement('div');
      menu.classList.add('popup-menu');
      var list = document.createElement('ul');
      menu.appendChild(list);
      privates.menuItems.forEach(function (item, index) {
        var listItem = document.createElement('li');
        listItem.classList.add('popup-menu-item');
        listItem.dataset.index = index.toString();
        list.appendChild(listItem);
        var icon = document.createElement('div');
        icon.classList.add('icon', 'material-icons', 'popup-menu-item-icon');
        icon.textContent = item.iconType;
        listItem.appendChild(icon);
        var label = document.createElement('div');
        label.classList.add('popup-menu-item-label');
        label.textContent = item.label;
        listItem.appendChild(label);
        listItem.addEventListener('click', function () {
          return selectItem(_this2, index);
        });
        listItem.addEventListener('mousemove', function () {
          return focusItem(_this2, index);
        });
      });
      menu.addEventListener('mouseleave', function () {
        return focusItem(_this2, null);
      });
      privates.container = menu;
      privates.parent.appendChild(menu);
      privates.callback = callback;
      positionMenu(this, position);
      document.addEventListener('mousedown', privates.eventListener);
      document.addEventListener('keydown', privates.eventListener);

      if (privates.scrollTarget) {
        document.addEventListener('scroll', privates.eventListener, true);
      }
    }
    /**
     * Close the popup menu if it is open.
     */

  }, {
    key: "close",
    value: function close() {
      var privates = privateMembers.get(this);

      if (privates.container) {
        privates.parent.removeChild(privates.container);
        privates.parent.removeChild(privates.overlay);
        privates.activeItem = null;
        privates.container = null;
        privates.overlay = null;
        privates.callback = null;
        document.removeEventListener('mousedown', privates.eventListener);
        document.removeEventListener('keydown', privates.eventListener);

        if (privates.scrollTarget) {
          document.removeEventListener('scroll', privates.eventListener, true);
        }
      }
    }
    /**
     * Toggle the state of the popup: if the menu is closed, it will be opened.
     * If the menu is open, it will be closed.
     * @param {module:popupMenu~PopupMenu~selectionCallback} callback A callback
     *   function that will be invoked when the user chooses a menu item.
     * @param {module:popupMenu~PopupMenu~position} [position] An object
     *   specifying the position in the document at which to place the menu. If
     *   not given, the upper-left corner of the document will be used.
     */

  }, {
    key: "toggle",
    value: function toggle(callback, position) {
      if (this.isOpen()) this.close();else this.open(callback, position);
    }
    /**
     * Set the menu items that will be shown the next time the popup menu is
     * opened. If the popup menu is currently open, the displayed items will not
     * be altered until the menu is reopened.
     * @param {module:popupMenu~PopupMenu~menuItem[]} menuItems The array of menu
     *   items.
     */

  }, {
    key: "setMenuItems",
    value: function setMenuItems(menuItems) {
      privateMembers.get(this).menuItems = menuItems;
    }
  }]);

  return PopupMenu;
}();

/* harmony default export */ __webpack_exports__["default"] = (PopupMenu);

/***/ }),

/***/ "./src/modules/project.js":
/*!********************************!*\
  !*** ./src/modules/project.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [Project]{@link module:project~Project} class.
 * @module project
 */

/**
 * Holds information about a user project.
 */
var Project = /*#__PURE__*/function () {
  /**
   * Create a project.
   * @param {string} name The name of the project.
   * @param {Object} [options={}] An object holding additional project options.
   * @param {string} [options.description] A description for the project.
   */
  function Project(name) {
    var _options$description;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Project);

    /**
     * The name of the project.
     * @type {string}
     */
    this.name = name;
    /**
     * A description for the project.
     * @type {?string}
     */

    this.description = (_options$description = options.description) !== null && _options$description !== void 0 ? _options$description : null;
  }
  /**
   * Create a project from a JSON object.
   * @param {Object} data The JSON object holding the serialized data.
   * @returns {module:project~Project} A new project converted from the JSON
   *   data.
   */


  _createClass(Project, null, [{
    key: "fromJson",
    value: function fromJson(data) {
      return new Project(data.name, {
        description: data.description
      });
    }
  }]);

  return Project;
}();

/* harmony default export */ __webpack_exports__["default"] = (Project);

/***/ }),

/***/ "./src/modules/projectList.js":
/*!************************************!*\
  !*** ./src/modules/projectList.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash_uniqWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/uniqWith */ "./node_modules/lodash/uniqWith.js");
/* harmony import */ var lodash_uniqWith__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_uniqWith__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_sortedIndexBy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/sortedIndexBy */ "./node_modules/lodash/sortedIndexBy.js");
/* harmony import */ var lodash_sortedIndexBy__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_sortedIndexBy__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./project */ "./src/modules/project.js");
/* harmony import */ var _utility_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utility/data */ "./src/modules/utility/data.js");





function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [ProjectList]{@link module:projectList~ProjectList} class.
 * @module projectList
 */




/**
 * Object holding private members for the
 * [ProjectList]{@link module:projectList~ProjectList} class.
 * @typedef {Object} module:projectList~ProjectList~privates
 * @property {module:projectList~ProjectList~projectWrapper[]} projects An
 *   array of projects. Each element in the array is a wrapper that holds the
 *   project along with its unique identifier.
 * @property {module:projectList~ProjectList~eventEmitter} Holds the event
 *   emitter which dispatches events to attached listeners.
 */

/**
 * Holds private data for the
 * [ProjectList]{@link module:projectList~ProjectList} class.
 * @type {WeakMap}
 * @see module:projectList~ProjectList~privates
 */

var privateMembers = new WeakMap();
/**
 * Get a project's index in the project list.
 * @param {module:projectList~ProjectList} instance The class instance on which
 *   to apply the function.
 * @param {string} id The identifier for the project to look up.
 * @returns {number} The index of the project, or -1 if not found.
 */

function findIndex(instance, id) {
  return privateMembers.get(instance).projects.findIndex(function (entry) {
    return entry.id === id;
  });
}
/**
 * Holds a list of projects.
 */


var ProjectList = /*#__PURE__*/function () {
  /**
   * Wrapper object holding a project along with its UUID.
   * @typedef {Object} module:projectList~ProjectList~projectWrapper
   * @property {string} id The unique identifier for the project.
   * @property {module:project~Project} project The project instance.
   */

  /**
   * Event that is fired when a project is added to the project list.
   * @event module:projectList~ProjectList~addProject
   * @type {Object}
   * @property {string} type The event type: 'add-project'.
   * @property {string} id The unique identifier of the newly-added project.
   * @property {module:project~Project} project A copy of the newly-added
   *   project.
   */

  /**
   * Event that is fired when a project in the list is modified.
   * @event module:projectList~ProjectList~updateProject
   * @type {Object}
   * @property {string} type The event type: 'update-project'.
   * @property {string} id The unique identifier for the updated project.
   * @property {module:project~Project} project A copy of the updated project.
   */

  /**
   * Event that is fired when a project in the list is deleted.
   * @event module:projectList~ProjectList~deleteProject
   * @type {Object}
   * @property {string} type The event type: 'delete-project'.
   * @property {string} id The unique identifier for the deleted project.
   * @property {module:project~Project} project A copy of the deleted project.
   */

  /**
   * An object holding information about the status of a data import.
   * @typedef {Object} module:projectList~ProjectList~importStatus
   * @property {Object} projects An object holding information about the number
   *   of projects that were imported.
   * @property {number} projects.added The number of new projects that were
   *   added to the project list.
   * @property {number} projects.updated The number of existing projects in the
   *   project list that were updated.
   * @property {number} projects.failed The number of projects that failed to
   *   import.
   * @property {number} projects.total The total number of projects that were
   *   processed.
   * @property {string[]} errors An array of error messages describing any
   *   errors that occurred during the import.
   */

  /**
   * Create a project list.
   */
  function ProjectList() {
    _classCallCheck(this, ProjectList);

    var privates = {
      projects: [],
      eventEmitter: new (events__WEBPACK_IMPORTED_MODULE_4___default())()
    };
    privateMembers.set(this, privates);
  }
  /**
   * Get a project in the project list. This method only returns a copy of the
   * project, not an actual reference to the project itself. To modify a
   * project in the list, use the
   * [updateProject]{@link module:projectList~ProjectList#updateProject}
   * method.
   * @param {string} id The unique identifier of the project to retrieve.
   * @returns {?module:project~Project} The requested project, or undefined if
   *   it could not be found.
   */


  _createClass(ProjectList, [{
    key: "getProject",
    value: function getProject(id) {
      var index = findIndex(this, id);
      if (index < 0) return undefined;
      return lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(privateMembers.get(this).projects[index].project);
    }
    /**
     * Update a project in the project list.
     * @param {string} id The unique identifier of the project to replace.
     * @param {module:project~Project} project The new project to associate with
     *   the given identifier.
     * @returns {boolean} Returns true if the project was replaced successfully,
     *   or false if the given identifier is invalid.
     * @fires module:projectList~ProjectList~updateProject
     */

  }, {
    key: "updateProject",
    value: function updateProject(id, project) {
      var index = findIndex(this, id);
      if (index < 0) return false;
      var privates = privateMembers.get(this);
      var wrapper = privates.projects[index];
      var needSort = project.name !== wrapper.project.name;
      wrapper.project = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(project);

      if (needSort) {
        privates.projects.splice(index, 1);

        var insertAt = lodash_sortedIndexBy__WEBPACK_IMPORTED_MODULE_2___default()(privates.projects, wrapper, function (elem) {
          return elem.project.name.toLowerCase();
        });

        privates.projects.splice(insertAt, 0, wrapper);
      }

      privates.eventEmitter.emit('update-project', {
        type: 'update-project',
        id: id,
        project: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(project)
      });
      return true;
    }
    /**
     * Add or update a project. If a project with the given identifier exists,
     * then it is replaced with the given project. Otherwise, the project is
     * added to the list as a new project. If the given identifier is not a valid
     * UUID, then the method returns false and nothing happens.
     * @param {string} id The unique identifier of the project.
     * @param {module:project~Project} project The project that should be added
     *   or with which an existing project should be replaced.
     * @returns {boolean} True if the project was successfully added or updated,
     *   or false if the given identifier is not a valid UUID.
     * @fires module:projectList~ProjectList~addProject
     * @fires module:projectList~ProjectList~updateProject
     */

  }, {
    key: "addOrUpdateProject",
    value: function addOrUpdateProject(id, project) {
      if (!(0,_utility_data__WEBPACK_IMPORTED_MODULE_6__.isUuidValid)(id)) return false;

      if (!this.updateProject(id, project)) {
        var privates = privateMembers.get(this);
        var value = {
          id: id,
          project: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(project)
        }; // Maintain sort order on insertion

        var index = lodash_sortedIndexBy__WEBPACK_IMPORTED_MODULE_2___default()(privates.projects, value, function (elem) {
          return elem.project.name.toLowerCase();
        });

        privates.projects.splice(index, 0, value);
        privates.eventEmitter.emit('add-project', {
          type: 'add-project',
          id: id,
          project: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(project)
        });
      }

      return true;
    }
    /**
     * Add a project to the list. In order to prevent unintentional external
     * modification of the project, a deep copy is made, and the original object
     * is not kept.
     * @param {module:project~Project} project The project to add.
     * @returns {string} The identifier of the newly-added project.
     * @fires module:projectList~ProjectList~addProject
     */

  }, {
    key: "addProject",
    value: function addProject(project) {
      // Generate UUID (loop in case of collision)
      var id;

      do {
        id = (0,uuid__WEBPACK_IMPORTED_MODULE_7__["default"])();
      } while (this.hasProject(id));

      this.addOrUpdateProject(id, project);
      return id;
    }
    /**
     * Remove a project from the project list.
     * @param {string} id The identifier of the project to remove.
     * @returns {boolean} Returns true if the project was successfully removed,
     *   or false if an invalid identifier was given.
     * @fires module:projectList~ProjectList~deleteProject
     */

  }, {
    key: "deleteProject",
    value: function deleteProject(id) {
      var index = findIndex(this, id);
      if (index < 0) return false;
      var privates = privateMembers.get(this);
      var project = privates.projects[index].project;
      privates.projects.splice(index, 1);
      privates.eventEmitter.emit('delete-project', {
        type: 'delete-project',
        id: id,
        project: project
      });
      return true;
    }
    /**
     * Delete all projects from the project list.
     * @fires module:projectList~ProjectList~deleteProject
     */

  }, {
    key: "deleteAll",
    value: function deleteAll() {
      var privates = privateMembers.get(this);

      var projects = _toConsumableArray(privates.projects);

      privates.projects.length = 0;
      projects.forEach(function (_ref) {
        var id = _ref.id,
            project = _ref.project;
        privates.eventEmitter.emit('delete-project', {
          type: 'delete-project',
          id: id,
          project: project
        });
      });
    }
    /**
     * Determines whether a project with the given identifier exists within the
     * project list.
     * @param {string} id The unique identifier of the project to look for.
     * @returns {boolean} True if the project exists, and false otherwise.
     */

  }, {
    key: "hasProject",
    value: function hasProject(id) {
      return findIndex(this, id) >= 0;
    }
    /**
     * Execute the provided function on each project in the list. Note that the
     * project instance passed to the callback function is only a copy of the
     * project in the list.
     * @param {Function} callback The function to execute on each project. The
     *   function will be passed a
     *   [wrapper]{@link module:projectList~ProjectList~projectWrapper}
     *   containing the project and its identifier. The function can also
     *   optionally accept the index of the project in the list as its second
     *   argument.
     */

  }, {
    key: "forEach",
    value: function forEach(callback) {
      privateMembers.get(this).projects.forEach(function (project, index) {
        var copy = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(project);

        callback(copy, index);
      });
    }
    /**
     * Add an event listener to the project list.
     * @param {string} type The type of event to listen for.
     * @param {Function} listener A callback function to be invoked when the
     *   event is triggered.
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      privateMembers.get(this).eventEmitter.on(type, listener);
    }
    /**
     * Convert data to an object suitable for serialization.
     * @returns {Object} An object representing serializable data for the class.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var projects = [];
      privateMembers.get(this).projects.forEach(function (_ref2) {
        var id = _ref2.id,
            project = _ref2.project;
        projects.push({
          name: project.name,
          id: id,
          description: project.description
        });
      });
      return projects;
    }
    /**
     * Import projects from a JSON object.
     * @param {Object} data The serialized JSON object to import.
     * @returns {module:projectList~ProjectList~importStatus} An object holding
     *   information about the status of the import.
     * @fires module:projectList~ProjectList~addProject
     * @fires module:projectList~ProjectList~updateProject
     */

  }, {
    key: "importFromJson",
    value: function importFromJson(data) {
      var _this = this;

      var counts = {
        added: 0,
        updated: 0,
        failed: 0,
        total: 0
      };
      var errors = [];

      if (!Array.isArray(data)) {
        errors.push('Error: Expected "projects" property to be an array.');
        return {
          projects: counts,
          errors: errors
        };
      }

      data.forEach(function (_ref3) {
        var name = _ref3.name,
            id = _ref3.id,
            description = _ref3.description;

        var handleError = function handleError(errorType, value, opts) {
          if (value == null) return;
          var msgPrefix = "Warning: Project \"".concat(name, "\"");
          var msg;

          switch (errorType) {
            case 'bad-type':
              msg = "Expected type \"".concat(opts.expectedType, "\" for property \"").concat(opts.valueName, "\" (received \"").concat((0,_utility_data__WEBPACK_IMPORTED_MODULE_6__.getJsonType)(value), "\").");
              break;

            case 'bad-id':
              msg = "Expected a version 4 UUID for property \"".concat(opts.valueName, "\" (received \"").concat(value, "\").");
              break;

            default:
              msg = "Encountered unrecognized error \"".concat(errorType, "\" for property \"").concat(opts.valueName, "\".");
              break;
          }

          errors.push("".concat(msgPrefix, ": ").concat(msg));
        };

        if (name == null) {
          errors.push('Error: Project must have a name.');
          counts.failed += 1;
        } else if (typeof name !== 'string') {
          errors.push("Error: Expected type \"string\" for project name (received \"".concat((0,_utility_data__WEBPACK_IMPORTED_MODULE_6__.getJsonType)(name), "\")."));
          counts.failed += 1;
        } else if (name.length === 0) {
          errors.push('Error: Project name must not be empty.');
          counts.failed += 1;
        } else {
          var projectOptions = {};
          if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_6__.validateValue)(description, {
            valueName: 'description',
            expectedType: 'string',
            errorCallback: handleError
          })) projectOptions.description = description;
          var newId = null;
          if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_6__.validateValue)(id, {
            valueName: 'id',
            expectedType: 'string',
            requireUuid: true,
            errorCallback: handleError
          })) newId = id;
          if (newId && _this.hasProject(newId)) counts.updated += 1;else counts.added += 1;
          var project = new _project__WEBPACK_IMPORTED_MODULE_5__["default"](name, projectOptions);
          if (newId) _this.addOrUpdateProject(newId, project);else _this.addProject(project);
        }
      });
      counts.total = counts.added + counts.updated + counts.failed;
      return {
        projects: counts,
        errors: errors
      };
    }
    /**
     * Import projects from parsed CSV data.
     * @param {string[][]} data An array of string arrays. Each member of the
     *   outer array represents a single project, and each member of each inner
     *   array is a data field for that particular project. The first member of
     *   the outer array should be a header holding field names. Duplicate
     *   projects are ignored, as are unrelated fields.
     * @returns {module:taskList~TaskList~importStatus} An object holding
     *   information about the status of the import.
     * @fires module:projectList~ProjectList~addProject
     * @fires module:projectList~ProjectList~updateProject
     */

  }, {
    key: "importFromCsv",
    value: function importFromCsv(data) {
      var columns = [];

      if (data.length > 0) {
        var header = data[0];
        header.forEach(function (field, index) {
          switch (field.toLowerCase()) {
            case 'project name':
            case 'project-name':
              columns.push({
                name: 'name',
                index: index
              });
              break;

            case 'project uuid':
            case 'project-uuid':
              columns.push({
                name: 'id',
                index: index
              });
              break;

            case 'project description':
            case 'project-description':
              columns.push({
                name: 'description',
                index: index
              });
              break;

            default:
              break;
          }
        });
      }

      var entries = [];

      if (columns.length > 0) {
        data.forEach(function (csvRecord, csvIndex) {
          if (csvIndex === 0) return;
          var entry = {};
          columns.forEach(function (_ref4) {
            var name = _ref4.name,
                index = _ref4.index;

            if (csvRecord.length > index && csvRecord[index].length > 0) {
              entry[name] = csvRecord[index];
            }
          });
          if (!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(entry)) entries.push(entry);
        });
      }

      var isEntryEqual = function isEntryEqual(left, right) {
        if (left.id != null || right.id != null) return left.id === right.id;
        return left.name === right.name && left.description === right.description;
      };

      return this.importFromJson(lodash_uniqWith__WEBPACK_IMPORTED_MODULE_0___default()(entries, isEntryEqual));
    }
  }]);

  return ProjectList;
}();

/* harmony default export */ __webpack_exports__["default"] = (ProjectList);

/***/ }),

/***/ "./src/modules/recurringDate.js":
/*!**************************************!*\
  !*** ./src/modules/recurringDate.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash_uniq__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/uniq */ "./node_modules/lodash/uniq.js");
/* harmony import */ var lodash_uniq__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_uniq__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ordinal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ordinal */ "./node_modules/ordinal/index.js");
/* harmony import */ var ordinal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ordinal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfDay/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/add/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfMonth/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/getDaysInMonth/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/nextDay/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isBefore/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isWeekend/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/previousDay/index.js");
/* harmony import */ var _utility_dates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utility/dates */ "./src/modules/utility/dates.js");



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }




/**
 * Starting from the given date, find the next date landing on one of the given
 * days of the week.
 * @param {Date} date The initial date to start from.
 * @param {number[]} daysOfWeek An array of desired weekdays. Each day is a
 *   value from 0-6, with Sunday being 0.
 * @returns {Date} The first date on or after the given date that matches one
 *   of the given weekdays.
 */

function nextDayOfWeek(date, daysOfWeek) {
  var result = (0,date_fns__WEBPACK_IMPORTED_MODULE_4__["default"])(date);
  if (daysOfWeek.length === 0) return result;
  var currentDay = result.getDay();
  var daysToAdd = daysOfWeek.map(function (day) {
    return day >= currentDay ? day - currentDay : day + 7 - currentDay;
  }).reduce(function (min, current) {
    return current < min ? current : min;
  });
  if (daysToAdd > 0) result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
    days: daysToAdd
  });
  return result;
}
/**
 * Starting from the given date, find the next date with the indicated day of
 * the month.
 * @param {Date} date The initial date to start from.
 * @param {number} dayOfMonth The desired day of the month, from 1-31.
 * @returns {Date} The first date on or after the given date that matches the
 *   day of the month.
 */


function nextDayOfMonth(date, dayOfMonth) {
  var currentMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_6__["default"])(date);
  var nextMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_6__["default"])((0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(currentMonth, {
    months: 1
  }));
  var result = date.getDate() <= dayOfMonth ? currentMonth : nextMonth;
  var daysInMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_7__["default"])(result);
  result.setDate(Math.min(dayOfMonth, daysInMonth));
  return result;
}
/**
 * Starting from the given date, find the next date belonging to the indicated
 * week and weekday of the month.
 * @param {Date} date The initial date to start from.
 * @param {number} weekNumber The week of the month, from 1-5.
 * @param {number} weekDay The day of the week, from 0-6 with Sunday being 0.
 * @returns {Date} The first date on or after the given date that matches the
 *   week and day of the month.
 */


function nextWeekOfMonth(date, weekNumber, weekDay) {
  var currentMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_6__["default"])(date);
  var nextMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_6__["default"])((0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(currentMonth, {
    months: 1
  }));

  var findDay = function findDay(month) {
    var daysInMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_7__["default"])(month);
    var result = month;
    if (result.getDay() !== weekDay) result = (0,date_fns__WEBPACK_IMPORTED_MODULE_8__["default"])(result, weekDay);
    var daysToAdd = (weekNumber - 1) * 7;

    if (result.getDate() + daysToAdd > daysInMonth) {
      daysToAdd = Math.floor((daysInMonth - result.getDate()) / 7) * 7;
    }

    if (weekNumber > 1) result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
      days: daysToAdd
    });
    return result;
  };

  var result = findDay(currentMonth);
  if ((0,date_fns__WEBPACK_IMPORTED_MODULE_9__["default"])(result, date)) result = findDay(nextMonth);
  return result;
}
/**
 * Starting from the given date, find the next date belonging to the given
 * month and day of the year.
 * @param {Date} date The initial date to start from.
 * @param {number} month The desired month, from 0-11 with January being 0.
 * @param {number} dayOfMonth The desired day of the month, from 1-31.
 * @returns {Date} The first date on or after the given date that matches the
 *   month and day of the year.
 */


function nextDayOfYear(date, month, dayOfMonth) {
  var dateOfCurrentYear = new Date(date.getFullYear(), month, 1);
  dateOfCurrentYear.setDate(Math.min(dayOfMonth, (0,date_fns__WEBPACK_IMPORTED_MODULE_7__["default"])(dateOfCurrentYear)));
  var dateOfNextYear = new Date(date.getFullYear() + 1, month, 1);
  dateOfNextYear.setDate(Math.min(dayOfMonth, (0,date_fns__WEBPACK_IMPORTED_MODULE_7__["default"])(dateOfNextYear)));
  var result = dateOfCurrentYear;
  if ((0,date_fns__WEBPACK_IMPORTED_MODULE_9__["default"])(result, date)) result = dateOfNextYear;
  return result;
}
/**
 * Represents a recurring date.
 */


var RecurringDate = /*#__PURE__*/function () {
  /**
   * Create a recurring date.
   * @param {string} intervalUnit The unit of time (e.g. 'week') in which the
   *   repetition interval is measured. Valid options are 'day', 'week',
   *   'month', and 'year'.
   * @param {Object} options An object holding configuration options for the
   *   recurrence.
   * @param {number} [options.intervalLength=1] The length of the repetition
   *   interval.
   * @param {Date} [options.startDate] Indicates the earliest date that the
   *   next occurrence can happen. Any occurrences that would fall before this
   *   date are skipped.
   * @param {boolean} [options.baseOnCompletion=false] If this is true, then
   *   the next occurrence should be calculated from the task's completion
   *   date. Otherwise, the occurrence should be calculated from the task's due
   *   date.
   * @param {number} [options.weekNumber] The number of the week within a month
   *   in which the recurring date should occur. Used in conjunction with
   *   daysOfWeek. A value of 1 indicates the first occurrence of a day within
   *   the month, 2 indicates the second occurrence, and so on. If this is set
   *   to 5, then the 4th or 5th occurrence of the day may be used, depending
   *   on how many such days are in a particular month.
   * @param {number[]} [options.daysOfWeek] An array holding the days of the
   *   week on which the recurring date should occur. Each day is an integer
   *   from 0-6, where 0 represents Sunday, 1 represents Monday, and so on.
   * @param {number} [options.month] The month in the year on which the
   *   recurring date should occur, represented as a number from 0 to 11.
   * @param {number} [options.dayOfMonth] The day of the month on which the
   *   recurring date should occur, represented as a number from 1 to 31.
   * @param {string} [options.onWeekend=no-change] Specifies what happens when
   *   the next recurrence falls on a weekend. If set to 'no-change', then the
   *   date is unaffected. If set to 'previous-weekday' or 'next-weekday', then
   *   the previous or next weekday is used instead. If set to
   *   'nearest-weekday', then the closest weekday is used instead.
   * @param {Date} [options.endDate] Indicates the date after which the
   *   repetition should stop.
   * @param {number} [options.maxCount] Indicates the maximum number of
   *   repetitions before the recurrence should stop.
   */
  function RecurringDate(intervalUnit) {
    var _options$intervalLeng, _options$baseOnComple, _options$weekNumber, _options$month, _options$dayOfMonth, _options$maxCount;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, RecurringDate);

    /**
     * The unit of time in which the repetition interval is measured.
     * @type {string}
     */
    this.intervalUnit = intervalUnit;
    /**
     * The length of the repetition interval.
     * @type {number}
     */

    this.intervalLength = (_options$intervalLeng = options.intervalLength) !== null && _options$intervalLeng !== void 0 ? _options$intervalLeng : 1;
    /**
     * Indicates the earliest date that the next occurrence can happen. Any
     * occurrences that would fall before this date are skipped.
     * @type {?Date}
     */

    this.startDate = options.startDate || null;
    /**
     * If this is true, then the next occurrence should be calculated from the
     * task's completion date. Otherwise, the occurrence should be calculated
     * from the task's due date.
     * @type {boolean}
     */

    this.baseOnCompletion = (_options$baseOnComple = options.baseOnCompletion) !== null && _options$baseOnComple !== void 0 ? _options$baseOnComple : false;
    /**
     * The number of the week within a month in which the recurring date should
     * occur. Used in conjunction with daysOfWeek. A value of 1 indicates the
     * first occurrence of a day within the month, 2 indicates the second
     * occurrence, and so on. If this is set to 5, then the 4th or 5th
     * occurrence of the day may be used, depending on how many such days are
     * in a particular month.
     * @type {?number}
     */

    this.weekNumber = (_options$weekNumber = options.weekNumber) !== null && _options$weekNumber !== void 0 ? _options$weekNumber : null;
    /**
     * An array holding the days of the week on which the recurring date should
     * occur. Each day is an integer from 0-6, where 0 represents Sunday, 1
     * represents Monday, and so on.
     * @type {?number[]}
     */

    this.daysOfWeek = options.daysOfWeek || null;
    /**
     * The month in the year on which the recurring date should occur,
     * represented as a number between 0 and 11.
     * @type {?number}
     */

    this.month = (_options$month = options.month) !== null && _options$month !== void 0 ? _options$month : null;
    /**
     * The day of the month on which the recurring date should occur,
     * represented as a number between 1 and 31.
     * @type {?number}
     */

    this.dayOfMonth = (_options$dayOfMonth = options.dayOfMonth) !== null && _options$dayOfMonth !== void 0 ? _options$dayOfMonth : null;
    /**
     * Specifies what happens when the next recurrence occurs on a weekend. If
     * set to 'no-change', then the date is unaffected. If set to
     * 'previous-weekday' or 'next-weekday', then the previous or next weekday
     * is used instead. If set to 'nearest-weekday', then the closest weekday
     * is used instead.
     * @type {string}
     */

    this.onWeekend = options.onWeekend || 'no-change';
    /**
    * Indicates the date after which the repetition should stop, if any.
    * @type {?Date}
    */

    this.endDate = options.endDate || null;
    /**
     * Indicates the maximum number of repetitions before the recurrence should
     * stop, if ever.
     * @type {?number}
     */

    this.maxCount = (_options$maxCount = options.maxCount) !== null && _options$maxCount !== void 0 ? _options$maxCount : null;
  }
  /**
   * Get the next occurrence of the recurring date.
   * @param {Date} [baseDate] The base date from which the next occurrence
   *   should be calculated. If not given, then the present day is used.
   * @returns {?Date} The date on which the recurrence will next occur, or null
   *   if the recurrence has ended.
   */


  _createClass(RecurringDate, [{
    key: "getNextOccurrence",
    value: function getNextOccurrence(baseDate) {
      if (typeof this.maxCount === 'number' && this.maxCount < 1) return null;
      var reference = (0,date_fns__WEBPACK_IMPORTED_MODULE_4__["default"])(baseDate || new Date());
      var startDate = reference;

      if (this.startDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_9__["default"])(reference, this.startDate)) {
        startDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_4__["default"])(this.startDate);
      }

      if (this.onWeekend === 'previous-weekday' && (0,date_fns__WEBPACK_IMPORTED_MODULE_10__["default"])(startDate)) {
        // Move starting date to following Monday
        startDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_8__["default"])(startDate, 1);
      } else if (this.onWeekend === 'nearest-weekday' && startDate.getDay() === 6) {
        // Move starting date to Sunday
        startDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_8__["default"])(startDate, 0);
      }

      var isBeforeStart = function isBeforeStart(date) {
        return startDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_9__["default"])(date, startDate);
      };

      var result = reference;

      switch (this.intervalUnit) {
        case 'day':
          result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
            days: this.intervalLength
          });
          if (isBeforeStart(result)) result = startDate;
          break;

        case 'month':
          if (this.dayOfMonth || this.weekNumber) {
            result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
              months: this.intervalLength,
              days: -14
            });

            if (this.dayOfMonth) {
              result = nextDayOfMonth(result, this.dayOfMonth);

              if (isBeforeStart(result)) {
                result = nextDayOfMonth(startDate, this.dayOfMonth);
              }
            } else if (this.weekNumber) {
              var weekDay = 0;

              if (this.daysOfWeek && this.daysOfWeek.length > 0) {
                var _this$daysOfWeek = _slicedToArray(this.daysOfWeek, 1);

                weekDay = _this$daysOfWeek[0];
              }

              result = nextWeekOfMonth(result, this.weekNumber, weekDay);

              if (isBeforeStart(result)) {
                result = nextWeekOfMonth(startDate, this.weekNumber, weekDay);
              }
            }
          } else {
            result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
              months: this.intervalLength
            });

            if (isBeforeStart(result)) {
              result = nextDayOfMonth(startDate, reference.getDate());
            }
          }

          break;

        case 'year':
          if (typeof this.month === 'number') {
            result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
              years: this.intervalLength,
              months: -6
            });
            result = nextDayOfYear(result, this.month, this.dayOfMonth || 1);

            if (isBeforeStart(result)) {
              result = nextDayOfYear(startDate, this.month, this.dayOfMonth || 1);
            }
          } else {
            result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
              years: this.intervalLength
            });

            if (isBeforeStart(result)) {
              result = nextDayOfYear(startDate, reference.getMonth(), reference.getDate());
            }
          }

          break;

        case 'week':
          if (this.daysOfWeek && this.daysOfWeek.length > 0) {
            // Check for occurrences remaining for the current week
            if (this.daysOfWeek.findIndex(function (day) {
              return day > result.getDay();
            }) !== -1) {
              result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
                days: 1
              });
              result = nextDayOfWeek(result, this.daysOfWeek);
            } else {
              // Done with current week, start at following Sunday
              result = (0,date_fns__WEBPACK_IMPORTED_MODULE_8__["default"])(result, 0);

              if (this.intervalLength > 1) {
                result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
                  weeks: this.intervalLength - 1
                });
              }

              result = nextDayOfWeek(result, this.daysOfWeek);
            }

            if (isBeforeStart(result)) {
              result = nextDayOfWeek(startDate, this.daysOfWeek);
            }
          } else {
            result = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(result, {
              weeks: this.intervalLength
            });

            if (isBeforeStart(result)) {
              result = nextDayOfWeek(startDate, [reference.getDay()]);
            }
          }

          break;

        default:
          break;
      }

      if (this.onWeekend !== 'no-change' && (0,date_fns__WEBPACK_IMPORTED_MODULE_10__["default"])(result)) {
        var forward;

        switch (this.onWeekend) {
          case 'previous-weekday':
            forward = false;
            break;

          case 'next-weekday':
            forward = true;
            break;

          case 'nearest-weekday':
            forward = result.getDay() === 0;
            break;

          default:
            forward = true;
            break;
        }

        if (forward) result = (0,date_fns__WEBPACK_IMPORTED_MODULE_8__["default"])(result, 1); // Next Monday
        else result = (0,date_fns__WEBPACK_IMPORTED_MODULE_11__["default"])(result, 5); // Previous Friday
      }

      if (this.endDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_9__["default"])(this.endDate, result)) return null;
      return result;
    }
    /**
     * Advance the recurrence to the next date. This will update the remaining
     * repetition count if needed.
     */

  }, {
    key: "advance",
    value: function advance() {
      if (typeof this.maxCount === 'number' && this.maxCount > 0) {
        this.maxCount -= 1;
      }
    }
    /**
     * Determine whether or not the recurrence was created with the default
     * options.
     * @returns {boolean} True if the recurring date is a default recurrence, and
     *   false otherwise.
     */

  }, {
    key: "isDefault",
    value: function isDefault() {
      var _this$startDate, _def$startDate, _this$endDate, _def$endDate;

      var def = new RecurringDate(this.intervalUnit);
      if (this.intervalLength !== def.intervalLength) return false;
      if (((_this$startDate = this.startDate) === null || _this$startDate === void 0 ? void 0 : _this$startDate.getTime()) !== ((_def$startDate = def.startDate) === null || _def$startDate === void 0 ? void 0 : _def$startDate.getTime())) return false;
      if (this.baseOnCompletion !== def.baseOnCompletion) return false;
      if (this.weekNumber !== def.weekNumber) return false;
      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(this.daysOfWeek, def.daysOfWeek)) return false;
      if (this.month !== def.month) return false;
      if (this.dayOfMonth !== def.dayOfMonth) return false;
      if (this.onWeekend !== def.onWeekend) return false;
      if (((_this$endDate = this.endDate) === null || _this$endDate === void 0 ? void 0 : _this$endDate.getTime()) !== ((_def$endDate = def.endDate) === null || _def$endDate === void 0 ? void 0 : _def$endDate.getTime())) return false;
      if (this.maxCount !== def.maxCount) return false;
      return true;
    }
    /**
     * Get a string representation of the recurring date.
     * @returns {string} A string representation of the recurring date.
     */

  }, {
    key: "toString",
    value: function toString() {
      var _this$daysOfWeek2;

      var length = this.intervalLength;
      var strValue = '';

      switch (this.intervalUnit) {
        case 'day':
          strValue = length === 1 ? 'Daily' : "Every ".concat(length, " days");
          break;

        case 'week':
          strValue = length === 1 ? 'Weekly' : "Every ".concat(length, " weeks");

          if (this.daysOfWeek && this.daysOfWeek.length > 0) {
            strValue += ' on ';

            if (lodash_uniq__WEBPACK_IMPORTED_MODULE_0___default()(this.daysOfWeek).length === 7) {
              strValue += 'all days';
            } else {
              this.daysOfWeek.forEach(function (day, index) {
                if (index > 0) strValue += ', ';
                strValue += (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.getWeekdayName)(day);
              });
            }
          }

          break;

        case 'month':
          strValue = length === 1 ? 'Monthly' : "Every ".concat(length, " months");

          if (this.dayOfMonth) {
            strValue += " on the ".concat(ordinal__WEBPACK_IMPORTED_MODULE_2___default()(this.dayOfMonth));
          } else if (this.weekNumber && ((_this$daysOfWeek2 = this.daysOfWeek) === null || _this$daysOfWeek2 === void 0 ? void 0 : _this$daysOfWeek2.length) === 1) {
            var weekStr;
            if (this.weekNumber < 5) weekStr = ordinal__WEBPACK_IMPORTED_MODULE_2___default()(this.weekNumber);else weekStr = 'last';
            var dayStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.getWeekdayName)(this.daysOfWeek[0]);
            strValue += " on the ".concat(weekStr, " ").concat(dayStr);
          }

          break;

        case 'year':
          strValue = length === 1 ? 'Annually' : "Every ".concat(length, " years");

          if (Number.isInteger(this.month) && this.dayOfMonth) {
            var monthStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.getMonthName)(this.month);

            var _dayStr = ordinal__WEBPACK_IMPORTED_MODULE_2___default()(this.dayOfMonth);

            strValue += " on ".concat(monthStr, " ").concat(_dayStr);
          }

          break;

        default:
          break;
      }

      return strValue;
    }
    /**
     * Like [toString]{@link module:recurringDate~RecurringDate#toString}, but
     * more verbose, including all details of the recurrence.
     * @param {string} dateFormatStr The format to use for dates.
     * @returns {string} A string representation of the recurring date.
     */

  }, {
    key: "toStringVerbose",
    value: function toStringVerbose(dateFormatStr) {
      var strValue = this.toString();

      if (this.startDate) {
        var dateStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.formatDate)(this.startDate, dateFormatStr);
        strValue += ", from ".concat(dateStr);
      }

      if (this.endDate) {
        var _dateStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.formatDate)(this.endDate, dateFormatStr);

        strValue += ", until ".concat(_dateStr);
      } else if (this.maxCount) {
        if (this.maxCount === 1) strValue += ', 1 time';else strValue += ", ".concat(this.maxCount, " times");
      }

      if (this.baseOnCompletion) {
        strValue += ', based on completion date';
      }

      if (this.onWeekend !== 'no-change') {
        strValue += ', ';

        switch (this.onWeekend) {
          case 'previous-weekday':
            strValue += 'previous weekday';
            break;

          case 'next-weekday':
            strValue += 'next weekday';
            break;

          case 'nearest-weekday':
            strValue += 'nearest weekday';
            break;

          default:
            break;
        }
      }

      return strValue;
    }
    /**
     * Create a recurring date from a JSON object.
     * @param {Object} data The JSON object holding the serialized data.
     * @returns {module:recurringDate~RecurringDate} A new recurring date
     *   converted from the JSON data.
     */

  }], [{
    key: "fromJson",
    value: function fromJson(data) {
      var convertDate = function convertDate(date) {
        return date ? (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.parseIsoDateTime)(date) : null;
      };

      return new RecurringDate(data.intervalUnit, {
        intervalLength: data.intervalLength,
        startDate: convertDate(data.startDate),
        baseOnCompletion: data.baseOnCompletion,
        weekNumber: data.weekNumber,
        daysOfWeek: data.daysOfWeek,
        month: data.month,
        dayOfMonth: data.dayOfMonth,
        onWeekend: data.onWeekend,
        endDate: convertDate(data.endDate),
        maxCount: data.maxCount
      });
    }
  }]);

  return RecurringDate;
}();

/* harmony default export */ __webpack_exports__["default"] = (RecurringDate);

/***/ }),

/***/ "./src/modules/settings.js":
/*!*********************************!*\
  !*** ./src/modules/settings.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utility_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utility/data */ "./src/modules/utility/data.js");
/* harmony import */ var _utility_dates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utility/dates */ "./src/modules/utility/dates.js");


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [Settings]{@link module:settings~Settings} class.
 * @module settings
 */



/**
 * Object holding private members for the
 * [Settings]{@link module:settings~Settings} class.
 * @typedef {Object} module:settings~Settings~privates
 * @property {string} storageMethod The method for storing data: 'none' (no
 *   storage) or 'local' (local storage in the browser).
 * @property {module:settings~Settings~dateFormat} dateFormat The format to use
 *   for calendar dates.
 * @property {?number} deleteAfter Determines how many days after a task is
 *   completed before the task will be automatically deleted. If set to null,
 *   completed tasks will never be deleted automatically.
 * @property {Map} filterGroups A map associating the name of a filter group to
 *   a [filterOptions]{@link module:settings~Settings~filterOptions} object.
 * @property {EventEmitter} eventEmitter Holds the event emitter which
 *   dispatches events to attached event listeners.
 */

/**
 * Holds private data for the [Settings]{@link module:settings~Settings} class.
 * @type {WeakMap}
 * @see module:settings~Settings~privates
 */

var privateMembers = new WeakMap();
/**
 * Holds user app settings.
 */

var Settings = /*#__PURE__*/function () {
  /**
   * Holds information about the pattern to use for formatting and parsing
   * calendar dates.
   * @typedef {Object} module:settings~Settings~dateFormat
   * @property {string} outputPattern The date format string used for
   *   formatting dates for output.
   * @property {string[]} inputPatterns An array of date format strings used
   *   for parsing dates. Each pattern will be tried in sequence until a valid
   *   match is made.
   * @property {string} visualPattern A visual representation of the date
   *   format suitable for displaying to the user.
   * @property {string} type The type of date format. Valid values are 'local',
   *   'iso', 'month-day-year', 'day-month-year', and 'year-month-day'.
   */

  /**
   * Holds options for displaying a task filter.
   * @typedef {Object} module:settings~Settings~filterOptions
   * @property {string} groupBy The field to group the tasks by: 'default',
   *   'due-date', 'priority', 'project', or 'none'. The default depends on the
   *   type of filter.
   * @property {string} sortBy The primary field to sort the tasks by: 'name',
   *   'due-date', 'create-date', 'priority', or 'project'.
   * @property {boolean} sortDescending Indicates whether to sort in descending
   *   order rather than ascending order.
   * @property {boolean} showCompleted Indicates whether to include completed
   *   tasks in the results.
   */

  /**
   * Event that is fired when a setting is modified.
   * @event module:settings~Settings~updateSetting
   * @type {Object}
   * @property {string} type The event type: 'update-setting'.
   * @property {string} name The name of the setting. This is the same as the
   *   name of the corresponding instance property, except for filter group
   *   settings, which have the form 'filterGroups.group-name', where
   *   'group-name' is the name of the filter group.
   * @property {*} value The new value of the setting.
   */

  /**
   * An object holding information about the status of a data import.
   * @typedef {Object} module:settings~Settings~importStatus
   * @property {string[]} errors An array of error messages describing any
   *   errors that occurred during the import.
   */

  /**
   * Create an object holding the default settings.
   */
  function Settings() {
    _classCallCheck(this, Settings);

    var privates = {
      storageMethod: null,
      dateFormat: {},
      deleteAfter: null,
      filterGroups: new Map(),
      eventEmitter: new (events__WEBPACK_IMPORTED_MODULE_1___default())()
    };
    privateMembers.set(this, privates);
    this.resetToDefault();
  }
  /**
   * Get the value of a setting. Although each setting can be retrieved
   * directly using other class methods and properties, this method can make
   * storage and serialization easier.
   * @param {string} name The name of the setting. This is the same as the name
   *   of the corresponding instance property, except for filter group
   *   settings, which have the form 'filterGroups.group-name', where
   *   'group-name' is the name of the filter group.
   * @returns {*} The value of the setting. For filter group settings, this is
   *   a [filterOptions]{@link module:settings~Settings~filterOptions} object.
   *   For date format settings, this is a
   *   [dateFormat]{@link module:settings~Settings~dateFormat} object.
   */


  _createClass(Settings, [{
    key: "getSetting",
    value: function getSetting(name) {
      switch (name) {
        case 'storageMethod':
          return this.storageMethod;

        case 'dateFormat':
          return this.dateFormat;

        case 'deleteAfter':
          return this.deleteAfter;

        default:
          if (name.startsWith('filterGroups.')) {
            var group = name.substring('filterGroups.'.length);
            return this.getFilterOptions(group);
          }

          return null;
      }
    }
    /**
     * Set the value of a setting. Although each setting can be set directly
     * using other class methods and properties, this method can make storage and
     * deserialization easier.
     * @param {string} name The name of the setting. This is the same as the name
     *   of the corresponding instance property, except for filter group
     *   settings, which have the form 'filterGroups.group-name', where
     *   'group-name' is the name of the filter group.
     * @param {*} value The value of the setting. For filter group settings, this
     *   should be a
     *   [filterOptions]{@link module:settings~Settings~filterOptions} object.
     *   For date format settings, this can be either a
     *   [dateFormat]{@link module:settings~Settings~dateFormat} object or a
     *   string specifying the name of the format to use.
     * @fires module:settings~Settings~updateSetting
     */

  }, {
    key: "setSetting",
    value: function setSetting(name, value) {
      var validSetting = true;

      switch (name) {
        case 'storageMethod':
          this.storageMethod = value;
          break;

        case 'dateFormat':
          this.setDateFormat(value);
          break;

        case 'deleteAfter':
          this.deleteAfter = value;
          break;

        default:
          if (name.startsWith('filterGroups.')) {
            var group = name.substring('filterGroups.'.length);
            this.setFilterOptions(group, value);
          } else {
            validSetting = false;
          }

          break;
      }

      if (validSetting) {
        privateMembers.get(this).eventEmitter.emit('update-setting', {
          type: 'update-setting',
          name: name,
          value: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(value)
        });
      }
    }
    /**
     * Execute the provided function for each available setting.
     * @param {Function} callback The function to execute for each setting. The
     *   function will be passed the name of each setting along with its value.
     */

  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _this = this;

      var privates = privateMembers.get(this);
      var settingList = ['storageMethod', 'dateFormat', 'deleteAfter'];

      var groupKeys = _toConsumableArray(privates.filterGroups.keys()).map(function (key) {
        return "filterGroups.".concat(key);
      });

      settingList.push.apply(settingList, _toConsumableArray(groupKeys));
      settingList.forEach(function (setting) {
        callback(setting, _this.getSetting(setting));
      });
    }
    /**
     * The method for storing data: 'none' (no storage) or 'local' (local storage
     * in the browser).
     * @type {string}
     */

  }, {
    key: "storageMethod",
    get: function get() {
      return privateMembers.get(this).storageMethod;
    },
    set: function set(method) {
      if (method !== 'none' && method !== 'local') {
        throw new RangeError("Unrecognized storage method: \"".concat(method, "\""));
      }

      var privates = privateMembers.get(this);
      privates.storageMethod = method;
      privates.eventEmitter.emit('update-setting', {
        type: 'update-setting',
        name: 'storageMethod',
        value: method
      });
    }
    /**
     * An object holding information about the format to use for calendar dates.
     * @type {module:settings~Settings~dateFormat}
     * @readonly
     */

  }, {
    key: "dateFormat",
    get: function get() {
      return lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(privateMembers.get(this).dateFormat);
    }
    /**
     * Determines how many days after a task is completed before the task will be
     * automatically deleted. If set to null, completed tasks will never be
     * deleted automatically.
     * @type {?number}
     */

  }, {
    key: "deleteAfter",
    get: function get() {
      return privateMembers.get(this).deleteAfter;
    },
    set: function set(days) {
      var privates = privateMembers.get(this);
      privates.deleteAfter = days;
      privates.eventEmitter.emit('update-setting', {
        type: 'update-setting',
        name: 'deleteAfter',
        value: days
      });
    }
    /**
     * Get an object holding options for displaying task filters belonging to a
     * particular filter group.
     * @param {string} filterGroup The filter group whose options are to be
     *   retrieved.
     * @returns {?module:settings~Settings~filterOptions} An object holding the
     *   filter options, or null if the filter group was not found.
     */

  }, {
    key: "getFilterOptions",
    value: function getFilterOptions(filterGroup) {
      var opts = privateMembers.get(this).filterGroups.get(filterGroup);
      return opts ? lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(opts) : null;
    }
    /**
     * Set options for displaying task filters belonging to a particular filter
     * group.
     * @param {string} filterGroup The filter group whose options are to be
     *   changed.
     * @param {module:settings~Settings~filterOptions} [options={}] An object
     *   specifying the filter options to set. Any unspecified options will
     *   retain their prior values, or will be set to default values if they were
     *   not previously set.
     * @fires module:settings~Settings~updateSetting
     */

  }, {
    key: "setFilterOptions",
    value: function setFilterOptions(filterGroup) {
      var _ref, _options$groupBy, _ref2, _options$sortBy, _ref3, _options$sortDescendi, _ref4, _options$showComplete;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var privates = privateMembers.get(this);
      var filterGroups = privates.filterGroups;
      var oldOptions = filterGroups.get(filterGroup);
      var newOptions = {
        groupBy: (_ref = (_options$groupBy = options.groupBy) !== null && _options$groupBy !== void 0 ? _options$groupBy : oldOptions === null || oldOptions === void 0 ? void 0 : oldOptions.groupBy) !== null && _ref !== void 0 ? _ref : 'default',
        sortBy: (_ref2 = (_options$sortBy = options.sortBy) !== null && _options$sortBy !== void 0 ? _options$sortBy : oldOptions === null || oldOptions === void 0 ? void 0 : oldOptions.sortBy) !== null && _ref2 !== void 0 ? _ref2 : 'create-date',
        sortDescending: (_ref3 = (_options$sortDescendi = options.sortDescending) !== null && _options$sortDescendi !== void 0 ? _options$sortDescendi : oldOptions === null || oldOptions === void 0 ? void 0 : oldOptions.sortDescending) !== null && _ref3 !== void 0 ? _ref3 : false,
        showCompleted: (_ref4 = (_options$showComplete = options.showCompleted) !== null && _options$showComplete !== void 0 ? _options$showComplete : oldOptions === null || oldOptions === void 0 ? void 0 : oldOptions.showCompleted) !== null && _ref4 !== void 0 ? _ref4 : false
      };
      filterGroups.set(filterGroup, newOptions);
      privates.eventEmitter.emit('update-setting', {
        type: 'update-setting',
        name: "filterGroups.".concat(filterGroup),
        value: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(newOptions)
      });
    }
    /**
     * Reset all settings to their default values.
     * @fires module:settings~Settings~updateSetting
     */

  }, {
    key: "resetToDefault",
    value: function resetToDefault() {
      var _this2 = this;

      this.storageMethod = 'local';
      this.setDateFormat('local');
      this.deleteAfter = 14;
      var filterOptions = {
        groupBy: 'default',
        sortBy: 'create-date',
        sortDescending: false,
        showCompleted: false
      };
      ['default', 'dates', 'projects', 'priorities'].forEach(function (group) {
        _this2.setFilterOptions(group, filterOptions);
      });
    }
    /**
     * Set the pattern used for formatting and parsing dates.
     * @param {string|module:settings~Settings~dateFormat} [format=local] The
     *   type of date format to use. This can either be a string specifying the
     *   format type ('local', 'iso', 'month-day-year', 'day-month-year', or
     *   'year-month-day'), or it can be a full
     *   [dateFormat]{@link module:settings~Settings~dateFormat} object.
     * @fires module:settings~Settings~updateSetting
     */

  }, {
    key: "setDateFormat",
    value: function setDateFormat() {
      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var privates = privateMembers.get(this);

      if (typeof format === 'string') {
        privates.dateFormat = Settings.lookupDateFormat(format);
      } else {
        privates.dateFormat = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(format);
      }

      privates.eventEmitter.emit('update-setting', {
        type: 'update-setting',
        name: 'dateFormat',
        value: this.dateFormat
      });
    }
    /**
     * Retrieve formatting information for a particular date format.
     * @param {string} [type=local] The type of date format to lookup: 'local',
     *   'iso', 'month-day-year', 'day-month-year', or 'year-month-day'.
     * @returns {module:settings~Settings~dateFormat} An object holding
     *   information about the date format.
     */

  }, {
    key: "addEventListener",
    value:
    /**
     * Add an event listener to settings instance.
     * @param {string} type The type of event to listen for.
     * @param {Function} listener A callback function to be invoked when the
     *   event is triggered.
     */
    function addEventListener(type, listener) {
      privateMembers.get(this).eventEmitter.on(type, listener);
    }
    /**
     * Convert data to an object suitable for serialization.
     * @returns {Object} An object representing serializable data for the class.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var result = {
        storageMethod: this.storageMethod,
        dateFormat: this.dateFormat,
        deleteAfter: this.deleteAfter,
        filterGroups: {}
      };
      privateMembers.get(this).filterGroups.forEach(function (options, group) {
        result.filterGroups[group] = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(options);
      });
      return result;
    }
    /**
     * Import settings from a JSON object.
     * @param {Object} data The serialized JSON object to import.
     * @returns {module:settings~Settings~importStatus} An object holding
     *   information about the status of the import.
     * @fires module:settings~Settings~updateSetting
     */

  }, {
    key: "importFromJson",
    value: function importFromJson(data) {
      var _this3 = this;

      var errors = [];

      var handleError = function handleError(errorType, value, options) {
        if (value == null) return;

        switch (errorType) {
          case 'bad-type':
            errors.push("Error: Expected type \"".concat(options.expectedType, "\" for setting \"").concat(options.valueName, "\" (received \"").concat((0,_utility_data__WEBPACK_IMPORTED_MODULE_2__.getJsonType)(value), "\")."));
            break;

          case 'unknown-value':
            errors.push("Error: Unrecognized value \"".concat(value, "\" for setting \"").concat(options.valueName, "\"."));
            break;

          case 'not-integer':
            errors.push("Error: Value for setting \"".concat(options.valueName, "\" must be an integer (received \"").concat(value, "\")."));
            break;

          case 'too-low':
            errors.push("Error: Value for setting \"".concat(options.valueName, "\" cannot be below \"").concat(options.min, "\" (received \"").concat(value, "\")."));
            break;

          case 'too-high':
            errors.push("Error: Value for setting \"".concat(options.valueName, "\" cannot be above \"").concat(options.max, "\" (received \"").concat(value, "\")."));
            break;

          default:
            errors.push("Error: Encountered unrecognized error \"".concat(errorType, "\" for setting \"").concat(options.valueName, "\"."));
            break;
        }
      };

      if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_2__.validateValue)(data.storageMethod, {
        valueName: 'storageMethod',
        expectedType: 'string',
        expectedValues: ['none', 'local'],
        errorCallback: handleError
      })) this.storageMethod = data.storageMethod;

      if (data.dateFormat != null) {
        if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_2__.validateValue)(data.dateFormat.type, {
          valueName: 'dateFormat.type',
          expectedType: 'string',
          expectedValues: ['local', 'iso', 'month-day-year', 'day-month-year', 'year-month-day'],
          errorCallback: handleError
        })) this.setDateFormat(data.dateFormat.type);
      }

      if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_2__.validateValue)(data.deleteAfter, {
        valueName: 'deleteAfter',
        expectedType: 'number',
        requireInteger: true,
        min: 0,
        errorCallback: handleError
      })) this.deleteAfter = data.deleteAfter;

      if (data.filterGroups != null) {
        var processGroup = function processGroup(name) {
          var filterOptions = data.filterGroups[name];

          if (filterOptions != null) {
            var newOptions = {};
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_2__.validateValue)(filterOptions.groupBy, {
              valueName: "filterGroups.".concat(name, ".groupBy"),
              expectedType: 'string',
              expectedValues: ['default', 'due-date', 'priority', 'project', 'none'],
              errorCallback: handleError
            })) newOptions.groupBy = filterOptions.groupBy;
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_2__.validateValue)(filterOptions.sortBy, {
              valueName: "filterGroups.".concat(name, ".sortBy"),
              expectedType: 'string',
              expectedValues: ['name', 'due-date', 'create-date', 'priority', 'project'],
              errorCallback: handleError
            })) newOptions.sortBy = filterOptions.sortBy;
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_2__.validateValue)(filterOptions.sortDescending, {
              valueName: "filterGroups.".concat(name, ".sortDescending"),
              expectedType: 'boolean',
              errorCallback: handleError
            })) newOptions.sortDescending = filterOptions.sortDescending;
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_2__.validateValue)(filterOptions.showCompleted, {
              valueName: "filterGroups.".concat(name, ".showCompleted"),
              expectedType: 'boolean',
              errorCallback: handleError
            })) newOptions.showCompleted = filterOptions.showCompleted;

            _this3.setFilterOptions(name, newOptions);
          }
        };

        processGroup('default');
        processGroup('dates');
        processGroup('projects');
        processGroup('priorities');
      }

      return {
        errors: errors
      };
    }
  }], [{
    key: "lookupDateFormat",
    value: function lookupDateFormat() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';

      switch (type) {
        case 'iso':
          return {
            outputPattern: 'yyyy-MM-dd',
            inputPatterns: ['yyyy-MM-dd'],
            visualPattern: 'YYYY-MM-DD',
            type: type
          };

        case 'month-day-year':
          return {
            outputPattern: 'MM/dd/yyyy',
            inputPatterns: ['MM/dd/yy', 'MM/dd/yyyy'],
            visualPattern: 'MM/DD/YYYY',
            type: type
          };

        case 'day-month-year':
          return {
            outputPattern: 'dd/MM/yyyy',
            inputPatterns: ['dd/MM/yy', 'dd/MM/yyyy'],
            visualPattern: 'DD/MM/YYYY',
            type: type
          };

        case 'year-month-day':
          return {
            outputPattern: 'yyyy/MM/dd',
            inputPatterns: ['yy/MM/dd', 'yyyy/MM/dd'],
            visualPattern: 'YYYY/MM/DD',
            type: type
          };

        case 'local':
        default:
          {
            var formatOpts = {
              tokenStyle: 'internal',
              fullYear: false,
              padMonths: true,
              padDays: true
            };
            var inputPatterns = [(0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.getDateFormat)(null, formatOpts)];
            formatOpts.fullYear = true;
            var outputPattern = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.getDateFormat)(null, formatOpts);
            inputPatterns.push(outputPattern);
            formatOpts.tokenStyle = 'visual';
            var visualPattern = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.getDateFormat)(null, formatOpts);
            return {
              outputPattern: outputPattern,
              inputPatterns: inputPatterns,
              visualPattern: visualPattern,
              type: 'local'
            };
          }
      }
    }
  }]);

  return Settings;
}();

/* harmony default export */ __webpack_exports__["default"] = (Settings);

/***/ }),

/***/ "./src/modules/task.js":
/*!*****************************!*\
  !*** ./src/modules/task.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _recurringDate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./recurringDate */ "./src/modules/recurringDate.js");
/* harmony import */ var _utility_dates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utility/dates */ "./src/modules/utility/dates.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [Task]{@link module:task~Task} class.
 * @module task
 */


/**
 * Represents a task.
 */

var Task = /*#__PURE__*/function () {
  /**
   * Create a task.
   * @param {string} name The name of the task.
   * @param {Object} [options={}] An object specifying additional options for
   *   the task.
   * @param {Date} [options.dueDate] The date when the task is due, if any.
   * @param {Date} [options.creationDate] The date the task was created. If not
   *   given, then the present date is used.
   * @param {Date} [options.completionDate] The date when the task was
   *   completed, if any.
   * @param {number|string} [options.priority=0] The priority of the task. For
   *   numeric values, a larger value indicates a higher priority, with 0
   *   representing medium priority, positive values representing higher-than-
   *   medium priority, and negative values representing lower-than-medium
   *   priority. For string values, possible settings are 'very-low', 'low',
   *   'medium', 'high', and 'very-high'.
   * @param {string} [options.description] A description for the task.
   * @param {module:recurringDate~RecurringDate} [options.recurringDate] A
   *   recurring date for the task, if any.
   * @param {string} [options.project] The identifier of the project to which
   *   the task belongs, if any.
   */
  function Task(name) {
    var _options$description;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Task);

    /**
     * The name of the task.
     * @type {string}
     */
    this.name = name;
    /**
     * The date when the task is due, if any.
     * @type {?Date}
     */

    this.dueDate = options.dueDate || null;
    /**
     * The date when the task was created.
     * @type {Date}
     */

    this.creationDate = options.creationDate || new Date();
    /**
     * The date when the task was completed, or null if it is not completed.
     * @type {?Date}
     */

    this.completionDate = options.completionDate || null;
    /**
     * The priority of the task. A larger value indicates a higher priority,
     * with 0 representing medium priority. Positive values are higher than
     * medium, and negative values are lower than medium.
     * @type {number}
     */

    this.priority = 0;

    if (typeof options.priority === 'number') {
      this.priority = options.priority;
    } else if (typeof options.priority === 'string') {
      this.priorityString = options.priority;
    }
    /**
     * An optional description of the task.
     * @type {?string}
     */


    this.description = (_options$description = options.description) !== null && _options$description !== void 0 ? _options$description : null;
    /**
     * A recurring date for the task, if any.
     * @type {?module:recurringDate~RecurringDate}
     */

    this.recurringDate = options.recurringDate || null;
    /**
     * The identifier of the project to which this task belongs, if any.
     * @type {?string}
     */

    this.project = options.project || null;
  }
  /**
   * The priority of the task represented as a string value. This corresponds
   * to the numerical [priority]{@link module:task~Task~priority} property,
   * with the following correspondence: 'very-low' = -2, 'low' = -1, 'medium' =
   * 0, 'high' = 1, and 'very-high' = 2.
   * @type {string}
   */


  _createClass(Task, [{
    key: "priorityString",
    get: function get() {
      return Task.convertPriorityToString(this.priority);
    },
    set: function set(priority) {
      this.priority = Task.convertStringToPriority(priority);
    }
    /**
     * Mark the task as completed.
     * @param {Date} [date] The date and time of completion. If not given, then
     *   the present time is used.
     */

  }, {
    key: "markComplete",
    value: function markComplete(date) {
      this.completionDate = date || new Date();
    }
    /**
     * Mark the task as incomplete.
     */

  }, {
    key: "markIncomplete",
    value: function markIncomplete() {
      this.completionDate = null;
    }
    /**
     * Determine whether or not the task has been completed.
     * @returns {boolean} True if the task has been completed and false
     *   otherwise.
     */

  }, {
    key: "isComplete",
    value: function isComplete() {
      return Boolean(this.completionDate);
    }
    /**
     * Get a string representation of the task.
     * @returns {string} A string representation of the task.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this.name ? "Task: ".concat(this.name) : 'Task: (untitled)';
    }
    /**
     * Create a task from a JSON object.
     * @param {Object} data The JSON object holding the serialized data.
     * @returns {module:task~Task} A new task converted from the JSON data.
     */

  }], [{
    key: "fromJson",
    value: function fromJson(data) {
      var convertDate = function convertDate(date) {
        return date ? (0,_utility_dates__WEBPACK_IMPORTED_MODULE_1__.parseIsoDateTime)(date) : null;
      };

      var recurringDate = data.recurringDate ? _recurringDate__WEBPACK_IMPORTED_MODULE_0__["default"].fromJson(data.recurringDate) : null;
      return new Task(data.name, {
        dueDate: convertDate(data.dueDate),
        creationDate: convertDate(data.creationDate),
        completionDate: convertDate(data.completionDate),
        priority: data.priority,
        description: data.description,
        recurringDate: recurringDate,
        project: data.project
      });
    }
    /**
     * Convert a task priority number to a string representation.
     * @param {number} priority The priority value to convert.
     * @returns {string} The string representation of the priority value.
     */

  }, {
    key: "convertPriorityToString",
    value: function convertPriorityToString(priority) {
      switch (priority) {
        case -2:
          return 'very-low';

        case -1:
          return 'low';

        case 0:
          return 'medium';

        case 1:
          return 'high';

        case 2:
          return 'very-high';

        default:
          return 'unknown';
      }
    }
    /**
     * Convert a task priority number to a string representation. Unlike
     * [convertPriorityToString]{@link module:task~Task.convertPriorityToString},
     * this method returns a string that is suitable for display to the user.
     * @param {number} priority The priority value to convert.
     * @returns {string} The string representation of the priority value.
     */

  }, {
    key: "convertPriorityToPrettyString",
    value: function convertPriorityToPrettyString(priority) {
      switch (priority) {
        case -2:
          return 'Very Low';

        case -1:
          return 'Low';

        case 0:
          return 'Medium';

        case 1:
          return 'High';

        case 2:
          return 'Very High';

        default:
          return 'Unknown';
      }
    }
    /**
     * Convert a string representation of a task priority to the standard numeric
     * equivalent.
     * @param {string} priorityStr The string representation of the priority to
     *   convert.
     * @returns {number} The priority value corresponding to the string.
     */

  }, {
    key: "convertStringToPriority",
    value: function convertStringToPriority(priorityStr) {
      switch (priorityStr.toLowerCase()) {
        case 'very-low':
        case 'very low':
          return -2;

        case 'low':
          return -1;

        case 'medium':
          return 0;

        case 'high':
          return 1;

        case 'very-high':
        case 'very high':
          return 2;

        default:
          return 0;
      }
    }
  }]);

  return Task;
}();

/* harmony default export */ __webpack_exports__["default"] = (Task);

/***/ }),

/***/ "./src/modules/taskDisplay.js":
/*!************************************!*\
  !*** ./src/modules/taskDisplay.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isSameDay/index.js");
/* harmony import */ var _popupMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./popupMenu */ "./src/modules/popupMenu.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings */ "./src/modules/settings.js");
/* harmony import */ var _task__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./task */ "./src/modules/task.js");
/* harmony import */ var _utility_dates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utility/dates */ "./src/modules/utility/dates.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utility/dom */ "./src/modules/utility/dom.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [TaskDisplay]{@link module:taskDisplay~TaskDisplay} class.
 * @module taskDisplay
 */






var CHECKED_ICON = 'check_circle_outline';
var UNCHECKED_ICON = 'radio_button_unchecked';
var STANDARD_MENU_ITEMS = [{
  label: 'Edit Task...',
  id: 'edit',
  iconType: 'edit'
}, {
  label: 'Clone Task',
  id: 'clone',
  iconType: 'content_copy'
}, {
  label: 'Delete Task...',
  id: 'delete',
  iconType: 'delete'
}];
var PROJECT_MENU_ITEMS = [{
  label: 'Go To Project',
  id: 'go-to-project',
  iconType: 'assignment'
}];
/**
 * Object holding private members for the
 * [TaskDisplay]{@link module:taskDisplay~TaskDisplay} class.
 * @typedef {Object} module:taskDisplay~TaskDisplay~privates
 * @property {HTMLElement} container The top-level container holding the
 *   display panel.
 * @property {HTMLElement} content The container holding the panel content.
 * @property {module:taskList~TaskList} tasks The task container.
 * @property {module:projectList~ProjectList} projects The project container.
 * @property {module:taskDisplay~TaskDisplay~taskCallback} [taskCallback] A
 *   callback function that is invoked when the user performs an action on a
 *   task.
 * @property {module:settings~Settings~dateFormat} dateFormat An object holding
 *   information about the format to use for calendar dates.
 * @property {module:popupMenu~PopupMenu} taskMenu The popup menu that is shown
 *   when the user clicks the 'more' button next to a task.
 */

/**
 * Holds private data for the
 * [TaskDisplay]{@link module:taskDisplay~TaskDisplay} class.
 * @type {WeakMap}
 * @see module:taskDisplay~TaskDisplay~privates
 */

var privateMembers = new WeakMap();
/**
 * Returns true if the two tasks belong to the same task group.
 * @param {string} groupBy The type of grouping being done: 'due-date',
 *   'project', 'priority', or 'none'.
 * @param {module:task~Task} task1 The first task to compare.
 * @param {module:task~Task} task2 The second task to compare.
 * @returns {boolean} True if the tasks belong to the same group and false
 *   otherwise.
 */

function isSameGroup(groupBy, task1, task2) {
  switch (groupBy) {
    case 'due-date':
      if (!task1.dueDate && !task2.dueDate) return true;
      if (!task1.dueDate && task2.dueDate) return false;
      if (task1.dueDate && !task2.dueDate) return false;
      return (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(task1.dueDate, task2.dueDate);

    case 'priority':
      return task1.priority === task2.priority;

    case 'project':
      if (!task1.project && !task2.project) return true;
      if (!task1.project && task2.project) return false;
      if (task1.project && !task2.project) return false;
      return task1.project === task2.project;

    case 'none':
    default:
      return true;
  }
}
/**
 * Empty the display panel.
 * @param {module:taskDisplay~TaskDisplay} instance The class instance on which
 *   to apply the function.
 */


function clear(instance) {
  privateMembers.get(instance).content.innerHTML = '';
}
/**
 * Add a list element and optional heading to the panel for holding tasks.
 * @param {module:taskDisplay~TaskDisplay} instance The class instance on which
 *   to apply the function.
 * @param {string} [label] The text content of the heading, if any.
 * @returns {HTMLElement} The list element where the task items can be
 *   inserted.
 */


function createList(instance, label) {
  var privates = privateMembers.get(instance);

  if (label) {
    var heading = document.createElement('h4');
    heading.classList.add('task-list-heading');
    heading.textContent = label;
    privates.content.appendChild(heading);
  }

  var list = document.createElement('ul');
  list.classList.add('task-list');
  privates.content.appendChild(list);
  return list;
}
/**
 * Add a task entry to a group list.
 * @param {module:taskDisplay~TaskDisplay} instance The class instance on which
 *   to apply the function.
 * @param {HTMLElement} list The list element in which the task information
 *   should be inserted.
 * @param {string} taskId The identifier for the task.
 * @param {module:task~Task} task The task to be added.
 */


function addTask(instance, list, taskId, task) {
  var privates = privateMembers.get(instance);
  var itemElem = document.createElement('li');
  itemElem.classList.add('task-list-item');
  list.appendChild(itemElem);
  var iconType = task.isComplete() ? CHECKED_ICON : UNCHECKED_ICON;
  var checkButton = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_4__.createIconButton)(iconType, {
    classList: ['task-list-item-checkbox']
  });
  itemElem.appendChild(checkButton);

  if (privates.taskCallback) {
    checkButton.addEventListener('click', function () {
      var type = task.isComplete() ? 'mark-incomplete' : 'mark-complete';
      privates.taskCallback(type, taskId, task);
    });
  }

  var infoContainer = document.createElement('div');
  infoContainer.classList.add('task-list-item-info-container');
  itemElem.appendChild(infoContainer);
  var nameElem = document.createElement('div');
  nameElem.classList.add('task-list-item-name');
  nameElem.textContent = task.name;
  infoContainer.appendChild(nameElem);

  if (task.description) {
    var descElem = document.createElement('div');
    descElem.classList.add('task-list-item-description');
    descElem.textContent = task.description;
    infoContainer.appendChild(descElem);
  }

  var detailsContainer = document.createElement('div');
  infoContainer.appendChild(detailsContainer);

  var addDetail = function addDetail(content, styleClass) {
    if (detailsContainer.hasChildNodes()) {
      var comma = document.createElement('span');
      comma.classList.add('task-list-item-details');
      comma.textContent = ', ';
      detailsContainer.appendChild(comma);
    }

    var detail = document.createElement('span');
    detail.classList.add('task-list-item-details', styleClass);
    detail.textContent = content;
    detailsContainer.appendChild(detail);
  };

  if (task.dueDate) {
    var dateFormat = privates.dateFormat.outputPattern;
    var dateStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.formatDate)(task.dueDate, dateFormat);
    addDetail(dateStr, 'task-list-item-due-date');
  }

  if (task.recurringDate) {
    var recurrenceStr = task.recurringDate.toString();
    addDetail(recurrenceStr, 'task-list-item-recurring-date');
  }

  if (task.project) {
    var project = privates.projects.getProject(task.project);
    addDetail(project.name, 'task-list-item-project');
  }

  var priorityStr = _task__WEBPACK_IMPORTED_MODULE_2__["default"].convertPriorityToPrettyString(task.priority);
  addDetail("".concat(priorityStr, " Priority"), 'task-list-item-priority');
  var buttonContainer = document.createElement('div');
  buttonContainer.classList.add('icon-container');
  itemElem.appendChild(buttonContainer);
  var editButton = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_4__.createIconButton)('edit');
  buttonContainer.appendChild(editButton);
  editButton.addEventListener('click', function () {
    if (privates.taskCallback) privates.taskCallback('edit', taskId, task);
  });
  var moreButton = (0,_utility_dom__WEBPACK_IMPORTED_MODULE_4__.createIconButton)('more_horiz');
  buttonContainer.appendChild(moreButton);
  moreButton.addEventListener('click', function (e) {
    privates.taskMenu.open(function (id) {
      if (privates.taskCallback) {
        privates.taskCallback(id, taskId, task);
      }
    }, {
      referenceElement: e.target
    });
  });
}
/**
 * Get the heading label for a task group.
 * @param {module:taskDisplay~TaskDisplay} instance The class instance on which
 *   to apply the function.
 * @param {string} groupBy The type of grouping being done: 'due-date',
 *   'project', 'priority', or 'none'.
 * @param {module:task~Task} task A task belonging to the group.
 * @returns {?string} The label for the heading, or null if no grouping is
 *   being done.
 */


function getGroupHeading(instance, groupBy, task) {
  var privates = privateMembers.get(instance);

  switch (groupBy) {
    case 'due-date':
      if (task.dueDate) {
        var format = privates.dateFormat.outputPattern;
        return (0,_utility_dates__WEBPACK_IMPORTED_MODULE_3__.formatDate)(task.dueDate, format);
      }

      return 'No Due Date';

    case 'priority':
      return "".concat(_task__WEBPACK_IMPORTED_MODULE_2__["default"].convertPriorityToPrettyString(task.priority), " Priority");

    case 'project':
      if (task.project) return privates.projects.getProject(task.project).name;
      return 'Uncategorized';

    case 'none':
    default:
      return null;
  }
}
/**
 * A display panel showing a list of tasks.
 */


var TaskDisplay = /*#__PURE__*/function () {
  /**
   * Callback function that is invoked when the user chooses to perform an
   * action on a task.
   * @callback module:taskDisplay~TaskDisplay~taskCallback
   * @param {string} type The type of action that is being performed:
   *   'mark-complete', 'mark-incomplete', 'edit', 'clone', 'delete', or
   *   'go-to-project'.
   * @param {string} id The identifier for the task on which the action is
   *   being performed.
   * @param {module:task~Task} task The task on which the action is being
   *   performed.
   */

  /**
   * An object holding options for creating the task display panel.
   * @typedef {Object} module:taskDisplay~TaskDisplay~options
   * @property {module:taskDisplay~TaskDisplay~taskCallback} [taskCallback] A
   *   callback function that will be invoked when the user performs an action
   *   on a task.
   */

  /**
   * An object holding options for updating the task display panel.
   * @typedef {Object} module:taskDisplay~TaskDisplay~updateOptions
   * @property {Date} [startDate] If provided, tasks with due dates before the
   *   given date will be excluded.
   * @property {Date} [endDate] If provided, tasks with due dates after the
   *   given date will be excluded.
   * @property {boolean} [completed=false] If set to true, then completed tasks
   *   will be included.
   * @property {boolean} [requireDueDate=false] If set to true, then tasks that
   *   do not have a due date will be excluded.
   * @property {string} [project] If provided, then only tasks with the
   *   specified project will be included. This can either be a project
   *   identifier, or the string 'none'.
   * @property {number} [priority] If provided, then only tasks with the given
   *   priority will be included.
   * @property {string} [groupBy=none] The field to group the tasks by:
   *   'due-date', 'priority', 'project', or 'none'.
   * @property {string} [sortBy=create-date] The primary field to sort the
   *   tasks by: 'name', 'due-date', 'create-date', 'priority', or 'project'.
   * @property {boolean} [sortDescending=false] If set to true, then results
   *   will be sorted in descending order.
   * @property {boolean} [caseSensitive=false] If set to true, then sorting for
   *   text-based fields will be case-sensitive.
   * @property {boolean} [missingLast=false] If set to true, then tasks that
   *   are missing a certain field will be sorted at the end of the list, when
   *   sorting by that field.
   * @property {boolean} [resetScroll=true] If set to true (the default), the
   *   panel's scroll position will be reset back to the top. Otherwise the
   *   scroll position will not be changed.
   * @property {module:settings~Settings~dateFormat} [dateFormat] An object
   *   holding information about the calendar date format to use when
   *   displaying dates.
   */

  /**
   * Create a task display.
   * @param {HTMLElement} parent The parent DOM node that will contain the
   *   panel.
   * @param {module:taskList~TaskList} taskList The
   *   [TaskList]{@link module:taskList~TaskList} holding all of the tasks.
   * @param {module:projectList~ProjectList} projectList The
   *   [ProjectList]{@link module:projectList~ProjectList} holding all of the
   *   projects.
   * @param {module:taskDisplay~TaskDisplay~options} [options={}] An object
   *   holding additional options for the display panel.
   */
  function TaskDisplay(parent, taskList, projectList) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, TaskDisplay);

    var panel = document.createElement('div');
    panel.classList.add('task-panel');
    parent.appendChild(panel);
    var content = document.createElement('div');
    content.classList.add('task-panel-content');
    panel.appendChild(content);
    var privates = {
      container: panel,
      content: content,
      tasks: taskList,
      projects: projectList,
      taskCallback: options.taskCallback || null,
      dateFormat: _settings__WEBPACK_IMPORTED_MODULE_1__["default"].lookupDateFormat('iso'),
      taskMenu: null
    };
    privateMembers.set(this, privates);
    privates.taskMenu = new _popupMenu__WEBPACK_IMPORTED_MODULE_0__["default"]({
      closeIfScrolled: panel
    });
  }
  /**
   * Refresh the display panel with a new list of tasks.
   * @param {module:taskDisplay~TaskDisplay~updateOptions} [options={}] An
   *   object holding options for updating the panel.
   */


  _createClass(TaskDisplay, [{
    key: "update",
    value: function update() {
      var _options$dateFormat,
          _options$completed,
          _options$requireDueDa,
          _options$sortDescendi,
          _options$caseSensitiv,
          _options$missingLast,
          _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var privates = privateMembers.get(this);
      privates.dateFormat = (_options$dateFormat = options.dateFormat) !== null && _options$dateFormat !== void 0 ? _options$dateFormat : _settings__WEBPACK_IMPORTED_MODULE_1__["default"].lookupDateFormat();
      clear(this);
      var listOptions = {
        projectList: privates.projects,
        startDate: options.startDate || null,
        endDate: options.endDate || null,
        completed: (_options$completed = options.completed) !== null && _options$completed !== void 0 ? _options$completed : false,
        requireDueDate: (_options$requireDueDa = options.requireDueDate) !== null && _options$requireDueDa !== void 0 ? _options$requireDueDa : false,
        project: options.project || null
      };

      if (typeof options.priority === 'number') {
        listOptions.priority = options.priority;
      }

      var groupBy = options.groupBy || 'none';
      var descending = (_options$sortDescendi = options.sortDescending) !== null && _options$sortDescendi !== void 0 ? _options$sortDescendi : false;
      var caseSensitive = (_options$caseSensitiv = options.caseSensitive) !== null && _options$caseSensitiv !== void 0 ? _options$caseSensitiv : false;
      var missingLast = (_options$missingLast = options.missingLast) !== null && _options$missingLast !== void 0 ? _options$missingLast : false;

      var pushSortField = function pushSortField(field) {
        if (!listOptions.sortBy) listOptions.sortBy = [];
        listOptions.sortBy.push({
          field: field,
          descending: descending,
          caseSensitive: caseSensitive,
          missingLast: missingLast
        });
      };

      if (groupBy !== 'none') pushSortField(groupBy);
      if (options.sortBy) pushSortField(options.sortBy);
      if (options.sortBy !== 'create-date') pushSortField('create-date');
      var entries = privates.tasks.entries(listOptions);
      var list = null;
      var prevTask = null;
      entries.forEach(function (entry) {
        if (!prevTask || !isSameGroup(groupBy, entry.task, prevTask)) {
          list = createList(_this, getGroupHeading(_this, groupBy, entry.task));
        }

        addTask(_this, list, entry.id, entry.task);
        prevTask = entry.task;
      });

      if (entries.length === 0) {
        var message = document.createElement('div');
        message.classList.add('task-list-empty');
        message.textContent = 'No Tasks Found';
        privates.content.appendChild(message);
      } // Set menu items for the 'more' button


      if (options.project) {
        privates.taskMenu.setMenuItems(STANDARD_MENU_ITEMS);
      } else {
        var menuItems = [].concat(PROJECT_MENU_ITEMS, STANDARD_MENU_ITEMS);
        privates.taskMenu.setMenuItems(menuItems);
      } // Reset the scroll position


      if (options.resetScroll !== false) {
        privates.container.scrollTop = 0;
        privates.container.scrollLeft = 0;
      }
    }
  }]);

  return TaskDisplay;
}();

/* harmony default export */ __webpack_exports__["default"] = (TaskDisplay);

/***/ }),

/***/ "./src/modules/taskList.js":
/*!*********************************!*\
  !*** ./src/modules/taskList.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_sortedLastIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/sortedLastIndex */ "./node_modules/lodash/sortedLastIndex.js");
/* harmony import */ var lodash_sortedLastIndex__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_sortedLastIndex__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_sortedIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/sortedIndex */ "./node_modules/lodash/sortedIndex.js");
/* harmony import */ var lodash_sortedIndex__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_sortedIndex__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isBefore/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isSameDay/index.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _recurringDate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./recurringDate */ "./src/modules/recurringDate.js");
/* harmony import */ var _task__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./task */ "./src/modules/task.js");
/* harmony import */ var _utility_data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utility/data */ "./src/modules/utility/data.js");
/* harmony import */ var _utility_dates__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utility/dates */ "./src/modules/utility/dates.js");
/* harmony import */ var _utility_storage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utility/storage */ "./src/modules/utility/storage.js");





function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Defines the [TaskList]{@link module:taskList~TaskList} class.
 * @module taskList
 */








/**
 * Object holding private members for the
 * [TaskList]{@link module:taskList~TaskList} class.
 * @typedef {Object} module:taskList~TaskList~privates
 * @property {Map} tasks Holds a map associating UUIDs to tasks.
 * @property {Map} tasksByDueDate Holds a map associating ISO date strings to
 *   arrays of [taskWrapper]{@link module:taskList~TaskList~taskWrapper}
 *   objects based on the due dates of the tasks. Tasks with no due date are
 *   assigned to the array associated with the string 'none'.
 * @property {Map} tasksByProject Holds a map associating project identifiers
 *   to arrays of [taskWrapper]{@link module:taskList~TaskList~taskWrapper}
 *   objects based on the projects associated with the tasks. Tasks not
 *   belonging to any project are assigned to the array associated with the
 *   string 'none'.
 * @property {Map} tasksByPriority Holds a map associating priority numbers to
 *   arrays of [taskWrapper]{@link module:taskList~TaskList~taskWrapper}
 *   objects based on the priorities of the tasks.
 * @property {EventEmitter} eventEmitter Holds the event emitter which
 *   dispatches events to attached event listeners.
 */

/**
 * Holds private data for the [TaskList]{@link module:taskList~TaskList} class.
 * @type {WeakMap}
 * @see module:taskList~TaskList~privates
 */

var privateMembers = new WeakMap();
/**
 * Container holding a list of tasks.
 */

var TaskList = /*#__PURE__*/function () {
  /**
   * Wrapper object holding a task along with its UUID.
   * @typedef {Object} module:taskList~TaskList~taskWrapper
   * @property {string} id The unique identifier for the task.
   * @property {module:task~Task} task The task instance.
   */

  /**
   * Event that is fired when a task is added to the task list.
   * @event module:taskList~TaskList~addTask
   * @type {Object}
   * @property {string} type The event type: 'add-task'.
   * @property {string} id The unique identifier of the newly-added task.
   * @property {module:task~Task} task A copy of the newly-added task.
   */

  /**
   * Event that is fired when a task in the list is modified.
   * @event module:taskList~TaskList~updateTask
   * @type {Object}
   * @property {string} type The event type: 'update-task'.
   * @property {string} id The unique identifier of the updated task.
   * @property {module:task~Task} task A copy of the modified task.
   */

  /**
   * Event that is fired when a task in the list is deleted.
   * @event module:taskList~TaskList~deleteTask
   * @type {Object}
   * @property {string} type The event type: 'delete-task'.
   * @property {string} id The unique identifier for the deleted task.
   * @property {module:task~Task} task A copy of the task that was deleted.
   */

  /**
   * An object specifying options for sorting tasks.
   * @typedef {Object} module:taskList~TaskList~sortOptions
   * @property {string} field The field to sort by. Can be one of 'name',
   *   'due-date', 'create-date', 'priority', or 'project'.
   * @property {boolean} [descending=false] If set to true, then the tasks will
   *   be sorted in descending order, rather than in ascending order.
   * @property {boolean} [caseSensitive=false] If set to true, then the sorting
   *   will be case-sensitive (only applies to text-based fields).
   * @property {boolean} [missingLast=false] If set to true, then tasks that do
   *   not have the specified field will be sorted at the end (or at the
   *   beginning if descending is true). Otherwise, tasks that are missing the
   *   specified field are sorted at the beginning (or end if descending).
   */

  /**
   * An object holding information about the status of a data import.
   * @typedef {Object} module:taskList~TaskList~importStatus
   * @property {Object} tasks An object holding information about the number of
   *   tasks that were imported.
   * @property {number} tasks.added The number of new tasks that were added to
   *   the task list.
   * @property {number} tasks.updated The number of existing tasks in the task
   *   list that were updated.
   * @property {number} tasks.failed The number of tasks that failed to import.
   * @property {number} tasks.total The total number of tasks that were
   *   processed.
   * @property {Object} [projects] An object holding information about the
   *   number of projects that were imported. This is not used for JSON
   *   imports.
   * @property {number} projects.added The number of new projects that were
   *   added to the project list.
   * @property {number} projects.updated The number of existing projects in the
   *   project list that were updated.
   * @property {number} projects.failed The number of projects that failed to
   *   import.
   * @property {number} projects.total The total number of projects that were
   *   processed.
   * @property {string[]} errors An array of error messages describing any
   *   errors that occurred during the import.
   */

  /**
   * Create a task list.
   */
  function TaskList() {
    _classCallCheck(this, TaskList);

    var privates = {
      tasks: new Map(),
      tasksByDueDate: new Map(),
      tasksByProject: new Map(),
      tasksByPriority: new Map(),
      eventEmitter: new (events__WEBPACK_IMPORTED_MODULE_4___default())()
    };
    privateMembers.set(this, privates);
  }
  /**
   * Get a task in the task list. This method only returns a copy of the task,
   * not an actual reference to the task itself. To modify a task in the list,
   * use the [updateTask]{@link module:taskList~TaskList#updateTask} method.
   * @param {string} id The unique identifier of the task to retrieve.
   * @returns {?module:task~Task} The requested task, or undefined if it could
   *   not be found.
   */


  _createClass(TaskList, [{
    key: "getTask",
    value: function getTask(id) {
      var task = privateMembers.get(this).tasks.get(id);
      if (task) return lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task);
      return undefined;
    }
    /**
     * Update a task in the task list.
     * @param {string} id The unique identifier of the task to replace.
     * @param {module:task~Task} task The new task to associate with the given
     *   identifier.
     * @returns {boolean} Returns true if the task was replaced successfully. If
     *   the given id is invalid, returns false.
     * @fires module:taskList~TaskList~updateTask
     */

  }, {
    key: "updateTask",
    value: function updateTask(id, task) {
      var privates = privateMembers.get(this);
      var oldTask = privates.tasks.get(id);
      if (!oldTask) return false;

      var copy = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task);

      privates.tasks.set(id, copy);

      var updateIndex = function updateIndex(map, oldKey, newKey) {
        if (oldKey === newKey) {
          var entry = (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.findInMapArray)(map, newKey, function (elem) {
            return elem.id === id;
          });
          entry.task = copy;
        } else {
          (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.removeFromMapArrayBy)(map, oldKey, function (elem) {
            return elem.id === id;
          });
          (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.addToMapArray)(map, newKey, {
            id: id,
            task: copy
          });
        }
      };

      var oldKey = 'none';
      var newKey = 'none';
      if (oldTask.dueDate) oldKey = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.formatIsoDate)(oldTask.dueDate);
      if (copy.dueDate) newKey = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.formatIsoDate)(copy.dueDate);
      updateIndex(privates.tasksByDueDate, oldKey, newKey);
      oldKey = oldTask.project || 'none';
      newKey = copy.project || 'none';
      updateIndex(privates.tasksByProject, oldKey, newKey);
      oldKey = oldTask.priority;
      newKey = copy.priority;
      updateIndex(privates.tasksByPriority, oldKey, newKey);
      privates.eventEmitter.emit('update-task', {
        type: 'update-task',
        id: id,
        task: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task)
      });
      return true;
    }
    /**
     * Add or update a task. If a task with the given identifier exists, then it
     * is replaced with the given task. Otherwise, the task is added to the list
     * as a new task. If the given identifier is not a valid UUID, then the
     * method returns false and nothing happens.
     * @param {string} id The unique identifier of the task.
     * @param {module:task~Task} task The task that should be added or with which
     *   an existing task should be replaced.
     * @returns {boolean} True if the task was successfully added or updated, or
     *   false if the given identifier is not a valid UUID.
     * @fires module:taskList~TaskList~addTask
     * @fires module:taskList~TaskList~updateTask
     */

  }, {
    key: "addOrUpdateTask",
    value: function addOrUpdateTask(id, task) {
      if (!(0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.isUuidValid)(id)) return false;

      if (!this.updateTask(id, task)) {
        var privates = privateMembers.get(this); // Add task to task map

        var copy = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task);

        privates.tasks.set(id, copy); // Add task to lookup maps

        var wrapper = {
          id: id,
          task: copy
        };
        var dateStr = 'none';
        if (task.dueDate) dateStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.formatIsoDate)(task.dueDate);
        var projectStr = task.project || 'none';
        var priority = task.priority;
        (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.addToMapArray)(privates.tasksByDueDate, dateStr, _objectSpread({}, wrapper));
        (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.addToMapArray)(privates.tasksByProject, projectStr, _objectSpread({}, wrapper));
        (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.addToMapArray)(privates.tasksByPriority, priority, _objectSpread({}, wrapper));
        privates.eventEmitter.emit('add-task', {
          type: 'add-task',
          id: id,
          task: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task)
        });
      }

      return true;
    }
    /**
     * Adds a task to the task list and returns its unique identifier. In order
     * to prevent unintentional external modification of the task, a deep copy is
     * made, and the original object is not kept.
     * @param {module:task~Task} task The task to be added.
     * @returns {string} The identifier of the newly-added task.
     * @fires module:taskList~TaskList~addTask
     */

  }, {
    key: "addTask",
    value: function addTask(task) {
      var privates = privateMembers.get(this); // Generate UUID (loop just in case there's a collision)

      var id;

      do {
        id = (0,uuid__WEBPACK_IMPORTED_MODULE_10__["default"])();
      } while (privates.tasks.has(id));

      this.addOrUpdateTask(id, task);
      return id;
    }
    /**
     * Determines whether a task with the given identifier exists within the task
     * list.
     * @param {string} id The unique identifier of the task to look for.
     * @returns {boolean} True if the task exists, and false otherwise.
     */

  }, {
    key: "hasTask",
    value: function hasTask(id) {
      return privateMembers.get(this).tasks.has(id);
    }
    /**
     * Remove a task from the task list.
     * @param {string} id The unique identifier of the task to remove.
     * @returns {boolean} Returns true if the task was found and removed
     *   successfully. Otherwise, if the given id was not found, returns false.
     * @fires module:taskList~TaskList~deleteTask
     */

  }, {
    key: "deleteTask",
    value: function deleteTask(id) {
      var privates = privateMembers.get(this);
      var task = privates.tasks.get(id);
      if (!task) return false;
      var dateStr = 'none';
      if (task.dueDate) dateStr = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.formatIsoDate)(task.dueDate);
      var projectStr = task.project || 'none';
      var priority = task.priority;
      privates.tasks.delete(id);
      (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.removeFromMapArrayBy)(privates.tasksByDueDate, dateStr, function (elem) {
        return elem.id === id;
      });
      (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.removeFromMapArrayBy)(privates.tasksByProject, projectStr, function (elem) {
        return elem.id === id;
      });
      (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.removeFromMapArrayBy)(privates.tasksByPriority, priority, function (elem) {
        return elem.id === id;
      });
      privates.eventEmitter.emit('delete-task', {
        type: 'delete-task',
        id: id,
        task: task
      });
      return true;
    }
    /**
     * Delete all tasks in the task list.
     * @fires module:taskList~TaskList~deleteTask
     */

  }, {
    key: "deleteAll",
    value: function deleteAll() {
      var privates = privateMembers.get(this); // Save task information in order to emit delete events later

      var tasks = [];
      privates.tasks.forEach(function (task, id) {
        return tasks.push({
          id: id,
          task: task
        });
      });
      privates.tasks.clear();
      privates.tasksByDueDate.clear();
      privates.tasksByProject.clear();
      privates.tasksByPriority.clear();
      tasks.forEach(function (_ref) {
        var id = _ref.id,
            task = _ref.task;
        privates.eventEmitter.emit('delete-task', {
          type: 'delete-task',
          id: id,
          task: task
        });
      });
    }
    /**
     * For each task belonging to a given project, remove the task from that
     * project. Afterward, there will be no tasks assigned to the project.
     * @param {string} projectId The unique identifier of the project to clear.
     * @fires module:taskList~TaskList~updateTask
     */

  }, {
    key: "clearProject",
    value: function clearProject(projectId) {
      var privates = privateMembers.get(this);
      var map = privates.tasksByProject;
      var tasks = map.get(projectId);
      if (!tasks) return; // Save modified tasks in order to emit events later

      var updatedTasks = [];
      tasks.forEach(function (entry) {
        var task = entry.task;
        task.project = null;
        (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.addToMapArray)(map, 'none', entry);
        updatedTasks.push(entry);
      });
      map.delete(projectId);
      updatedTasks.forEach(function (_ref2) {
        var id = _ref2.id,
            task = _ref2.task;
        privates.eventEmitter.emit('update-task', {
          type: 'update-task',
          id: id,
          task: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task)
        });
      });
    }
    /**
     * Execute the provided function on each task in the list. Note that the task
     * instance passed to the callback function is only a copy of the task in the
     * list.
     * @param {Function} callback The function to execute on each task. The
     *   function will be passed a
     *   [wrapper]{@link module:taskList~TaskList~taskWrapper} containing the
     *   task and its identifier.
     */

  }, {
    key: "forEach",
    value: function forEach(callback) {
      privateMembers.get(this).tasks.forEach(function (task, id) {
        var copy = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task);

        callback({
          id: id,
          task: copy
        });
      });
    }
    /**
     * Get an array of [taskWrapper]{@link module:taskList~TaskList~taskWrapper}
     * objects filtered and sorted according to the given options.
     * @param {Object} [options={}] An object holding options to control which
     *   tasks to include in the Iterator.
     * @param {module:projectList~ProjectList} [options.projectList] The project
     *   container. If not provided, then sorting by project will be disabled.
     * @param {Date} [options.startDate] If provided, all tasks with due dates
     *   before the given date will be excluded.
     * @param {Date} [options.endDate] If provided, all tasks with due dates
     *   after the given date will be excluded.
     * @param {boolean} [options.completed=false] If set to true, then tasks that
     *   have been completed will be included. Otherwise they are excluded.
     * @param {boolean} [options.requireDueDate=false] If set to true, then tasks
     *   that do not have a due date will be excluded.
     * @param {string} [options.project] If provided, only tasks belonging to the
     *   specified project will be included. If set to 'none', then only tasks
     *   that do not have a project assigned will be included.
     * @param {number} [options.priority] If provided, only tasks with the
     *   specified priority will be included.
     * @param {module:taskList~TaskList~sortOptions[]} [options.sortBy] An array
     *   of objects specifying the sort order. The first element in the array
     *   determines the primary field on which to sort the tasks, the second
     *   element determines the field used to break ties, the third element
     *   determines the field used to break further ties, and so on.
     * @returns {module:taskList~TaskList~taskWrapper[]} The array of
     *   [taskWrapper]{@link module:taskList~TaskList~taskWrapper} objects.
     */

  }, {
    key: "entries",
    value: function entries() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var privates = privateMembers.get(this);
      var sortBy = options.sortBy || []; // Which index to use: default | due-date | project | priority

      var lookupType = 'default';

      if (options.project) {
        lookupType = 'project';
      } else if (typeof options.priority === 'number') {
        lookupType = 'priority';
      } else if (options.startDate || options.endDate) {
        lookupType = 'due-date';
      }

      var output = [];

      var copyTasks = function copyTasks(map, key) {
        var tasks = map.get(key);
        if (tasks) tasks.forEach(function (task) {
          return output.push(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task));
        });
      };

      switch (lookupType) {
        case 'due-date':
          {
            var dates = _toConsumableArray(privates.tasksByDueDate.keys());

            dates.sort();
            var startKey = null;
            var endKey = null;

            if (options.startDate) {
              startKey = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.formatIsoDate)(options.startDate);
            }

            if (options.endDate) {
              endKey = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.formatIsoDate)(options.endDate);
            }

            var lowIndex = 0;
            var highIndex = dates.length;

            if (startKey) {
              lowIndex = lodash_sortedIndex__WEBPACK_IMPORTED_MODULE_2___default()(dates, startKey);
            }

            if (endKey) {
              highIndex = lodash_sortedLastIndex__WEBPACK_IMPORTED_MODULE_1___default()(dates, endKey);
            } else if (dates.length > 0 && dates[dates.length - 1] === 'none') {
              highIndex -= 1;
            }

            dates.slice(lowIndex, highIndex).forEach(function (key) {
              copyTasks(privates.tasksByDueDate, key);
            });
            copyTasks(privates.tasksByDueDate, 'none');
            break;
          }

        case 'priority':
          {
            copyTasks(privates.tasksByPriority, options.priority);
            break;
          }

        case 'project':
          copyTasks(privates.tasksByProject, options.project);
          break;

        case 'default':
        default:
          privates.tasks.forEach(function (task, id) {
            output.push({
              id: id,
              task: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task)
            });
          });
          break;
      }

      output = output.filter(function (entry) {
        var task = entry.task;

        if (task.dueDate) {
          if (options.startDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_11__["default"])(task.dueDate, options.startDate)) {
            return false;
          }

          if (options.endDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_11__["default"])(options.endDate, task.dueDate)) {
            return false;
          }
        }

        if (!options.completed && task.isComplete()) return false;
        if (options.requireDueDate && !task.dueDate) return false;

        if (options.project) {
          if (options.project === 'none' && task.project) return false;

          if (options.project !== 'none' && task.project !== options.project) {
            return false;
          }
        }

        if (typeof options.priority === 'number' && task.priority !== options.priority) {
          return false;
        }

        return true;
      });
      output = output.sort(function (a, b) {
        var leftTask = a.task;
        var rightTask = b.task;

        for (var index = 0; index < sortBy.length; index += 1) {
          var _sortBy$index$caseSen, _sortBy$index$descend, _sortBy$index$missing;

          var caseSensitive = (_sortBy$index$caseSen = sortBy[index].caseSensitive) !== null && _sortBy$index$caseSen !== void 0 ? _sortBy$index$caseSen : false;
          var descending = (_sortBy$index$descend = sortBy[index].descending) !== null && _sortBy$index$descend !== void 0 ? _sortBy$index$descend : false;
          var missingLast = (_sortBy$index$missing = sortBy[index].missingLast) !== null && _sortBy$index$missing !== void 0 ? _sortBy$index$missing : false;
          var LESS = descending ? 1 : -1;
          var MORE = descending ? -1 : 1;

          switch (sortBy[index].field) {
            case 'name':
              {
                var leftName = leftTask.name;
                var rightName = rightTask.name;

                if (!caseSensitive) {
                  leftName = leftName.toLowerCase();
                  rightName = rightName.toLowerCase();
                }

                if (leftName < rightName) return LESS;
                if (leftName > rightName) return MORE;
                break;
              }

            case 'due-date':
              {
                var leftDate = leftTask.dueDate;
                var rightDate = rightTask.dueDate;
                if (!leftDate && rightDate) return missingLast ? MORE : LESS;
                if (leftDate && !rightDate) return missingLast ? LESS : MORE;

                if (leftDate && rightDate && !(0,date_fns__WEBPACK_IMPORTED_MODULE_12__["default"])(leftDate, rightDate)) {
                  return (0,date_fns__WEBPACK_IMPORTED_MODULE_11__["default"])(leftDate, rightDate) ? LESS : MORE;
                }

                break;
              }

            case 'create-date':
              if ((0,date_fns__WEBPACK_IMPORTED_MODULE_11__["default"])(leftTask.creationDate, rightTask.creationDate)) {
                return LESS;
              }

              if ((0,date_fns__WEBPACK_IMPORTED_MODULE_11__["default"])(rightTask.creationDate, leftTask.creationDate)) {
                return MORE;
              }

              break;

            case 'priority':
              if (leftTask.priority > rightTask.priority) return LESS;
              if (leftTask.priority < rightTask.priority) return MORE;
              break;

            case 'project':
              {
                var leftProj = leftTask.project;
                var rightProj = rightTask.project;
                if (!leftProj && rightProj) return missingLast ? MORE : LESS;
                if (leftProj && !rightProj) return missingLast ? LESS : MORE;

                if (leftProj && rightProj) {
                  var projectList = options.projectList;
                  if (!projectList) break;
                  var _leftName = projectList.getProject(leftProj).name;
                  var _rightName = projectList.getProject(rightProj).name;

                  if (!caseSensitive) {
                    _leftName = _leftName.toLowerCase();
                    _rightName = _rightName.toLowerCase();
                  }

                  if (_leftName < _rightName) return LESS;
                  if (_leftName > _rightName) return MORE;
                }

                break;
              }

            default:
              return 0;
          }
        }

        return 0;
      });
      return output;
    }
    /**
     * Add an event listener to the task list.
     * @param {string} type The type of event to listen for.
     * @param {Function} listener A callback function to be invoked when the
     *   event is triggered.
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      privateMembers.get(this).eventEmitter.on(type, listener);
    }
    /**
     * Convert data to an object suitable for serialization.
     * @returns {Object} An object representing serializable data for the class.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var tasks = [];
      privateMembers.get(this).tasks.forEach(function (task, id) {
        var copy = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(task);

        copy.id = id;
        tasks.push(copy);
      });
      return tasks;
    }
    /**
     * Convert data to a string in CSV (comma-separated values) format.
     * @param {Object} [options={}] An object holding additional options.
     * @param {string} [options.newlineSequence] The character sequence to use
     *   for newlines. If not given, then a carriage return/line feed pair (CRLF)
     *   is used, as suggested by the
     *   [RFC 4180]{@link https://datatracker.ietf.org/doc/html/rfc4180}
     *   specification.
     * @param {module:projectList~ProjectList} [options.projectList] The project
     *   container. If not provided, then no project information besides the
     *   project identifier will be included in the CSV fields.
     * @returns {string} The task data in CSV format.
     */

  }, {
    key: "toCsv",
    value: function toCsv() {
      var _options$newlineSeque;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var projectFields = [];
      if (options.projectList) projectFields.push('Project Name');
      projectFields.push('Project UUID');
      if (options.projectList) projectFields.push('Project Description');
      var header = ['Name', 'UUID', 'Due Date', 'Date Added', 'Date Completed', 'Priority', 'Description'].concat(projectFields, ['Recurrence Interval Unit', 'Recurrence Interval Length', 'Recurrence Start Date', 'Recurrence Based on Completion?', 'Recurrence Week Number', 'Recurrence Week Days', 'Recurrence Month', 'Recurrence Day', 'Recurrence Weekend Behavior', 'Recurrence End Date', 'Recurrence Max Count']);
      var newlineSequence = (_options$newlineSeque = options.newlineSequence) !== null && _options$newlineSeque !== void 0 ? _options$newlineSeque : '\r\n';
      var csvOptions = {
        newlineSequence: newlineSequence
      };

      var convertDate = function convertDate(date) {
        var _date$toJSON;

        return (_date$toJSON = date === null || date === void 0 ? void 0 : date.toJSON()) !== null && _date$toJSON !== void 0 ? _date$toJSON : '';
      };

      var lines = [(0,_utility_storage__WEBPACK_IMPORTED_MODULE_9__.arrayToCsvRecord)(header, csvOptions)];
      privateMembers.get(this).tasks.forEach(function (task, id) {
        var _task$description, _recurringDate$interv, _recurringDate$baseOn, _recurringDate$weekNu, _recurringDate$weekNu2, _recurringDate$dayOfM, _recurringDate$dayOfM2, _recurringDate$maxCou, _recurringDate$maxCou2;

        var fields = [task.name, id, convertDate(task.dueDate), convertDate(task.creationDate), convertDate(task.completionDate), _task__WEBPACK_IMPORTED_MODULE_6__["default"].convertPriorityToPrettyString(task.priority), (_task$description = task.description) !== null && _task$description !== void 0 ? _task$description : ''];

        if (options.projectList) {
          var _project$name, _project, _task$project, _project$description, _project2;

          var project = null;

          if (task.project) {
            project = options.projectList.getProject(task.project);
          }

          fields.push((_project$name = (_project = project) === null || _project === void 0 ? void 0 : _project.name) !== null && _project$name !== void 0 ? _project$name : '', (_task$project = task.project) !== null && _task$project !== void 0 ? _task$project : '', (_project$description = (_project2 = project) === null || _project2 === void 0 ? void 0 : _project2.description) !== null && _project$description !== void 0 ? _project$description : '');
        } else {
          var _task$project2;

          fields.push((_task$project2 = task.project) !== null && _task$project2 !== void 0 ? _task$project2 : '');
        }

        var recurringDate = task.recurringDate;
        var intervalUnit = '';

        switch (recurringDate === null || recurringDate === void 0 ? void 0 : recurringDate.intervalUnit) {
          case 'day':
            intervalUnit = 'Day';
            break;

          case 'week':
            intervalUnit = 'Week';
            break;

          case 'month':
            intervalUnit = 'Month';
            break;

          case 'year':
            intervalUnit = 'Year';
            break;

          default:
            break;
        }

        var daysOfWeek = '';

        if (recurringDate !== null && recurringDate !== void 0 && recurringDate.daysOfWeek) {
          daysOfWeek = recurringDate.daysOfWeek.map(_utility_dates__WEBPACK_IMPORTED_MODULE_8__.getWeekdayName).join(', ');
        }

        var month = '';

        if (Number.isInteger(recurringDate === null || recurringDate === void 0 ? void 0 : recurringDate.month)) {
          month = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.getMonthName)(recurringDate.month);
        }

        var onWeekend = '';

        switch (recurringDate === null || recurringDate === void 0 ? void 0 : recurringDate.onWeekend) {
          case 'no-change':
            onWeekend = 'No Change';
            break;

          case 'previous-weekday':
            onWeekend = 'Use Previous Weekday';
            break;

          case 'next-weekday':
            onWeekend = 'Use Next Weekday';
            break;

          case 'nearest-weekday':
            onWeekend = 'Use Nearest Weekday';
            break;

          default:
            break;
        }

        fields.push(intervalUnit, (_recurringDate$interv = recurringDate === null || recurringDate === void 0 ? void 0 : recurringDate.intervalLength.toString()) !== null && _recurringDate$interv !== void 0 ? _recurringDate$interv : '', convertDate(recurringDate === null || recurringDate === void 0 ? void 0 : recurringDate.startDate), (_recurringDate$baseOn = recurringDate === null || recurringDate === void 0 ? void 0 : recurringDate.baseOnCompletion.toString()) !== null && _recurringDate$baseOn !== void 0 ? _recurringDate$baseOn : '', (_recurringDate$weekNu = recurringDate === null || recurringDate === void 0 ? void 0 : (_recurringDate$weekNu2 = recurringDate.weekNumber) === null || _recurringDate$weekNu2 === void 0 ? void 0 : _recurringDate$weekNu2.toString()) !== null && _recurringDate$weekNu !== void 0 ? _recurringDate$weekNu : '', daysOfWeek, month, (_recurringDate$dayOfM = recurringDate === null || recurringDate === void 0 ? void 0 : (_recurringDate$dayOfM2 = recurringDate.dayOfMonth) === null || _recurringDate$dayOfM2 === void 0 ? void 0 : _recurringDate$dayOfM2.toString()) !== null && _recurringDate$dayOfM !== void 0 ? _recurringDate$dayOfM : '', onWeekend, convertDate(recurringDate === null || recurringDate === void 0 ? void 0 : recurringDate.endDate), (_recurringDate$maxCou = recurringDate === null || recurringDate === void 0 ? void 0 : (_recurringDate$maxCou2 = recurringDate.maxCount) === null || _recurringDate$maxCou2 === void 0 ? void 0 : _recurringDate$maxCou2.toString()) !== null && _recurringDate$maxCou !== void 0 ? _recurringDate$maxCou : '');
        lines.push((0,_utility_storage__WEBPACK_IMPORTED_MODULE_9__.arrayToCsvRecord)(fields, csvOptions));
      });
      lines.push('');
      return lines.join(newlineSequence);
    }
    /**
     * Import tasks from a JSON object.
     * @param {Object} data The serialized JSON object to import.
     * @param {Object} [options={}] An object holding additional options for the
     *   import.
     * @param {module:projectList~ProjectList} [options.projectList] The project
     *   container. If not provided, then full validation will not be performed
     *   on project identifiers.
     * @returns {module:taskList~TaskList~importStatus} An object holding
     *   information about the status of the import.
     * @fires module:taskList~TaskList~addTask
     * @fires module:taskList~TaskList~updateTask
     */

  }, {
    key: "importFromJson",
    value: function importFromJson(data) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var counts = {
        added: 0,
        updated: 0,
        failed: 0,
        total: 0
      };
      var errors = [];

      if (!Array.isArray(data)) {
        errors.push('Error: Expected "tasks" property to be an array.');
        return {
          tasks: counts,
          errors: errors
        };
      }

      data.forEach(function (task) {
        var handleError = function handleError(errorType, value, opts) {
          if (value == null) return;
          var msgPrefix = "Warning: Task \"".concat(task.name, "\"");
          var msg;

          switch (errorType) {
            case 'bad-type':
              if (opts.allowConversion && typeof value === 'string') {
                msg = "Expected type \"".concat(opts.expectedType, "\" for property \"").concat(opts.valueName, "\" (conversion from type \"string\" failed).");
              } else {
                msg = "Expected type \"".concat(opts.expectedType, "\" for property \"").concat(opts.valueName, "\" (received \"").concat((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.getJsonType)(value), "\").");
              }

              break;

            case 'unknown-value':
              msg = "Unrecognized value \"".concat(value, "\" for property \"").concat(opts.valueName, "\".");
              break;

            case 'not-integer':
              msg = "Value for property \"".concat(opts.valueName, "\" must be an integer (received \"").concat(value, "\").");
              break;

            case 'too-low':
              msg = "Value for property \"".concat(opts.valueName, "\" cannot be below \"").concat(opts.min, "\" (received \"").concat(value, "\").");
              break;

            case 'too-high':
              msg = "Value for property \"".concat(opts.valueName, "\" cannot be above \"").concat(opts.max, "\" (received \"").concat(value, "\").");
              break;

            case 'bad-date':
              msg = "Expected a date in ISO format for property \"".concat(opts.valueName, "\" (received \"").concat(value, "\").");
              break;

            case 'bad-id':
              msg = "Expected a version 4 UUID for property \"".concat(opts.valueName, "\" (received \"").concat(value, "\").");
              break;

            case 'failed-predicate':
              if (opts.valueName === 'project') {
                msg = "Unrecognized project identifier \"".concat(value, "\" for property \"").concat(opts.valueName, "\".");
              } else {
                msg = "Failed custom validation for property \"".concat(opts.valueName, ".");
              }

              break;

            default:
              msg = "Encountered unrecognized error \"".concat(errorType, "\" for property \"").concat(opts.valueName, "\".");
              break;
          }

          errors.push("".concat(msgPrefix, ": ").concat(msg));
        };

        if (task.name == null) {
          errors.push('Error: Task must have a name.');
          counts.failed += 1;
        } else if (typeof task.name !== 'string') {
          errors.push("Error: Expected type \"string\" for task name (received \"".concat((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.getJsonType)(task.name), "\")."));
          counts.failed += 1;
        } else if (task.name.length === 0) {
          errors.push('Error: Task name must not be empty.');
          counts.failed += 1;
        } else {
          var taskOptions = {};
          var newId = null;
          if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.id, {
            valueName: 'id',
            expectedType: 'string',
            requireUuid: true,
            errorCallback: handleError
          })) newId = task.id;
          (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.dueDate, {
            valueName: 'dueDate',
            expectedType: 'date',
            allowConversion: true,
            successCallback: function successCallback(value) {
              taskOptions.dueDate = value;
            },
            errorCallback: handleError
          });
          (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.creationDate, {
            valueName: 'creationDate',
            expectedType: 'date',
            allowConversion: true,
            successCallback: function successCallback(value) {
              taskOptions.creationDate = value;
            },
            errorCallback: handleError
          });
          (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.completionDate, {
            valueName: 'completionDate',
            expectedType: 'date',
            allowConversion: true,
            successCallback: function successCallback(value) {
              taskOptions.completionDate = value;
            },
            errorCallback: handleError
          });

          if (task.priority != null) {
            var setPriority = function setPriority(value) {
              taskOptions.priority = value;
            };

            if (typeof task.priority === 'string') {
              (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.priority, {
                valueName: 'priority',
                expectedValues: ['very-low', 'low', 'medium', 'high', 'very-high'],
                successCallback: setPriority,
                errorCallback: handleError
              });
            } else {
              (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.priority, {
                valueName: 'priority',
                expectedType: 'number',
                requireInteger: true,
                successCallback: setPriority,
                errorCallback: handleError
              });
            }
          }

          if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.description, {
            valueName: 'description',
            expectedType: 'string',
            errorCallback: handleError
          })) taskOptions.description = task.description;

          if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.recurringDate, {
            valueName: 'recurringDate',
            expectedType: 'object',
            errorCallback: handleError
          }) && (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.recurringDate.intervalUnit, {
            valueName: 'recurringDate.intervalUnit',
            expectedType: 'string',
            expectedValues: ['day', 'week', 'month', 'year'],
            errorCallback: handleError
          })) {
            var recurringDate = task.recurringDate;
            var recOptions = {};
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.intervalLength, {
              valueName: 'recurringDate.intervalLength',
              expectedType: 'number',
              requireInteger: true,
              min: 1,
              errorCallback: handleError
            })) recOptions.intervalLength = recurringDate.intervalLength;
            (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.startDate, {
              valueName: 'recurringDate.startDate',
              expectedType: 'date',
              allowConversion: true,
              successCallback: function successCallback(value) {
                recOptions.startDate = value;
              },
              errorCallback: handleError
            });
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.baseOnCompletion, {
              valueName: 'recurringDate.baseOnCompletion',
              expectedType: 'boolean',
              errorCallback: handleError
            })) recOptions.baseOnCompletion = recurringDate.baseOnCompletion;
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.weekNumber, {
              valueName: 'recurringDate.weekNumber',
              expectedType: 'number',
              requireInteger: true,
              min: 1,
              max: 5,
              errorCallback: handleError
            })) recOptions.weekNumber = recurringDate.weekNumber;

            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.daysOfWeek, {
              valueName: 'recurringDate.daysOfWeek',
              expectedType: 'array',
              errorCallback: handleError
            })) {
              var daysOfWeek = [];
              recurringDate.daysOfWeek.forEach(function (value, index) {
                if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(value, {
                  valueName: "recurringDate.daysOfWeek[".concat(index, "]"),
                  expectedType: 'number',
                  requireInteger: true,
                  min: 0,
                  max: 6,
                  errorCallback: handleError
                })) daysOfWeek.push(value);
              });
              recOptions.daysOfWeek = daysOfWeek;
            }

            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.month, {
              valueName: 'recurringDate.month',
              expectedType: 'number',
              requireInteger: true,
              min: 0,
              max: 11,
              errorCallback: handleError
            })) recOptions.month = recurringDate.month;
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.dayOfMonth, {
              valueName: 'recurringDate.dayOfMonth',
              expectedType: 'number',
              requireInteger: true,
              min: 1,
              max: 31,
              errorCallback: handleError
            })) recOptions.dayOfMonth = recurringDate.dayOfMonth;
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.onWeekend, {
              valueName: 'recurringDate.onWeekend',
              expectedType: 'string',
              expectedValues: ['no-change', 'previous-weekday', 'next-weekday', 'nearest-weekday'],
              errorCallback: handleError
            })) recOptions.onWeekend = recurringDate.onWeekend;
            (0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.endDate, {
              valueName: 'recurringDate.endDate',
              expectedType: 'date',
              allowConversion: true,
              successCallback: function successCallback(value) {
                recOptions.endDate = value;
              },
              errorCallback: handleError
            });
            if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(recurringDate.maxCount, {
              valueName: 'recurringDate.maxCount',
              expectedType: 'number',
              requireInteger: true,
              min: 0,
              errorCallback: handleError
            })) recOptions.maxCount = recurringDate.maxCount;
            var recurrence = new _recurringDate__WEBPACK_IMPORTED_MODULE_5__["default"](task.recurringDate.intervalUnit, recOptions);
            taskOptions.recurringDate = recurrence;
          }

          if ((0,_utility_data__WEBPACK_IMPORTED_MODULE_7__.validateValue)(task.project, {
            valueName: 'project',
            expectedType: 'string',
            requireUuid: true,
            customPredicate: function customPredicate(value) {
              var projectList = options.projectList;
              return !projectList || projectList.hasProject(value);
            },
            errorCallback: handleError
          })) taskOptions.project = task.project;
          if (newId && _this.hasTask(newId)) counts.updated += 1;else counts.added += 1;
          var newTask = new _task__WEBPACK_IMPORTED_MODULE_6__["default"](task.name, taskOptions);
          if (newId) _this.addOrUpdateTask(newId, newTask);else _this.addTask(newTask);
        }
      });
      counts.total = counts.added + counts.updated + counts.failed;
      return {
        tasks: counts,
        errors: errors
      };
    }
    /**
     * Import tasks from parsed CSV data.
     * @param {string[][]} data An array of string arrays. Each member of the
     *   outer array represents a single task, and each member of each inner
     *   array is a data field for that particular task. The first member of the
     *   outer array should be a header holding field names.
     * @param {Object} [options={}] An object holding additional options for the
     *   import.
     * @param {module:projectList~ProjectList} [options.projectList] The project
     *   container. If not provided, then full validation will not be performed
     *   on project identifiers.
     * @returns {module:taskList~TaskList~importStatus} An object holding
     *   information about the status of the import.
     * @fires module:taskList~TaskList~addTask
     * @fires module:taskList~TaskList~updateTask
     */

  }, {
    key: "importFromCsv",
    value: function importFromCsv(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var header = data.length > 0 ? data[0] : [];
      var entries = [];
      data.forEach(function (csvRecord, csvIndex) {
        if (csvIndex === 0) return;
        var entry = {};
        var recurringDate = {};
        csvRecord.forEach(function (value, index) {
          if (index >= header.length || value.length === 0) return;

          switch (header[index].toLowerCase()) {
            case 'name':
              entry.name = value;
              break;

            case 'uuid':
              entry.id = value;
              break;

            case 'due date':
            case 'due-date':
              entry.dueDate = value;
              break;

            case 'date added':
            case 'date-added':
              entry.creationDate = value;
              break;

            case 'date completed':
            case 'date-completed':
              entry.completionDate = value;
              break;

            case 'priority':
              entry.priority = _task__WEBPACK_IMPORTED_MODULE_6__["default"].convertStringToPriority(value);
              break;

            case 'description':
              entry.description = value;
              break;

            case 'project uuid':
            case 'project-uuid':
              entry.project = value;
              break;

            case 'recurrence interval unit':
            case 'recurrence-interval-unit':
              recurringDate.intervalUnit = value.toLowerCase();
              break;

            case 'recurrence interval length':
            case 'recurrence-interval-length':
              recurringDate.intervalLength = Number(value);
              break;

            case 'recurrence start date':
            case 'recurrence-start-date':
              recurringDate.startDate = value;
              break;

            case 'recurrence based on completion?':
            case 'recurrence based on completion':
            case 'recurrence-based-on-completion':
              recurringDate.baseOnCompletion = value.toLowerCase() === 'true';
              break;

            case 'recurrence week number':
            case 'recurrence-week-number':
              recurringDate.weekNumber = Number(value);
              break;

            case 'recurrence week days':
            case 'recurrence-week-days':
              recurringDate.daysOfWeek = value.split(',').map(function (day) {
                return (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.getWeekdayIndex)(day.trim());
              }).filter(function (day) {
                return day != null;
              });
              break;

            case 'recurrence month':
            case 'recurrence-month':
              recurringDate.month = (0,_utility_dates__WEBPACK_IMPORTED_MODULE_8__.getMonthIndex)(value);
              break;

            case 'recurrence day':
            case 'recurrence-day':
              recurringDate.dayOfMonth = Number(value);
              break;

            case 'recurrence weekend behavior':
            case 'recurrence-weekend-behavior':
              {
                var behavior = null;

                switch (value.toLowerCase()) {
                  case 'no change':
                  case 'no-change':
                    behavior = 'no-change';
                    break;

                  case 'use previous weekday':
                  case 'previous weekday':
                  case 'previous-weekday':
                    behavior = 'previous-weekday';
                    break;

                  case 'use next weekday':
                  case 'next weekday':
                  case 'next-weekday':
                    behavior = 'next-weekday';
                    break;

                  case 'use nearest weekday':
                  case 'nearest weekday':
                  case 'nearest-weekday':
                    behavior = 'nearest-weekday';
                    break;

                  default:
                    break;
                }

                recurringDate.onWeekend = behavior;
                break;
              }

            case 'recurrence end date':
            case 'recurrence-end-date':
              recurringDate.endDate = value;
              break;

            case 'recurrence max count':
            case 'recurrence-max-count':
              recurringDate.maxCount = Number(value);
              break;

            default:
              break;
          }
        });
        if (!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default()(recurringDate)) entry.recurringDate = recurringDate;
        if (!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default()(entry)) entries.push(entry);
      });
      return this.importFromJson(entries, options);
    }
  }]);

  return TaskList;
}();

/* harmony default export */ __webpack_exports__["default"] = (TaskList);

/***/ }),

/***/ "./src/modules/utility/data.js":
/*!*************************************!*\
  !*** ./src/modules/utility/data.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addToMapArray": function() { return /* binding */ addToMapArray; },
/* harmony export */   "findInMapArray": function() { return /* binding */ findInMapArray; },
/* harmony export */   "getJsonType": function() { return /* binding */ getJsonType; },
/* harmony export */   "isUuidValid": function() { return /* binding */ isUuidValid; },
/* harmony export */   "removeFromMapArray": function() { return /* binding */ removeFromMapArray; },
/* harmony export */   "removeFromMapArrayBy": function() { return /* binding */ removeFromMapArrayBy; },
/* harmony export */   "validateValue": function() { return /* binding */ validateValue; }
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _dates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dates */ "./src/modules/utility/dates.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Defines functions for manipulating data.
 * @module data
 */


/**
 * Add a value to an array belonging to a Map having array values. If the given
 * key does not exist in the map, then a new array will be inserted at that
 * key.
 * @param {Map} map The map of arrays.
 * @param {*} key The key corresponding to the array in which the value is to
 *   be inserted.
 * @param {*} value The value to insert into the array.
 */

function addToMapArray(map, key, value) {
  var arr = map.get(key);

  if (!arr) {
    arr = [];
    map.set(key, arr);
  }

  arr.push(value);
}
/**
 * Find a value in an array belonging to a Map having array values. The first
 * value in the appropriate array for which the predicate returns true is
 * returned.
 * @param {Map} map The map of arrays.
 * @param {*} key The key corresponding to the array in which the element is to
 *   be found.
 * @param {Function} predicate The predicate function that will be used to find
 *   the array element. The function will be invoked for each element in the
 *   array associated with the given key. When invoked, the function will be
 *   passed the array element, the index of the element in the array, and the
 *   array itself, in that order, as arguments.
 * @return {*} The matching value, or undefined if not found.
 */


function findInMapArray(map, key, predicate) {
  var arr = map.get(key);
  if (!arr) return undefined;
  return arr.find(predicate);
}
/**
 * Remove a value from an array belonging to a Map having array values. This
 * function is similar to
 * [removeFromMapArray]{@link module:data~removeFromMapArray}, except that it
 * takes a predicate function instead of a value. The first value in the array
 * for which the predicate returns true is removed.
 * @param {Map} map The map of arrays.
 * @param {*} key The key corresponding to the array from which the value is to
 *   be removed.
 * @param {Function} predicate The predicate function that will be used to find
 *   a matching array element. The function will be invoked for each element in
 *   the array associated with the given key. When invoked, the function will
 *   be passed the array element, the index of the element in the array, and
 *   the array itself, in that order, as arguments.
 * @returns {boolean} Returns true if a value was successfully removed, or
 *   false if a matching array element could not be found.
 */


function removeFromMapArrayBy(map, key, predicate) {
  var arr = map.get(key);
  if (!arr) return false;
  var index = arr.findIndex(predicate);
  if (index < 0) return false;
  arr.splice(index, 1);
  if (arr.length === 0) map.delete(key);
  return true;
}
/**
 * Remove a value from an array belonging to a Map having array values.
 * @param {Map} map The map of arrays.
 * @param {*} key The key corresponding to the array from which the value is to
 *   be removed.
 * @param {*} value The value to remove from the array.
 * @returns {boolean} Returns true if the value was successfully removed, or
 *   false if a matching array element could not be found.
 */


function removeFromMapArray(map, key, value) {
  return removeFromMapArrayBy(map, key, function (elem) {
    return elem === value;
  });
}
/**
 * Get the type of a JSON value: 'object', 'array', 'string', 'number',
 * 'boolean', or 'null'. Types that are not supported in JSON, such as
 * functions or undefined, will return 'null'.
 * @param {*} value The value whose type is to be checked.
 * @returns {string} A string representation of the value's type.
 */


function getJsonType(value) {
  if (value == null) return 'null';

  switch (_typeof(value)) {
    case 'object':
      return Array.isArray(value) ? 'array' : 'object';

    case 'string':
    case 'number':
    case 'boolean':
      return _typeof(value);

    default:
      return 'null';
  }
}
/**
 * Determine whether a string is a valid version 4 UUID.
 * @param {string} id The string to test.
 * @returns {boolean} True if the UUID is valid, and false otherwise.
 */


function isUuidValid(id) {
  return typeof id === 'string' && (0,uuid__WEBPACK_IMPORTED_MODULE_1__["default"])(id) && (0,uuid__WEBPACK_IMPORTED_MODULE_2__["default"])(id) === 4;
}
/**
 * A callback function that will be invoked when a value passes validation.
 * @callback module:data~validationSuccess
 * @param {*} value The value that passed validation. If the allowConversion
 *   option was set, then this will be the converted value.
 * @param {Object} options An object specifying additional information.
 * @param {string} [options.valueName] The name for the data field that the
 *   value corresponds to.
 */

/**
 * A callback function that will be invoked when a value fails validation.
 * @callback module:data~validationError
 * @param {string} errorType A string specifying the type of error that
 *   occurred: 'bad-type' indicates a type error, 'unknown-value' indicates an
 *   unrecognized value, 'not-integer' indicates a value that is not an
 *   integer, 'too-low' indicates a value below the minimum, 'too-high'
 *   indicates a value above the maximum, 'bad-date' indicates an invalid date,
 *   'bad-id' indicates an invalid UUID, and 'failed-predicate' indicates that
 *   the value was rejected by the custom predicate function.
 * @param {*} value The value that failed validation.
 * @param {Object} options An object specifying the criteria that were used to
 *   validate the value.
 * @param {string} [options.valueName] The name for the data field that the
 *   value corresponds to.
 * @param {string} [options.expectedType] The expected type of the value.
 * @param {boolean} [options.allowConversion] Indicates whether conversion from
 *   string was allowed.
 * @param {string[]} [options.expectedValues] An array of acceptable strings
 *   that the value should have matched.
 * @param {boolean} [options.requireUuid] Indicates whether a UUID was
 *   required.
 * @param {boolean} [options.requireInteger] Indicates whether an integer was
 *   required.
 * @param {number} [options.min] The minimum acceptable value.
 * @param {number} [options.max] The maximum acceptable value.
 * @param {Function} [options.customPredicate] The custom predicate function
 *   that was used for validation.
 */

/**
 * An object specifying options for validating a value.
 * @typedef {Object} module:data~validationOptions
 * @property {string} [valueName] An optional name for the data field that the
 *   value is read from or being assigned to. This is passed to the callback
 *   functions but is otherwise ignored.
 * @property {string} [expectedType] The type that the value should have. This
 *   can be one of 'object', 'array', 'string', 'number', 'boolean', 'null', or
 *   'date'.
 * @property {boolean} [allowConversion=false] This property is used in
 *   conjunction with expectedType. If this is set to true, then the value is
 *   allowed to have string type as long as it can be converted to the expected
 *   type. Objects and arrays cannot be converted from string.
 * @property {string[]} [expectedValues] For string values, this property
 *   specifies an optional list of acceptable values. Values that do match an
 *   item in the given array will fail validation.
 * @property {boolean} [requireUuid=false] For string values, if this property
 *   is set to true, then the string must contain a UUID.
 * @property {boolean} [requireInteger=false] For values of number type, if
 *   this property is set to true, then the number must be an integer.
 * @property {number} [min] For numeric values, this property specifies the
 *   minimum acceptable value.
 * @property {number} [max] For numeric values, this property specifies the
 *   maximum acceptable value.
 * @property {Function} [customPredicate] A predicate function that can perform
 *   custom validation. If the value passes all other constraints, then it is
 *   passed to this function. The function should return true or false to
 *   indicate whether the value passes validation.
 * @property {module:data~validationSuccess} [successCallback] A callback
 *   function that will be invoked if the value passes validation.
 * @property {module:data~validationError} [errorCallback] A callback
 *   function that will be invoked if the value fails validation.
 */

/**
 * Validate a value according to a set of criteria.
 * @param {*} value The value to check.
 * @param {module:data~validationOptions} [options={}] An object specifying
 *   validation options.
 * @returns {boolean} True if the value passes validation, and false otherwise.
 */


function validateValue(value) {
  var _options$successCallb, _options$valueName2;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var fail = function fail(errorType) {
    var _options$errorCallbac, _options$valueName, _options$expectedType, _options$min, _options$max;

    (_options$errorCallbac = options.errorCallback) === null || _options$errorCallbac === void 0 ? void 0 : _options$errorCallbac.call(options, errorType, value, {
      valueName: (_options$valueName = options.valueName) !== null && _options$valueName !== void 0 ? _options$valueName : null,
      expectedType: (_options$expectedType = options.expectedType) !== null && _options$expectedType !== void 0 ? _options$expectedType : null,
      allowConversion: options.allowConversion || false,
      expectedValues: options.expectedValues || null,
      requireUuid: options.requireUuid || false,
      requireInteger: options.requireInteger || false,
      min: (_options$min = options.min) !== null && _options$min !== void 0 ? _options$min : null,
      max: (_options$max = options.max) !== null && _options$max !== void 0 ? _options$max : null,
      customPredicate: options.customPredicate || null
    });
  };

  var allowConversion = options.allowConversion || false;
  var convertedValue = value;

  if (options.expectedType) {
    if (options.expectedType !== 'null' && value == null) {
      fail('bad-type');
      return false;
    }

    switch (options.expectedType) {
      case 'string':
        if (typeof value !== 'string') {
          fail('bad-type');
          return false;
        }

        break;

      case 'number':
        if (typeof value !== 'number') {
          if (!allowConversion || typeof value !== 'string') {
            fail('bad-type');
            return false;
          }

          convertedValue = Number(value);
        }

        if (!Number.isFinite(convertedValue)) {
          fail('bad-type');
          return false;
        }

        break;

      case 'boolean':
        if (typeof value !== 'boolean') {
          if (!allowConversion || typeof value !== 'string') {
            fail('bad-type');
            return false;
          }

          switch (value.toLowerCase()) {
            case 'true':
              convertedValue = true;
              break;

            case 'false':
              convertedValue = false;
              break;

            default:
              fail('bad-type');
              return false;
          }
        }

        break;

      case 'null':
        if (value != null) {
          fail('bad-type');
          return false;
        }

        break;

      case 'date':
        if (!(value instanceof Date)) {
          if (!allowConversion || typeof value !== 'string') {
            fail('bad-type');
            return false;
          }

          convertedValue = (0,_dates__WEBPACK_IMPORTED_MODULE_0__.parseIsoDateTime)(value);
        }

        if (!(0,_dates__WEBPACK_IMPORTED_MODULE_0__.isDateValid)(convertedValue)) {
          fail('bad-date');
          return false;
        }

        break;

      default:
        if (getJsonType(value) !== options.expectedType) {
          fail('bad-type');
          return false;
        }

        break;
    }
  }

  if (typeof convertedValue === 'string') {
    if (options.expectedValues && !options.expectedValues.includes(convertedValue)) {
      fail('unknown-value');
      return false;
    }

    if (options.requireUuid && !isUuidValid(convertedValue)) {
      fail('bad-id');
      return false;
    }
  }

  if (typeof convertedValue === 'number') {
    if (options.requireInteger && !Number.isInteger(convertedValue)) {
      fail('not-integer');
      return false;
    }

    if (options.min != null && convertedValue < options.min) {
      fail('too-low');
      return false;
    }

    if (options.max != null && convertedValue > options.max) {
      fail('too-high');
      return false;
    }
  }

  if (options.customPredicate) {
    if (!options.customPredicate(convertedValue)) {
      fail('failed-predicate');
      return false;
    }
  }

  (_options$successCallb = options.successCallback) === null || _options$successCallb === void 0 ? void 0 : _options$successCallb.call(options, convertedValue, {
    valueName: (_options$valueName2 = options.valueName) !== null && _options$valueName2 !== void 0 ? _options$valueName2 : null
  });
  return true;
}



/***/ }),

/***/ "./src/modules/utility/dates.js":
/*!**************************************!*\
  !*** ./src/modules/utility/dates.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatDate": function() { return /* binding */ formatDate; },
/* harmony export */   "formatIsoDate": function() { return /* binding */ formatIsoDate; },
/* harmony export */   "formatIsoDateTime": function() { return /* binding */ formatIsoDateTime; },
/* harmony export */   "getDateFormat": function() { return /* binding */ getDateFormat; },
/* harmony export */   "getDaysInMonth": function() { return /* binding */ getDaysInMonth; },
/* harmony export */   "getMonthIndex": function() { return /* binding */ getMonthIndex; },
/* harmony export */   "getMonthName": function() { return /* binding */ getMonthName; },
/* harmony export */   "getWeekdayIndex": function() { return /* binding */ getWeekdayIndex; },
/* harmony export */   "getWeekdayName": function() { return /* binding */ getWeekdayName; },
/* harmony export */   "isDateValid": function() { return /* binding */ isDateValid; },
/* harmony export */   "parseDate": function() { return /* binding */ parseDate; },
/* harmony export */   "parseIsoDateTime": function() { return /* binding */ parseIsoDateTime; }
/* harmony export */ });
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/format/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/formatISO/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/parse/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isValid/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/parseISO/index.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Defines utility functions for handling dates and times.
 * @module dates
 */

var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
var MONTHS = [{
  name: 'January',
  maxDays: 31
}, {
  name: 'February',
  maxDays: 29
}, {
  name: 'March',
  maxDays: 31
}, {
  name: 'April',
  maxDays: 30
}, {
  name: 'May',
  maxDays: 31
}, {
  name: 'June',
  maxDays: 30
}, {
  name: 'July',
  maxDays: 31
}, {
  name: 'August',
  maxDays: 31
}, {
  name: 'September',
  maxDays: 30
}, {
  name: 'October',
  maxDays: 31
}, {
  name: 'November',
  maxDays: 30
}, {
  name: 'December',
  maxDays: 31
}];
/**
 * Retrieve the date format for a given locale, or for the default locale.
 * For example, the format string for en-US should look like M/d/yy.
 * @param {string} [locale] The locale whose date format is to be retrieved.
 *   If not given, then the browser's default locale is used.
 * @param {Object} [options={}] An object with formatting options.
 * @param {string} [options.dateStyle=short] The date formatting style:
 *   'short', 'medium', 'long', 'full', or 'none'.
 * @param {string} [options.timeStyle=none] The time formatting style: 'short',
 *   'medium', 'long', 'full', or 'none'.
 * @param {string} [options.tokenStyle=internal] The type of format tokens to
 *   use. Valid values are 'internal' and 'visual'. If set to 'internal' (the
 *   default), then the function uses the same format tokens that the
 *   [date-fns]{@link https://date-fns.org/} library uses. If set to 'visual',
 *   then more human-readable tokens are used: for example, a human-readable
 *   format string might look like 'YYYY-MM-DD hh:mm:ss' or
 *   'MM/DD/YYYY hh:mm a'.
 * @param {boolean|string} [options.fullYear=auto] Indicates whether or not to
 *   use a full four-digit year instead of a two-digit abbreviation. If set to
 *   'auto', then the local default is used.
 * @param {boolean|string} [options.padMonths=auto] Indicates whether or not to
 *   pad single-digit months with a leading zero. If set to 'auto', then the
 *   local default is used.
 * @param {boolean|string} [options.padDays=auto] Indicates whether or not to
 *   pad single-digit days with a leading zero. If set to 'auto', then the
 *   local default is used.
 * @param {boolean|string} [options.padHours=auto] Indicates whether or not to
 *   pad single-digit hours with a leading zero. If set to 'auto', then the
 *   local default is used.
 * @param {boolean|string} [options.padMinutes=auto] Indicates whether or not
 *   to pad single-digit minutes with a leading zero. If set to 'auto', then
 *   the local default is used.
 * @param {boolean|string} [options.padSeconds=auto] Indicates whether or not
 *   to pad single-digit seconds with a leading zero. If set to 'auto', then
 *   the local default is used.
 * @param {number|string} [options.hourSystem=auto] Indicates whether to use a
 *   12- or 24-hour clock. Valid values are 12 for a 12-hour clock, 24 for a
 *   24-hour clock, or the string 'auto' to use the local default.
 * @returns The date format string.
 */

function getDateFormat(locale) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var REFERENCE_DATE = new Date(2020, 0, 1, 14, 5, 5);
  var formatterOptions = {};
  var dateStyle = options.dateStyle || 'short';
  var timeStyle = options.timeStyle || 'none';

  if (dateStyle !== 'none') {
    formatterOptions.dateStyle = dateStyle;
  }

  if (timeStyle !== 'none') {
    formatterOptions.timeStyle = timeStyle;
  }

  if (options.hourSystem && options.hourSystem !== 'auto') {
    formatterOptions.hour12 = options.hourSystem === 12;
  }

  var formatter = new Intl.DateTimeFormat(locale || [], formatterOptions);
  var parts; // Fallback if browser doesn't support formatToParts - use en-US

  if (!('formatToParts' in formatter)) {
    var dateParts = [{
      type: 'month',
      value: '1'
    }, {
      type: 'literal',
      value: '/'
    }, {
      type: 'day',
      value: '1'
    }, {
      type: 'literal',
      value: '/'
    }, {
      type: 'year',
      value: '20'
    }];
    var timeParts = [{
      type: 'hour',
      value: '2'
    }, {
      type: 'literal',
      value: ':'
    }, {
      type: 'minute',
      value: '05'
    }];

    if (formatter.resolvedOptions().hour12) {
      timeParts = timeParts.concat([{
        type: 'literal',
        value: ' '
      }, {
        type: 'dayPeriod',
        value: 'am'
      }]);
    }

    var hasDate = dateStyle !== 'none';
    var hasTime = timeStyle !== 'none';

    if (hasDate && hasTime) {
      parts = [].concat(dateParts, [{
        type: 'literal',
        value: ' '
      }], _toConsumableArray(timeParts));
    } else if (hasTime) {
      parts = timeParts;
    } else {
      parts = dateParts;
    }
  } else {
    // Browser supports formatToParts
    parts = formatter.formatToParts(REFERENCE_DATE);
  }

  return parts.map(function (_ref) {
    var type = _ref.type,
        value = _ref.value;
    var token = '';
    var count = 1;

    switch (type) {
      case 'literal':
        if (options.tokenStyle !== 'visual' && /[A-Za-z]/.test(value)) {
          token = "'".concat(value.replace(/'/g, "''"), "'");
        } else {
          token = value;
        }

        break;

      case 'day':
        token = options.tokenStyle === 'visual' ? 'D' : 'd';

        if (options.padDays === true) {
          count = 2;
        } else if (options.padDays === false) {
          count = 1;
        } else {
          count = value.length;
        }

        break;

      case 'era':
        token = 'G';
        break;

      case 'month':
        token = 'M';

        if (value.length > 3) {
          count = 4;
        } else if (value.length === 3) {
          count = 3;
        } else if (options.padMonths === true) {
          count = 2;
        } else if (options.padMonths === false) {
          count = 1;
        } else {
          count = value.length;
        }

        break;

      case 'relatedYear':
      case 'year':
        token = options.tokenStyle === 'visual' ? 'Y' : 'y';

        if (options.fullYear === true) {
          count = 4;
        } else if (options.fullYear === false) {
          count = 2;
        } else {
          count = value.length;
        }

        break;

      case 'dayPeriod':
        token = 'a';
        break;

      case 'fractionalSecond':
        token = 'S';
        count = value.length;
        break;

      case 'hour':
        if (options.tokenStyle === 'visual') {
          token = 'h';
        } else {
          token = formatter.resolvedOptions().hour12 ? 'h' : 'H';
        }

        if (options.padHours === true) {
          count = 2;
        } else if (options.padHours === false) {
          count = 1;
        } else {
          count = value.length;
        }

        break;

      case 'minute':
        token = 'm';

        if (options.padMinutes === true) {
          count = 2;
        } else if (options.padMinutes === false) {
          count = 1;
        } else {
          count = value.length;
        }

        break;

      case 'second':
        token = 's';

        if (options.padSeconds === true) {
          count = 2;
        } else if (options.padSeconds === false) {
          count = 1;
        } else {
          count = value.length;
        }

        break;

      case 'weekday':
        token = 'e';
        count = 4;
        break;

      default:
        break;
    }

    return token.repeat(count);
  }).join('');
}
/**
 * Format a date into a string representation according to a given pattern.
 * @param {Date} date The date to be formatted.
 * @param {string} [format] The format string to use as a pattern. If not
 *   given, then the format from the browser's default locale is used. The
 *   format tokens are the same as used by the
 *   [date-fns]{@link https://date-fns.org/} library, as specified in the
 *   documentation for the
 *   [format function]{@link https://date-fns.org/v2.28.0/docs/format}.
 * @returns {string} The formatted date string.
 */


function formatDate(date, format) {
  return (0,date_fns__WEBPACK_IMPORTED_MODULE_0__["default"])(date, format !== null && format !== void 0 ? format : getDateFormat());
}
/**
 * Format a date into a string representation in ISO 8601 format. The returned
 * date string will not include a time component. To include the time and time
 * zone, use [formatIsoDateTime]{@link module:dates~formatIsoDateTime}
 * instead.
 * @param {Date} date The date to be formatted.
 * @returns {string} The formatted date string.
 */


function formatIsoDate(date) {
  return (0,date_fns__WEBPACK_IMPORTED_MODULE_1__["default"])(date, {
    representation: 'date'
  });
}
/**
 * Format a date and time into a string representation in ISO 8601 format. The
 * returned date string will include the time and time zone.
 * @param {Date} date The date to be formatted.
 * @returns {string} The formatted date string.
 */


function formatIsoDateTime(date) {
  return (0,date_fns__WEBPACK_IMPORTED_MODULE_1__["default"])(date);
}
/**
 * Parse a date from a string according to a pattern or sequence of patterns.
 * @param {string} dateString The string to parse.
 * @param {string|string[]} [format] The format string or sequence of format
 *   strings to use as patterns. If an array is given, then each string in the
 *   array is attempted to be used as a pattern until a match is found. If no
 *   pattern is given, then the format from the browser's default locale is
 *   used. The format tokens are the same as used by the
 *   [date-fns]{@link https://date-fns.org/} library, as specified in the
 *   documentation for the
 *   [format function]{@link https://date-fns.org/v2.28.0/docs/format}.
 * @returns {Date} The parsed date, or null if the string does not match the
 *   pattern.
 */


function parseDate(dateString, format) {
  var patterns;
  if (typeof format === 'string') patterns = [format];else if (Array.isArray(format) && format.length > 0) patterns = format;else patterns = [getDateFormat()];
  var today = new Date();

  for (var i = 0; i < patterns.length; i += 1) {
    var result = (0,date_fns__WEBPACK_IMPORTED_MODULE_2__["default"])(dateString, patterns[i], today);
    if ((0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(result)) return result;
  }

  return null;
}
/**
 * Parse a date from an ISO 8601 string representation.
 * @param {string} dateString The string to parse.
 * @returns {Date} The parsed date, or null if the string does not match the
 *   pattern.
 */


function parseIsoDateTime(dateString) {
  var result = (0,date_fns__WEBPACK_IMPORTED_MODULE_4__["default"])(dateString);
  return (0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(result) ? result : null;
}
/**
 * Determine whether a Date object holds a valid date.
 * @param {Date} date The date to check.
 * @returns {boolean} True if the date is valid (it is a Date object holding a
 *   valid date), and false otherwise.
 */


function isDateValid(date) {
  return date instanceof Date && (0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(date);
}
/**
 * Get the name of a day of the week.
 * @param {number} dayIndex The index of the weekday as an integer from 0 to 6,
 *   with 0 representing Sunday, 1 representing Monday, and so on.
 * @returns {string} The English name of the weekday.
 */


function getWeekdayName(dayIndex) {
  return WEEKDAYS[dayIndex] || 'Unknown';
}
/**
 * Get the index of the day of a week, with Sunday corresponding to 0.
 * @param {string} day The name of the weekday.
 * @returns {?number} The index of the weekday as an integer from 0 to 6, with
 *   0 representing Sunday, 1 representing Monday, and so on. If the weekday is
 *   not recognized, null is returned.
 */


function getWeekdayIndex(day) {
  var dayLower = day.toLowerCase();
  var index = WEEKDAYS.findIndex(function (elem) {
    return elem.toLowerCase() === dayLower;
  });
  if (index < 0) return null;
  return index;
}
/**
 * Get the name of a month.
 * @param {number} monthIndex The index of the month as an integer from 0 to
 *   11, with 0 representing January, 1 representing February, and so on.
 * @returns {string} The English name of the month.
 */


function getMonthName(monthIndex) {
  var _MONTHS$monthIndex;

  return ((_MONTHS$monthIndex = MONTHS[monthIndex]) === null || _MONTHS$monthIndex === void 0 ? void 0 : _MONTHS$monthIndex.name) || 'Unknown';
}
/**
 * Get the index of a month of the year, with January corresponding to 0.
 * @param {string} month The name of the month.
 * @returns {?number} The index of the month as an integer from 0 to 11, with 0
 *   representing January, 1 representing February, and so on. If the month is
 *   not recognized, null is returned.
 */


function getMonthIndex(month) {
  var monthLower = month.toLowerCase();
  var index = MONTHS.findIndex(function (elem) {
    return elem.name.toLowerCase() === monthLower;
  });
  if (index < 0) return null;
  return index;
}
/**
 * Get the (maximum) number of days in a particular month.
 * @param {number} monthIndex The index of the month as an integer from 0 to
 *   11, with 0 representing January, 1 representing February, and so on.
 * @returns {number} The maximum number of days in the month. For example, the
 *   value returned for February will be 29, not 28. Returns a value of 0 if
 *   an invalid index is given.
 */


function getDaysInMonth(monthIndex) {
  var _MONTHS$monthIndex$ma, _MONTHS$monthIndex2;

  return (_MONTHS$monthIndex$ma = (_MONTHS$monthIndex2 = MONTHS[monthIndex]) === null || _MONTHS$monthIndex2 === void 0 ? void 0 : _MONTHS$monthIndex2.maxDays) !== null && _MONTHS$monthIndex$ma !== void 0 ? _MONTHS$monthIndex$ma : 0;
}



/***/ }),

/***/ "./src/modules/utility/dom.js":
/*!************************************!*\
  !*** ./src/modules/utility/dom.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDateInputField": function() { return /* binding */ createDateInputField; },
/* harmony export */   "createFormControl": function() { return /* binding */ createFormControl; },
/* harmony export */   "createIconButton": function() { return /* binding */ createIconButton; },
/* harmony export */   "createToggleButton": function() { return /* binding */ createToggleButton; }
/* harmony export */ });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Defines functions for manipulating the DOM.
 * @module dom
 */

/**
 * Specifies options for creating input controls in a form.
 * @typedef {Object} module:dom~formControlOptions
 * @property {string} [type=text] The type of input. For most text or numeric
 *   forms of input, this value is used as the 'type' attribute on an 'input'
 *   element. Setting this to 'select' indicates that a 'select' element should
 *   be created. Setting this to 'textarea' indicates that a 'textarea' element
 *   should be created.
 * @property {string} [id] The identifier for the input element.
 * @property {string} [name] The name of the input element, used in form
 *   submission and for grouping radio buttons.
 * @property {string} [title] The title of the input element, usually displayed
 *   by the browser as a tooltip.
 * @property {string} [value] The initial value of the input element, or a
 *   value identifying a checkbox or radio button option. This property is
 *   ignored for the 'select' input type.
 * @property {string} [placeholder] A hint string used as a placeholder for
 *   text-based input elements.
 * @property {string[]} [classList=[]] An array of class names to apply to the
 *   input element.
 * @property {boolean} [checked=false] If true, indicates that the control
 *   should be checked by default. This applies only to the 'checkbox' and
 *   'radio' input types.
 * @property {boolean} [required=false] If true, indicates that the control
 *   is a required field.
 * @property {string} [pattern] Specifies a regular expression that the input
 *   control's value should match in order to be considered valid.
 * @property {number|string} [min] Sets the minimum acceptable value for a
 *   numeric input field.
 * @property {number|string} [max] Sets the maximum acceptable value for a
 *   numeric input field.
 * @property {number|string} [step] Sets the acceptable increments for values
 *   in a numeric input field. This can be a number or the string 'any'.
 * @property {number} [minLength] Sets the minimum acceptable length for an
 *   input field.
 * @property {number} [maxLength] Sets the maximum acceptable length for an
 *   input field.
 * @property {string|string[]} [accept] Sets the acceptable file types for a
 *   file input field. Can be a string containing a comma-separated list of
 *   file extensions and/or media types, or an array of strings each specifying
 *   one file extension or media type.
 * @property {Object} [label] An object specifying information about the label
 *   for the input element.
 * @property {string} [label.value] The text content of the label that should
 *   be displayed on the page.
 * @property {string} [label.placement=auto] Determines whether the label
 *   should be placed before or after the input control. Valid values are
 *   'before', 'after', and 'auto' (the default). If set to 'auto', then the
 *   label is placed after the element if the input type is 'radio' or
 *   'checkbox', and before the element in all other cases.
 * @property {string[]} [label.classList=[]] An array of class names to apply
 *   to the label element.
 * @property {Object} [size] An object containing size information for the
 *   input element. This is only used for the 'textarea' input type.
 * @property {number} [size.rows] The number of rows that a textarea should
 *   have.
 * @property {number} [size.cols] The number of columns that a textarea should
 *   have.
 * @property {Object} [container] An object containing information about the
 *   container holding the input element and its label.
 * @property {string} [container.id] The identifier for the container.
 * @property {string[]} [container.classList=[]] An array of class names to
 *   apply to the container.
 * @property {boolean} [container.inline=false] If set to true, indicates that
 *   the container should be an inline element rather than a block element.
 * @property {Object[]} [menuItems] An array of objects containing information
 *   about options for a select control. This property is ignored unless the
 *   input type is 'select'.
 * @property {string} [menuItems.value] The form value identifying the item.
 * @property {string} menuItems.label The label that will be displayed for
 *   the item.
 * @property {boolean} [menuItems.selected=false] If true, indicates that the
 *   item should be selected by default.
 */

/**
 * Create an input control in a form, optionally including a label.
 * @param {module:dom~formControlOptions} [options={}] An object specifying
 *   options for the input element.
 * @returns {HTMLElement} The container holding the input element and its
 *   label. If no label and no container id were specified, then the form
 *   element is not placed in a container and is instead returned directly.
 */
function createFormControl() {
  var _options$type, _input$classList;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var type = ((_options$type = options.type) === null || _options$type === void 0 ? void 0 : _options$type.toLowerCase()) || 'text';
  var container = null;

  if (options.label || options.container) {
    var _options$container, _options$container2, _options$container3;

    var containerTag = (_options$container = options.container) !== null && _options$container !== void 0 && _options$container.inline ? 'span' : 'div';
    container = document.createElement(containerTag);
    if ((_options$container2 = options.container) !== null && _options$container2 !== void 0 && _options$container2.id) container.id = options.container.id;

    if ((_options$container3 = options.container) !== null && _options$container3 !== void 0 && _options$container3.classList) {
      var _container$classList;

      (_container$classList = container.classList).add.apply(_container$classList, _toConsumableArray(options.container.classList));
    }
  }

  var label = null;

  if (options.label) {
    label = document.createElement('label');
    label.textContent = options.label.value || '';

    if (options.label.classList) {
      var _label$classList;

      (_label$classList = label.classList).add.apply(_label$classList, _toConsumableArray(options.label.classList));
    }

    if (options.id) label.htmlFor = options.id;
  }

  var input = null;

  switch (type) {
    case 'select':
      input = document.createElement('select');

      if (options.menuItems) {
        options.menuItems.forEach(function (item) {
          var opt = document.createElement('option');
          if (item.value) opt.value = item.value;

          if (item.selected) {
            opt.defaultSelected = true;
            opt.selected = true;
          }

          opt.textContent = item.label;
          input.appendChild(opt);
        });
      }

      break;

    case 'textarea':
      input = document.createElement('textarea');
      input.textContent = options.value || '';

      if (options.size) {
        if (options.size.rows) input.rows = options.size.rows;
        if (options.size.cols) input.cols = options.size.cols;
      }

      break;

    default:
      input = document.createElement('input');
      input.type = type;

      if (options.value) {
        input.defaultValue = options.value;
        input.value = options.value;
      }

      if (options.pattern) input.pattern = options.pattern;
      if (options.min != null) input.min = options.min;
      if (options.max != null) input.max = options.max;
      if (options.step != null) input.step = options.step;
      break;
  }

  if (options.id) input.id = options.id;
  if (options.name) input.name = options.name;
  if (options.title) input.title = options.title;
  if (options.classList) (_input$classList = input.classList).add.apply(_input$classList, _toConsumableArray(options.classList));
  if (options.required) input.required = true;

  if (type !== 'select' && options.minLength != null) {
    input.minLength = options.minLength;
  }

  if (type !== 'select' && options.maxLength != null) {
    input.maxLength = options.maxLength;
  }

  if (type === 'file' && options.accept) {
    if (Array.isArray(options.accept)) input.accept = options.accept.join(',');else input.accept = options.accept;
  }

  var checkable = type === 'checkbox' || type === 'radio';

  if (checkable && options.checked) {
    input.defaultChecked = true;
    input.checked = true;
  }

  if (options.placeholder && !checkable && type !== 'select') {
    input.placeholder = options.placeholder;
  }

  if (label) {
    var placement = options.label.placement || 'auto';
    if (placement === 'auto') placement = checkable ? 'after' : 'before';

    if (placement === 'after') {
      container.appendChild(input);
      container.appendChild(label);
    } else {
      container.appendChild(label);
      container.appendChild(input);
    }

    return container;
  }

  if (container) {
    container.appendChild(input);
    return container;
  }

  return input;
}
/**
 * Specifies options for creating a date input field in a form.
 * @typedef {Object} module:dom~dateInputOptions
 * @property {string} [id] The identifier for the text input element.
 * @property {string} [name] The name of the text input element.
 * @property {string} [title] The title of the text input element, usually
 *   displayed by the browser as a tooltip.
 * @property {string} [value] The initial value of the text input element.
 * @property {string} [placeholder] A hint string used as a placeholder for the
 *   text input element.
 * @property {string[]} [classList=[]] An array of class names to apply to the
 *   text input element.
 * @property {boolean} [required=false] If true, indicates that the input
 *   control is a required field.
 * @property {string} [pattern] Specifies a regular expression that the input
 *   control's value should match in order to be considered valid.
 * @property {number} [minLength] Sets the minimum acceptable length for the
 *   text input field.
 * @property {number} [maxLength] Sets the maximum acceptable length for the
 *   text input field.
 * @property {Object} [label] An object specifying information about the label
 *   for the input field.
 * @property {string} [label.value] The text content of the label that should
 *   be displayed on the page.
 * @property {string[]} [label.classList=[]] An array of class names to apply
 *   to the label element.
 * @property {Object} [container] An object containing information about the
 *   container holding the input field.
 * @property {string} [container.id] The identifier for the container.
 * @property {string[]} [container.classList=[]] An array of class names to
 *   apply to the container.
 * @property {boolean} [container.inline=false] If set to true, indicates that
 *   the container should be an inline element rather than a block element.
 * @property {Object} [button] An object containing information about the
 *   button element.
 * @property {string} [button.id] The identifier for the button.
 * @property {string} [button.name] The form name for the button.
 * @property {string} [button.title] The title for the button, usually
 *   displayed by the browser as a tooltip.
 * @property {string} [button.label=Choose...] The label to be displayed in the
 *   button.
 * @property {string[]} [button.classList] An array of class names to apply to
 *   the button element.
 * @property {Function} [button.callback] A callback function to be invoked
 *   when the button is clicked or activated. The function will be passed a
 *   reference to the text input element as an argument.
 */

/**
 * Create an input field for entering dates. This will create a text input
 * control together with a button that can invoke a callback allowing for the
 * caller to open a date picker.
 * @param {module:dom~dateInputOptions} [options={}] An object specifying
 *   options for the input field.
 * @returns {HTMLElement} The container holding the input elements and label.
 */


function createDateInputField() {
  var _options$container4, _options$container5, _options$container6, _options$id, _options$name, _options$title, _options$value, _options$placeholder, _options$required, _options$pattern, _options$minLength, _options$maxLength, _options$button, _options$button2, _options$button3, _options$button4, _options$button5, _options$button6;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var containerTag = (_options$container4 = options.container) !== null && _options$container4 !== void 0 && _options$container4.inline ? 'span' : 'div';
  var container = document.createElement(containerTag);
  if ((_options$container5 = options.container) !== null && _options$container5 !== void 0 && _options$container5.id) container.id = options.container.id;

  if ((_options$container6 = options.container) !== null && _options$container6 !== void 0 && _options$container6.classList) {
    var _container$classList2;

    (_container$classList2 = container.classList).add.apply(_container$classList2, _toConsumableArray(options.container.classList));
  }

  if (options.label) {
    var label = document.createElement('label');
    if (options.id) label.htmlFor = options.id;

    if (options.label.classList) {
      var _label$classList2;

      (_label$classList2 = label.classList).add.apply(_label$classList2, _toConsumableArray(options.label.classList));
    }

    label.textContent = options.label.value || '';
    container.appendChild(label);
  }

  container.appendChild(createFormControl({
    type: 'text',
    id: (_options$id = options.id) !== null && _options$id !== void 0 ? _options$id : null,
    name: (_options$name = options.name) !== null && _options$name !== void 0 ? _options$name : null,
    title: (_options$title = options.title) !== null && _options$title !== void 0 ? _options$title : null,
    value: (_options$value = options.value) !== null && _options$value !== void 0 ? _options$value : null,
    placeholder: (_options$placeholder = options.placeholder) !== null && _options$placeholder !== void 0 ? _options$placeholder : null,
    classList: options.classList || null,
    required: (_options$required = options.required) !== null && _options$required !== void 0 ? _options$required : false,
    pattern: (_options$pattern = options.pattern) !== null && _options$pattern !== void 0 ? _options$pattern : null,
    minLength: (_options$minLength = options.minLength) !== null && _options$minLength !== void 0 ? _options$minLength : null,
    maxLength: (_options$maxLength = options.maxLength) !== null && _options$maxLength !== void 0 ? _options$maxLength : null
  }));
  var button = document.createElement('button');
  if ((_options$button = options.button) !== null && _options$button !== void 0 && _options$button.id) button.id = options.button.id;
  if ((_options$button2 = options.button) !== null && _options$button2 !== void 0 && _options$button2.name) button.name = options.button.name;
  if ((_options$button3 = options.button) !== null && _options$button3 !== void 0 && _options$button3.title) button.title = options.button.title;

  if ((_options$button4 = options.button) !== null && _options$button4 !== void 0 && _options$button4.classList) {
    var _button$classList;

    (_button$classList = button.classList).add.apply(_button$classList, _toConsumableArray(options.button.classList));
  }

  button.textContent = ((_options$button5 = options.button) === null || _options$button5 === void 0 ? void 0 : _options$button5.label) || 'Choose...';

  if ((_options$button6 = options.button) !== null && _options$button6 !== void 0 && _options$button6.callback) {
    var input = container.querySelector('input');
    button.addEventListener('click', function () {
      return options.button.callback(input);
    });
  }

  container.appendChild(button);
  return container;
}
/**
 * Create an icon button element.
 * @param {string} iconType The type of icon to display. This is stored in the
 *   data-icon-type attribute of the button and also indicates the icon to use
 *   from the Google Material Icons font.
 * @param {Object} [options={}] An object holding configuration options
 *   controlling the button creation.
 * @param {string} [options.id] The identifier for the button.
 * @param {string} [options.title] The title of the button, usually displayed
 *   by the browser as a tooltip.
 * @param {string[]} [options.classList] An array of class names to apply to
 *   the button.
 * @returns {HTMLElement} The newly-created button element.
 */


function createIconButton(iconType) {
  var _button$classList2;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var button = document.createElement('button');
  button.classList.add('icon', 'material-icons');
  button.dataset.iconType = iconType;
  button.textContent = iconType;
  if (options.id) button.id = options.id;
  if (options.title) button.title = options.title;
  if (options.classList) (_button$classList2 = button.classList).add.apply(_button$classList2, _toConsumableArray(options.classList));
  return button;
}
/**
 * Create a button that can be toggled on and off.
 * @param {string} label The button label.
 * @param {Object} [options={}] An object holding configuration options
 *   controlling the button creation.
 * @param {string} [options.id] The identifier for the button.
 * @param {string} [options.name] The form name for the button.
 * @param {string} [options.title] The title of the button, usually displayed
 *   by the browser as a tooltip.
 * @param {string} [options.value] The form value associated with the button.
 * @param {boolean} [options.defaultActive=false] Sets the initial state of the
 *   button. If set to true, then the button will be active (on) by default.
 * @param {string[]} [options.classList] An array of class names to apply to
 *   the button. If not specified, the button will receive the 'toggle-button'
 *   class.
 * @param {string} [options.activeClass=active] The CSS class to apply when
 *   the button is active (on).
 * @returns {HTMLElement} The newly-created button element.
 */


function createToggleButton(label) {
  var _button$classList3;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var button = document.createElement('button');
  if (options.id) button.id = options.id;
  if (options.name) button.name = options.name;
  if (options.title) button.title = options.title;
  if (options.value) button.value = options.value;
  if (options.classList) (_button$classList3 = button.classList).add.apply(_button$classList3, _toConsumableArray(options.classList));else button.classList.add('toggle-button');
  button.textContent = label;
  var activeClass = options.activeClass || 'active';
  if (options.defaultActive) button.classList.add(activeClass);
  button.addEventListener('click', function () {
    return button.classList.toggle(activeClass);
  });
  return button;
}



/***/ }),

/***/ "./src/modules/utility/storage.js":
/*!****************************************!*\
  !*** ./src/modules/utility/storage.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayToCsvRecord": function() { return /* binding */ arrayToCsvRecord; },
/* harmony export */   "clearData": function() { return /* binding */ clearData; },
/* harmony export */   "forEachDataItem": function() { return /* binding */ forEachDataItem; },
/* harmony export */   "generateFile": function() { return /* binding */ generateFile; },
/* harmony export */   "getFileExtension": function() { return /* binding */ getFileExtension; },
/* harmony export */   "isLocalStorageSupported": function() { return /* binding */ isLocalStorageSupported; },
/* harmony export */   "parseCsv": function() { return /* binding */ parseCsv; },
/* harmony export */   "readFile": function() { return /* binding */ readFile; },
/* harmony export */   "removeData": function() { return /* binding */ removeData; },
/* harmony export */   "retrieveData": function() { return /* binding */ retrieveData; },
/* harmony export */   "storeData": function() { return /* binding */ storeData; }
/* harmony export */ });
/**
 * Defines storage-related utility functions.
 * @module storage
 */
var storageSupported = null;
/**
 * Determine whether or not local storage is supported and enabled in the
 * browser. The check is only performed once: subsequent calls will immediately
 * return the same value.
 * @returns {boolean} True if local storage is supported and enabled, and false
 *   otherwise.
 */

function isLocalStorageSupported() {
  if (storageSupported !== null) return storageSupported;
  var storage;

  try {
    storage = window.localStorage;
    var testItem = '__storage-test';
    storage.setItem(testItem, testItem);
    storage.removeItem(testItem);
    storageSupported = true;
  } catch (e) {
    storageSupported = e instanceof DOMException && (e.code === 22 || e.code === 1014 || e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') && storage && storage.length !== 0;
  }

  return storageSupported;
}
/**
 * Store data in the browser's local storage, if available. This function will
 * associate the given key with the given value in storage. The value is first
 * converted to JSON format before being stored.
 * @param {?string} prefix A prefix to use for the key name to avoid clashes
 *   with other web apps hosted on the same origin. If given, the actual key
 *   used will have the form 'prefix.key'.
 * @param {string} key The key to create or update.
 * @param {*} value The value to be associated with the key.
 * @returns {boolean} True if the data was successfully stored, and false
 *   otherwise. Possible reasons for returning false include local storage
 *   being unsupported or disabled, or storage limits being exceeded.
 */


function storeData(prefix, key, value) {
  if (!isLocalStorageSupported()) return false;
  var fullKey = prefix ? "".concat(prefix, ".").concat(key) : key;

  try {
    window.localStorage.setItem(fullKey, JSON.stringify(value));
    return true;
  } catch (_unused) {
    return false;
  }
}
/**
 * Retrieve data from the browser's local storage, if available. This function
 * will return the data associated with the given key. The data is converted
 * from JSON format and the resulting value or object is used as the return
 * value. If the key does not exist or if local storage is not available, null
 * is returned.
 * @param {?string} prefix The prefix for the key name whose value is to be
 *   retrieved.
 * @param {string} key The key whose value is to be retrieved.
 * @returns {*} The data associated with the key, or null if not found.
 */


function retrieveData(prefix, key) {
  if (!isLocalStorageSupported()) return null;
  var fullKey = prefix ? "".concat(prefix, ".").concat(key) : key;

  try {
    return JSON.parse(window.localStorage.getItem(fullKey));
  } catch (_unused2) {
    return null;
  }
}
/**
 * Remove data from the browser's local storage. If it exists, the given key
 * and its associated data will be removed from storage.
 * @param {?string} prefix The prefix for the key to be removed.
 * @param {string} key The key to be removed.
 * @returns {boolean} True if the key was found and removed. If the key was not
 *   found or if local storage is unavailable, returns false.
 */


function removeData(prefix, key) {
  if (!isLocalStorageSupported()) return false;
  window.localStorage.removeItem(prefix ? "".concat(prefix, ".").concat(key) : key);
  return true;
}
/**
 * Execute the provided function on each item in the browser's local storage
 * area, or on each item having a given prefix.
 * @param {?string} prefix The prefix for the keys to iterate over. If not
 *   given, then all items will be iterated over.
 * @param {Function} callback A callback function that will be called for each
 *   matching storage item. The function will be passed the key (by default
 *   without the prefix), the value (unless using the noValue option), and the
 *   index.
 * @param {Object} [options={}] An object holding additional options for the
 *   callback function.
 * @param {boolean} [options.includePrefix] If set to true, then the callback
 *   function will receive the full key, with the prefix included.
 * @param {boolean} [options.noValue] If set to true, then only the key and
 *   index for the data item will be passed to the callback function. By not
 *   retrieving and deserializing every value, this can save time if the caller
 *   does not need every value.
 */


function forEachDataItem(prefix, callback) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (isLocalStorageSupported()) {
    var storage = window.localStorage;

    for (var i = 0; i < storage.length; i += 1) {
      var key = storage.key(i);

      if (!prefix || key.startsWith("".concat(prefix, "."))) {
        var localKey = prefix && !options.includePrefix ? key.substring(prefix.length + 1) : key;
        var value = options.noValue ? null : retrieveData(null, key);
        if (value) callback(localKey, value, i);else callback(localKey, i);
      }
    }
  }
}
/**
 * Clear all data from the browser's local storage. If local storage is
 * unsupported or disabled, nothing happens.
 * @param {?string} prefix The prefix for the keys to be removed. If not given,
 *   then everything stored in local storage will be removed.
 */


function clearData(prefix) {
  if (isLocalStorageSupported()) {
    var storage = window.localStorage;

    if (prefix) {
      var keys = [];
      forEachDataItem(prefix, function (key) {
        return keys.push(key);
      }, {
        includePrefix: true,
        noValue: true
      });
      keys.forEach(function (key) {
        return removeData(null, key);
      });
    } else {
      storage.clear();
    }
  }
}
/**
 * Generate a text file, and present it to the user as a download.
 * @param {string} content The text data to store in the file.
 * @param {string} filename The default file name.
 * @param {string} [type=text/plain] The Internet media type for the file. For
 *   example, 'application/json' would indicate a JSON file, and 'text/csv'
 *   would indicate a file containing comma-separated values.
 */


function generateFile(content, filename) {
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'text/plain';
  var data = new Blob([content], {
    type: type
  });
  var url = URL.createObjectURL(data);
  var linkElem = document.createElement('a');
  linkElem.href = url;
  linkElem.download = filename;
  linkElem.click();
  setTimeout(function () {
    return URL.revokeObjectURL(url);
  }, 0);
}
/**
 * Read the contents of a text file. The file contents are passed to the
 * specified callback function once the read operation is complete.
 * @param {Blob} file The file to be read.
 * @param {Function} callback The callback function that will receive the file
 *   contents. If an error occurs, the callback function will be invoked with a
 *   null argument instead.
 */


function readFile(file, callback) {
  var reader = new FileReader();
  reader.addEventListener('load', function () {
    return callback(reader.result);
  });
  reader.addEventListener('error', function () {
    return callback(null);
  });
  reader.addEventListener('abort', function () {
    return callback(null);
  });
  reader.readAsText(file);
}
/**
 * Convert an array of strings to comma-separated values (CSV format, as
 * described by the
 * [RFC 4180]{@link https://datatracker.ietf.org/doc/html/rfc4180}
 * specification). This function will create one CSV record, which can then be
 * combined with other records to form a complete CSV file.
 * @param {string[]} data An array of strings specifying the values for the
 *   fields in the record.
 * @param {Object} [options={}] An object specifying options for the
 *   conversion.
 * @param {string} [options.newlineSequence] The character sequence to use for
 *   newlines. If not provided, a carriage return/line feed pair (CRLF) is
 *   used. All newline characters within each field will be replaced by this
 *   sequence.
 * @returns {string} The record in CSV format. The returned string is not
 *   terminated by a newline, but may contain quoted newlines within the field
 *   data.
 */


function arrayToCsvRecord(data) {
  var _options$newlineSeque;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var newlineSequence = (_options$newlineSeque = options.newlineSequence) !== null && _options$newlineSeque !== void 0 ? _options$newlineSeque : '\r\n';
  var fields = [];
  data.forEach(function (value) {
    var needQuotes = false;
    var result = value.replace(/,|"|\r\n|\n|\r/g, function (match) {
      needQuotes = true;

      switch (match) {
        case '"':
          return '""';

        case '\r\n':
        case '\n':
          return newlineSequence;

        default:
          return match;
      }
    });
    fields.push(needQuotes ? "\"".concat(result, "\"") : result);
  });
  return fields.join(',');
}
/**
 * Convert data in comma-separated value (CSV) format into an array of arrays
 * of strings. Each data record is stored as an array of strings within the
 * outer array, with each string corresponding to a field in the record. Any
 * newline sequences (CRLF, LF, or CR) are converted to linefeed (LF)
 * characters.
 * @param {string} data The data in CSV format.
 * @returns {string[][]} An array of string arrays. Each inner array contains
 *   the fields for one record.
 */


function parseCsv(data) {
  var result = [];
  var currentRow = [];
  var currentField = '';

  var commitField = function commitField() {
    currentRow.push(currentField);
    currentField = '';
  };

  var commitRow = function commitRow() {
    result.push(currentRow);
    currentRow = [];
  };

  var quoted = false;

  for (var pos = 0; pos < data.length; pos += 1) {
    switch (data[pos]) {
      case '"':
        if (!quoted) {
          quoted = true;
        } else if (pos + 1 < data.length && data[pos + 1] === '"') {
          // This is a double double quote, so convert it and move to next char
          currentField += '"';
          pos += 1;
        } else {
          // Not a double double quote, so the quoting ends here
          quoted = false;
        }

        break;

      case '\r':
      case '\n':
        // Handle CRLF sequence
        if (data[pos] === '\r' && pos + 1 < data.length && data[pos + 1] === '\n') {
          pos += 1;
        }

        if (quoted) {
          currentField += '\n';
        } else {
          commitField();
          commitRow();
        }

        break;

      case ',':
        if (quoted) currentField += ',';else commitField();
        break;

      default:
        currentField += data[pos];
        break;
    }
  } // Commit last entry if last character was not a newline


  if (data.length > 0) {
    var lastChar = data[data.length - 1];

    if (lastChar !== '\r' && lastChar !== '\n') {
      commitField();
      commitRow();
    }
  }

  return result;
}
/**
 * Extract the extension from a file name. The extension, for the purposes of
 * this function, is considered to be the portion of the filename starting from
 * (and including) the last period in the name and extending to the end of the
 * name. If there is no period in the name, or if the only period is located at
 * the very start of the name (as seen with dotfiles on Unix systems, for
 * example), then the file is considered to have no extension.
 * @param {string} filename The name of the file.
 * @returns {string} The file's extension, including the period. If the file
 *   has no extension, an empty string is returned.
 */


function getFileExtension(filename) {
  var index = filename.lastIndexOf('.');
  return index > 0 ? filename.substring(index) : '';
}



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./src/styles/main.css":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./src/styles/main.css ***!
  \*****************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_variables_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./variables.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/variables.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_datePicker_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./datePicker.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/datePicker.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_filterMenu_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./filterMenu.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/filterMenu.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_form_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./form.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/form.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_modal_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./modal.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/modal.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_popupMenu_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./popupMenu.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/popupMenu.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_taskPanel_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./taskPanel.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/taskPanel.css");
// Imports









var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Carter+One&display=swap);"]);
___CSS_LOADER_EXPORT___.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Material+Icons);"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_variables_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_datePicker_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_filterMenu_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_form_css__WEBPACK_IMPORTED_MODULE_5__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_modal_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_popupMenu_css__WEBPACK_IMPORTED_MODULE_7__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_taskPanel_css__WEBPACK_IMPORTED_MODULE_8__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Use alternative box model */\nhtml {\n  box-sizing: border-box;\n}\n*, *::before, *::after {\n  box-sizing: inherit;\n}\n\nbody {\n  font-family: var(--content-font);\n}\n\na, a:visited {\n  text-decoration: none;\n}\n\na:hover {\n  text-decoration: underline;\n}\n\n#app {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n\n  width: 100vw;\n  height: 100vh;\n}\n\n#header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  height: var(--header-height);\n\n  color: white;\n  background-color: #0000bb;\n  padding: 12px;\n}\n\n#header .icon {\n  font-size: 24px;\n}\n\n#middle-container {\n  flex: 1 1 auto;\n  display: flex;\n  height: calc(100% - var(--header-height) - var(--footer-height));\n}\n\n#side-panel {\n  height: 100%;\n  background-color: var(--side-panel-bg-color);\n  overflow: auto;\n  width: 350px;\n  min-width: 250px;\n  max-width: min(100vw, 500px);\n}\n\n#main-panel {\n  flex: 1 1 auto;\n  height: 100%;\n  overflow: auto;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n#main-panel-header {\n  width: 100%;\n  max-width: var(--main-content-width);\n  margin: auto;\n  display: flex;\n  justify-content: space-between;\n  padding: 24px 12px;\n}\n\n#main-panel-heading-container {\n  font-family: var(--label-font);\n  flex: 1;\n}\n\n#main-panel-heading {\n  font-size: 24px;\n  font-weight: bold;\n}\n\n#main-panel-subheading {\n  margin-top: 8px;\n  font-size: 16px;\n  white-space: pre-wrap;\n  color: #505050;\n\n  max-height: 64px;\n  overflow: auto;\n  line-height: normal;\n}\n\n#main-panel-header .icon-container {\n  margin-left: 12px;\n}\n\n#footer {\n  color: white;\n  background-color: #2c2c32;\n  font-size: 16px;\n  padding: 12px;\n  height: var(--footer-height);\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n#footer a {\n  color: inherit;\n}\n\n#footer a:hover {\n  color: #c3c2fd;\n}\n\n.closed {\n  display: none;\n}\n\n.resizer {\n  background-color: var(--side-panel-bg-color);\n  width: 8px;\n  height: 100%;\n  cursor: col-resize;\n}\n\n.resizer.dragging, .resizer:hover {\n  background-color: #9b9b9b;\n}\n\n.icon {\n  color: inherit;\n}\n\n.icon-container {\n  display: flex;\n}\n\n.icon-container .icon {\n  font-size: 24px;\n}\n\n.icon-container > * + * {\n  margin-left: 4px;\n}\n\n.collapsible {\n  overflow: hidden;\n  transition: height 250ms ease-out;\n}\n\n.title-container {\n  display: flex;\n  align-items: center;\n}\n\n.title-container > * + * {\n  margin-left: 12px;\n}\n\n.title {\n  font-family: 'Carter One', sans-serif;\n  font-size: 24px;\n}\n\n.data-import-results {\n  font-family: var(--label-font);\n  font-size: 14px;\n  white-space: pre-wrap;\n  line-height: 1.5;\n}\n\n.data-import-error-list {\n  list-style: disc inside;\n}\n\n@media (max-width: 400px) {\n  .title-container .title {\n    display: none;\n  }\n}\n\n@media (max-height: 500px) {\n  #main-panel-subheading {\n    max-height: 24px;\n  }\n}\n", "",{"version":3,"sources":["webpack://./src/styles/main.css"],"names":[],"mappings":"AAWA,8BAA8B;AAC9B;EACE,sBAAsB;AACxB;AACA;EACE,mBAAmB;AACrB;;AAEA;EACE,gCAAgC;AAClC;;AAEA;EACE,qBAAqB;AACvB;;AAEA;EACE,0BAA0B;AAC5B;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,uBAAuB;;EAEvB,YAAY;EACZ,aAAa;AACf;;AAEA;EACE,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;EACnB,4BAA4B;;EAE5B,YAAY;EACZ,yBAAyB;EACzB,aAAa;AACf;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,cAAc;EACd,aAAa;EACb,gEAAgE;AAClE;;AAEA;EACE,YAAY;EACZ,4CAA4C;EAC5C,cAAc;EACd,YAAY;EACZ,gBAAgB;EAChB,4BAA4B;AAC9B;;AAEA;EACE,cAAc;EACd,YAAY;EACZ,cAAc;;EAEd,aAAa;EACb,sBAAsB;EACtB,2BAA2B;EAC3B,mBAAmB;AACrB;;AAEA;EACE,WAAW;EACX,oCAAoC;EACpC,YAAY;EACZ,aAAa;EACb,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,8BAA8B;EAC9B,OAAO;AACT;;AAEA;EACE,eAAe;EACf,iBAAiB;AACnB;;AAEA;EACE,eAAe;EACf,eAAe;EACf,qBAAqB;EACrB,cAAc;;EAEd,gBAAgB;EAChB,cAAc;EACd,mBAAmB;AACrB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,YAAY;EACZ,yBAAyB;EACzB,eAAe;EACf,aAAa;EACb,4BAA4B;;EAE5B,aAAa;EACb,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,4CAA4C;EAC5C,UAAU;EACV,YAAY;EACZ,kBAAkB;AACpB;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;EAChB,iCAAiC;AACnC;;AAEA;EACE,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,qCAAqC;EACrC,eAAe;AACjB;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,qBAAqB;EACrB,gBAAgB;AAClB;;AAEA;EACE,uBAAuB;AACzB;;AAEA;EACE;IACE,aAAa;EACf;AACF;;AAEA;EACE;IACE,gBAAgB;EAClB;AACF","sourcesContent":["@import url('https://fonts.googleapis.com/css2?family=Carter+One&display=swap');\n@import url('https://fonts.googleapis.com/css2?family=Material+Icons');\n\n@import './variables.css';\n@import './datePicker.css';\n@import './filterMenu.css';\n@import './form.css';\n@import './modal.css';\n@import './popupMenu.css';\n@import './taskPanel.css';\n\n/* Use alternative box model */\nhtml {\n  box-sizing: border-box;\n}\n*, *::before, *::after {\n  box-sizing: inherit;\n}\n\nbody {\n  font-family: var(--content-font);\n}\n\na, a:visited {\n  text-decoration: none;\n}\n\na:hover {\n  text-decoration: underline;\n}\n\n#app {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n\n  width: 100vw;\n  height: 100vh;\n}\n\n#header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  height: var(--header-height);\n\n  color: white;\n  background-color: #0000bb;\n  padding: 12px;\n}\n\n#header .icon {\n  font-size: 24px;\n}\n\n#middle-container {\n  flex: 1 1 auto;\n  display: flex;\n  height: calc(100% - var(--header-height) - var(--footer-height));\n}\n\n#side-panel {\n  height: 100%;\n  background-color: var(--side-panel-bg-color);\n  overflow: auto;\n  width: 350px;\n  min-width: 250px;\n  max-width: min(100vw, 500px);\n}\n\n#main-panel {\n  flex: 1 1 auto;\n  height: 100%;\n  overflow: auto;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n#main-panel-header {\n  width: 100%;\n  max-width: var(--main-content-width);\n  margin: auto;\n  display: flex;\n  justify-content: space-between;\n  padding: 24px 12px;\n}\n\n#main-panel-heading-container {\n  font-family: var(--label-font);\n  flex: 1;\n}\n\n#main-panel-heading {\n  font-size: 24px;\n  font-weight: bold;\n}\n\n#main-panel-subheading {\n  margin-top: 8px;\n  font-size: 16px;\n  white-space: pre-wrap;\n  color: #505050;\n\n  max-height: 64px;\n  overflow: auto;\n  line-height: normal;\n}\n\n#main-panel-header .icon-container {\n  margin-left: 12px;\n}\n\n#footer {\n  color: white;\n  background-color: #2c2c32;\n  font-size: 16px;\n  padding: 12px;\n  height: var(--footer-height);\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n#footer a {\n  color: inherit;\n}\n\n#footer a:hover {\n  color: #c3c2fd;\n}\n\n.closed {\n  display: none;\n}\n\n.resizer {\n  background-color: var(--side-panel-bg-color);\n  width: 8px;\n  height: 100%;\n  cursor: col-resize;\n}\n\n.resizer.dragging, .resizer:hover {\n  background-color: #9b9b9b;\n}\n\n.icon {\n  color: inherit;\n}\n\n.icon-container {\n  display: flex;\n}\n\n.icon-container .icon {\n  font-size: 24px;\n}\n\n.icon-container > * + * {\n  margin-left: 4px;\n}\n\n.collapsible {\n  overflow: hidden;\n  transition: height 250ms ease-out;\n}\n\n.title-container {\n  display: flex;\n  align-items: center;\n}\n\n.title-container > * + * {\n  margin-left: 12px;\n}\n\n.title {\n  font-family: 'Carter One', sans-serif;\n  font-size: 24px;\n}\n\n.data-import-results {\n  font-family: var(--label-font);\n  font-size: 14px;\n  white-space: pre-wrap;\n  line-height: 1.5;\n}\n\n.data-import-error-list {\n  list-style: disc inside;\n}\n\n@media (max-width: 400px) {\n  .title-container .title {\n    display: none;\n  }\n}\n\n@media (max-height: 500px) {\n  #main-panel-subheading {\n    max-height: 24px;\n  }\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./src/styles/reset.css":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./src/styles/reset.css ***!
  \******************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/*\n * Adapted from:\n * http://meyerweb.com/eric/tools/css/reset/\n * v2.0 - 2011-01-26\n */\n\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed,\nfigure, figcaption, footer, header, hgroup,\nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video,\ninput, button, select, textarea {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tfont-size: 100%;\n\tfont: inherit;\n\tvertical-align: baseline;\n}\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section {\n\tdisplay: block;\n}\nbody {\n\tline-height: 1;\n}\nol, ul {\n\tlist-style: none;\n}\nblockquote, q {\n\tquotes: none;\n}\nblockquote:before, blockquote:after,\nq:before, q:after {\n\tcontent: '';\n\tcontent: none;\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n", "",{"version":3,"sources":["webpack://./src/styles/reset.css"],"names":[],"mappings":"AAAA;;;;EAIE;;AAEF;;;;;;;;;;;;;;CAcC,SAAS;CACT,UAAU;CACV,SAAS;CACT,eAAe;CACf,aAAa;CACb,wBAAwB;AACzB;AACA,gDAAgD;AAChD;;CAEC,cAAc;AACf;AACA;CACC,cAAc;AACf;AACA;CACC,gBAAgB;AACjB;AACA;CACC,YAAY;AACb;AACA;;CAEC,WAAW;CACX,aAAa;AACd;AACA;CACC,yBAAyB;CACzB,iBAAiB;AAClB","sourcesContent":["/*\n * Adapted from:\n * http://meyerweb.com/eric/tools/css/reset/\n * v2.0 - 2011-01-26\n */\n\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed,\nfigure, figcaption, footer, header, hgroup,\nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video,\ninput, button, select, textarea {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tfont-size: 100%;\n\tfont: inherit;\n\tvertical-align: baseline;\n}\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section {\n\tdisplay: block;\n}\nbody {\n\tline-height: 1;\n}\nol, ul {\n\tlist-style: none;\n}\nblockquote, q {\n\tquotes: none;\n}\nblockquote:before, blockquote:after,\nq:before, q:after {\n\tcontent: '';\n\tcontent: none;\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/datePicker.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/datePicker.css ***!
  \*************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".date-picker-heading {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.date-picker-heading select, .date-picker-heading input {\n  font-size: 16px;\n}\n\n.date-picker-grid {\n  margin: 12px 0;\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  gap: 6px;\n}\n\n.date-picker-day-header, .date-picker-day {\n  width: 40px;\n  height: 40px;\n  line-height: 32px;\n  padding: 4px;\n  font-family: var(--label-font);\n  font-size: 16px;\n  text-align: center;\n\n  border-radius: 20px;\n}\n\n.date-picker-day-header {\n  font-weight: bold;\n}\n\n.date-picker-day.selected {\n  color: white;\n  background-color: rgb(35, 35, 211);\n  font-weight: bold;\n}\n\n.date-picker-day.today {\n  font-weight: bold;\n  border: 1px solid black;\n}\n\n.date-picker-day.different-month {\n  color: #707070;\n}\n\n.date-picker-day.selected.different-month {\n  color: white;\n  background-color: rgba(35, 35, 211, 0.5);\n}\n", "",{"version":3,"sources":["webpack://./src/styles/datePicker.css"],"names":[],"mappings":"AAAA;EACE,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;AACrB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,cAAc;EACd,aAAa;EACb,qCAAqC;EACrC,QAAQ;AACV;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,iBAAiB;EACjB,YAAY;EACZ,8BAA8B;EAC9B,eAAe;EACf,kBAAkB;;EAElB,mBAAmB;AACrB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,YAAY;EACZ,kCAAkC;EAClC,iBAAiB;AACnB;;AAEA;EACE,iBAAiB;EACjB,uBAAuB;AACzB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,YAAY;EACZ,wCAAwC;AAC1C","sourcesContent":[".date-picker-heading {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.date-picker-heading select, .date-picker-heading input {\n  font-size: 16px;\n}\n\n.date-picker-grid {\n  margin: 12px 0;\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  gap: 6px;\n}\n\n.date-picker-day-header, .date-picker-day {\n  width: 40px;\n  height: 40px;\n  line-height: 32px;\n  padding: 4px;\n  font-family: var(--label-font);\n  font-size: 16px;\n  text-align: center;\n\n  border-radius: 20px;\n}\n\n.date-picker-day-header {\n  font-weight: bold;\n}\n\n.date-picker-day.selected {\n  color: white;\n  background-color: rgb(35, 35, 211);\n  font-weight: bold;\n}\n\n.date-picker-day.today {\n  font-weight: bold;\n  border: 1px solid black;\n}\n\n.date-picker-day.different-month {\n  color: #707070;\n}\n\n.date-picker-day.selected.different-month {\n  color: white;\n  background-color: rgba(35, 35, 211, 0.5);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/filterMenu.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/filterMenu.css ***!
  \*************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".filter-menu {\n  margin: 24px;\n}\n\n.filter-group {\n  margin-bottom: 12px;\n}\n\n.filter-group-heading {\n  display: flex;\n  justify-content: space-between;\n  margin-right: 2px;\n}\n\n.filter-group-heading > .icon-container > .icon {\n  margin-left: 4px;\n}\n\n.filter-group-toggle {\n  flex: 1;\n  text-align: left;\n  padding: 8px;\n}\n\n.filter-group-expand-icon {\n  font-size: 24px;\n  vertical-align: middle;\n}\n\n.filter-group-label {\n  font-family: var(--label-font);\n  font-size: 16px;\n  font-weight: bold;\n  vertical-align: middle;\n}\n\n.filter-list {\n  padding: 2px;\n}\n\n.filter-item {\n  margin: 4px 0 6px 32px;\n}\n\n.filter-item-selector {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  width: 100%;\n\n  padding: 8px;\n  border-radius: 4px;\n  outline-offset: 0;\n}\n\n.filter-item-selector:hover, .filter-item.selected .filter-item-selector {\n  background-color: #dadada;\n}\n\n.filter-item-label {\n  font-family: var(--label-font);\n  font-size: 16px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n", "",{"version":3,"sources":["webpack://./src/styles/filterMenu.css"],"names":[],"mappings":"AAAA;EACE,YAAY;AACd;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,aAAa;EACb,8BAA8B;EAC9B,iBAAiB;AACnB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,OAAO;EACP,gBAAgB;EAChB,YAAY;AACd;;AAEA;EACE,eAAe;EACf,sBAAsB;AACxB;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,iBAAiB;EACjB,sBAAsB;AACxB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;EACnB,WAAW;;EAEX,YAAY;EACZ,kBAAkB;EAClB,iBAAiB;AACnB;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;AACrB","sourcesContent":[".filter-menu {\n  margin: 24px;\n}\n\n.filter-group {\n  margin-bottom: 12px;\n}\n\n.filter-group-heading {\n  display: flex;\n  justify-content: space-between;\n  margin-right: 2px;\n}\n\n.filter-group-heading > .icon-container > .icon {\n  margin-left: 4px;\n}\n\n.filter-group-toggle {\n  flex: 1;\n  text-align: left;\n  padding: 8px;\n}\n\n.filter-group-expand-icon {\n  font-size: 24px;\n  vertical-align: middle;\n}\n\n.filter-group-label {\n  font-family: var(--label-font);\n  font-size: 16px;\n  font-weight: bold;\n  vertical-align: middle;\n}\n\n.filter-list {\n  padding: 2px;\n}\n\n.filter-item {\n  margin: 4px 0 6px 32px;\n}\n\n.filter-item-selector {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  width: 100%;\n\n  padding: 8px;\n  border-radius: 4px;\n  outline-offset: 0;\n}\n\n.filter-item-selector:hover, .filter-item.selected .filter-item-selector {\n  background-color: #dadada;\n}\n\n.filter-item-label {\n  font-family: var(--label-font);\n  font-size: 16px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/form.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/form.css ***!
  \*******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "input:focus, select:focus, textarea:focus, button:focus {\n  outline: 1px solid blue;\n}\n\n/* Use :focus-visible if browser supports it */\n:is(input, select, textarea, button):focus:not(:focus-visible) {\n  outline: none;\n}\n\ninput:invalid, select:invalid, textarea:invalid {\n  outline: 1px solid red;\n}\n\nbutton {\n  background-color: transparent;\n  border-style: none;\n  cursor: pointer;\n}\n\ninput[type=\"radio\"], input[type=\"checkbox\"] {\n  margin: 0 6px;\n}\n\n.toggle-button {\n  padding: 6px;\n\n  font-family: var(--label-font);\n  font-size: 14px;\n\n  color: black;\n  background-color: white;\n  border: 1px solid black;\n  border-radius: 6px;\n\n  transition: color 100ms, background-color 100ms;\n}\n\n.toggle-button.active {\n  color: white;\n  background-color: #2323d3;\n}\n\n.toggle-button.active:disabled {\n  color: var(--input-disabled-color);\n  background-color: #c8c8f4;\n}\n\n.form-input-container {\n  margin: 12px 0 24px;\n}\n\n.form-input-date-container {\n  display: flex;\n  width: 100%;\n}\n\n.form-input-date-container input {\n  flex: auto;\n  margin-right: 6px;\n}\n\n.form-input-date-container-inline input {\n  width: 150px;\n  margin-right: 6px;\n}\n\n.form-input-label {\n  display: block;\n  font-family: var(--label-font);\n  font-size: 16px;\n  font-weight: bold;\n  margin-bottom: 8px;\n}\n\n.form-input-label-inline {\n  font-family: var(--label-font);\n  font-size: 14px;\n}\n\n.form-input, .form-select, .form-textarea {\n  width: 100%;\n}\n\n.form-input,\n.form-input-inline,\n.form-select,\n.form-select-inline,\n.form-textarea,\n.form-button {\n  padding: 8px;\n  border: 1px solid black;\n  border-radius: 8px;\n\n  font-family: var(--label-font);\n  font-size: 14px;\n}\n\n.form-select {\n  text-overflow: ellipsis;\n}\n\n.form-textarea {\n  width: 100%;\n  resize: vertical;\n}\n\n.form-button {\n  background-color: white;\n}\n\n.form-button:active {\n  background-color: #f0f0f0;\n}\n\n.form-button-container > .form-button + .form-button {\n  margin-left: 8px;\n}\n\n.form-input-item-container {\n  padding: 8px 0;\n}\n\n.form-input-item-label {\n  padding-left: 8px;\n  font-family: var(--label-font);\n  font-size: 14px;\n}\n\n.form-input-inline.form-input-count {\n  width: 90px;\n}\n\n.form-input-hidden {\n  display: none;\n}\n\n.form-weekday-button {\n  margin: 8px 6px 8px 0;\n  border-radius: 10px;\n}\n\n.form-input:disabled,\n.form-input-inline:disabled,\n.form-select:disabled,\n.form-select-inline:disabled,\n.form-textarea:disabled,\n.form-button:disabled,\n.toggle-button:disabled {\n  color: var(--input-disabled-color);\n  background-color: var(--input-disabled-bg-color);\n  border-color: var(--input-disabled-bg-color);\n}\n\n.confirmation-box {\n  display: block;\n  margin-top: 8px;\n}\n", "",{"version":3,"sources":["webpack://./src/styles/form.css"],"names":[],"mappings":"AAAA;EACE,uBAAuB;AACzB;;AAEA,8CAA8C;AAC9C;EACE,aAAa;AACf;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE,6BAA6B;EAC7B,kBAAkB;EAClB,eAAe;AACjB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,YAAY;;EAEZ,8BAA8B;EAC9B,eAAe;;EAEf,YAAY;EACZ,uBAAuB;EACvB,uBAAuB;EACvB,kBAAkB;;EAElB,+CAA+C;AACjD;;AAEA;EACE,YAAY;EACZ,yBAAyB;AAC3B;;AAEA;EACE,kCAAkC;EAClC,yBAAyB;AAC3B;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,aAAa;EACb,WAAW;AACb;;AAEA;EACE,UAAU;EACV,iBAAiB;AACnB;;AAEA;EACE,YAAY;EACZ,iBAAiB;AACnB;;AAEA;EACE,cAAc;EACd,8BAA8B;EAC9B,eAAe;EACf,iBAAiB;EACjB,kBAAkB;AACpB;;AAEA;EACE,8BAA8B;EAC9B,eAAe;AACjB;;AAEA;EACE,WAAW;AACb;;AAEA;;;;;;EAME,YAAY;EACZ,uBAAuB;EACvB,kBAAkB;;EAElB,8BAA8B;EAC9B,eAAe;AACjB;;AAEA;EACE,uBAAuB;AACzB;;AAEA;EACE,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,uBAAuB;AACzB;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,iBAAiB;EACjB,8BAA8B;EAC9B,eAAe;AACjB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;AACrB;;AAEA;;;;;;;EAOE,kCAAkC;EAClC,gDAAgD;EAChD,4CAA4C;AAC9C;;AAEA;EACE,cAAc;EACd,eAAe;AACjB","sourcesContent":["input:focus, select:focus, textarea:focus, button:focus {\n  outline: 1px solid blue;\n}\n\n/* Use :focus-visible if browser supports it */\n:is(input, select, textarea, button):focus:not(:focus-visible) {\n  outline: none;\n}\n\ninput:invalid, select:invalid, textarea:invalid {\n  outline: 1px solid red;\n}\n\nbutton {\n  background-color: transparent;\n  border-style: none;\n  cursor: pointer;\n}\n\ninput[type=\"radio\"], input[type=\"checkbox\"] {\n  margin: 0 6px;\n}\n\n.toggle-button {\n  padding: 6px;\n\n  font-family: var(--label-font);\n  font-size: 14px;\n\n  color: black;\n  background-color: white;\n  border: 1px solid black;\n  border-radius: 6px;\n\n  transition: color 100ms, background-color 100ms;\n}\n\n.toggle-button.active {\n  color: white;\n  background-color: #2323d3;\n}\n\n.toggle-button.active:disabled {\n  color: var(--input-disabled-color);\n  background-color: #c8c8f4;\n}\n\n.form-input-container {\n  margin: 12px 0 24px;\n}\n\n.form-input-date-container {\n  display: flex;\n  width: 100%;\n}\n\n.form-input-date-container input {\n  flex: auto;\n  margin-right: 6px;\n}\n\n.form-input-date-container-inline input {\n  width: 150px;\n  margin-right: 6px;\n}\n\n.form-input-label {\n  display: block;\n  font-family: var(--label-font);\n  font-size: 16px;\n  font-weight: bold;\n  margin-bottom: 8px;\n}\n\n.form-input-label-inline {\n  font-family: var(--label-font);\n  font-size: 14px;\n}\n\n.form-input, .form-select, .form-textarea {\n  width: 100%;\n}\n\n.form-input,\n.form-input-inline,\n.form-select,\n.form-select-inline,\n.form-textarea,\n.form-button {\n  padding: 8px;\n  border: 1px solid black;\n  border-radius: 8px;\n\n  font-family: var(--label-font);\n  font-size: 14px;\n}\n\n.form-select {\n  text-overflow: ellipsis;\n}\n\n.form-textarea {\n  width: 100%;\n  resize: vertical;\n}\n\n.form-button {\n  background-color: white;\n}\n\n.form-button:active {\n  background-color: #f0f0f0;\n}\n\n.form-button-container > .form-button + .form-button {\n  margin-left: 8px;\n}\n\n.form-input-item-container {\n  padding: 8px 0;\n}\n\n.form-input-item-label {\n  padding-left: 8px;\n  font-family: var(--label-font);\n  font-size: 14px;\n}\n\n.form-input-inline.form-input-count {\n  width: 90px;\n}\n\n.form-input-hidden {\n  display: none;\n}\n\n.form-weekday-button {\n  margin: 8px 6px 8px 0;\n  border-radius: 10px;\n}\n\n.form-input:disabled,\n.form-input-inline:disabled,\n.form-select:disabled,\n.form-select-inline:disabled,\n.form-textarea:disabled,\n.form-button:disabled,\n.toggle-button:disabled {\n  color: var(--input-disabled-color);\n  background-color: var(--input-disabled-bg-color);\n  border-color: var(--input-disabled-bg-color);\n}\n\n.confirmation-box {\n  display: block;\n  margin-top: 8px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/modal.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/modal.css ***!
  \********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 100;\n  background-color: rgba(0, 0, 0, 0.7);\n}\n\n.modal-wrapper {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 200;\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.modal {\n  width: 400px;\n  max-width: 100vw;\n  max-height: min(600px, 100vh);\n  overflow: auto;\n\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n\n  background-color: white;\n  border: 1px solid black;\n  border-radius: 8px;\n}\n\n.modal-title-bar {\n  background-color: var(--modal-accent-color);\n  width: 100%;\n  padding: 12px;\n  border-bottom: 1px solid black;\n  flex: none;\n\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.modal-title-bar .icon {\n  font-size: 24px;\n}\n\n.modal-title {\n  font-family: var(--label-font);\n  font-size: 20px;\n  font-weight: bold;\n}\n\n.modal-content {\n  width: 100%;\n  overflow: auto;\n  padding: 12px;\n}\n\n.modal-button-container {\n  display: flex;\n  justify-content: flex-end;\n\n  width: 100%;\n  padding: 12px;\n\n  border-top: 1px solid black;\n  background-color: var(--modal-accent-color);\n}\n\n.modal-button-container > * + * {\n  margin-left: 12px;\n}\n\n.modal-button {\n  width: 100px;\n  padding: 6px;\n\n  font-family: var(--label-font);\n  font-size: 16px;\n\n  background-color: white;\n  border: 1px solid black;\n  border-radius: 6px;\n}\n\n.modal-button:focus {\n  font-weight: bold;\n}\n\n.modal-button.modal-okay {\n  color: white;\n  background-color: #2323d3;\n}\n\n.info-modal-content-paragraph {\n  font-family: var(--label-font);\n  font-size: 14px;\n  line-height: 1.5;\n}\n\n.info-modal-content-paragraph + .info-modal-content-paragraph {\n  margin-top: 12px;\n}\n", "",{"version":3,"sources":["webpack://./src/styles/modal.css"],"names":[],"mappings":"AAAA;EACE,eAAe;EACf,MAAM;EACN,OAAO;EACP,YAAY;EACZ,aAAa;EACb,YAAY;EACZ,oCAAoC;AACtC;;AAEA;EACE,eAAe;EACf,MAAM;EACN,OAAO;EACP,YAAY;EACZ,aAAa;EACb,YAAY;;EAEZ,aAAa;EACb,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,YAAY;EACZ,gBAAgB;EAChB,6BAA6B;EAC7B,cAAc;;EAEd,aAAa;EACb,sBAAsB;EACtB,mBAAmB;;EAEnB,uBAAuB;EACvB,uBAAuB;EACvB,kBAAkB;AACpB;;AAEA;EACE,2CAA2C;EAC3C,WAAW;EACX,aAAa;EACb,8BAA8B;EAC9B,UAAU;;EAEV,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;AACrB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,iBAAiB;AACnB;;AAEA;EACE,WAAW;EACX,cAAc;EACd,aAAa;AACf;;AAEA;EACE,aAAa;EACb,yBAAyB;;EAEzB,WAAW;EACX,aAAa;;EAEb,2BAA2B;EAC3B,2CAA2C;AAC7C;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,YAAY;EACZ,YAAY;;EAEZ,8BAA8B;EAC9B,eAAe;;EAEf,uBAAuB;EACvB,uBAAuB;EACvB,kBAAkB;AACpB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,YAAY;EACZ,yBAAyB;AAC3B;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB","sourcesContent":[".modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 100;\n  background-color: rgba(0, 0, 0, 0.7);\n}\n\n.modal-wrapper {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 200;\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.modal {\n  width: 400px;\n  max-width: 100vw;\n  max-height: min(600px, 100vh);\n  overflow: auto;\n\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n\n  background-color: white;\n  border: 1px solid black;\n  border-radius: 8px;\n}\n\n.modal-title-bar {\n  background-color: var(--modal-accent-color);\n  width: 100%;\n  padding: 12px;\n  border-bottom: 1px solid black;\n  flex: none;\n\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.modal-title-bar .icon {\n  font-size: 24px;\n}\n\n.modal-title {\n  font-family: var(--label-font);\n  font-size: 20px;\n  font-weight: bold;\n}\n\n.modal-content {\n  width: 100%;\n  overflow: auto;\n  padding: 12px;\n}\n\n.modal-button-container {\n  display: flex;\n  justify-content: flex-end;\n\n  width: 100%;\n  padding: 12px;\n\n  border-top: 1px solid black;\n  background-color: var(--modal-accent-color);\n}\n\n.modal-button-container > * + * {\n  margin-left: 12px;\n}\n\n.modal-button {\n  width: 100px;\n  padding: 6px;\n\n  font-family: var(--label-font);\n  font-size: 16px;\n\n  background-color: white;\n  border: 1px solid black;\n  border-radius: 6px;\n}\n\n.modal-button:focus {\n  font-weight: bold;\n}\n\n.modal-button.modal-okay {\n  color: white;\n  background-color: #2323d3;\n}\n\n.info-modal-content-paragraph {\n  font-family: var(--label-font);\n  font-size: 14px;\n  line-height: 1.5;\n}\n\n.info-modal-content-paragraph + .info-modal-content-paragraph {\n  margin-top: 12px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/popupMenu.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/popupMenu.css ***!
  \************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".popup-menu-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 950;\n  background-color: transparent;\n}\n\n.popup-menu {\n  position: absolute;\n  top: 0;\n  left: 0;\n  border: 1px solid black;\n  background-color: white;\n  z-index: 1000;\n  max-width: 100vw;\n  max-height: 100vh;\n  overflow: auto;\n}\n\n.popup-menu-item {\n  padding: 8px;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.popup-menu-item + .popup-menu-item {\n  border-top: 1px solid var(--item-separator-color);\n}\n\n.popup-menu-item.active {\n  background-color: var(--item-selection-color);\n}\n\n.popup-menu-item-icon {\n  width: 24px;\n  height: 24px;\n}\n\n.popup-menu-item-label {\n  font-family: var(--label-font);\n  font-size: 16px;\n  flex: 1;\n  margin-left: 8px;\n}\n", "",{"version":3,"sources":["webpack://./src/styles/popupMenu.css"],"names":[],"mappings":"AAAA;EACE,eAAe;EACf,MAAM;EACN,OAAO;EACP,YAAY;EACZ,aAAa;EACb,YAAY;EACZ,6BAA6B;AAC/B;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,uBAAuB;EACvB,uBAAuB;EACvB,aAAa;EACb,gBAAgB;EAChB,iBAAiB;EACjB,cAAc;AAChB;;AAEA;EACE,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,eAAe;AACjB;;AAEA;EACE,iDAAiD;AACnD;;AAEA;EACE,6CAA6C;AAC/C;;AAEA;EACE,WAAW;EACX,YAAY;AACd;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,OAAO;EACP,gBAAgB;AAClB","sourcesContent":[".popup-menu-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 950;\n  background-color: transparent;\n}\n\n.popup-menu {\n  position: absolute;\n  top: 0;\n  left: 0;\n  border: 1px solid black;\n  background-color: white;\n  z-index: 1000;\n  max-width: 100vw;\n  max-height: 100vh;\n  overflow: auto;\n}\n\n.popup-menu-item {\n  padding: 8px;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.popup-menu-item + .popup-menu-item {\n  border-top: 1px solid var(--item-separator-color);\n}\n\n.popup-menu-item.active {\n  background-color: var(--item-selection-color);\n}\n\n.popup-menu-item-icon {\n  width: 24px;\n  height: 24px;\n}\n\n.popup-menu-item-label {\n  font-family: var(--label-font);\n  font-size: 16px;\n  flex: 1;\n  margin-left: 8px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/taskPanel.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/taskPanel.css ***!
  \************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".task-panel {\n  width: 100%;\n  border-top: 1px solid var(--item-separator-color);\n  flex: 1;\n  overflow: auto;\n}\n\n.task-panel-content {\n  width: 100%;\n  max-width: var(--main-content-width);\n  padding: 12px;\n  margin: auto;\n}\n\n.task-list-heading {\n  font-family: var(--label-font);\n  font-size: 20px;\n  font-weight: bold;\n  margin-top: 28px;\n  padding: 0 8px;\n}\n\n.task-list-item {\n  font-family: var(--label-font);\n  display: flex;\n  align-items: flex-start;\n  padding: 12px 8px;\n}\n\n.task-list-item + .task-list-item {\n  border-top: 1px solid var(--item-separator-color);\n}\n\n.task-list-item:hover {\n  background-color: var(--item-selection-color);\n  border-radius: 8px;\n}\n\n.task-list-item-checkbox {\n  margin: 2px 12px 4px 0;\n}\n\n.task-list-item-info-container {\n  flex: 1;\n}\n\n.task-list-item-name {\n  font-size: 18px;\n  margin: 6px 0;\n}\n\n.task-list-item-description {\n  font-size: 14px;\n  margin: 6px 0;\n  color: #505050;\n  white-space: pre-wrap;\n}\n\n.task-list-item-details {\n  font-size: 14px;\n}\n\n.task-list-item .icon-container {\n  margin-left: 12px;\n}\n\n.task-list-empty {\n  font-family: var(--label-font);\n  font-size: 18px;\n  color: #505050;\n  padding: 0 8px;\n}\n", "",{"version":3,"sources":["webpack://./src/styles/taskPanel.css"],"names":[],"mappings":"AAAA;EACE,WAAW;EACX,iDAAiD;EACjD,OAAO;EACP,cAAc;AAChB;;AAEA;EACE,WAAW;EACX,oCAAoC;EACpC,aAAa;EACb,YAAY;AACd;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,iBAAiB;EACjB,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,8BAA8B;EAC9B,aAAa;EACb,uBAAuB;EACvB,iBAAiB;AACnB;;AAEA;EACE,iDAAiD;AACnD;;AAEA;EACE,6CAA6C;EAC7C,kBAAkB;AACpB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE,OAAO;AACT;;AAEA;EACE,eAAe;EACf,aAAa;AACf;;AAEA;EACE,eAAe;EACf,aAAa;EACb,cAAc;EACd,qBAAqB;AACvB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,cAAc;EACd,cAAc;AAChB","sourcesContent":[".task-panel {\n  width: 100%;\n  border-top: 1px solid var(--item-separator-color);\n  flex: 1;\n  overflow: auto;\n}\n\n.task-panel-content {\n  width: 100%;\n  max-width: var(--main-content-width);\n  padding: 12px;\n  margin: auto;\n}\n\n.task-list-heading {\n  font-family: var(--label-font);\n  font-size: 20px;\n  font-weight: bold;\n  margin-top: 28px;\n  padding: 0 8px;\n}\n\n.task-list-item {\n  font-family: var(--label-font);\n  display: flex;\n  align-items: flex-start;\n  padding: 12px 8px;\n}\n\n.task-list-item + .task-list-item {\n  border-top: 1px solid var(--item-separator-color);\n}\n\n.task-list-item:hover {\n  background-color: var(--item-selection-color);\n  border-radius: 8px;\n}\n\n.task-list-item-checkbox {\n  margin: 2px 12px 4px 0;\n}\n\n.task-list-item-info-container {\n  flex: 1;\n}\n\n.task-list-item-name {\n  font-size: 18px;\n  margin: 6px 0;\n}\n\n.task-list-item-description {\n  font-size: 14px;\n  margin: 6px 0;\n  color: #505050;\n  white-space: pre-wrap;\n}\n\n.task-list-item-details {\n  font-size: 14px;\n}\n\n.task-list-item .icon-container {\n  margin-left: 12px;\n}\n\n.task-list-empty {\n  font-family: var(--label-font);\n  font-size: 18px;\n  color: #505050;\n  padding: 0 8px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/variables.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/variables.css ***!
  \************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ":root {\n  --label-font: Verdana, Geneva, Tahoma, sans-serif;\n  --content-font: 'Times New Roman', Times, serif;\n  --header-height: 56px;\n  --footer-height: 44px;\n  --side-panel-bg-color: #f4f4f4;\n  --modal-accent-color: #d4d4d4;\n  --input-disabled-color: #707070;\n  --input-disabled-bg-color: #e2e2e2;\n  --item-separator-color: #f0f0f0;\n  --item-selection-color: #f0f0f0;\n  --main-content-width: 800px;\n}\n", "",{"version":3,"sources":["webpack://./src/styles/variables.css"],"names":[],"mappings":"AAAA;EACE,iDAAiD;EACjD,+CAA+C;EAC/C,qBAAqB;EACrB,qBAAqB;EACrB,8BAA8B;EAC9B,6BAA6B;EAC7B,+BAA+B;EAC/B,kCAAkC;EAClC,+BAA+B;EAC/B,+BAA+B;EAC/B,2BAA2B;AAC7B","sourcesContent":[":root {\n  --label-font: Verdana, Geneva, Tahoma, sans-serif;\n  --content-font: 'Times New Roman', Times, serif;\n  --header-height: 56px;\n  --footer-height: 44px;\n  --side-panel-bg-color: #f4f4f4;\n  --modal-accent-color: #d4d4d4;\n  --input-disabled-color: #707070;\n  --input-disabled-bg-color: #e2e2e2;\n  --item-separator-color: #f0f0f0;\n  --item-selection-color: #f0f0f0;\n  --main-content-width: 800px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./src/styles/main.css":
/*!*****************************!*\
  !*** ./src/styles/main.css ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_main_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./main.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./src/styles/main.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_main_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_main_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_main_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_main_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/styles/reset.css":
/*!******************************!*\
  !*** ./src/styles/reset.css ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_reset_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./reset.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./src/styles/reset.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ (function(module) {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ (function(module) {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	!function() {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/app */ "./src/modules/app.js");

var app = new _modules_app__WEBPACK_IMPORTED_MODULE_0__["default"](document.body);
app.run();
}();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQSxlQUFlLDRCQUE0QjtXQUMzQyxlQUFlO1dBQ2YsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BELDhDQUE4Qzs7Ozs7V0NBOUM7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDSkE7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUVBLElBQU1xb0MsR0FBRyxHQUFHLElBQUk0RyxvREFBSixDQUFRdkosUUFBUSxDQUFDZ1EsSUFBakIsQ0FBWjtBQUNBck4sR0FBRyxDQUFDOG1CLEdBQUosRyIsInNvdXJjZXMiOlsid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2FkZExlYWRpbmdaZXJvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2Fzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2Zvcm1hdC9mb3JtYXR0ZXJzL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZm9ybWF0L2xpZ2h0Rm9ybWF0dGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2Zvcm1hdC9sb25nRm9ybWF0dGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRVVENEYXlPZlllYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRVVENJU09XZWVrL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZ2V0VVRDSVNPV2Vla1llYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRVVENXZWVrL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZ2V0VVRDV2Vla1llYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9wcm90ZWN0ZWRUb2tlbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9zZXRVVENEYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9zZXRVVENJU09EYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9zZXRVVENJU09XZWVrL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvc2V0VVRDV2Vlay9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL3N0YXJ0T2ZVVENJU09XZWVrL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvc3RhcnRPZlVUQ0lTT1dlZWtZZWFyL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvc3RhcnRPZlVUQ1dlZWsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9zdGFydE9mVVRDV2Vla1llYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi90b0ludGVnZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vYWRkL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2FkZERheXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vYWRkTWlsbGlzZWNvbmRzL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2FkZE1vbnRocy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9jb25zdGFudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vZW5kT2ZEYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vZm9ybWF0L2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2Zvcm1hdElTTy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9nZXREYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vZ2V0RGF5c0luTW9udGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vaXNCZWZvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vaXNEYXRlL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2lzU2FtZURheS9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9pc1NhbWVNb250aC9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9pc1RvZGF5L2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2lzVmFsaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vaXNXZWVrZW5kL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9fbGliL2J1aWxkTG9jYWxpemVGbi9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvX2xpYi9idWlsZE1hdGNoRm4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL19saWIvYnVpbGRNYXRjaFBhdHRlcm5Gbi9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXREaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXRMb25nL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9fbGliL2xvY2FsaXplL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9fbGliL21hdGNoL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9uZXh0RGF5L2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3BhcnNlL19saWIvcGFyc2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9wYXJzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9wYXJzZUlTTy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9wcmV2aW91c0RheS9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9zdGFydE9mRGF5L2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3N0YXJ0T2ZNb250aC9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9zdGFydE9mV2Vlay9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9zdWJEYXlzL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3N1Yk1pbGxpc2Vjb25kcy9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS90b0RhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXAuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzU2V0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTb3J0ZWRJbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNvcnRlZEluZGV4QnkuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVHJpbS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5pcS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVJhbmdlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVTZXQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RyaW1tZWRFbmRJbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZURlZXAuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0VxdWFsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNNYXAuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU2V0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vb3AuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc29ydGVkSW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc29ydGVkSW5kZXhCeS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zb3J0ZWRMYXN0SW5kZXguanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC91bmlxLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3VuaXFXaXRoLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvb3JkaW5hbC9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL29yZGluYWwvaW5kaWNhdG9yLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2VxLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21ham9yLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ByZXJlbGVhc2UuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcGFyc2Utb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9yZS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvZ3RyLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tc2F0aXNmeWluZy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3NpbXBsaWZ5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9hcHAuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL2NvbGxhcHNpYmxlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9kYXRlUGlja2VyLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9maWx0ZXJNZW51LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9tb2RhbFN0YWNrLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9tb2RhbHMvYWRkUHJvamVjdE1vZGFsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9tb2RhbHMvYWRkVGFza01vZGFsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9tb2RhbHMvY29uZmlybU1vZGFsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9tb2RhbHMvZGF0YU1vZGFsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9tb2RhbHMvZGF0ZVBpY2tlck1vZGFsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9tb2RhbHMvZXhwb3J0TW9kYWwuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL21vZGFscy9pbmZvTW9kYWwuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL21vZGFscy9yZWN1cnJlbmNlTW9kYWwuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL21vZGFscy9zZXR0aW5nc01vZGFsLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9wb3B1cE1lbnUuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL3Byb2plY3QuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL3Byb2plY3RMaXN0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9yZWN1cnJpbmdEYXRlLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vc3JjL21vZHVsZXMvdGFzay5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vc3JjL21vZHVsZXMvdGFza0Rpc3BsYXkuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL3Rhc2tMaXN0LmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy91dGlsaXR5L2RhdGEuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL3V0aWxpdHkvZGF0ZXMuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9tb2R1bGVzL3V0aWxpdHkvZG9tLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvbW9kdWxlcy91dGlsaXR5L3N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9zdHlsZXMvbWFpbi5jc3MiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9zdHlsZXMvcmVzZXQuY3NzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvc3R5bGVzL2RhdGVQaWNrZXIuY3NzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvc3R5bGVzL2ZpbHRlck1lbnUuY3NzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvc3R5bGVzL2Zvcm0uY3NzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvc3R5bGVzL21vZGFsLmNzcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vc3JjL3N0eWxlcy9wb3B1cE1lbnUuY3NzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvc3R5bGVzL3Rhc2tQYW5lbC5jc3MiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL3NyYy9zdHlsZXMvdmFyaWFibGVzLmNzcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vc3JjL3N0eWxlcy9tYWluLmNzcz85ZDEyIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9zcmMvc3R5bGVzL3Jlc2V0LmNzcz9iNDAwIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL3Rhc2staXQtdXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90YXNrLWl0LXVwL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3Rhc2staXQtdXAvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3Rhc2staXQtdXAvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly90YXNrLWl0LXVwL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdGFzay1pdC11cC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Rhc2staXQtdXAvd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly90YXNrLWl0LXVwL3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly90YXNrLWl0LXVwLy4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvcyhudW1iZXIsIHRhcmdldExlbmd0aCkge1xuICB2YXIgc2lnbiA9IG51bWJlciA8IDAgPyAnLScgOiAnJztcbiAgdmFyIG91dHB1dCA9IE1hdGguYWJzKG51bWJlcikudG9TdHJpbmcoKTtcblxuICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBzaWduICsgb3V0cHV0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIGRpcnR5T2JqZWN0KSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Fzc2lnbiByZXF1aXJlcyB0aGF0IGlucHV0IHBhcmFtZXRlciBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGRpcnR5T2JqZWN0ID0gZGlydHlPYmplY3QgfHwge307XG5cbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gZGlydHlPYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpcnR5T2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBkaXJ0eU9iamVjdFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJpbXBvcnQgZ2V0VVRDRGF5T2ZZZWFyIGZyb20gXCIuLi8uLi8uLi9fbGliL2dldFVUQ0RheU9mWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IGdldFVUQ0lTT1dlZWsgZnJvbSBcIi4uLy4uLy4uL19saWIvZ2V0VVRDSVNPV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IGdldFVUQ0lTT1dlZWtZZWFyIGZyb20gXCIuLi8uLi8uLi9fbGliL2dldFVUQ0lTT1dlZWtZZWFyL2luZGV4LmpzXCI7XG5pbXBvcnQgZ2V0VVRDV2VlayBmcm9tIFwiLi4vLi4vLi4vX2xpYi9nZXRVVENXZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgZ2V0VVRDV2Vla1llYXIgZnJvbSBcIi4uLy4uLy4uL19saWIvZ2V0VVRDV2Vla1llYXIvaW5kZXguanNcIjtcbmltcG9ydCBhZGRMZWFkaW5nWmVyb3MgZnJvbSBcIi4uLy4uL2FkZExlYWRpbmdaZXJvcy9pbmRleC5qc1wiO1xuaW1wb3J0IGxpZ2h0Rm9ybWF0dGVycyBmcm9tIFwiLi4vbGlnaHRGb3JtYXR0ZXJzL2luZGV4LmpzXCI7XG52YXIgZGF5UGVyaW9kRW51bSA9IHtcbiAgYW06ICdhbScsXG4gIHBtOiAncG0nLFxuICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgbm9vbjogJ25vb24nLFxuICBtb3JuaW5nOiAnbW9ybmluZycsXG4gIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgbmlnaHQ6ICduaWdodCdcbn07XG4vKlxuICogfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAgYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgfCAgQSogfCBNaWxsaXNlY29uZHMgaW4gZGF5ICAgICAgICAgICAgfFxuICogfCAgYiAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgfCAgQiAgfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgfFxuICogfCAgYyAgfCBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2VlayAgfCAgQyogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfFxuICogfCAgZCAgfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgfCAgRCAgfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZSAgfCBMb2NhbCBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgfCAgRSAgfCBEYXkgb2Ygd2VlayAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgRiogfCBEYXkgb2Ygd2VlayBpbiBtb250aCAgICAgICAgICAgfFxuICogfCAgZyogfCBNb2RpZmllZCBKdWxpYW4gZGF5ICAgICAgICAgICAgfCAgRyAgfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaCAgfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgfCAgSCAgfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaSEgfCBJU08gZGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgfCAgSSEgfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgfFxuICogfCAgaiogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfCAgSiogfCBMb2NhbGl6ZWQgaG91ciB3L28gZGF5IHBlcmlvZCAgfFxuICogfCAgayAgfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgfCAgSyAgfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbCogfCAoZGVwcmVjYXRlZCkgICAgICAgICAgICAgICAgICAgfCAgTCAgfCBTdGFuZC1hbG9uZSBtb250aCAgICAgICAgICAgICAgfFxuICogfCAgbSAgfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTSAgfCBNb250aCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbyEgfCBPcmRpbmFsIG51bWJlciBtb2RpZmllciAgICAgICAgfCAgTyAgfCBUaW1lem9uZSAoR01UKSAgICAgICAgICAgICAgICAgfFxuICogfCAgcCEgfCBMb25nIGxvY2FsaXplZCB0aW1lICAgICAgICAgICAgfCAgUCEgfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgfFxuICogfCAgcSAgfCBTdGFuZC1hbG9uZSBxdWFydGVyICAgICAgICAgICAgfCAgUSAgfCBRdWFydGVyICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgciogfCBSZWxhdGVkIEdyZWdvcmlhbiB5ZWFyICAgICAgICAgfCAgUiEgfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgfFxuICogfCAgcyAgfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUyAgfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgfFxuICogfCAgdCEgfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgfCAgVCEgfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICAgICAgICAgfFxuICogfCAgdSAgfCBFeHRlbmRlZCB5ZWFyICAgICAgICAgICAgICAgICAgfCAgVSogfCBDeWNsaWMgeWVhciAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgdiogfCBUaW1lem9uZSAoZ2VuZXJpYyBub24tbG9jYXQuKSAgfCAgViogfCBUaW1lem9uZSAobG9jYXRpb24pICAgICAgICAgICAgfFxuICogfCAgdyAgfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgfCAgVyogfCBXZWVrIG9mIG1vbnRoICAgICAgICAgICAgICAgICAgfFxuICogfCAgeCAgfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgfCAgWCAgfCBUaW1lem9uZSAoSVNPLTg2MDEpICAgICAgICAgICAgfFxuICogfCAgeSAgfCBZZWFyIChhYnMpICAgICAgICAgICAgICAgICAgICAgfCAgWSAgfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgfFxuICogfCAgeiAgfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgfCAgWiogfCBUaW1lem9uZSAoYWxpYXNlcykgICAgICAgICAgICAgfFxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICogYXJlIG5vdCBpbXBsZW1lbnRlZCBidXQgcmVzZXJ2ZWQgYnkgVW5pY29kZSBzdGFuZGFyZC5cbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAhIGFyZSBub24tc3RhbmRhcmQsIGJ1dCBpbXBsZW1lbnRlZCBieSBkYXRlLWZuczpcbiAqIC0gYG9gIG1vZGlmaWVzIHRoZSBwcmV2aW91cyB0b2tlbiB0byB0dXJuIGl0IGludG8gYW4gb3JkaW5hbCAoc2VlIGBmb3JtYXRgIGRvY3MpXG4gKiAtIGBpYCBpcyBJU08gZGF5IG9mIHdlZWsuIEZvciBgaWAgYW5kIGBpaWAgaXMgcmV0dXJucyBudW1lcmljIElTTyB3ZWVrIGRheXMsXG4gKiAgIGkuZS4gNyBmb3IgU3VuZGF5LCAxIGZvciBNb25kYXksIGV0Yy5cbiAqIC0gYElgIGlzIElTTyB3ZWVrIG9mIHllYXIsIGFzIG9wcG9zZWQgdG8gYHdgIHdoaWNoIGlzIGxvY2FsIHdlZWsgb2YgeWVhci5cbiAqIC0gYFJgIGlzIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyLCBhcyBvcHBvc2VkIHRvIGBZYCB3aGljaCBpcyBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyLlxuICogICBgUmAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBJYCBhbmQgYGlgXG4gKiAgIGZvciB1bml2ZXJzYWwgSVNPIHdlZWstbnVtYmVyaW5nIGRhdGUsIHdoZXJlYXNcbiAqICAgYFlgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgd2AgYW5kIGBlYFxuICogICBmb3Igd2Vlay1udW1iZXJpbmcgZGF0ZSBzcGVjaWZpYyB0byB0aGUgbG9jYWxlLlxuICogLSBgUGAgaXMgbG9uZyBsb2NhbGl6ZWQgZGF0ZSBmb3JtYXRcbiAqIC0gYHBgIGlzIGxvbmcgbG9jYWxpemVkIHRpbWUgZm9ybWF0XG4gKi9cblxudmFyIGZvcm1hdHRlcnMgPSB7XG4gIC8vIEVyYVxuICBHOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGVyYSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA+IDAgPyAxIDogMDtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIEFELCBCQ1xuICAgICAgY2FzZSAnRyc6XG4gICAgICBjYXNlICdHRyc6XG4gICAgICBjYXNlICdHR0cnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnXG4gICAgICAgIH0pO1xuICAgICAgLy8gQSwgQlxuXG4gICAgICBjYXNlICdHR0dHRyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnXG4gICAgICAgIH0pO1xuICAgICAgLy8gQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3RcblxuICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZSdcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBZZWFyXG4gIHk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICAvLyBPcmRpbmFsIG51bWJlclxuICAgIGlmICh0b2tlbiA9PT0gJ3lvJykge1xuICAgICAgdmFyIHNpZ25lZFllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7IC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG5cbiAgICAgIHZhciB5ZWFyID0gc2lnbmVkWWVhciA+IDAgPyBzaWduZWRZZWFyIDogMSAtIHNpZ25lZFllYXI7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih5ZWFyLCB7XG4gICAgICAgIHVuaXQ6ICd5ZWFyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy55KGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhclxuICBZOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIHNpZ25lZFdlZWtZZWFyID0gZ2V0VVRDV2Vla1llYXIoZGF0ZSwgb3B0aW9ucyk7IC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG5cbiAgICB2YXIgd2Vla1llYXIgPSBzaWduZWRXZWVrWWVhciA+IDAgPyBzaWduZWRXZWVrWWVhciA6IDEgLSBzaWduZWRXZWVrWWVhcjsgLy8gVHdvIGRpZ2l0IHllYXJcblxuICAgIGlmICh0b2tlbiA9PT0gJ1lZJykge1xuICAgICAgdmFyIHR3b0RpZ2l0WWVhciA9IHdlZWtZZWFyICUgMTAwO1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0d29EaWdpdFllYXIsIDIpO1xuICAgIH0gLy8gT3JkaW5hbCBudW1iZXJcblxuXG4gICAgaWYgKHRva2VuID09PSAnWW8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrWWVhciwge1xuICAgICAgICB1bml0OiAneWVhcidcbiAgICAgIH0pO1xuICAgIH0gLy8gUGFkZGluZ1xuXG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHdlZWtZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICBSOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgaXNvV2Vla1llYXIgPSBnZXRVVENJU09XZWVrWWVhcihkYXRlKTsgLy8gUGFkZGluZ1xuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29XZWVrWWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRXh0ZW5kZWQgeWVhci4gVGhpcyBpcyBhIHNpbmdsZSBudW1iZXIgZGVzaWduYXRpbmcgdGhlIHllYXIgb2YgdGhpcyBjYWxlbmRhciBzeXN0ZW0uXG4gIC8vIFRoZSBtYWluIGRpZmZlcmVuY2UgYmV0d2VlbiBgeWAgYW5kIGB1YCBsb2NhbGl6ZXJzIGFyZSBCLkMuIHllYXJzOlxuICAvLyB8IFllYXIgfCBgeWAgfCBgdWAgfFxuICAvLyB8LS0tLS0tfC0tLS0tfC0tLS0tfFxuICAvLyB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICAvLyB8IEJDIDEgfCAgIDEgfCAgIDAgfFxuICAvLyB8IEJDIDIgfCAgIDIgfCAgLTEgfFxuICAvLyBBbHNvIGB5eWAgYWx3YXlzIHJldHVybnMgdGhlIGxhc3QgdHdvIGRpZ2l0cyBvZiBhIHllYXIsXG4gIC8vIHdoaWxlIGB1dWAgcGFkcyBzaW5nbGUgZGlnaXQgeWVhcnMgdG8gMiBjaGFyYWN0ZXJzIGFuZCByZXR1cm5zIG90aGVyIHllYXJzIHVuY2hhbmdlZC5cbiAgdTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh5ZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBRdWFydGVyXG4gIFE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgcXVhcnRlciA9IE1hdGguY2VpbCgoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgLyAzKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKHF1YXJ0ZXIpO1xuICAgICAgLy8gMDEsIDAyLCAwMywgMDRcblxuICAgICAgY2FzZSAnUVEnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHF1YXJ0ZXIsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXG5cbiAgICAgIGNhc2UgJ1FvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIocXVhcnRlciwge1xuICAgICAgICAgIHVuaXQ6ICdxdWFydGVyJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFExLCBRMiwgUTMsIFE0XG5cbiAgICAgIGNhc2UgJ1FRUSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcblxuICAgICAgY2FzZSAnUVFRUVEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG5cbiAgICAgIGNhc2UgJ1FRUVEnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgcXVhcnRlclxuICBxOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIHF1YXJ0ZXIgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpIC8gMyk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICBjYXNlICdxJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhxdWFydGVyKTtcbiAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG5cbiAgICAgIGNhc2UgJ3FxJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhxdWFydGVyLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuXG4gICAgICBjYXNlICdxbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB1bml0OiAncXVhcnRlcidcbiAgICAgICAgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuXG4gICAgICBjYXNlICdxcXEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG5cbiAgICAgIGNhc2UgJ3FxcXFxJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuXG4gICAgICBjYXNlICdxcXFxJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIE1vbnRoXG4gIE06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdNJzpcbiAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5NKGRhdGUsIHRva2VuKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcblxuICAgICAgY2FzZSAnTW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHtcbiAgICAgICAgICB1bml0OiAnbW9udGgnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG5cbiAgICAgIGNhc2UgJ01NTSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEosIEYsIC4uLiwgRFxuXG4gICAgICBjYXNlICdNTU1NTSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuXG4gICAgICBjYXNlICdNTU1NJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgbW9udGhcbiAgTDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIC4uLiwgMTJcbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKG1vbnRoICsgMSk7XG4gICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcblxuICAgICAgY2FzZSAnTEwnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKG1vbnRoICsgMSwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG5cbiAgICAgIGNhc2UgJ0xvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobW9udGggKyAxLCB7XG4gICAgICAgICAgdW5pdDogJ21vbnRoJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xuXG4gICAgICBjYXNlICdMTEwnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBKLCBGLCAuLi4sIERcblxuICAgICAgY2FzZSAnTExMTEwnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcblxuICAgICAgY2FzZSAnTExMTCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIExvY2FsIHdlZWsgb2YgeWVhclxuICB3OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIHdlZWsgPSBnZXRVVENXZWVrKGRhdGUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHRva2VuID09PSAnd28nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrLCB7XG4gICAgICAgIHVuaXQ6ICd3ZWVrJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh3ZWVrLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBJU08gd2VlayBvZiB5ZWFyXG4gIEk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaXNvV2VlayA9IGdldFVUQ0lTT1dlZWsoZGF0ZSk7XG5cbiAgICBpZiAodG9rZW4gPT09ICdJbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGlzb1dlZWssIHtcbiAgICAgICAgdW5pdDogJ3dlZWsnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGlzb1dlZWssIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIERheSBvZiB0aGUgbW9udGhcbiAgZDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ2RvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENEYXRlKCksIHtcbiAgICAgICAgdW5pdDogJ2RhdGUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLmQoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBEYXkgb2YgeWVhclxuICBEOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGRheU9mWWVhciA9IGdldFVUQ0RheU9mWWVhcihkYXRlKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJ0RvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF5T2ZZZWFyLCB7XG4gICAgICAgIHVuaXQ6ICdkYXlPZlllYXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRheU9mWWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHdlZWtcbiAgRTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gVHVlXG4gICAgICBjYXNlICdFJzpcbiAgICAgIGNhc2UgJ0VFJzpcbiAgICAgIGNhc2UgJ0VFRSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuXG4gICAgICBjYXNlICdFRUVFRSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG5cbiAgICAgIGNhc2UgJ0VFRUVFRSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuXG4gICAgICBjYXNlICdFRUVFJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBMb2NhbCBkYXkgb2Ygd2Vla1xuICBlOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgdmFyIGxvY2FsRGF5T2ZXZWVrID0gKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBOdW1lcmljYWwgdmFsdWUgKE50aCBkYXkgb2Ygd2VlayB3aXRoIGN1cnJlbnQgbG9jYWxlIG9yIHdlZWtTdGFydHNPbilcbiAgICAgIGNhc2UgJ2UnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGxvY2FsRGF5T2ZXZWVrKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcblxuICAgICAgY2FzZSAnZWUnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGxvY2FsRGF5T2ZXZWVrLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxuXG4gICAgICBjYXNlICdlbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7XG4gICAgICAgICAgdW5pdDogJ2RheSdcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2VlZSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuXG4gICAgICBjYXNlICdlZWVlZSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG5cbiAgICAgIGNhc2UgJ2VlZWVlZSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuXG4gICAgICBjYXNlICdlZWVlJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2Vla1xuICBjOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgdmFyIGxvY2FsRGF5T2ZXZWVrID0gKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBOdW1lcmljYWwgdmFsdWUgKHNhbWUgYXMgaW4gYGVgKVxuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIHJldHVybiBTdHJpbmcobG9jYWxEYXlPZldlZWspO1xuICAgICAgLy8gUGFkZGVkIG51bWVyaWNhbCB2YWx1ZVxuXG4gICAgICBjYXNlICdjYyc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobG9jYWxEYXlPZldlZWssIHRva2VuLmxlbmd0aCk7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCA3dGhcblxuICAgICAgY2FzZSAnY28nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihsb2NhbERheU9mV2Vlaywge1xuICAgICAgICAgIHVuaXQ6ICdkYXknXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdjY2MnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRcblxuICAgICAgY2FzZSAnY2NjY2MnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuXG4gICAgICBjYXNlICdjY2NjY2MnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgY2FzZSAnY2NjYyc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gSVNPIGRheSBvZiB3ZWVrXG4gIGk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgICB2YXIgaXNvRGF5T2ZXZWVrID0gZGF5T2ZXZWVrID09PSAwID8gNyA6IGRheU9mV2VlaztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDJcbiAgICAgIGNhc2UgJ2knOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGlzb0RheU9mV2Vlayk7XG4gICAgICAvLyAwMlxuXG4gICAgICBjYXNlICdpaSc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvRGF5T2ZXZWVrLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgLy8gMm5kXG5cbiAgICAgIGNhc2UgJ2lvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaXNvRGF5T2ZXZWVrLCB7XG4gICAgICAgICAgdW5pdDogJ2RheSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVcblxuICAgICAgY2FzZSAnaWlpJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG5cbiAgICAgIGNhc2UgJ2lpaWlpJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcblxuICAgICAgY2FzZSAnaWlpaWlpJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG5cbiAgICAgIGNhc2UgJ2lpaWknOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIEFNIG9yIFBNXG4gIGE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgdmFyIGRheVBlcmlvZEVudW1WYWx1ZSA9IGhvdXJzIC8gMTIgPj0gMSA/ICdwbScgOiAnYW0nO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnYSc6XG4gICAgICBjYXNlICdhYSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdhYWEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjYXNlICdhYWFhYSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYWFhYSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gQU0sIFBNLCBtaWRuaWdodCwgbm9vblxuICBiOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWU7XG5cbiAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm5vb247XG4gICAgfSBlbHNlIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5taWRuaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gaG91cnMgLyAxMiA+PSAxID8gJ3BtJyA6ICdhbSc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnYic6XG4gICAgICBjYXNlICdiYic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdiYmInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjYXNlICdiYmJiYic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYmJiYic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gaW4gdGhlIG1vcm5pbmcsIGluIHRoZSBhZnRlcm5vb24sIGluIHRoZSBldmVuaW5nLCBhdCBuaWdodFxuICBCOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWU7XG5cbiAgICBpZiAoaG91cnMgPj0gMTcpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uZXZlbmluZztcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLmFmdGVybm9vbjtcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubW9ybmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5uaWdodDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdCJzpcbiAgICAgIGNhc2UgJ0JCJzpcbiAgICAgIGNhc2UgJ0JCQic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdCQkJCQic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnQkJCQic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gSG91ciBbMS0xMl1cbiAgaDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ2hvJykge1xuICAgICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpICUgMTI7XG4gICAgICBpZiAoaG91cnMgPT09IDApIGhvdXJzID0gMTI7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3Vycywge1xuICAgICAgICB1bml0OiAnaG91cidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMuaChkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIEhvdXIgWzAtMjNdXG4gIEg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdIbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDSG91cnMoKSwge1xuICAgICAgICB1bml0OiAnaG91cidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMuSChkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIEhvdXIgWzAtMTFdXG4gIEs6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMjtcblxuICAgIGlmICh0b2tlbiA9PT0gJ0tvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHtcbiAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGhvdXJzLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBIb3VyIFsxLTI0XVxuICBrOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIGlmIChob3VycyA9PT0gMCkgaG91cnMgPSAyNDtcblxuICAgIGlmICh0b2tlbiA9PT0gJ2tvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHtcbiAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGhvdXJzLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBNaW51dGVcbiAgbTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ21vJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENNaW51dGVzKCksIHtcbiAgICAgICAgdW5pdDogJ21pbnV0ZSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMubShkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIFNlY29uZFxuICBzOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnc28nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ1NlY29uZHMoKSwge1xuICAgICAgICB1bml0OiAnc2Vjb25kJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5zKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gRnJhY3Rpb24gb2Ygc2Vjb25kXG4gIFM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMuUyhkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBhbHdheXMgYCdaJ2ApXG4gIFg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgaWYgKHRpbWV6b25lT2Zmc2V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1onO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIEhvdXJzIGFuZCBvcHRpb25hbCBtaW51dGVzXG4gICAgICBjYXNlICdYJzpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGBYWGBcblxuICAgICAgY2FzZSAnWFhYWCc6XG4gICAgICBjYXNlICdYWCc6XG4gICAgICAgIC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQpO1xuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgWFhYYFxuXG4gICAgICBjYXNlICdYWFhYWCc6XG4gICAgICBjYXNlICdYWFgnOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRoIGA6YCBkZWxpbWl0ZXJcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgIH1cbiAgfSxcbiAgLy8gVGltZXpvbmUgKElTTy04NjAxLiBJZiBvZmZzZXQgaXMgMCwgb3V0cHV0IGlzIGAnKzAwOjAwJ2Agb3IgZXF1aXZhbGVudClcbiAgeDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSAneCc6XG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXModGltZXpvbmVPZmZzZXQpO1xuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aG91dCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgeHhgXG5cbiAgICAgIGNhc2UgJ3h4eHgnOlxuICAgICAgY2FzZSAneHgnOlxuICAgICAgICAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYHh4eGBcblxuICAgICAgY2FzZSAneHh4eHgnOlxuICAgICAgY2FzZSAneHh4JzogLy8gSG91cnMgYW5kIG1pbnV0ZXMgd2l0aCBgOmAgZGVsaW1pdGVyXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRpbWV6b25lIChHTVQpXG4gIE86IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gU2hvcnRcbiAgICAgIGNhc2UgJ08nOlxuICAgICAgY2FzZSAnT08nOlxuICAgICAgY2FzZSAnT09PJzpcbiAgICAgICAgcmV0dXJuICdHTVQnICsgZm9ybWF0VGltZXpvbmVTaG9ydCh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICAgIC8vIExvbmdcblxuICAgICAgY2FzZSAnT09PTyc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ0dNVCcgKyBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXRpb24pXG4gIHo6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gU2hvcnRcbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnenonOlxuICAgICAgY2FzZSAnenp6JzpcbiAgICAgICAgcmV0dXJuICdHTVQnICsgZm9ybWF0VGltZXpvbmVTaG9ydCh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICAgIC8vIExvbmdcblxuICAgICAgY2FzZSAnenp6eic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ0dNVCcgKyBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICB9XG4gIH0sXG4gIC8vIFNlY29uZHMgdGltZXN0YW1wXG4gIHQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKG9yaWdpbmFsRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRpbWVzdGFtcCwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICBUOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXN0YW1wID0gb3JpZ2luYWxEYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRpbWVzdGFtcCwgdG9rZW4ubGVuZ3RoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmVTaG9ydChvZmZzZXQsIGRpcnR5RGVsaW1pdGVyKSB7XG4gIHZhciBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcbiAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApO1xuICB2YXIgbWludXRlcyA9IGFic09mZnNldCAlIDYwO1xuXG4gIGlmIChtaW51dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24gKyBTdHJpbmcoaG91cnMpO1xuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGRpcnR5RGVsaW1pdGVyIHx8ICcnO1xuICByZXR1cm4gc2lnbiArIFN0cmluZyhob3VycykgKyBkZWxpbWl0ZXIgKyBhZGRMZWFkaW5nWmVyb3MobWludXRlcywgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyhvZmZzZXQsIGRpcnR5RGVsaW1pdGVyKSB7XG4gIGlmIChvZmZzZXQgJSA2MCA9PT0gMCkge1xuICAgIHZhciBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcbiAgICByZXR1cm4gc2lnbiArIGFkZExlYWRpbmdaZXJvcyhNYXRoLmFicyhvZmZzZXQpIC8gNjAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKG9mZnNldCwgZGlydHlEZWxpbWl0ZXIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZShvZmZzZXQsIGRpcnR5RGVsaW1pdGVyKSB7XG4gIHZhciBkZWxpbWl0ZXIgPSBkaXJ0eURlbGltaXRlciB8fCAnJztcbiAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xuICB2YXIgYWJzT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgdmFyIGhvdXJzID0gYWRkTGVhZGluZ1plcm9zKE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApLCAyKTtcbiAgdmFyIG1pbnV0ZXMgPSBhZGRMZWFkaW5nWmVyb3MoYWJzT2Zmc2V0ICUgNjAsIDIpO1xuICByZXR1cm4gc2lnbiArIGhvdXJzICsgZGVsaW1pdGVyICsgbWludXRlcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0dGVyczsiLCJpbXBvcnQgYWRkTGVhZGluZ1plcm9zIGZyb20gXCIuLi8uLi9hZGRMZWFkaW5nWmVyb3MvaW5kZXguanNcIjtcbi8qXG4gKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XG4gKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxuICovXG5cbnZhciBmb3JtYXR0ZXJzID0ge1xuICAvLyBZZWFyXG4gIHk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIC8vIEZyb20gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS0zMS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfdG9rZW5zXG4gICAgLy8gfCBZZWFyICAgICB8ICAgICB5IHwgeXkgfCAgIHl5eSB8ICB5eXl5IHwgeXl5eXkgfFxuICAgIC8vIHwtLS0tLS0tLS0tfC0tLS0tLS18LS0tLXwtLS0tLS0tfC0tLS0tLS18LS0tLS0tLXxcbiAgICAvLyB8IEFEIDEgICAgIHwgICAgIDEgfCAwMSB8ICAgMDAxIHwgIDAwMDEgfCAwMDAwMSB8XG4gICAgLy8gfCBBRCAxMiAgICB8ICAgIDEyIHwgMTIgfCAgIDAxMiB8ICAwMDEyIHwgMDAwMTIgfFxuICAgIC8vIHwgQUQgMTIzICAgfCAgIDEyMyB8IDIzIHwgICAxMjMgfCAgMDEyMyB8IDAwMTIzIHxcbiAgICAvLyB8IEFEIDEyMzQgIHwgIDEyMzQgfCAzNCB8ICAxMjM0IHwgIDEyMzQgfCAwMTIzNCB8XG4gICAgLy8gfCBBRCAxMjM0NSB8IDEyMzQ1IHwgNDUgfCAxMjM0NSB8IDEyMzQ1IHwgMTIzNDUgfFxuICAgIHZhciBzaWduZWRZZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpOyAvLyBSZXR1cm5zIDEgZm9yIDEgQkMgKHdoaWNoIGlzIHllYXIgMCBpbiBKYXZhU2NyaXB0KVxuXG4gICAgdmFyIHllYXIgPSBzaWduZWRZZWFyID4gMCA/IHNpZ25lZFllYXIgOiAxIC0gc2lnbmVkWWVhcjtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRva2VuID09PSAneXknID8geWVhciAlIDEwMCA6IHllYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1vbnRoXG4gIE06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICByZXR1cm4gdG9rZW4gPT09ICdNJyA/IFN0cmluZyhtb250aCArIDEpIDogYWRkTGVhZGluZ1plcm9zKG1vbnRoICsgMSwgMik7XG4gIH0sXG4gIC8vIERheSBvZiB0aGUgbW9udGhcbiAgZDogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0RhdGUoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gQU0gb3IgUE1cbiAgYTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRhdGUuZ2V0VVRDSG91cnMoKSAvIDEyID49IDEgPyAncG0nIDogJ2FtJztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgY2FzZSAnYWEnOlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIGNhc2UgJ2FhYSc6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWU7XG5cbiAgICAgIGNhc2UgJ2FhYWFhJzpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZVswXTtcblxuICAgICAgY2FzZSAnYWFhYSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlID09PSAnYW0nID8gJ2EubS4nIDogJ3AubS4nO1xuICAgIH1cbiAgfSxcbiAgLy8gSG91ciBbMS0xMl1cbiAgaDogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMiB8fCAxMiwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSG91ciBbMC0yM11cbiAgSDogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0hvdXJzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1pbnV0ZVxuICBtOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDTWludXRlcygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBTZWNvbmRcbiAgczogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ1NlY29uZHMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRnJhY3Rpb24gb2Ygc2Vjb25kXG4gIFM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciBudW1iZXJPZkRpZ2l0cyA9IHRva2VuLmxlbmd0aDtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICB2YXIgZnJhY3Rpb25hbFNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAqIE1hdGgucG93KDEwLCBudW1iZXJPZkRpZ2l0cyAtIDMpKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGZyYWN0aW9uYWxTZWNvbmRzLCB0b2tlbi5sZW5ndGgpO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgZm9ybWF0dGVyczsiLCJmdW5jdGlvbiBkYXRlTG9uZ0Zvcm1hdHRlcihwYXR0ZXJuLCBmb3JtYXRMb25nKSB7XG4gIHN3aXRjaCAocGF0dGVybikge1xuICAgIGNhc2UgJ1AnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7XG4gICAgICAgIHdpZHRoOiAnc2hvcnQnXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1BQJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe1xuICAgICAgICB3aWR0aDogJ21lZGl1bSdcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnUFBQJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe1xuICAgICAgICB3aWR0aDogJ2xvbmcnXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1BQUFAnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHtcbiAgICAgICAgd2lkdGg6ICdmdWxsJ1xuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGltZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZykge1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlICdwJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe1xuICAgICAgICB3aWR0aDogJ3Nob3J0J1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdwcCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHtcbiAgICAgICAgd2lkdGg6ICdtZWRpdW0nXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ3BwcCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHtcbiAgICAgICAgd2lkdGg6ICdsb25nJ1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdwcHBwJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7XG4gICAgICAgIHdpZHRoOiAnZnVsbCdcbiAgICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGVUaW1lTG9uZ0Zvcm1hdHRlcihwYXR0ZXJuLCBmb3JtYXRMb25nKSB7XG4gIHZhciBtYXRjaFJlc3VsdCA9IHBhdHRlcm4ubWF0Y2goLyhQKykocCspPy8pIHx8IFtdO1xuICB2YXIgZGF0ZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsxXTtcbiAgdmFyIHRpbWVQYXR0ZXJuID0gbWF0Y2hSZXN1bHRbMl07XG5cbiAgaWYgKCF0aW1lUGF0dGVybikge1xuICAgIHJldHVybiBkYXRlTG9uZ0Zvcm1hdHRlcihwYXR0ZXJuLCBmb3JtYXRMb25nKTtcbiAgfVxuXG4gIHZhciBkYXRlVGltZUZvcm1hdDtcblxuICBzd2l0Y2ggKGRhdGVQYXR0ZXJuKSB7XG4gICAgY2FzZSAnUCc6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoe1xuICAgICAgICB3aWR0aDogJ3Nob3J0J1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BQJzpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7XG4gICAgICAgIHdpZHRoOiAnbWVkaXVtJ1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BQUCc6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoe1xuICAgICAgICB3aWR0aDogJ2xvbmcnXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUFBQUCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7XG4gICAgICAgIHdpZHRoOiAnZnVsbCdcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gZGF0ZVRpbWVGb3JtYXQucmVwbGFjZSgne3tkYXRlfX0nLCBkYXRlTG9uZ0Zvcm1hdHRlcihkYXRlUGF0dGVybiwgZm9ybWF0TG9uZykpLnJlcGxhY2UoJ3t7dGltZX19JywgdGltZUxvbmdGb3JtYXR0ZXIodGltZVBhdHRlcm4sIGZvcm1hdExvbmcpKTtcbn1cblxudmFyIGxvbmdGb3JtYXR0ZXJzID0ge1xuICBwOiB0aW1lTG9uZ0Zvcm1hdHRlcixcbiAgUDogZGF0ZVRpbWVMb25nRm9ybWF0dGVyXG59O1xuZXhwb3J0IGRlZmF1bHQgbG9uZ0Zvcm1hdHRlcnM7IiwiLyoqXG4gKiBHb29nbGUgQ2hyb21lIGFzIG9mIDY3LjAuMzM5Ni44NyBpbnRyb2R1Y2VkIHRpbWV6b25lcyB3aXRoIG9mZnNldCB0aGF0IGluY2x1ZGVzIHNlY29uZHMuXG4gKiBUaGV5IHVzdWFsbHkgYXBwZWFyIGZvciBkYXRlcyB0aGF0IGRlbm90ZSB0aW1lIGJlZm9yZSB0aGUgdGltZXpvbmVzIHdlcmUgaW50cm9kdWNlZFxuICogKGUuZy4gZm9yICdFdXJvcGUvUHJhZ3VlJyB0aW1lem9uZSB0aGUgb2Zmc2V0IGlzIEdNVCswMDo1Nzo0NCBiZWZvcmUgMSBPY3RvYmVyIDE4OTFcbiAqIGFuZCBHTVQrMDE6MDA6MDAgYWZ0ZXIgdGhhdCBkYXRlKVxuICpcbiAqIERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgYW5kIHdvdWxkIHJldHVybiA1NyBmb3IgdGhlIGV4YW1wbGUgYWJvdmUsXG4gKiB3aGljaCB3b3VsZCBsZWFkIHRvIGluY29ycmVjdCBjYWxjdWxhdGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSB0aW1lem9uZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzIHRoYXQgdGFrZXMgc2Vjb25kcyBpbiBhY2NvdW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKGRhdGUpIHtcbiAgdmFyIHV0Y0RhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCksIGRhdGUuZ2V0U2Vjb25kcygpLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpKSk7XG4gIHV0Y0RhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC0gdXRjRGF0ZS5nZXRUaW1lKCk7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbnZhciBNSUxMSVNFQ09ORFNfSU5fREFZID0gODY0MDAwMDA7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVVENEYXlPZlllYXIoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mWWVhclRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICB2YXIgZGlmZmVyZW5jZSA9IHRpbWVzdGFtcCAtIHN0YXJ0T2ZZZWFyVGltZXN0YW1wO1xuICByZXR1cm4gTWF0aC5mbG9vcihkaWZmZXJlbmNlIC8gTUlMTElTRUNPTkRTX0lOX0RBWSkgKyAxO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uLy4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENJU09XZWVrIGZyb20gXCIuLi9zdGFydE9mVVRDSVNPV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENJU09XZWVrWWVhciBmcm9tIFwiLi4vc3RhcnRPZlVUQ0lTT1dlZWtZZWFyL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbnZhciBNSUxMSVNFQ09ORFNfSU5fV0VFSyA9IDYwNDgwMDAwMDsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVUQ0lTT1dlZWsoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGlmZiA9IHN0YXJ0T2ZVVENJU09XZWVrKGRhdGUpLmdldFRpbWUoKSAtIHN0YXJ0T2ZVVENJU09XZWVrWWVhcihkYXRlKS5nZXRUaW1lKCk7IC8vIFJvdW5kIHRoZSBudW1iZXIgb2YgZGF5cyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG4gIC8vIGJlY2F1c2UgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gYSB3ZWVrIGlzIG5vdCBjb25zdGFudFxuICAvLyAoZS5nLiBpdCdzIGRpZmZlcmVudCBpbiB0aGUgd2VlayBvZiB0aGUgZGF5bGlnaHQgc2F2aW5nIHRpbWUgY2xvY2sgc2hpZnQpXG5cbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIE1JTExJU0VDT05EU19JTl9XRUVLKSArIDE7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDSVNPV2VlayBmcm9tIFwiLi4vc3RhcnRPZlVUQ0lTT1dlZWsvaW5kZXguanNcIjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIHZhciBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0VVRDRnVsbFllYXIoeWVhciArIDEsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZk5leHRZZWFyID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhcik7XG4gIHZhciBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mVGhpc1llYXIgPSBzdGFydE9mVVRDSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyKTtcblxuICBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyICsgMTtcbiAgfSBlbHNlIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mVGhpc1llYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHllYXIgLSAxO1xuICB9XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgc3RhcnRPZlVUQ1dlZWsgZnJvbSBcIi4uL3N0YXJ0T2ZVVENXZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgc3RhcnRPZlVUQ1dlZWtZZWFyIGZyb20gXCIuLi9zdGFydE9mVVRDV2Vla1llYXIvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xudmFyIE1JTExJU0VDT05EU19JTl9XRUVLID0gNjA0ODAwMDAwOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VVRDV2VlayhkaXJ0eURhdGUsIG9wdGlvbnMpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkaWZmID0gc3RhcnRPZlVUQ1dlZWsoZGF0ZSwgb3B0aW9ucykuZ2V0VGltZSgpIC0gc3RhcnRPZlVUQ1dlZWtZZWFyKGRhdGUsIG9wdGlvbnMpLmdldFRpbWUoKTsgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcbiAgLy8gYmVjYXVzZSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50XG4gIC8vIChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdClcblxuICByZXR1cm4gTWF0aC5yb3VuZChkaWZmIC8gTUlMTElTRUNPTkRTX0lOX1dFRUspICsgMTtcbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi8uLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENXZWVrIGZyb20gXCIuLi9zdGFydE9mVVRDV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vdG9JbnRlZ2VyL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVVENXZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xuICB2YXIgZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gMSA6IHRvSW50ZWdlcihsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID0gb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgOiB0b0ludGVnZXIob3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA+PSAxICYmIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA8PSA3KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBmaXJzdFdlZWtPZk5leHRZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0VVRDRnVsbFllYXIoeWVhciArIDEsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mTmV4dFllYXIgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWtPZk5leHRZZWFyLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZmlyc3RXZWVrT2ZUaGlzWWVhciA9IG5ldyBEYXRlKDApO1xuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mVGhpc1llYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mVGhpc1llYXIgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWtPZlRoaXNZZWFyLCBkaXJ0eU9wdGlvbnMpO1xuXG4gIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mTmV4dFllYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXIgKyAxO1xuICB9IGVsc2UgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZUaGlzWWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDE7XG4gIH1cbn0iLCJ2YXIgcHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW5zID0gWydEJywgJ0REJ107XG52YXIgcHJvdGVjdGVkV2Vla1llYXJUb2tlbnMgPSBbJ1lZJywgJ1lZWVknXTtcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiBwcm90ZWN0ZWREYXlPZlllYXJUb2tlbnMuaW5kZXhPZih0b2tlbikgIT09IC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbih0b2tlbikge1xuICByZXR1cm4gcHJvdGVjdGVkV2Vla1llYXJUb2tlbnMuaW5kZXhPZih0b2tlbikgIT09IC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRocm93UHJvdGVjdGVkRXJyb3IodG9rZW4sIGZvcm1hdCwgaW5wdXQpIHtcbiAgaWYgKHRva2VuID09PSAnWVlZWScpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVzZSBgeXl5eWAgaW5zdGVhZCBvZiBgWVlZWWAgKGluIGBcIi5jb25jYXQoZm9ybWF0LCBcImApIGZvciBmb3JtYXR0aW5nIHllYXJzIHRvIHRoZSBpbnB1dCBgXCIpLmNvbmNhdChpbnB1dCwgXCJgOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXCIpKTtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ1lZJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIChpbiBgXCIuY29uY2F0KGZvcm1hdCwgXCJgKSBmb3IgZm9ybWF0dGluZyB5ZWFycyB0byB0aGUgaW5wdXQgYFwiKS5jb25jYXQoaW5wdXQsIFwiYDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clwiKSk7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09ICdEJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVXNlIGBkYCBpbnN0ZWFkIG9mIGBEYCAoaW4gYFwiLmNvbmNhdChmb3JtYXQsIFwiYCkgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGggdG8gdGhlIGlucHV0IGBcIikuY29uY2F0KGlucHV0LCBcImA7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcIikpO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAnREQnKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVc2UgYGRkYCBpbnN0ZWFkIG9mIGBERGAgKGluIGBcIi5jb25jYXQoZm9ybWF0LCBcImApIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHRvIHRoZSBpbnB1dCBgXCIpLmNvbmNhdChpbnB1dCwgXCJgOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXCIpKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcXVpcmVkQXJncyhyZXF1aXJlZCwgYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPCByZXF1aXJlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocmVxdWlyZWQgKyAnIGFyZ3VtZW50JyArIChyZXF1aXJlZCA+IDEgPyAncycgOiAnJykgKyAnIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJncy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uLy4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG5pbXBvcnQgdG9JbnRlZ2VyIGZyb20gXCIuLi90b0ludGVnZXIvaW5kZXguanNcIjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldFVUQ0RheShkaXJ0eURhdGUsIGRpcnR5RGF5LCBkaXJ0eU9wdGlvbnMpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT0gbnVsbCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiB0b0ludGVnZXIob3B0aW9ucy53ZWVrU3RhcnRzT24pOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXkgPSB0b0ludGVnZXIoZGlydHlEYXkpO1xuICB2YXIgY3VycmVudERheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIHZhciByZW1haW5kZXIgPSBkYXkgJSA3O1xuICB2YXIgZGF5SW5kZXggPSAocmVtYWluZGVyICsgNykgJSA3O1xuICB2YXIgZGlmZiA9IChkYXlJbmRleCA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIGN1cnJlbnREYXk7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZTtcbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi8uLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vdG9JbnRlZ2VyL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRVVENJU09EYXkoZGlydHlEYXRlLCBkaXJ0eURheSkge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIGRheSA9IHRvSW50ZWdlcihkaXJ0eURheSk7XG5cbiAgaWYgKGRheSAlIDcgPT09IDApIHtcbiAgICBkYXkgPSBkYXkgLSA3O1xuICB9XG5cbiAgdmFyIHdlZWtTdGFydHNPbiA9IDE7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBjdXJyZW50RGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgdmFyIHJlbWFpbmRlciA9IGRheSAlIDc7XG4gIHZhciBkYXlJbmRleCA9IChyZW1haW5kZXIgKyA3KSAlIDc7XG4gIHZhciBkaWZmID0gKGRheUluZGV4IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gY3VycmVudERheTtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBkYXRlO1xufSIsImltcG9ydCB0b0ludGVnZXIgZnJvbSBcIi4uL3RvSW50ZWdlci9pbmRleC5qc1wiO1xuaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgZ2V0VVRDSVNPV2VlayBmcm9tIFwiLi4vZ2V0VVRDSVNPV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRVVENJU09XZWVrKGRpcnR5RGF0ZSwgZGlydHlJU09XZWVrKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgaXNvV2VlayA9IHRvSW50ZWdlcihkaXJ0eUlTT1dlZWspO1xuICB2YXIgZGlmZiA9IGdldFVUQ0lTT1dlZWsoZGF0ZSkgLSBpc29XZWVrO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmICogNyk7XG4gIHJldHVybiBkYXRlO1xufSIsImltcG9ydCB0b0ludGVnZXIgZnJvbSBcIi4uL3RvSW50ZWdlci9pbmRleC5qc1wiO1xuaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgZ2V0VVRDV2VlayBmcm9tIFwiLi4vZ2V0VVRDV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRVVENXZWVrKGRpcnR5RGF0ZSwgZGlydHlXZWVrLCBvcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgd2VlayA9IHRvSW50ZWdlcihkaXJ0eVdlZWspO1xuICB2YXIgZGlmZiA9IGdldFVUQ1dlZWsoZGF0ZSwgb3B0aW9ucykgLSB3ZWVrO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmICogNyk7XG4gIHJldHVybiBkYXRlO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uLy4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGFydE9mVVRDSVNPV2VlayhkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSAxO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiaW1wb3J0IGdldFVUQ0lTT1dlZWtZZWFyIGZyb20gXCIuLi9nZXRVVENJU09XZWVrWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENJU09XZWVrIGZyb20gXCIuLi9zdGFydE9mVVRDSVNPV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGFydE9mVVRDSVNPV2Vla1llYXIoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgeWVhciA9IGdldFVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSk7XG4gIHZhciBmb3VydGhPZkphbnVhcnkgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBkYXRlID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5KTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbmltcG9ydCB0b0ludGVnZXIgZnJvbSBcIi4uL3RvSW50ZWdlci9pbmRleC5qc1wiOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3RhcnRPZlVUQ1dlZWsoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT0gbnVsbCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiB0b0ludGVnZXIob3B0aW9ucy53ZWVrU3RhcnRzT24pOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xuICB2YXIgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSB3ZWVrU3RhcnRzT247XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIGRpZmYpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZGF0ZTtcbn0iLCJpbXBvcnQgZ2V0VVRDV2Vla1llYXIgZnJvbSBcIi4uL2dldFVUQ1dlZWtZZWFyL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDV2VlayBmcm9tIFwiLi4vc3RhcnRPZlVUQ1dlZWsvaW5kZXguanNcIjtcbmltcG9ydCB0b0ludGVnZXIgZnJvbSBcIi4uL3RvSW50ZWdlci9pbmRleC5qc1wiOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3RhcnRPZlVUQ1dlZWtZZWFyKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlICYmIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IDEgOiB0b0ludGVnZXIobG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlIDogdG9JbnRlZ2VyKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIHllYXIgPSBnZXRVVENXZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBmaXJzdFdlZWsgPSBuZXcgRGF0ZSgwKTtcbiAgZmlyc3RXZWVrLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vlay5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIGRhdGUgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWssIGRpcnR5T3B0aW9ucyk7XG4gIHJldHVybiBkYXRlO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvSW50ZWdlcihkaXJ0eU51bWJlcikge1xuICBpZiAoZGlydHlOdW1iZXIgPT09IG51bGwgfHwgZGlydHlOdW1iZXIgPT09IHRydWUgfHwgZGlydHlOdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuXG4gIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcik7XG59IiwiaW1wb3J0IGFkZERheXMgZnJvbSBcIi4uL2FkZERheXMvaW5kZXguanNcIjtcbmltcG9ydCBhZGRNb250aHMgZnJvbSBcIi4uL2FkZE1vbnRocy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAbmFtZSBhZGRcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgQWRkIHRoZSBzcGVjaWZpZWQgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge0R1cmF0aW9ufSBkdXJhdGlvbiAtIHRoZSBvYmplY3Qgd2l0aCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMgdG8gYmUgYWRkZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqXG4gKiB8IEtleSAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IHllYXJzICAgICAgICAgIHwgQW1vdW50IG9mIHllYXJzIHRvIGJlIGFkZGVkICAgICAgICB8XG4gKiB8IG1vbnRocyAgICAgICAgIHwgQW1vdW50IG9mIG1vbnRocyB0byBiZSBhZGRlZCAgICAgICB8XG4gKiB8IHdlZWtzICAgICAgICAgIHwgQW1vdW50IG9mIHdlZWtzIHRvIGJlIGFkZGVkICAgICAgICB8XG4gKiB8IGRheXMgICAgICAgICAgIHwgQW1vdW50IG9mIGRheXMgdG8gYmUgYWRkZWQgICAgICAgICB8XG4gKiB8IGhvdXJzICAgICAgICAgIHwgQW1vdW50IG9mIGhvdXJzIHRvIGJlIGFkZGVkICAgICAgICB8XG4gKiB8IG1pbnV0ZXMgICAgICAgIHwgQW1vdW50IG9mIG1pbnV0ZXMgdG8gYmUgYWRkZWQgICAgICB8XG4gKiB8IHNlY29uZHMgICAgICAgIHwgQW1vdW50IG9mIHNlY29uZHMgdG8gYmUgYWRkZWQgICAgICB8XG4gKlxuICogQWxsIHZhbHVlcyBkZWZhdWx0IHRvIDBcbiAqXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIHNlY29uZHMgYWRkZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIHRoZSBmb2xsb3dpbmcgZHVyYXRpb24gdG8gMSBTZXB0ZW1iZXIgMjAxNCwgMTA6MTk6NTBcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZChuZXcgRGF0ZSgyMDE0LCA4LCAxLCAxMCwgMTksIDUwKSwge1xuICogICB5ZWFyczogMixcbiAqICAgbW9udGhzOiA5LFxuICogICB3ZWVrczogMSxcbiAqICAgZGF5czogNyxcbiAqICAgaG91cnM6IDUsXG4gKiAgIG1pbnV0ZXM6IDksXG4gKiAgIHNlY29uZHM6IDMwLFxuICogfSlcbiAqIC8vPT4gVGh1IEp1biAxNSAyMDE3IDE1OjI5OjIwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZChkaXJ0eURhdGUsIGR1cmF0aW9uKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICBpZiAoIWR1cmF0aW9uIHx8IHR5cGVvZiBkdXJhdGlvbiAhPT0gJ29iamVjdCcpIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB2YXIgeWVhcnMgPSBkdXJhdGlvbi55ZWFycyA/IHRvSW50ZWdlcihkdXJhdGlvbi55ZWFycykgOiAwO1xuICB2YXIgbW9udGhzID0gZHVyYXRpb24ubW9udGhzID8gdG9JbnRlZ2VyKGR1cmF0aW9uLm1vbnRocykgOiAwO1xuICB2YXIgd2Vla3MgPSBkdXJhdGlvbi53ZWVrcyA/IHRvSW50ZWdlcihkdXJhdGlvbi53ZWVrcykgOiAwO1xuICB2YXIgZGF5cyA9IGR1cmF0aW9uLmRheXMgPyB0b0ludGVnZXIoZHVyYXRpb24uZGF5cykgOiAwO1xuICB2YXIgaG91cnMgPSBkdXJhdGlvbi5ob3VycyA/IHRvSW50ZWdlcihkdXJhdGlvbi5ob3VycykgOiAwO1xuICB2YXIgbWludXRlcyA9IGR1cmF0aW9uLm1pbnV0ZXMgPyB0b0ludGVnZXIoZHVyYXRpb24ubWludXRlcykgOiAwO1xuICB2YXIgc2Vjb25kcyA9IGR1cmF0aW9uLnNlY29uZHMgPyB0b0ludGVnZXIoZHVyYXRpb24uc2Vjb25kcykgOiAwOyAvLyBBZGQgeWVhcnMgYW5kIG1vbnRoc1xuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXRlV2l0aE1vbnRocyA9IG1vbnRocyB8fCB5ZWFycyA/IGFkZE1vbnRocyhkYXRlLCBtb250aHMgKyB5ZWFycyAqIDEyKSA6IGRhdGU7IC8vIEFkZCB3ZWVrcyBhbmQgZGF5c1xuXG4gIHZhciBkYXRlV2l0aERheXMgPSBkYXlzIHx8IHdlZWtzID8gYWRkRGF5cyhkYXRlV2l0aE1vbnRocywgZGF5cyArIHdlZWtzICogNykgOiBkYXRlV2l0aE1vbnRoczsgLy8gQWRkIGRheXMsIGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzXG5cbiAgdmFyIG1pbnV0ZXNUb0FkZCA9IG1pbnV0ZXMgKyBob3VycyAqIDYwO1xuICB2YXIgc2Vjb25kc1RvQWRkID0gc2Vjb25kcyArIG1pbnV0ZXNUb0FkZCAqIDYwO1xuICB2YXIgbXNUb0FkZCA9IHNlY29uZHNUb0FkZCAqIDEwMDA7XG4gIHZhciBmaW5hbERhdGUgPSBuZXcgRGF0ZShkYXRlV2l0aERheXMuZ2V0VGltZSgpICsgbXNUb0FkZCk7XG4gIHJldHVybiBmaW5hbERhdGU7XG59IiwiaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgYWRkRGF5c1xuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGF5cyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkYXlzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGRheXMgdG8gYmUgYWRkZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqIEByZXR1cm5zIHtEYXRlfSAtIHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBkYXlzIGFkZGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IC0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIDEwIGRheXMgdG8gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZERheXMobmV3IERhdGUoMjAxNCwgOCwgMSksIDEwKVxuICogLy89PiBUaHUgU2VwIDExIDIwMTQgMDA6MDA6MDBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGREYXlzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIoZGlydHlBbW91bnQpO1xuXG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICBpZiAoIWFtb3VudCkge1xuICAgIC8vIElmIDAgZGF5cywgbm8tb3AgdG8gYXZvaWQgY2hhbmdpbmcgdGltZXMgaW4gdGhlIGhvdXIgYmVmb3JlIGVuZCBvZiBEU1RcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIGFtb3VudCk7XG4gIHJldHVybiBkYXRlO1xufSIsImltcG9ydCB0b0ludGVnZXIgZnJvbSBcIi4uL19saWIvdG9JbnRlZ2VyL2luZGV4LmpzXCI7XG5pbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGFkZE1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBiZSBhZGRlZC4gUG9zaXRpdmUgZGVjaW1hbHMgd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmZsb29yYCwgZGVjaW1hbHMgbGVzcyB0aGFuIHplcm8gd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmNlaWxgLlxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgYWRkZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIDc1MCBtaWxsaXNlY29uZHMgdG8gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZE1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjMwLjc1MFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZE1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIGRpcnR5QW1vdW50KSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgdGltZXN0YW1wID0gdG9EYXRlKGRpcnR5RGF0ZSkuZ2V0VGltZSgpO1xuICB2YXIgYW1vdW50ID0gdG9JbnRlZ2VyKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIGFtb3VudCk7XG59IiwiaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgYWRkTW9udGhzXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1vbnRocyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtb250aHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbW9udGhzIHRvIGJlIGFkZGVkLiBQb3NpdGl2ZSBkZWNpbWFscyB3aWxsIGJlIHJvdW5kZWQgdXNpbmcgYE1hdGguZmxvb3JgLCBkZWNpbWFscyBsZXNzIHRoYW4gemVybyB3aWxsIGJlIHJvdW5kZWQgdXNpbmcgYE1hdGguY2VpbGAuXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1vbnRocyBhZGRlZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgNSBtb250aHMgdG8gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZE1vbnRocyhuZXcgRGF0ZSgyMDE0LCA4LCAxKSwgNSlcbiAqIC8vPT4gU3VuIEZlYiAwMSAyMDE1IDAwOjAwOjAwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkTW9udGhzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIoZGlydHlBbW91bnQpO1xuXG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICBpZiAoIWFtb3VudCkge1xuICAgIC8vIElmIDAgbW9udGhzLCBuby1vcCB0byBhdm9pZCBjaGFuZ2luZyB0aW1lcyBpbiB0aGUgaG91ciBiZWZvcmUgZW5kIG9mIERTVFxuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIGRheU9mTW9udGggPSBkYXRlLmdldERhdGUoKTsgLy8gVGhlIEpTIERhdGUgb2JqZWN0IHN1cHBvcnRzIGRhdGUgbWF0aCBieSBhY2NlcHRpbmcgb3V0LW9mLWJvdW5kcyB2YWx1ZXMgZm9yXG4gIC8vIG1vbnRoLCBkYXksIGV0Yy4gRm9yIGV4YW1wbGUsIG5ldyBEYXRlKDIwMjAsIDAsIDApIHJldHVybnMgMzEgRGVjIDIwMTkgYW5kXG4gIC8vIG5ldyBEYXRlKDIwMjAsIDEzLCAxKSByZXR1cm5zIDEgRmViIDIwMjEuICBUaGlzIGlzICphbG1vc3QqIHRoZSBiZWhhdmlvciB3ZVxuICAvLyB3YW50IGV4Y2VwdCB0aGF0IGRhdGVzIHdpbGwgd3JhcCBhcm91bmQgdGhlIGVuZCBvZiBhIG1vbnRoLCBtZWFuaW5nIHRoYXRcbiAgLy8gbmV3IERhdGUoMjAyMCwgMTMsIDMxKSB3aWxsIHJldHVybiAzIE1hciAyMDIxIG5vdCAyOCBGZWIgMjAyMSBhcyBkZXNpcmVkLiBTb1xuICAvLyB3ZSdsbCBkZWZhdWx0IHRvIHRoZSBlbmQgb2YgdGhlIGRlc2lyZWQgbW9udGggYnkgYWRkaW5nIDEgdG8gdGhlIGRlc2lyZWRcbiAgLy8gbW9udGggYW5kIHVzaW5nIGEgZGF0ZSBvZiAwIHRvIGJhY2sgdXAgb25lIGRheSB0byB0aGUgZW5kIG9mIHRoZSBkZXNpcmVkXG4gIC8vIG1vbnRoLlxuXG4gIHZhciBlbmRPZkRlc2lyZWRNb250aCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgZW5kT2ZEZXNpcmVkTW9udGguc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgYW1vdW50ICsgMSwgMCk7XG4gIHZhciBkYXlzSW5Nb250aCA9IGVuZE9mRGVzaXJlZE1vbnRoLmdldERhdGUoKTtcblxuICBpZiAoZGF5T2ZNb250aCA+PSBkYXlzSW5Nb250aCkge1xuICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgbW9udGgsIHRoZW4gdGhpcyBpcyB0aGUgY29ycmVjdCBkYXRlXG4gICAgLy8gYW5kIHdlJ3JlIGRvbmUuXG4gICAgcmV0dXJuIGVuZE9mRGVzaXJlZE1vbnRoO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgd2Ugbm93IGtub3cgdGhhdCBzZXR0aW5nIHRoZSBvcmlnaW5hbCBkYXktb2YtbW9udGggdmFsdWUgd29uJ3RcbiAgICAvLyBjYXVzZSBhbiBvdmVyZmxvdywgc28gc2V0IHRoZSBkZXNpcmVkIGRheS1vZi1tb250aC4gTm90ZSB0aGF0IHdlIGNhbid0XG4gICAgLy8ganVzdCBzZXQgdGhlIGRhdGUgb2YgYGVuZE9mRGVzaXJlZE1vbnRoYCBiZWNhdXNlIHRoYXQgb2JqZWN0IG1heSBoYXZlIGhhZFxuICAgIC8vIGl0cyB0aW1lIGNoYW5nZWQgaW4gdGhlIHVudXN1YWwgY2FzZSB3aGVyZSB3aGVyZSBhIERTVCB0cmFuc2l0aW9uIHdhcyBvblxuICAgIC8vIHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGggYW5kIGl0cyBsb2NhbCB0aW1lIHdhcyBpbiB0aGUgaG91ciBza2lwcGVkIG9yXG4gICAgLy8gcmVwZWF0ZWQgbmV4dCB0byBhIERTVCB0cmFuc2l0aW9uLiAgU28gd2UgdXNlIGBkYXRlYCBpbnN0ZWFkIHdoaWNoIGlzXG4gICAgLy8gZ3VhcmFudGVlZCB0byBzdGlsbCBoYXZlIHRoZSBvcmlnaW5hbCB0aW1lLlxuICAgIGRhdGUuc2V0RnVsbFllYXIoZW5kT2ZEZXNpcmVkTW9udGguZ2V0RnVsbFllYXIoKSwgZW5kT2ZEZXNpcmVkTW9udGguZ2V0TW9udGgoKSwgZGF5T2ZNb250aCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbn0iLCIvKipcbiAqIERheXMgaW4gMSB3ZWVrLlxuICpcbiAqIEBuYW1lIGRheXNJbldlZWtcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cbmV4cG9ydCB2YXIgZGF5c0luV2VlayA9IDc7XG4vKipcbiAqIE1heGltdW0gYWxsb3dlZCB0aW1lLlxuICpcbiAqIEBuYW1lIG1heFRpbWVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBtYXhUaW1lID0gTWF0aC5wb3coMTAsIDgpICogMjQgKiA2MCAqIDYwICogMTAwMDtcbi8qKlxuICogTWlsbGlzZWNvbmRzIGluIDEgbWludXRlXG4gKlxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5NaW51dGVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBtaWxsaXNlY29uZHNJbk1pbnV0ZSA9IDYwMDAwO1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgaW4gMSBob3VyXG4gKlxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5Ib3VyXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgbWlsbGlzZWNvbmRzSW5Ib3VyID0gMzYwMDAwMDtcbi8qKlxuICogTWlsbGlzZWNvbmRzIGluIDEgc2Vjb25kXG4gKlxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5TZWNvbmRcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBtaWxsaXNlY29uZHNJblNlY29uZCA9IDEwMDA7XG4vKipcbiAqIE1pbmltdW0gYWxsb3dlZCB0aW1lLlxuICpcbiAqIEBuYW1lIG1pblRpbWVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBtaW5UaW1lID0gLW1heFRpbWU7XG4vKipcbiAqIE1pbnV0ZXMgaW4gMSBob3VyXG4gKlxuICogQG5hbWUgbWludXRlc0luSG91clxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1pbnV0ZXNJbkhvdXIgPSA2MDtcbi8qKlxuICogTW9udGhzIGluIDEgcXVhcnRlclxuICpcbiAqIEBuYW1lIG1vbnRoc0luUXVhcnRlclxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1vbnRoc0luUXVhcnRlciA9IDM7XG4vKipcbiAqIE1vbnRocyBpbiAxIHllYXJcbiAqXG4gKiBAbmFtZSBtb250aHNJblllYXJcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBtb250aHNJblllYXIgPSAxMjtcbi8qKlxuICogUXVhcnRlcnMgaW4gMSB5ZWFyXG4gKlxuICogQG5hbWUgcXVhcnRlcnNJblllYXJcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBxdWFydGVyc0luWWVhciA9IDQ7XG4vKipcbiAqIFNlY29uZHMgaW4gMSBob3VyXG4gKlxuICogQG5hbWUgc2Vjb25kc0luSG91clxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIHNlY29uZHNJbkhvdXIgPSAzNjAwO1xuLyoqXG4gKiBTZWNvbmRzIGluIDEgbWludXRlXG4gKlxuICogQG5hbWUgc2Vjb25kc0luTWludXRlXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgc2Vjb25kc0luTWludXRlID0gNjA7IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBlbmRPZkRheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIGVuZCBvZiBhIGRheVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBlbmQgb2YgYSBkYXkgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBlbmRPZkRheShuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDAyIDIwMTQgMjM6NTk6NTkuOTk5XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5kT2ZEYXkoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICBkYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSk7XG4gIHJldHVybiBkYXRlO1xufSIsImltcG9ydCBpc1ZhbGlkIGZyb20gXCIuLi9pc1ZhbGlkL2luZGV4LmpzXCI7XG5pbXBvcnQgZGVmYXVsdExvY2FsZSBmcm9tIFwiLi4vbG9jYWxlL2VuLVVTL2luZGV4LmpzXCI7XG5pbXBvcnQgc3ViTWlsbGlzZWNvbmRzIGZyb20gXCIuLi9zdWJNaWxsaXNlY29uZHMvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IGZvcm1hdHRlcnMgZnJvbSBcIi4uL19saWIvZm9ybWF0L2Zvcm1hdHRlcnMvaW5kZXguanNcIjtcbmltcG9ydCBsb25nRm9ybWF0dGVycyBmcm9tIFwiLi4vX2xpYi9mb3JtYXQvbG9uZ0Zvcm1hdHRlcnMvaW5kZXguanNcIjtcbmltcG9ydCBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzIGZyb20gXCIuLi9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4sIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbiwgdGhyb3dQcm90ZWN0ZWRFcnJvciB9IGZyb20gXCIuLi9fbGliL3Byb3RlY3RlZFRva2Vucy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7IC8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XG4vLyAtIFt5WVFxTUx3SWREZWNpaEhLa21zXW8gbWF0Y2hlcyBhbnkgYXZhaWxhYmxlIG9yZGluYWwgbnVtYmVyIHRva2VuXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuXG52YXIgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IC9beVlRcU1Md0lkRGVjaWhIS2ttc11vfChcXHcpXFwxKnwnJ3wnKCcnfFteJ10pKygnfCQpfC4vZzsgLy8gVGhpcyBSZWdFeHAgY2F0Y2hlcyBzeW1ib2xzIGVzY2FwZWQgYnkgcXVvdGVzLCBhbmQgYWxzb1xuLy8gc2VxdWVuY2VzIG9mIHN5bWJvbHMgUCwgcCwgYW5kIHRoZSBjb21iaW5hdGlvbnMgbGlrZSBgUFBQUFBQUHBwcHBwYFxuXG52YXIgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvUCtwK3xQK3xwK3wnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcbnZhciBlc2NhcGVkU3RyaW5nUmVnRXhwID0gL14nKFteXSo/KSc/JC87XG52YXIgZG91YmxlUXVvdGVSZWdFeHAgPSAvJycvZztcbnZhciB1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCA9IC9bYS16QS1aXS87XG4vKipcbiAqIEBuYW1lIGZvcm1hdFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgdGhlIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZyBpbiB0aGUgZ2l2ZW4gZm9ybWF0LiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBgZm9ybWF0YCB0b2tlbnMgZGlmZmVyIGZyb20gTW9tZW50LmpzIGFuZCBvdGhlciBsaWJyYXJpZXMuXG4gKiA+IFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXG4gKiBUd28gc2luZ2xlIHF1b3RlcyBpbiBhIHJvdywgd2hldGhlciBpbnNpZGUgb3Igb3V0c2lkZSBhIHF1b3RlZCBzZXF1ZW5jZSwgcmVwcmVzZW50IGEgJ3JlYWwnIHNpbmdsZSBxdW90ZS5cbiAqIChzZWUgdGhlIGxhc3QgZXhhbXBsZSlcbiAqXG4gKiBGb3JtYXQgb2YgdGhlIHN0cmluZyBpcyBiYXNlZCBvbiBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNyBiZWxvdyB0aGUgdGFibGUpLlxuICpcbiAqIEFjY2VwdGVkIHBhdHRlcm5zOlxuICogfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUGF0dGVybiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgICB8IE5vdGVzIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18XG4gKiB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHLi5HR0cgIHwgQUQsIEJDICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgR0dHRyAgICB8IEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0dHICAgfCBBLCBCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENhbGVuZGFyIHllYXIgICAgICAgICAgICAgICAgICAgfCB5ICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeW8gICAgICB8IDQ0dGgsIDFzdCwgMHRoLCAxN3RoICAgICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5ICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eXl5ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgfCBZICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCAyMDE3dGggICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZWSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWVlZICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICAgfCBSICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlIgICAgICB8IC00MywgMDAsIDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUiAgICAgfCAtMDQzLCAwMDAsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlJSICAgIHwgLTAwNDMsIDAwMDAsIDAwMDEsIDE5MDAsIDIwMTcgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUlIgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSw3IHxcbiAqIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgICB8IHUgICAgICAgfCAtNDMsIDAsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dSAgICAgIHwgLTQzLCAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1ICAgICB8IC0wNDMsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dXUgICAgfCAtMDA0MywgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1dSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBRdWFydGVyIChmb3JtYXR0aW5nKSAgICAgICAgICAgIHwgUSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUVEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRUSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBRdWFydGVyIChzdGFuZC1hbG9uZSkgICAgICAgICAgIHwgcSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcXEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxcSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBNb250aCAoZm9ybWF0dGluZykgICAgICAgICAgICAgIHwgTSAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1vICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTSAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTU0gICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NTSAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNb250aCAoc3RhbmQtYWxvbmUpICAgICAgICAgICAgIHwgTCAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTCAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTEwgICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMTCAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgIHwgdyAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHdvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3dyAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgIHwgSSAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IElvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJSSAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGRvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICAgIHwgMDEsIDAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgIHwgRCAgICAgICB8IDEsIDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgICB8IDkgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzNjV0aCwgMzY2dGggICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICAgIHwgMDEsIDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgIHwgOSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREREICAgICB8IDAwMSwgMDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEREREQgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzICAgICB8XG4gKiB8IERheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICAgICAgfCBFLi5FRUUgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUVFICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRUUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgIHwgaSAgICAgICB8IDEsIDIsIDMsIC4uLiwgNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA3dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaSAgICAgIHwgMDEsIDAyLCAuLi4sIDA3ICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWkgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyLDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpaSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWlpICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8IDcgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICB8IGUgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWUgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZWUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWVlZSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChzdGFuZC1hbG9uZSkgfCBjICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY28gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2MgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjYyAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2NjICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjY2MgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgYS4uYWEgICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYSAgICAgfCBhbSwgcG0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWFhYWEgICB8IGEsIHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICB8IGIuLmJiICAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmIgICAgIHwgYW0sIHBtLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYmJiYiAgICB8IGEubS4sIHAubS4sIG5vb24sIG1pZG5pZ2h0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmJiICAgfCBhLCBwLCBuLCBtaSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICAgfCBCLi5CQkIgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQkJCQiAgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkJCICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICAgfCBoICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDEydGggICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhoICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSG8gICAgICB8IDB0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICAgfCBLICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgS28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDB0aCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtLICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICAgfCBrICAgICAgIHwgMjQsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwga28gICAgICB8IDI0dGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtrICAgICAgfCAyNCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbW8gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1tICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc28gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNzICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1MgICAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTUyAgICAgfCAwMDAsIDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy8gWikgICAgICAgIHwgWCAgICAgICB8IC0wOCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYICAgICAgfCAtMDgwMCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFggICAgIHwgLTA4OjAwLCArMDU6MzAsIFogICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYWCAgICB8IC0wODAwLCArMDUzMCwgWiwgKzEyMzQ1NiAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFhYICAgfCAtMDg6MDAsICswNTozMCwgWiwgKzEyOjM0OjU2ICAgICAgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICAgfCB4ICAgICAgIHwgLTA4LCArMDUzMCwgKzAwICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHggICAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eCAgICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHh4ICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCwgKzEyMzQ1NiAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eHggICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAsICsxMjozNDo1NiB8ICAgICAgIHxcbiAqIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgICB8IE8uLi5PT08gfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBPT09PICAgIHwgR01ULTA4OjAwLCBHTVQrMDU6MzAsIEdNVCswMDowMCAgIHwgMiAgICAgfFxuICogfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgIHwgei4uLnp6eiB8IEdNVC04LCBHTVQrNTozMCwgR01UKzAgICAgICAgICAgICB8IDYgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHp6enogICAgfCBHTVQtMDg6MDAsIEdNVCswNTozMCwgR01UKzAwOjAwICAgfCAyLDYgICB8XG4gKiB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICAgfCB0ICAgICAgIHwgNTEyOTY5NTIwICAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdHQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBUVCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw3ICAgfFxuICogfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgIHwgUCAgICAgICB8IDA0LzI5LzE0NTMgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQICAgICAgfCBBcHIgMjksIDE0NTMgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFAgICAgIHwgQXByaWwgMjl0aCwgMTQ1MyAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUCAgICB8IEZyaWRheSwgQXByaWwgMjl0aCwgMTQ1MyAgICAgICAgICB8IDIsNyAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgICB8IHAgICAgICAgfCAxMjowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcCAgICAgIHwgMTI6MDA6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHBwICAgICB8IDEyOjAwOjAwIEFNIEdNVCsyICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcHAgICAgfCAxMjowMDowMCBBTSBHTVQrMDI6MDAgICAgICAgICAgICAgfCAyLDcgICB8XG4gKiB8IENvbWJpbmF0aW9uIG9mIGRhdGUgYW5kIHRpbWUgICAgfCBQcCAgICAgIHwgMDQvMjkvMTQ1MywgMTI6MDAgQU0gICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBwcCAgICB8IEFwciAyOSwgMTQ1MywgMTI6MDA6MDAgQU0gICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUHBwcCAgfCBBcHJpbCAyOXRoLCAxNDUzIGF0IC4uLiAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBQcHBwcHwgRnJpZGF5LCBBcHJpbCAyOXRoLCAxNDUzIGF0IC4uLiAgIHwgMiw3ICAgfFxuICogTm90ZXM6XG4gKiAxLiBcIkZvcm1hdHRpbmdcIiB1bml0cyAoZS5nLiBmb3JtYXR0aW5nIHF1YXJ0ZXIpIGluIHRoZSBkZWZhdWx0IGVuLVVTIGxvY2FsZVxuICogICAgYXJlIHRoZSBzYW1lIGFzIFwic3RhbmQtYWxvbmVcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXG4gKiAgICBcIkZvcm1hdHRpbmdcIiB1bml0cyBhcmUgZGVjbGluZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBvZiB0aGUgbGFuZ3VhZ2VcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXCJTdGFuZC1hbG9uZVwiIHVuaXRzIGFyZSBhbHdheXMgbm9taW5hdGl2ZSBzaW5ndWxhcjpcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIE1NTU0nLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkdSdgXG4gKlxuICogMi4gQW55IHNlcXVlbmNlIG9mIHRoZSBpZGVudGljYWwgbGV0dGVycyBpcyBhIHBhdHRlcm4sIHVubGVzcyBpdCBpcyBlc2NhcGVkIGJ5XG4gKiAgICB0aGUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgKHNlZSBiZWxvdykuXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlIChlLmcuIGBFRUVFRUVFRUVFRWApXG4gKiAgICB0aGUgb3V0cHV0IHdpbGwgYmUgdGhlIHNhbWUgYXMgZGVmYXVsdCBwYXR0ZXJuIGZvciB0aGlzIHVuaXQsIHVzdWFsbHlcbiAqICAgIHRoZSBsb25nZXN0IG9uZSAoaW4gY2FzZSBvZiBJU08gd2Vla2RheXMsIGBFRUVFYCkuIERlZmF1bHQgcGF0dGVybnMgZm9yIHVuaXRzXG4gKiAgICBhcmUgbWFya2VkIHdpdGggXCIyXCIgaW4gdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTScpIC8vPT4gJ05vdidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTU0nKSAvLz0+ICdOJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogMy4gU29tZSBwYXR0ZXJucyBjb3VsZCBiZSB1bmxpbWl0ZWQgbGVuZ3RoIChzdWNoIGFzIGB5eXl5eXl5eWApLlxuICogICAgVGhlIG91dHB1dCB3aWxsIGJlIHBhZGRlZCB3aXRoIHplcm9zIHRvIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICd5eXl5eXl5eScpIC8vPT4gJzAwMDAyMDE3J2BcbiAqXG4gKiA0LiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxuICogICAgVGhlc2UgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2hvcnRlc3QgZm9ybSBvZiB0aGUgcXVhcnRlci5cbiAqXG4gKiA1LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XG4gKlxuICogICAgfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XG4gKiAgICB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICogICAgfCBCQyAxIHwgICAxIHwgICAwIHxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gKlxuICogICAgQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICogICAgd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkOlxuICpcbiAqICAgIHwgWWVhciB8IGB5eWAgfCBgdXVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS0tfC0tLS0tLXxcbiAqICAgIHwgMSAgICB8ICAgMDEgfCAgIDAxIHxcbiAqICAgIHwgMTQgICB8ICAgMTQgfCAgIDE0IHxcbiAqICAgIHwgMzc2ICB8ICAgNzYgfCAgMzc2IHxcbiAqICAgIHwgMTQ1MyB8ICAgNTMgfCAxNDUzIHxcbiAqXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcbiAqICAgIGV4Y2VwdCBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFycyBhcmUgZGVwZW5kZW50IG9uIGBvcHRpb25zLndlZWtTdGFydHNPbmBcbiAqICAgIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIChjb21wYXJlIFtnZXRJU09XZWVrWWVhcl17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9nZXRJU09XZWVrWWVhcn1cbiAqICAgIGFuZCBbZ2V0V2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0V2Vla1llYXJ9KS5cbiAqXG4gKiA2LiBTcGVjaWZpYyBub24tbG9jYXRpb24gdGltZXpvbmVzIGFyZSBjdXJyZW50bHkgdW5hdmFpbGFibGUgaW4gYGRhdGUtZm5zYCxcbiAqICAgIHNvIHJpZ2h0IG5vdyB0aGVzZSB0b2tlbnMgZmFsbCBiYWNrIHRvIEdNVCB0aW1lem9uZXMuXG4gKlxuICogNy4gVGhlc2UgcGF0dGVybnMgYXJlIG5vdCBpbiB0aGUgVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogICAgLSBgaWA6IElTTyBkYXkgb2Ygd2Vla1xuICogICAgLSBgSWA6IElTTyB3ZWVrIG9mIHllYXJcbiAqICAgIC0gYFJgOiBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICogICAgLSBgdGA6IHNlY29uZHMgdGltZXN0YW1wXG4gKiAgICAtIGBUYDogbWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICogICAgLSBgb2A6IG9yZGluYWwgbnVtYmVyIG1vZGlmaWVyXG4gKiAgICAtIGBQYDogbG9uZyBsb2NhbGl6ZWQgZGF0ZVxuICogICAgLSBgcGA6IGxvbmcgbG9jYWxpemVkIHRpbWVcbiAqXG4gKiA4LiBgWVlgIGFuZCBgWVlZWWAgdG9rZW5zIHJlcHJlc2VudCB3ZWVrLW51bWJlcmluZyB5ZWFycyBidXQgdGhleSBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCB5ZWFycy5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiA5LiBgRGAgYW5kIGBERGAgdG9rZW5zIHJlcHJlc2VudCBkYXlzIG9mIHRoZSB5ZWFyIGJ1dCB0aGV5IGFyZSBvZnRlbiBjb25mdXNlZCB3aXRoIGRheXMgb2YgdGhlIG1vbnRoLlxuICogICAgWW91IHNob3VsZCBlbmFibGUgYG9wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gVGhlIHNlY29uZCBhcmd1bWVudCBpcyBub3cgcmVxdWlyZWQgZm9yIHRoZSBzYWtlIG9mIGV4cGxpY2l0bmVzcy5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgLy8gQmVmb3JlIHYyLjAuMFxuICogICBmb3JtYXQobmV3IERhdGUoMjAxNiwgMCwgMSkpXG4gKlxuICogICAvLyB2Mi4wLjAgb253YXJkXG4gKiAgIGZvcm1hdChuZXcgRGF0ZSgyMDE2LCAwLCAxKSwgXCJ5eXl5LU1NLWRkJ1QnSEg6bW06c3MuU1NTeHh4XCIpXG4gKiAgIGBgYFxuICpcbiAqIC0gTmV3IGZvcm1hdCBzdHJpbmcgQVBJIGZvciBgZm9ybWF0YCBmdW5jdGlvblxuICogICB3aGljaCBpcyBiYXNlZCBvbiBbVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1XShodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlKS5cbiAqICAgU2VlIFt0aGlzIHBvc3RdKGh0dHBzOi8vYmxvZy5kYXRlLWZucy5vcmcvcG9zdC91bmljb2RlLXRva2Vucy1pbi1kYXRlLWZucy12Mi1zcmVhdHlraTkxamcpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogLSBDaGFyYWN0ZXJzIGFyZSBub3cgZXNjYXBlZCB1c2luZyBzaW5nbGUgcXVvdGUgc3ltYm9scyAoYCdgKSBpbnN0ZWFkIG9mIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgLSB0aGUgc3RyaW5nIG9mIHRva2Vuc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cbiAqIEBwYXJhbSB7MHwxfDJ8M3w0fDV8Nn0gW29wdGlvbnMud2Vla1N0YXJ0c09uPTBdIC0gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgLSBTdW5kYXkpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlPTFdIC0gdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM9ZmFsc2VdIC0gaWYgdHJ1ZSwgYWxsb3dzIHVzYWdlIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyIHRva2VucyBgWVlgIGFuZCBgWVlZWWA7XG4gKiAgIHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vucz1mYWxzZV0gLSBpZiB0cnVlLCBhbGxvd3MgdXNhZ2Ugb2YgdGhlIGRheSBvZiB5ZWFyIHRva2VucyBgRGAgYW5kIGBERGA7XG4gKiAgIHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBsb2NhbGl6ZWAgcHJvcGVydHlcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXRMb25nYCBwcm9wZXJ0eVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMud2Vla1N0YXJ0c09uYCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNlxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgN1xuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGB5eXl5YCBpbnN0ZWFkIG9mIGBZWVlZYCBmb3IgZm9ybWF0dGluZyB5ZWFycyB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYGRgIGluc3RlYWQgb2YgYERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYGRkYCBpbnN0ZWFkIG9mIGBERGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGggdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTEgRmVicnVhcnkgMjAxNCBpbiBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQobmV3IERhdGUoMjAxNCwgMSwgMTEpLCAnTU0vZGQveXl5eScpXG4gKiAvLz0+ICcwMi8xMS8yMDE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMiBKdWx5IDIwMTQgaW4gRXNwZXJhbnRvOlxuICogaW1wb3J0IHsgZW9Mb2NhbGUgfSBmcm9tICdkYXRlLWZucy9sb2NhbGUvZW8nXG4gKiB2YXIgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDYsIDIpLCBcImRvICdkZScgTU1NTSB5eXl5XCIsIHtcbiAqICAgbG9jYWxlOiBlb0xvY2FsZVxuICogfSlcbiAqIC8vPT4gJzItYSBkZSBqdWxpbyAyMDE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFc2NhcGUgc3RyaW5nIGJ5IHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzOlxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCA2LCAyLCAxNSksIFwiaCAnbycnY2xvY2snXCIpXG4gKiAvLz0+IFwiMyBvJ2Nsb2NrXCJcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXQoZGlydHlEYXRlLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlPcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZm9ybWF0U3RyID0gU3RyaW5nKGRpcnR5Rm9ybWF0U3RyKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZSB8fCBkZWZhdWx0TG9jYWxlO1xuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xuICB2YXIgZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gMSA6IHRvSW50ZWdlcihsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID0gb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgOiB0b0ludGVnZXIob3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA+PSAxICYmIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA8PSA3KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy53ZWVrU3RhcnRzT247XG4gIHZhciBkZWZhdWx0V2Vla1N0YXJ0c09uID0gbG9jYWxlV2Vla1N0YXJ0c09uID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGxvY2FsZVdlZWtTdGFydHNPbik7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PSBudWxsID8gZGVmYXVsdFdlZWtTdGFydHNPbiA6IHRvSW50ZWdlcihvcHRpb25zLndlZWtTdGFydHNPbik7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgaWYgKCFsb2NhbGUubG9jYWxpemUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBsb2NhbGl6ZSBwcm9wZXJ0eScpO1xuICB9XG5cbiAgaWYgKCFsb2NhbGUuZm9ybWF0TG9uZykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIGZvcm1hdExvbmcgcHJvcGVydHknKTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbERhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcblxuICBpZiAoIWlzVmFsaWQob3JpZ2luYWxEYXRlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgfSAvLyBDb252ZXJ0IHRoZSBkYXRlIGluIHN5c3RlbSB0aW1lem9uZSB0byB0aGUgc2FtZSBkYXRlIGluIFVUQyswMDowMCB0aW1lem9uZS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiBVVEMgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQsIGxvY2FsZXMgd2lsbCBiZSBjb21wYXRpYmxlIHdpdGggdGhlbS5cbiAgLy8gU2VlIGFuIGlzc3VlIGFib3V0IFVUQyBmdW5jdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cblxuICB2YXIgdGltZXpvbmVPZmZzZXQgPSBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKG9yaWdpbmFsRGF0ZSk7XG4gIHZhciB1dGNEYXRlID0gc3ViTWlsbGlzZWNvbmRzKG9yaWdpbmFsRGF0ZSwgdGltZXpvbmVPZmZzZXQpO1xuICB2YXIgZm9ybWF0dGVyT3B0aW9ucyA9IHtcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSxcbiAgICB3ZWVrU3RhcnRzT246IHdlZWtTdGFydHNPbixcbiAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICBfb3JpZ2luYWxEYXRlOiBvcmlnaW5hbERhdGVcbiAgfTtcbiAgdmFyIHJlc3VsdCA9IGZvcm1hdFN0ci5tYXRjaChsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCkubWFwKGZ1bmN0aW9uIChzdWJzdHJpbmcpIHtcbiAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XG5cbiAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09ICdwJyB8fCBmaXJzdENoYXJhY3RlciA9PT0gJ1AnKSB7XG4gICAgICB2YXIgbG9uZ0Zvcm1hdHRlciA9IGxvbmdGb3JtYXR0ZXJzW2ZpcnN0Q2hhcmFjdGVyXTtcbiAgICAgIHJldHVybiBsb25nRm9ybWF0dGVyKHN1YnN0cmluZywgbG9jYWxlLmZvcm1hdExvbmcsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzdHJpbmc7XG4gIH0pLmpvaW4oJycpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnNSZWdFeHApLm1hcChmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgLy8gUmVwbGFjZSB0d28gc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgd2l0aCBvbmUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlclxuICAgIGlmIChzdWJzdHJpbmcgPT09IFwiJydcIikge1xuICAgICAgcmV0dXJuIFwiJ1wiO1xuICAgIH1cblxuICAgIHZhciBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcblxuICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCInXCIpIHtcbiAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zICYmIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbihzdWJzdHJpbmcpKSB7XG4gICAgICAgIHRocm93UHJvdGVjdGVkRXJyb3Ioc3Vic3RyaW5nLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlEYXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnMgJiYgaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbihzdWJzdHJpbmcpKSB7XG4gICAgICAgIHRocm93UHJvdGVjdGVkRXJyb3Ioc3Vic3RyaW5nLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlEYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvcm1hdHRlcih1dGNEYXRlLCBzdWJzdHJpbmcsIGxvY2FsZS5sb2NhbGl6ZSwgZm9ybWF0dGVyT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Q2hhcmFjdGVyLm1hdGNoKHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Zvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlciBgJyArIGZpcnN0Q2hhcmFjdGVyICsgJ2AnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic3RyaW5nO1xuICB9KS5qb2luKCcnKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2xlYW5Fc2NhcGVkU3RyaW5nKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5tYXRjaChlc2NhcGVkU3RyaW5nUmVnRXhwKVsxXS5yZXBsYWNlKGRvdWJsZVF1b3RlUmVnRXhwLCBcIidcIik7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgYWRkTGVhZGluZ1plcm9zIGZyb20gXCIuLi9fbGliL2FkZExlYWRpbmdaZXJvcy9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgZm9ybWF0SVNPXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEZvcm1hdCB0aGUgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIElTTyA4NjAxIHN0YW5kYXJkIChodHRwczovL3N1cHBvcnQuc2FzLmNvbS9kb2N1bWVudGF0aW9uL2NkbC9lbi9scmRpY3QvNjQzMTYvSFRNTC9kZWZhdWx0L3ZpZXdlci5odG0jYTAwMzE2OTgxNC5odG0pLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gSVNPIDg2MDEgZm9ybWF0LiBPcHRpb25zIG1heSBiZSBwYXNzZWQgdG8gY29udHJvbCB0aGUgcGFydHMgYW5kIG5vdGF0aW9ucyBvZiB0aGUgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHsnZXh0ZW5kZWQnfCdiYXNpYyd9IFtvcHRpb25zLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGlmICdiYXNpYycsIGhpZGUgZGVsaW1pdGVycyBiZXR3ZWVuIGRhdGUgYW5kIHRpbWUgdmFsdWVzLlxuICogQHBhcmFtIHsnY29tcGxldGUnfCdkYXRlJ3wndGltZSd9IFtvcHRpb25zLnJlcHJlc2VudGF0aW9uPSdjb21wbGV0ZSddIC0gZm9ybWF0IGRhdGUsIHRpbWUgd2l0aCBsb2NhbCB0aW1lIHpvbmUsIG9yIGJvdGguXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIChpbiBsb2NhbCB0aW1lIHpvbmUpXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmZvcm1hdGAgbXVzdCBiZSAnZXh0ZW5kZWQnIG9yICdiYXNpYydcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLnJlcHJlc2VuYXRpb25gIG11c3QgYmUgJ2RhdGUnLCAndGltZScgb3IgJ2NvbXBsZXRlJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTggU2VwdGVtYmVyIDIwMTkgaW4gSVNPIDg2MDEgZm9ybWF0IChsb2NhbCB0aW1lIHpvbmUgaXMgVVRDKTpcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdElTTyhuZXcgRGF0ZSgyMDE5LCA4LCAxOCwgMTksIDAsIDUyKSlcbiAqIC8vPT4gJzIwMTktMDktMThUMTk6MDA6NTJaJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTggU2VwdGVtYmVyIDIwMTkgaW4gSVNPIDg2MDEsIHNob3J0IGZvcm1hdCAobG9jYWwgdGltZSB6b25lIGlzIFVUQyk6XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXRJU08obmV3IERhdGUoMjAxOSwgOCwgMTgsIDE5LCAwLCA1MiksIHsgZm9ybWF0OiAnYmFzaWMnIH0pXG4gKiAvLz0+ICcyMDE5MDkxOFQxOTAwNTInXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxOCBTZXB0ZW1iZXIgMjAxOSBpbiBJU08gODYwMSBmb3JtYXQsIGRhdGUgb25seTpcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdElTTyhuZXcgRGF0ZSgyMDE5LCA4LCAxOCwgMTksIDAsIDUyKSwgeyByZXByZXNlbnRhdGlvbjogJ2RhdGUnIH0pXG4gKiAvLz0+ICcyMDE5LTA5LTE4J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTggU2VwdGVtYmVyIDIwMTkgaW4gSVNPIDg2MDEgZm9ybWF0LCB0aW1lIG9ubHkgKGxvY2FsIHRpbWUgem9uZSBpcyBVVEMpOlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0SVNPKG5ldyBEYXRlKDIwMTksIDgsIDE4LCAxOSwgMCwgNTIpLCB7IHJlcHJlc2VudGF0aW9uOiAndGltZScgfSlcbiAqIC8vPT4gJzE5OjAwOjUyWidcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRJU08oZGF0ZSwgb3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIG9yaWdpbmFsRGF0ZSA9IHRvRGF0ZShkYXRlKTtcblxuICBpZiAoaXNOYU4ob3JpZ2luYWxEYXRlLmdldFRpbWUoKSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gIH1cblxuICB2YXIgZm9ybWF0ID0gIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmZvcm1hdCkgPyAnZXh0ZW5kZWQnIDogU3RyaW5nKG9wdGlvbnMuZm9ybWF0KTtcbiAgdmFyIHJlcHJlc2VudGF0aW9uID0gIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLnJlcHJlc2VudGF0aW9uKSA/ICdjb21wbGV0ZScgOiBTdHJpbmcob3B0aW9ucy5yZXByZXNlbnRhdGlvbik7XG5cbiAgaWYgKGZvcm1hdCAhPT0gJ2V4dGVuZGVkJyAmJiBmb3JtYXQgIT09ICdiYXNpYycpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImZvcm1hdCBtdXN0IGJlICdleHRlbmRlZCcgb3IgJ2Jhc2ljJ1wiKTtcbiAgfVxuXG4gIGlmIChyZXByZXNlbnRhdGlvbiAhPT0gJ2RhdGUnICYmIHJlcHJlc2VudGF0aW9uICE9PSAndGltZScgJiYgcmVwcmVzZW50YXRpb24gIT09ICdjb21wbGV0ZScpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJlcHJlc2VudGF0aW9uIG11c3QgYmUgJ2RhdGUnLCAndGltZScsIG9yICdjb21wbGV0ZSdcIik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciB0ek9mZnNldCA9ICcnO1xuICB2YXIgZGF0ZURlbGltaXRlciA9IGZvcm1hdCA9PT0gJ2V4dGVuZGVkJyA/ICctJyA6ICcnO1xuICB2YXIgdGltZURlbGltaXRlciA9IGZvcm1hdCA9PT0gJ2V4dGVuZGVkJyA/ICc6JyA6ICcnOyAvLyBSZXByZXNlbnRhdGlvbiBpcyBlaXRoZXIgJ2RhdGUnIG9yICdjb21wbGV0ZSdcblxuICBpZiAocmVwcmVzZW50YXRpb24gIT09ICd0aW1lJykge1xuICAgIHZhciBkYXkgPSBhZGRMZWFkaW5nWmVyb3Mob3JpZ2luYWxEYXRlLmdldERhdGUoKSwgMik7XG4gICAgdmFyIG1vbnRoID0gYWRkTGVhZGluZ1plcm9zKG9yaWdpbmFsRGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gICAgdmFyIHllYXIgPSBhZGRMZWFkaW5nWmVyb3Mob3JpZ2luYWxEYXRlLmdldEZ1bGxZZWFyKCksIDQpOyAvLyB5eXl5TU1kZCBvciB5eXl5LU1NLWRkLlxuXG4gICAgcmVzdWx0ID0gXCJcIi5jb25jYXQoeWVhcikuY29uY2F0KGRhdGVEZWxpbWl0ZXIpLmNvbmNhdChtb250aCkuY29uY2F0KGRhdGVEZWxpbWl0ZXIpLmNvbmNhdChkYXkpO1xuICB9IC8vIFJlcHJlc2VudGF0aW9uIGlzIGVpdGhlciAndGltZScgb3IgJ2NvbXBsZXRlJ1xuXG5cbiAgaWYgKHJlcHJlc2VudGF0aW9uICE9PSAnZGF0ZScpIHtcbiAgICAvLyBBZGQgdGhlIHRpbWV6b25lLlxuICAgIHZhciBvZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIHZhciBhYnNvbHV0ZU9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgICB2YXIgaG91ck9mZnNldCA9IGFkZExlYWRpbmdaZXJvcyhNYXRoLmZsb29yKGFic29sdXRlT2Zmc2V0IC8gNjApLCAyKTtcbiAgICAgIHZhciBtaW51dGVPZmZzZXQgPSBhZGRMZWFkaW5nWmVyb3MoYWJzb2x1dGVPZmZzZXQgJSA2MCwgMik7IC8vIElmIGxlc3MgdGhhbiAwLCB0aGUgc2lnbiBpcyArLCBiZWNhdXNlIGl0IGlzIGFoZWFkIG9mIHRpbWUuXG5cbiAgICAgIHZhciBzaWduID0gb2Zmc2V0IDwgMCA/ICcrJyA6ICctJztcbiAgICAgIHR6T2Zmc2V0ID0gXCJcIi5jb25jYXQoc2lnbikuY29uY2F0KGhvdXJPZmZzZXQsIFwiOlwiKS5jb25jYXQobWludXRlT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHpPZmZzZXQgPSAnWic7XG4gICAgfVxuXG4gICAgdmFyIGhvdXIgPSBhZGRMZWFkaW5nWmVyb3Mob3JpZ2luYWxEYXRlLmdldEhvdXJzKCksIDIpO1xuICAgIHZhciBtaW51dGUgPSBhZGRMZWFkaW5nWmVyb3Mob3JpZ2luYWxEYXRlLmdldE1pbnV0ZXMoKSwgMik7XG4gICAgdmFyIHNlY29uZCA9IGFkZExlYWRpbmdaZXJvcyhvcmlnaW5hbERhdGUuZ2V0U2Vjb25kcygpLCAyKTsgLy8gSWYgdGhlcmUncyBhbHNvIGRhdGUsIHNlcGFyYXRlIGl0IHdpdGggdGltZSB3aXRoICdUJ1xuXG4gICAgdmFyIHNlcGFyYXRvciA9IHJlc3VsdCA9PT0gJycgPyAnJyA6ICdUJzsgLy8gQ3JlYXRlcyBhIHRpbWUgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgaG91ciwgbWludXRlLCBhbmQgc2Vjb25kLCBzZXBhcmF0ZWQgYnkgZGVsaW1pdGVycywgaWYgZGVmaW5lZC5cblxuICAgIHZhciB0aW1lID0gW2hvdXIsIG1pbnV0ZSwgc2Vjb25kXS5qb2luKHRpbWVEZWxpbWl0ZXIpOyAvLyBISG1tc3Mgb3IgSEg6bW06c3MuXG5cbiAgICByZXN1bHQgPSBcIlwiLmNvbmNhdChyZXN1bHQpLmNvbmNhdChzZXBhcmF0b3IpLmNvbmNhdCh0aW1lKS5jb25jYXQodHpPZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGdldERheVxuICogQGNhdGVnb3J5IFdlZWtkYXkgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIGRheSBvZiB0aGUgd2VlayBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZ2l2ZW4gZGF0ZVxuICogQHJldHVybnMgezB8MXwyfDN8NHw1fDZ9IHRoZSBkYXkgb2Ygd2VlaywgMCByZXByZXNlbnRzIFN1bmRheVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIGRheSBvZiB0aGUgd2VlayBpcyAyOSBGZWJydWFyeSAyMDEyP1xuICogY29uc3QgcmVzdWx0ID0gZ2V0RGF5KG5ldyBEYXRlKDIwMTIsIDEsIDI5KSlcbiAqIC8vPT4gM1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERheShkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICByZXR1cm4gZGF5O1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgZ2V0RGF5c0luTW9udGhcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGggb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGggb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGdpdmVuIGRhdGVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgZGF5cyBhcmUgaW4gRmVicnVhcnkgMjAwMD9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldERheXNJbk1vbnRoKG5ldyBEYXRlKDIwMDAsIDEpKVxuICogLy89PiAyOVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gIHZhciBtb250aEluZGV4ID0gZGF0ZS5nZXRNb250aCgpO1xuICB2YXIgbGFzdERheU9mTW9udGggPSBuZXcgRGF0ZSgwKTtcbiAgbGFzdERheU9mTW9udGguc2V0RnVsbFllYXIoeWVhciwgbW9udGhJbmRleCArIDEsIDApO1xuICBsYXN0RGF5T2ZNb250aC5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGxhc3REYXlPZk1vbnRoLmdldERhdGUoKTtcbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGlzQmVmb3JlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0aGF0IHNob3VsZCBiZSBiZWZvcmUgdGhlIG90aGVyIG9uZSB0byByZXR1cm4gdHJ1ZVxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZVRvQ29tcGFyZSAtIHRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBmaXJzdCBkYXRlIGlzIGJlZm9yZSB0aGUgc2Vjb25kIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMTAgSnVseSAxOTg5IGJlZm9yZSAxMSBGZWJydWFyeSAxOTg3P1xuICogdmFyIHJlc3VsdCA9IGlzQmVmb3JlKG5ldyBEYXRlKDE5ODksIDYsIDEwKSwgbmV3IERhdGUoMTk4NywgMSwgMTEpKVxuICogLy89PiBmYWxzZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQmVmb3JlKGRpcnR5RGF0ZSwgZGlydHlEYXRlVG9Db21wYXJlKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF0ZVRvQ29tcGFyZSA9IHRvRGF0ZShkaXJ0eURhdGVUb0NvbXBhcmUpO1xuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPCBkYXRlVG9Db21wYXJlLmdldFRpbWUoKTtcbn0iLCJpbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBpc0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIHZhbHVlIGEgZGF0ZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZS4gVGhlIGZ1bmN0aW9uIHdvcmtzIGZvciBkYXRlcyB0cmFuc2ZlcnJlZCBhY3Jvc3MgaWZyYW1lcy5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIGEgdmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZShuZXcgRGF0ZSgpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhbiBpbnZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUobmV3IERhdGUoTmFOKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3Igc29tZSB2YWx1ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZSgnMjAxNC0wMi0zMScpXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhbiBvYmplY3Q6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUoe30pXG4gKiAvLz0+IGZhbHNlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufSIsImltcG9ydCBzdGFydE9mRGF5IGZyb20gXCIuLi9zdGFydE9mRGF5L2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBpc1NhbWVEYXlcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBkYXkgKGFuZCB5ZWFyIGFuZCBtb250aCk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIGRheSAoYW5kIHllYXIgYW5kIG1vbnRoKT9cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVMZWZ0IC0gdGhlIGZpcnN0IGRhdGUgdG8gY2hlY2tcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVSaWdodCAtIHRoZSBzZWNvbmQgZGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgZGF5IChhbmQgeWVhciBhbmQgbW9udGgpXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciAwNjowMDowMCBhbmQgNCBTZXB0ZW1iZXIgMTg6MDA6MDAgaW4gdGhlIHNhbWUgZGF5P1xuICogdmFyIHJlc3VsdCA9IGlzU2FtZURheShuZXcgRGF0ZSgyMDE0LCA4LCA0LCA2LCAwKSwgbmV3IERhdGUoMjAxNCwgOCwgNCwgMTgsIDApKVxuICogLy89PiB0cnVlXG4gKiBcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgNCBTZXB0ZW1iZXIgYW5kIDQgT2N0b2JlciBpbiB0aGUgc2FtZSBkYXk/XG4gKiB2YXIgcmVzdWx0ID0gaXNTYW1lRGF5KG5ldyBEYXRlKDIwMTQsIDgsIDQpLCBuZXcgRGF0ZSgyMDE0LCA5LCA0KSlcbiAqIC8vPT4gZmFsc2VcbiAqIFxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciwgMjAxNCBhbmQgNCBTZXB0ZW1iZXIsIDIwMTUgaW4gdGhlIHNhbWUgZGF5P1xuICogdmFyIHJlc3VsdCA9IGlzU2FtZURheShuZXcgRGF0ZSgyMDE0LCA4LCA0KSwgbmV3IERhdGUoMjAxNSwgOCwgNCkpXG4gKiAvLz0+IGZhbHNlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTYW1lRGF5KGRpcnR5RGF0ZUxlZnQsIGRpcnR5RGF0ZVJpZ2h0KSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZUxlZnRTdGFydE9mRGF5ID0gc3RhcnRPZkRheShkaXJ0eURhdGVMZWZ0KTtcbiAgdmFyIGRhdGVSaWdodFN0YXJ0T2ZEYXkgPSBzdGFydE9mRGF5KGRpcnR5RGF0ZVJpZ2h0KTtcbiAgcmV0dXJuIGRhdGVMZWZ0U3RhcnRPZkRheS5nZXRUaW1lKCkgPT09IGRhdGVSaWdodFN0YXJ0T2ZEYXkuZ2V0VGltZSgpO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgaXNTYW1lTW9udGhcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIG1vbnRoIChhbmQgeWVhcik/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIG1vbnRoIChhbmQgeWVhcik/XG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlTGVmdCAtIHRoZSBmaXJzdCBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlUmlnaHQgLSB0aGUgc2Vjb25kIGRhdGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIG1vbnRoIChhbmQgeWVhcilcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDIgU2VwdGVtYmVyIDIwMTQgYW5kIDI1IFNlcHRlbWJlciAyMDE0IGluIHRoZSBzYW1lIG1vbnRoP1xuICogdmFyIHJlc3VsdCA9IGlzU2FtZU1vbnRoKG5ldyBEYXRlKDIwMTQsIDgsIDIpLCBuZXcgRGF0ZSgyMDE0LCA4LCAyNSkpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDIgU2VwdGVtYmVyIDIwMTQgYW5kIDI1IFNlcHRlbWJlciAyMDE1IGluIHRoZSBzYW1lIG1vbnRoP1xuICogdmFyIHJlc3VsdCA9IGlzU2FtZU1vbnRoKG5ldyBEYXRlKDIwMTQsIDgsIDIpLCBuZXcgRGF0ZSgyMDE1LCA4LCAyNSkpXG4gKiAvLz0+IGZhbHNlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTYW1lTW9udGgoZGlydHlEYXRlTGVmdCwgZGlydHlEYXRlUmlnaHQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlTGVmdCA9IHRvRGF0ZShkaXJ0eURhdGVMZWZ0KTtcbiAgdmFyIGRhdGVSaWdodCA9IHRvRGF0ZShkaXJ0eURhdGVSaWdodCk7XG4gIHJldHVybiBkYXRlTGVmdC5nZXRGdWxsWWVhcigpID09PSBkYXRlUmlnaHQuZ2V0RnVsbFllYXIoKSAmJiBkYXRlTGVmdC5nZXRNb250aCgpID09PSBkYXRlUmlnaHQuZ2V0TW9udGgoKTtcbn0iLCJpbXBvcnQgaXNTYW1lRGF5IGZyb20gXCIuLi9pc1NhbWVEYXkvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGlzVG9kYXlcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdG9kYXk/XG4gKiBAcHVyZSBmYWxzZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgdG9kYXk/XG4gKlxuICogPiDimqDvuI8gUGxlYXNlIG5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBwcmVzZW50IGluIHRoZSBGUCBzdWJtb2R1bGUgYXNcbiAqID4gaXQgdXNlcyBgRGF0ZS5ub3coKWAgaW50ZXJuYWxseSBoZW5jZSBpbXB1cmUgYW5kIGNhbid0IGJlIHNhZmVseSBjdXJyaWVkLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGUgaXMgdG9kYXlcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyA2IE9jdG9iZXIgMjAxNCwgaXMgNiBPY3RvYmVyIDE0OjAwOjAwIHRvZGF5P1xuICogdmFyIHJlc3VsdCA9IGlzVG9kYXkobmV3IERhdGUoMjAxNCwgOSwgNiwgMTQsIDApKVxuICogLy89PiB0cnVlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUb2RheShkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBpc1NhbWVEYXkoZGlydHlEYXRlLCBEYXRlLm5vdygpKTtcbn0iLCJpbXBvcnQgaXNEYXRlIGZyb20gXCIuLi9pc0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgaXNWYWxpZFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB2YWxpZD9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgZmFsc2UgaWYgYXJndW1lbnQgaXMgSW52YWxpZCBEYXRlIGFuZCB0cnVlIG90aGVyd2lzZS5cbiAqIEFyZ3VtZW50IGlzIGNvbnZlcnRlZCB0byBEYXRlIHVzaW5nIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XG4gKiBJbnZhbGlkIERhdGUgaXMgYSBEYXRlLCB3aG9zZSB0aW1lIHZhbHVlIGlzIE5hTi5cbiAqXG4gKiBUaW1lIHZhbHVlIG9mIERhdGU6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuOS4xLjFcbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gTm93IGBpc1ZhbGlkYCBkb2Vzbid0IHRocm93IGFuIGV4Y2VwdGlvblxuICogICBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKiAgIEluc3RlYWQsIGFyZ3VtZW50IGlzIGNvbnZlcnRlZCBiZWZvcmVoYW5kIHVzaW5nIGB0b0RhdGVgLlxuICpcbiAqICAgRXhhbXBsZXM6XG4gKlxuICogICB8IGBpc1ZhbGlkYCBhcmd1bWVudCAgICAgICAgfCBCZWZvcmUgdjIuMC4wIHwgdjIuMC4wIG9ud2FyZCB8XG4gKiAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLXxcbiAqICAgfCBgbmV3IERhdGUoKWAgICAgICAgICAgICAgIHwgYHRydWVgICAgICAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZSgnMjAxNi0wMS0wMScpYCAgfCBgdHJ1ZWAgICAgICAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYG5ldyBEYXRlKCcnKWAgICAgICAgICAgICB8IGBmYWxzZWAgICAgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqICAgfCBgbmV3IERhdGUoMTQ4ODM3MDgzNTA4MSlgIHwgYHRydWVgICAgICAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZShOYU4pYCAgICAgICAgICAgfCBgZmFsc2VgICAgICAgIHwgYGZhbHNlYCAgICAgICB8XG4gKiAgIHwgYCcyMDE2LTAxLTAxJ2AgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqICAgfCBgJydgICAgICAgICAgICAgICAgICAgICAgIHwgYFR5cGVFcnJvcmAgICB8IGBmYWxzZWAgICAgICAgfFxuICogICB8IGAxNDg4MzcwODM1MDgxYCAgICAgICAgICAgfCBgVHlwZUVycm9yYCAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYE5hTmAgICAgICAgICAgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqXG4gKiAgIFdlIGludHJvZHVjZSB0aGlzIGNoYW5nZSB0byBtYWtlICpkYXRlLWZucyogY29uc2lzdGVudCB3aXRoIEVDTUFTY3JpcHQgYmVoYXZpb3JcbiAqICAgdGhhdCB0cnkgdG8gY29lcmNlIGFyZ3VtZW50cyB0byB0aGUgZXhwZWN0ZWQgdHlwZVxuICogICAod2hpY2ggaXMgYWxzbyB0aGUgY2FzZSB3aXRoIG90aGVyICpkYXRlLWZucyogZnVuY3Rpb25zKS5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlIGlzIHZhbGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWxpZCBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNWYWxpZChuZXcgRGF0ZSgyMDE0LCAxLCAzMSkpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWx1ZSwgY29udmVydGFibGUgaW50byBhIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc1ZhbGlkKDEzOTM4MDQ4MDAwMDApXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSBpbnZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKCcnKSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1ZhbGlkKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcblxuICBpZiAoIWlzRGF0ZShkaXJ0eURhdGUpICYmIHR5cGVvZiBkaXJ0eURhdGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgcmV0dXJuICFpc05hTihOdW1iZXIoZGF0ZSkpO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgaXNXZWVrZW5kXG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBEb2VzIHRoZSBnaXZlbiBkYXRlIGZhbGwgb24gYSB3ZWVrZW5kP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRG9lcyB0aGUgZ2l2ZW4gZGF0ZSBmYWxsIG9uIGEgd2Vla2VuZD9cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlIGZhbGxzIG9uIGEgd2Vla2VuZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIERvZXMgNSBPY3RvYmVyIDIwMTQgZmFsbCBvbiBhIHdlZWtlbmQ/XG4gKiBjb25zdCByZXN1bHQgPSBpc1dlZWtlbmQobmV3IERhdGUoMjAxNCwgOSwgNSkpXG4gKiAvLz0+IHRydWVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1dlZWtlbmQoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgcmV0dXJuIGRheSA9PT0gMCB8fCBkYXkgPT09IDY7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRGb3JtYXRMb25nRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAvLyBUT0RPOiBSZW1vdmUgU3RyaW5nKClcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgdmFyIGZvcm1hdCA9IGFyZ3MuZm9ybWF0c1t3aWR0aF0gfHwgYXJncy5mb3JtYXRzW2FyZ3MuZGVmYXVsdFdpZHRoXTtcbiAgICByZXR1cm4gZm9ybWF0O1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkTG9jYWxpemVGbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlJbmRleCwgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQgPyBTdHJpbmcob3B0aW9ucy5jb250ZXh0KSA6ICdzdGFuZGFsb25lJztcbiAgICB2YXIgdmFsdWVzQXJyYXk7XG5cbiAgICBpZiAoY29udGV4dCA9PT0gJ2Zvcm1hdHRpbmcnICYmIGFyZ3MuZm9ybWF0dGluZ1ZhbHVlcykge1xuICAgICAgdmFyIGRlZmF1bHRXaWR0aCA9IGFyZ3MuZGVmYXVsdEZvcm1hdHRpbmdXaWR0aCB8fCBhcmdzLmRlZmF1bHRXaWR0aDtcbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBkZWZhdWx0V2lkdGg7XG4gICAgICB2YWx1ZXNBcnJheSA9IGFyZ3MuZm9ybWF0dGluZ1ZhbHVlc1t3aWR0aF0gfHwgYXJncy5mb3JtYXR0aW5nVmFsdWVzW2RlZmF1bHRXaWR0aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZGVmYXVsdFdpZHRoID0gYXJncy5kZWZhdWx0V2lkdGg7XG5cbiAgICAgIHZhciBfd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogYXJncy5kZWZhdWx0V2lkdGg7XG5cbiAgICAgIHZhbHVlc0FycmF5ID0gYXJncy52YWx1ZXNbX3dpZHRoXSB8fCBhcmdzLnZhbHVlc1tfZGVmYXVsdFdpZHRoXTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBhcmdzLmFyZ3VtZW50Q2FsbGJhY2sgPyBhcmdzLmFyZ3VtZW50Q2FsbGJhY2soZGlydHlJbmRleCkgOiBkaXJ0eUluZGV4OyAvLyBAdHMtaWdub3JlOiBGb3Igc29tZSByZWFzb24gVHlwZVNjcmlwdCBqdXN0IGRvbid0IHdhbnQgdG8gbWF0Y2ggaXQsIG5vIG1hdHRlciBob3cgaGFyZCB3ZSB0cnkuIEkgY2hhbGxlbmdlIHlvdSB0byB0cnkgdG8gcmVtb3ZlIGl0IVxuXG4gICAgcmV0dXJuIHZhbHVlc0FycmF5W2luZGV4XTtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZE1hdGNoRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIHZhciBtYXRjaFBhdHRlcm4gPSB3aWR0aCAmJiBhcmdzLm1hdGNoUGF0dGVybnNbd2lkdGhdIHx8IGFyZ3MubWF0Y2hQYXR0ZXJuc1thcmdzLmRlZmF1bHRNYXRjaFdpZHRoXTtcbiAgICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2gobWF0Y2hQYXR0ZXJuKTtcblxuICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG4gICAgdmFyIHBhcnNlUGF0dGVybnMgPSB3aWR0aCAmJiBhcmdzLnBhcnNlUGF0dGVybnNbd2lkdGhdIHx8IGFyZ3MucGFyc2VQYXR0ZXJuc1thcmdzLmRlZmF1bHRQYXJzZVdpZHRoXTtcbiAgICB2YXIga2V5ID0gQXJyYXkuaXNBcnJheShwYXJzZVBhdHRlcm5zKSA/IGZpbmRJbmRleChwYXJzZVBhdHRlcm5zLCBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChtYXRjaGVkU3RyaW5nKTtcbiAgICB9KSA6IGZpbmRLZXkocGFyc2VQYXR0ZXJucywgZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobWF0Y2hlZFN0cmluZyk7XG4gICAgfSk7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhbHVlID0gYXJncy52YWx1ZUNhbGxiYWNrID8gYXJncy52YWx1ZUNhbGxiYWNrKGtleSkgOiBrZXk7XG4gICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlQ2FsbGJhY2sgPyBvcHRpb25zLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XG4gICAgdmFyIHJlc3QgPSBzdHJpbmcuc2xpY2UobWF0Y2hlZFN0cmluZy5sZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICByZXN0OiByZXN0XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHByZWRpY2F0ZShvYmplY3Rba2V5XSkpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgZm9yICh2YXIga2V5ID0gMDsga2V5IDwgYXJyYXkubGVuZ3RoOyBrZXkrKykge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlba2V5XSkpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZE1hdGNoUGF0dGVybkZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKGFyZ3MubWF0Y2hQYXR0ZXJuKTtcbiAgICBpZiAoIW1hdGNoUmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICB2YXIgbWF0Y2hlZFN0cmluZyA9IG1hdGNoUmVzdWx0WzBdO1xuICAgIHZhciBwYXJzZVJlc3VsdCA9IHN0cmluZy5tYXRjaChhcmdzLnBhcnNlUGF0dGVybik7XG4gICAgaWYgKCFwYXJzZVJlc3VsdCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHZhbHVlID0gYXJncy52YWx1ZUNhbGxiYWNrID8gYXJncy52YWx1ZUNhbGxiYWNrKHBhcnNlUmVzdWx0WzBdKSA6IHBhcnNlUmVzdWx0WzBdO1xuICAgIHZhbHVlID0gb3B0aW9ucy52YWx1ZUNhbGxiYWNrID8gb3B0aW9ucy52YWx1ZUNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xuICAgIHZhciByZXN0ID0gc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgcmVzdDogcmVzdFxuICAgIH07XG4gIH07XG59IiwidmFyIGZvcm1hdERpc3RhbmNlTG9jYWxlID0ge1xuICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgb25lOiAnbGVzcyB0aGFuIGEgc2Vjb25kJyxcbiAgICBvdGhlcjogJ2xlc3MgdGhhbiB7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6ICcxIHNlY29uZCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcbiAgaGFsZkFNaW51dGU6ICdoYWxmIGEgbWludXRlJyxcbiAgbGVzc1RoYW5YTWludXRlczoge1xuICAgIG9uZTogJ2xlc3MgdGhhbiBhIG1pbnV0ZScsXG4gICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiAnMSBtaW51dGUnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG4gIGFib3V0WEhvdXJzOiB7XG4gICAgb25lOiAnYWJvdXQgMSBob3VyJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBob3VycydcbiAgfSxcbiAgeEhvdXJzOiB7XG4gICAgb25lOiAnMSBob3VyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBob3VycydcbiAgfSxcbiAgeERheXM6IHtcbiAgICBvbmU6ICcxIGRheScsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gZGF5cydcbiAgfSxcbiAgYWJvdXRYV2Vla3M6IHtcbiAgICBvbmU6ICdhYm91dCAxIHdlZWsnLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IHdlZWtzJ1xuICB9LFxuICB4V2Vla3M6IHtcbiAgICBvbmU6ICcxIHdlZWsnLFxuICAgIG90aGVyOiAne3tjb3VudH19IHdlZWtzJ1xuICB9LFxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6ICdhYm91dCAxIG1vbnRoJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBtb250aHMnXG4gIH0sXG4gIHhNb250aHM6IHtcbiAgICBvbmU6ICcxIG1vbnRoJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBtb250aHMnXG4gIH0sXG4gIGFib3V0WFllYXJzOiB7XG4gICAgb25lOiAnYWJvdXQgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgeFllYXJzOiB7XG4gICAgb25lOiAnMSB5ZWFyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgb3ZlclhZZWFyczoge1xuICAgIG9uZTogJ292ZXIgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ292ZXIge3tjb3VudH19IHllYXJzJ1xuICB9LFxuICBhbG1vc3RYWWVhcnM6IHtcbiAgICBvbmU6ICdhbG1vc3QgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ2FsbW9zdCB7e2NvdW50fX0geWVhcnMnXG4gIH1cbn07XG5cbnZhciBmb3JtYXREaXN0YW5jZSA9IGZ1bmN0aW9uICh0b2tlbiwgY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIHRva2VuVmFsdWUgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl07XG5cbiAgaWYgKHR5cGVvZiB0b2tlblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWU7XG4gIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm9uZTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50LnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYWRkU3VmZml4KSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyaXNvbiAmJiBvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ2luICcgKyByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAnIGFnbyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdERpc3RhbmNlOyIsImltcG9ydCBidWlsZEZvcm1hdExvbmdGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZEZvcm1hdExvbmdGbi9pbmRleC5qc1wiO1xudmFyIGRhdGVGb3JtYXRzID0ge1xuICBmdWxsOiAnRUVFRSwgTU1NTSBkbywgeScsXG4gIGxvbmc6ICdNTU1NIGRvLCB5JyxcbiAgbWVkaXVtOiAnTU1NIGQsIHknLFxuICBzaG9ydDogJ01NL2RkL3l5eXknXG59O1xudmFyIHRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiAnaDptbTpzcyBhIHp6enonLFxuICBsb25nOiAnaDptbTpzcyBhIHonLFxuICBtZWRpdW06ICdoOm1tOnNzIGEnLFxuICBzaG9ydDogJ2g6bW0gYSdcbn07XG52YXIgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbG9uZzogXCJ7e2RhdGV9fSAnYXQnIHt7dGltZX19XCIsXG4gIG1lZGl1bTogJ3t7ZGF0ZX19LCB7e3RpbWV9fScsXG4gIHNob3J0OiAne3tkYXRlfX0sIHt7dGltZX19J1xufTtcbnZhciBmb3JtYXRMb25nID0ge1xuICBkYXRlOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSksXG4gIHRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiB0aW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgZGF0ZVRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlVGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSlcbn07XG5leHBvcnQgZGVmYXVsdCBmb3JtYXRMb25nOyIsInZhciBmb3JtYXRSZWxhdGl2ZUxvY2FsZSA9IHtcbiAgbGFzdFdlZWs6IFwiJ2xhc3QnIGVlZWUgJ2F0JyBwXCIsXG4gIHllc3RlcmRheTogXCIneWVzdGVyZGF5IGF0JyBwXCIsXG4gIHRvZGF5OiBcIid0b2RheSBhdCcgcFwiLFxuICB0b21vcnJvdzogXCIndG9tb3Jyb3cgYXQnIHBcIixcbiAgbmV4dFdlZWs6IFwiZWVlZSAnYXQnIHBcIixcbiAgb3RoZXI6ICdQJ1xufTtcblxudmFyIGZvcm1hdFJlbGF0aXZlID0gZnVuY3Rpb24gKHRva2VuLCBfZGF0ZSwgX2Jhc2VEYXRlLCBfb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UmVsYXRpdmVMb2NhbGVbdG9rZW5dO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0UmVsYXRpdmU7IiwiaW1wb3J0IGJ1aWxkTG9jYWxpemVGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZExvY2FsaXplRm4vaW5kZXguanNcIjtcbnZhciBlcmFWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydCJywgJ0EnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnQkMnLCAnQUQnXSxcbiAgd2lkZTogWydCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJ11cbn07XG52YXIgcXVhcnRlclZhbHVlcyA9IHtcbiAgbmFycm93OiBbJzEnLCAnMicsICczJywgJzQnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnUTEnLCAnUTInLCAnUTMnLCAnUTQnXSxcbiAgd2lkZTogWycxc3QgcXVhcnRlcicsICcybmQgcXVhcnRlcicsICczcmQgcXVhcnRlcicsICc0dGggcXVhcnRlciddXG59OyAvLyBOb3RlOiBpbiBFbmdsaXNoLCB0aGUgbmFtZXMgb2YgZGF5cyBvZiB0aGUgd2VlayBhbmQgbW9udGhzIGFyZSBjYXBpdGFsaXplZC5cbi8vIElmIHlvdSBhcmUgbWFraW5nIGEgbmV3IGxvY2FsZSBiYXNlZCBvbiB0aGlzIG9uZSwgY2hlY2sgaWYgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgdGhlIGxhbmd1YWdlIHlvdSdyZSB3b3JraW5nIG9uLlxuLy8gR2VuZXJhbGx5LCBmb3JtYXR0ZWQgZGF0ZXMgc2hvdWxkIGxvb2sgbGlrZSB0aGV5IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgc2VudGVuY2UsXG4vLyBlLmcuIGluIFNwYW5pc2ggbGFuZ3VhZ2UgdGhlIHdlZWtkYXlzIGFuZCBtb250aHMgc2hvdWxkIGJlIGluIHRoZSBsb3dlcmNhc2UuXG5cbnZhciBtb250aFZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ0onLCAnRicsICdNJywgJ0EnLCAnTScsICdKJywgJ0onLCAnQScsICdTJywgJ08nLCAnTicsICdEJ10sXG4gIGFiYnJldmlhdGVkOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gIHdpZGU6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddXG59O1xudmFyIGRheVZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXSxcbiAgc2hvcnQ6IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIHdpZGU6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVxufTtcbnZhciBkYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAnYScsXG4gICAgcG06ICdwJyxcbiAgICBtaWRuaWdodDogJ21pJyxcbiAgICBub29uOiAnbicsXG4gICAgbW9ybmluZzogJ21vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnbmlnaHQnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICdBTScsXG4gICAgcG06ICdQTScsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgICBuaWdodDogJ25pZ2h0J1xuICB9LFxuICB3aWRlOiB7XG4gICAgYW06ICdhLm0uJyxcbiAgICBwbTogJ3AubS4nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnZXZlbmluZycsXG4gICAgbmlnaHQ6ICduaWdodCdcbiAgfVxufTtcbnZhciBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ2EnLFxuICAgIHBtOiAncCcsXG4gICAgbWlkbmlnaHQ6ICdtaScsXG4gICAgbm9vbjogJ24nLFxuICAgIG1vcm5pbmc6ICdpbiB0aGUgbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnaW4gdGhlIGFmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2luIHRoZSBldmVuaW5nJyxcbiAgICBuaWdodDogJ2F0IG5pZ2h0J1xuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiAnQU0nLFxuICAgIHBtOiAnUE0nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnaW4gdGhlIG1vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2luIHRoZSBhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdpbiB0aGUgZXZlbmluZycsXG4gICAgbmlnaHQ6ICdhdCBuaWdodCdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAnYS5tLicsXG4gICAgcG06ICdwLm0uJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ2luIHRoZSBtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdpbiB0aGUgYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnaW4gdGhlIGV2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnYXQgbmlnaHQnXG4gIH1cbn07XG5cbnZhciBvcmRpbmFsTnVtYmVyID0gZnVuY3Rpb24gKGRpcnR5TnVtYmVyLCBfb3B0aW9ucykge1xuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTsgLy8gSWYgb3JkaW5hbCBudW1iZXJzIGRlcGVuZCBvbiBjb250ZXh0LCBmb3IgZXhhbXBsZSxcbiAgLy8gaWYgdGhleSBhcmUgZGlmZmVyZW50IGZvciBkaWZmZXJlbnQgZ3JhbW1hdGljYWwgZ2VuZGVycyxcbiAgLy8gdXNlIGBvcHRpb25zLnVuaXRgLlxuICAvL1xuICAvLyBgdW5pdGAgY2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXRlJywgJ2RheU9mWWVhcicsXG4gIC8vICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJy5cblxuICB2YXIgcmVtMTAwID0gbnVtYmVyICUgMTAwO1xuXG4gIGlmIChyZW0xMDAgPiAyMCB8fCByZW0xMDAgPCAxMCkge1xuICAgIHN3aXRjaCAocmVtMTAwICUgMTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdzdCc7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICduZCc7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdyZCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bWJlciArICd0aCc7XG59O1xuXG52YXIgbG9jYWxpemUgPSB7XG4gIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXIsXG4gIGVyYTogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGVyYVZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IHF1YXJ0ZXJWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZScsXG4gICAgYXJndW1lbnRDYWxsYmFjazogZnVuY3Rpb24gKHF1YXJ0ZXIpIHtcbiAgICAgIHJldHVybiBxdWFydGVyIC0gMTtcbiAgICB9XG4gIH0pLFxuICBtb250aDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IG1vbnRoVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBkYXk6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBkYXlWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBmb3JtYXR0aW5nVmFsdWVzOiBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRGb3JtYXR0aW5nV2lkdGg6ICd3aWRlJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsaXplOyIsImltcG9ydCBidWlsZE1hdGNoRm4gZnJvbSBcIi4uLy4uLy4uL19saWIvYnVpbGRNYXRjaEZuL2luZGV4LmpzXCI7XG5pbXBvcnQgYnVpbGRNYXRjaFBhdHRlcm5GbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZE1hdGNoUGF0dGVybkZuL2luZGV4LmpzXCI7XG52YXIgbWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybiA9IC9eKFxcZCspKHRofHN0fG5kfHJkKT8vaTtcbnZhciBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL1xcZCsvaTtcbnZhciBtYXRjaEVyYVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKGJ8YSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKGJcXC4/XFxzP2NcXC4/fGJcXC4/XFxzP2NcXC4/XFxzP2VcXC4/fGFcXC4/XFxzP2RcXC4/fGNcXC4/XFxzP2VcXC4/KS9pLFxuICB3aWRlOiAvXihiZWZvcmUgY2hyaXN0fGJlZm9yZSBjb21tb24gZXJhfGFubm8gZG9taW5pfGNvbW1vbiBlcmEpL2lcbn07XG52YXIgcGFyc2VFcmFQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15iL2ksIC9eKGF8YykvaV1cbn07XG52YXIgbWF0Y2hRdWFydGVyUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bMTIzNF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9ecVsxMjM0XS9pLFxuICB3aWRlOiAvXlsxMjM0XSh0aHxzdHxuZHxyZCk/IHF1YXJ0ZXIvaVxufTtcbnZhciBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgYW55OiBbLzEvaSwgLzIvaSwgLzMvaSwgLzQvaV1cbn07XG52YXIgbWF0Y2hNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW2pmbWFzb25kXS9pLFxuICBhYmJyZXZpYXRlZDogL14oamFufGZlYnxtYXJ8YXByfG1heXxqdW58anVsfGF1Z3xzZXB8b2N0fG5vdnxkZWMpL2ksXG4gIHdpZGU6IC9eKGphbnVhcnl8ZmVicnVhcnl8bWFyY2h8YXByaWx8bWF5fGp1bmV8anVseXxhdWd1c3R8c2VwdGVtYmVyfG9jdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXIpL2lcbn07XG52YXIgcGFyc2VNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IFsvXmovaSwgL15mL2ksIC9ebS9pLCAvXmEvaSwgL15tL2ksIC9eai9pLCAvXmovaSwgL15hL2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXSxcbiAgYW55OiBbL15qYS9pLCAvXmYvaSwgL15tYXIvaSwgL15hcC9pLCAvXm1heS9pLCAvXmp1bi9pLCAvXmp1bC9pLCAvXmF1L2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXVxufTtcbnZhciBtYXRjaERheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW3NtdHdmXS9pLFxuICBzaG9ydDogL14oc3V8bW98dHV8d2V8dGh8ZnJ8c2EpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihzdW58bW9ufHR1ZXx3ZWR8dGh1fGZyaXxzYXQpL2ksXG4gIHdpZGU6IC9eKHN1bmRheXxtb25kYXl8dHVlc2RheXx3ZWRuZXNkYXl8dGh1cnNkYXl8ZnJpZGF5fHNhdHVyZGF5KS9pXG59O1xudmFyIHBhcnNlRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogWy9ecy9pLCAvXm0vaSwgL150L2ksIC9edy9pLCAvXnQvaSwgL15mL2ksIC9ecy9pXSxcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxufTtcbnZhciBtYXRjaERheVBlcmlvZFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKGF8cHxtaXxufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaSxcbiAgYW55OiAvXihbYXBdXFwuP1xccz9tXFwuP3xtaWRuaWdodHxub29ufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaVxufTtcbnZhciBwYXJzZURheVBlcmlvZFBhdHRlcm5zID0ge1xuICBhbnk6IHtcbiAgICBhbTogL15hL2ksXG4gICAgcG06IC9ecC9pLFxuICAgIG1pZG5pZ2h0OiAvXm1pL2ksXG4gICAgbm9vbjogL15uby9pLFxuICAgIG1vcm5pbmc6IC9tb3JuaW5nL2ksXG4gICAgYWZ0ZXJub29uOiAvYWZ0ZXJub29uL2ksXG4gICAgZXZlbmluZzogL2V2ZW5pbmcvaSxcbiAgICBuaWdodDogL25pZ2h0L2lcbiAgfVxufTtcbnZhciBtYXRjaCA9IHtcbiAgb3JkaW5hbE51bWJlcjogYnVpbGRNYXRjaFBhdHRlcm5Gbih7XG4gICAgbWF0Y2hQYXR0ZXJuOiBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHBhcnNlUGF0dGVybjogcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgfSksXG4gIGVyYTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaEVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueScsXG4gICAgdmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cbiAgfSksXG4gIG1vbnRoOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIGRheTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnYW55JyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IG1hdGNoOyIsImltcG9ydCBmb3JtYXREaXN0YW5jZSBmcm9tIFwiLi9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzXCI7XG5pbXBvcnQgZm9ybWF0TG9uZyBmcm9tIFwiLi9fbGliL2Zvcm1hdExvbmcvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRSZWxhdGl2ZSBmcm9tIFwiLi9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzXCI7XG5pbXBvcnQgbG9jYWxpemUgZnJvbSBcIi4vX2xpYi9sb2NhbGl6ZS9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoIGZyb20gXCIuL19saWIvbWF0Y2gvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAdHlwZSB7TG9jYWxlfVxuICogQGNhdGVnb3J5IExvY2FsZXNcbiAqIEBzdW1tYXJ5IEVuZ2xpc2ggbG9jYWxlIChVbml0ZWQgU3RhdGVzKS5cbiAqIEBsYW5ndWFnZSBFbmdsaXNoXG4gKiBAaXNvLTYzOS0yIGVuZ1xuICogQGF1dGhvciBTYXNoYSBLb3NzIFtAa29zc25vY29ycF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2tvc3Nub2NvcnB9XG4gKiBAYXV0aG9yIExlc2hhIEtvc3MgW0BsZXNoYWtvc3Nde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXNoYWtvc3N9XG4gKi9cbnZhciBsb2NhbGUgPSB7XG4gIGNvZGU6ICdlbi1VUycsXG4gIGZvcm1hdERpc3RhbmNlOiBmb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcbiAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICBsb2NhbGl6ZTogbG9jYWxpemUsXG4gIG1hdGNoOiBtYXRjaCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMFxuICAgIC8qIFN1bmRheSAqL1xuICAgICxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDFcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsZTsiLCJpbXBvcnQgYWRkRGF5cyBmcm9tIFwiLi4vYWRkRGF5cy9pbmRleC5qc1wiO1xuaW1wb3J0IGdldERheSBmcm9tIFwiLi4vZ2V0RGF5L2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBuZXh0RGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBXaGVuIGlzIHRoZSBuZXh0IGRheSBvZiB0aGUgd2Vlaz9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdoZW4gaXMgdGhlIG5leHQgZGF5IG9mIHRoZSB3ZWVrPyAwLTYgdGhlIGRheSBvZiB0aGUgd2VlaywgMCByZXByZXNlbnRzIFN1bmRheS5cbiAqXG4gKiBAcGFyYW0ge0RhdGUgfCBudW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIHtEYXl9IGRheSAtIGRheSBvZiB0aGUgd2Vla1xuICogQHJldHVybnMge0RhdGV9IC0gdGhlIGRhdGUgaXMgdGhlIG5leHQgZGF5IG9mIHdlZWtcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gLSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGVuIGlzIHRoZSBuZXh0IE1vbmRheSBhZnRlciBNYXIsIDIwLCAyMDIwP1xuICogY29uc3QgcmVzdWx0ID0gbmV4dERheShuZXcgRGF0ZSgyMDIwLCAyLCAyMCksIDEpXG4gKiAvLz0+IE1vbiBNYXIgMjMgMjAyMCAwMDowMDowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGVuIGlzIHRoZSBuZXh0IFR1ZXNkYXkgYWZ0ZXIgTWFyLCAyMSwgMjAyMD9cbiAqIGNvbnN0IHJlc3VsdCA9IG5leHREYXkobmV3IERhdGUoMjAyMCwgMiwgMjEpLCAyKVxuICogLy89PiBUdWUgTWFyIDI0IDIwMjAgMDA6MDA6MDBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZXh0RGF5KGRhdGUsIGRheSkge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIGRlbHRhID0gZGF5IC0gZ2V0RGF5KGRhdGUpO1xuICBpZiAoZGVsdGEgPD0gMCkgZGVsdGEgKz0gNztcbiAgcmV0dXJuIGFkZERheXMoZGF0ZSwgZGVsdGEpO1xufSIsImltcG9ydCBnZXRVVENXZWVrWWVhciBmcm9tIFwiLi4vLi4vLi4vX2xpYi9nZXRVVENXZWVrWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IHNldFVUQ0RheSBmcm9tIFwiLi4vLi4vLi4vX2xpYi9zZXRVVENEYXkvaW5kZXguanNcIjtcbmltcG9ydCBzZXRVVENJU09EYXkgZnJvbSBcIi4uLy4uLy4uL19saWIvc2V0VVRDSVNPRGF5L2luZGV4LmpzXCI7XG5pbXBvcnQgc2V0VVRDSVNPV2VlayBmcm9tIFwiLi4vLi4vLi4vX2xpYi9zZXRVVENJU09XZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgc2V0VVRDV2VlayBmcm9tIFwiLi4vLi4vLi4vX2xpYi9zZXRVVENXZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgc3RhcnRPZlVUQ0lTT1dlZWsgZnJvbSBcIi4uLy4uLy4uL19saWIvc3RhcnRPZlVUQ0lTT1dlZWsvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDV2VlayBmcm9tIFwiLi4vLi4vLi4vX2xpYi9zdGFydE9mVVRDV2Vlay9pbmRleC5qc1wiO1xudmFyIE1JTExJU0VDT05EU19JTl9IT1VSID0gMzYwMDAwMDtcbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDA7XG52YXIgTUlMTElTRUNPTkRTX0lOX1NFQ09ORCA9IDEwMDA7XG52YXIgbnVtZXJpY1BhdHRlcm5zID0ge1xuICBtb250aDogL14oMVswLTJdfDA/XFxkKS8sXG4gIC8vIDAgdG8gMTJcbiAgZGF0ZTogL14oM1swLTFdfFswLTJdP1xcZCkvLFxuICAvLyAwIHRvIDMxXG4gIGRheU9mWWVhcjogL14oMzZbMC02XXwzWzAtNV1cXGR8WzAtMl0/XFxkP1xcZCkvLFxuICAvLyAwIHRvIDM2NlxuICB3ZWVrOiAvXig1WzAtM118WzAtNF0/XFxkKS8sXG4gIC8vIDAgdG8gNTNcbiAgaG91cjIzaDogL14oMlswLTNdfFswLTFdP1xcZCkvLFxuICAvLyAwIHRvIDIzXG4gIGhvdXIyNGg6IC9eKDJbMC00XXxbMC0xXT9cXGQpLyxcbiAgLy8gMCB0byAyNFxuICBob3VyMTFoOiAvXigxWzAtMV18MD9cXGQpLyxcbiAgLy8gMCB0byAxMVxuICBob3VyMTJoOiAvXigxWzAtMl18MD9cXGQpLyxcbiAgLy8gMCB0byAxMlxuICBtaW51dGU6IC9eWzAtNV0/XFxkLyxcbiAgLy8gMCB0byA1OVxuICBzZWNvbmQ6IC9eWzAtNV0/XFxkLyxcbiAgLy8gMCB0byA1OVxuICBzaW5nbGVEaWdpdDogL15cXGQvLFxuICAvLyAwIHRvIDlcbiAgdHdvRGlnaXRzOiAvXlxcZHsxLDJ9LyxcbiAgLy8gMCB0byA5OVxuICB0aHJlZURpZ2l0czogL15cXGR7MSwzfS8sXG4gIC8vIDAgdG8gOTk5XG4gIGZvdXJEaWdpdHM6IC9eXFxkezEsNH0vLFxuICAvLyAwIHRvIDk5OTlcbiAgYW55RGlnaXRzU2lnbmVkOiAvXi0/XFxkKy8sXG4gIHNpbmdsZURpZ2l0U2lnbmVkOiAvXi0/XFxkLyxcbiAgLy8gMCB0byA5LCAtMCB0byAtOVxuICB0d29EaWdpdHNTaWduZWQ6IC9eLT9cXGR7MSwyfS8sXG4gIC8vIDAgdG8gOTksIC0wIHRvIC05OVxuICB0aHJlZURpZ2l0c1NpZ25lZDogL14tP1xcZHsxLDN9LyxcbiAgLy8gMCB0byA5OTksIC0wIHRvIC05OTlcbiAgZm91ckRpZ2l0c1NpZ25lZDogL14tP1xcZHsxLDR9LyAvLyAwIHRvIDk5OTksIC0wIHRvIC05OTk5XG5cbn07XG52YXIgdGltZXpvbmVQYXR0ZXJucyA9IHtcbiAgYmFzaWNPcHRpb25hbE1pbnV0ZXM6IC9eKFsrLV0pKFxcZHsyfSkoXFxkezJ9KT98Wi8sXG4gIGJhc2ljOiAvXihbKy1dKShcXGR7Mn0pKFxcZHsyfSl8Wi8sXG4gIGJhc2ljT3B0aW9uYWxTZWNvbmRzOiAvXihbKy1dKShcXGR7Mn0pKFxcZHsyfSkoKFxcZHsyfSkpP3xaLyxcbiAgZXh0ZW5kZWQ6IC9eKFsrLV0pKFxcZHsyfSk6KFxcZHsyfSl8Wi8sXG4gIGV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzOiAvXihbKy1dKShcXGR7Mn0pOihcXGR7Mn0pKDooXFxkezJ9KSk/fFovXG59O1xuXG5mdW5jdGlvbiBwYXJzZU51bWVyaWNQYXR0ZXJuKHBhdHRlcm4sIHN0cmluZywgdmFsdWVDYWxsYmFjaykge1xuICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2gocGF0dGVybik7XG5cbiAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcGFyc2VJbnQobWF0Y2hSZXN1bHRbMF0sIDEwKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWVDYWxsYmFjayA/IHZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWUsXG4gICAgcmVzdDogc3RyaW5nLnNsaWNlKG1hdGNoUmVzdWx0WzBdLmxlbmd0aClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lem9uZVBhdHRlcm4ocGF0dGVybiwgc3RyaW5nKSB7XG4gIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChwYXR0ZXJuKTtcblxuICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gSW5wdXQgaXMgJ1onXG5cblxuICBpZiAobWF0Y2hSZXN1bHRbMF0gPT09ICdaJykge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogMCxcbiAgICAgIHJlc3Q6IHN0cmluZy5zbGljZSgxKVxuICAgIH07XG4gIH1cblxuICB2YXIgc2lnbiA9IG1hdGNoUmVzdWx0WzFdID09PSAnKycgPyAxIDogLTE7XG4gIHZhciBob3VycyA9IG1hdGNoUmVzdWx0WzJdID8gcGFyc2VJbnQobWF0Y2hSZXN1bHRbMl0sIDEwKSA6IDA7XG4gIHZhciBtaW51dGVzID0gbWF0Y2hSZXN1bHRbM10gPyBwYXJzZUludChtYXRjaFJlc3VsdFszXSwgMTApIDogMDtcbiAgdmFyIHNlY29uZHMgPSBtYXRjaFJlc3VsdFs1XSA/IHBhcnNlSW50KG1hdGNoUmVzdWx0WzVdLCAxMCkgOiAwO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBzaWduICogKGhvdXJzICogTUlMTElTRUNPTkRTX0lOX0hPVVIgKyBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSArIHNlY29uZHMgKiBNSUxMSVNFQ09ORFNfSU5fU0VDT05EKSxcbiAgICByZXN0OiBzdHJpbmcuc2xpY2UobWF0Y2hSZXN1bHRbMF0ubGVuZ3RoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUFueURpZ2l0c1NpZ25lZChzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcbiAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmFueURpZ2l0c1NpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VORGlnaXRzKG4sIHN0cmluZywgdmFsdWVDYWxsYmFjaykge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuc2luZ2xlRGlnaXQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMudHdvRGlnaXRzLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnRocmVlRGlnaXRzLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmZvdXJEaWdpdHMsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obmV3IFJlZ0V4cCgnXlxcXFxkezEsJyArIG4gKyAnfScpLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTkRpZ2l0c1NpZ25lZChuLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnNpbmdsZURpZ2l0U2lnbmVkLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnR3b0RpZ2l0c1NpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy50aHJlZURpZ2l0c1NpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKTtcblxuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5mb3VyRGlnaXRzU2lnbmVkLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG5ldyBSZWdFeHAoJ14tP1xcXFxkezEsJyArIG4gKyAnfScpLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRheVBlcmlvZEVudW1Ub0hvdXJzKGVudW1WYWx1ZSkge1xuICBzd2l0Y2ggKGVudW1WYWx1ZSkge1xuICAgIGNhc2UgJ21vcm5pbmcnOlxuICAgICAgcmV0dXJuIDQ7XG5cbiAgICBjYXNlICdldmVuaW5nJzpcbiAgICAgIHJldHVybiAxNztcblxuICAgIGNhc2UgJ3BtJzpcbiAgICBjYXNlICdub29uJzpcbiAgICBjYXNlICdhZnRlcm5vb24nOlxuICAgICAgcmV0dXJuIDEyO1xuXG4gICAgY2FzZSAnYW0nOlxuICAgIGNhc2UgJ21pZG5pZ2h0JzpcbiAgICBjYXNlICduaWdodCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3b0RpZ2l0WWVhcih0d29EaWdpdFllYXIsIGN1cnJlbnRZZWFyKSB7XG4gIHZhciBpc0NvbW1vbkVyYSA9IGN1cnJlbnRZZWFyID4gMDsgLy8gQWJzb2x1dGUgbnVtYmVyIG9mIHRoZSBjdXJyZW50IHllYXI6XG4gIC8vIDEgLT4gMSBBQ1xuICAvLyAwIC0+IDEgQkNcbiAgLy8gLTEgLT4gMiBCQ1xuXG4gIHZhciBhYnNDdXJyZW50WWVhciA9IGlzQ29tbW9uRXJhID8gY3VycmVudFllYXIgOiAxIC0gY3VycmVudFllYXI7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKGFic0N1cnJlbnRZZWFyIDw9IDUwKSB7XG4gICAgcmVzdWx0ID0gdHdvRGlnaXRZZWFyIHx8IDEwMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmFuZ2VFbmQgPSBhYnNDdXJyZW50WWVhciArIDUwO1xuICAgIHZhciByYW5nZUVuZENlbnR1cnkgPSBNYXRoLmZsb29yKHJhbmdlRW5kIC8gMTAwKSAqIDEwMDtcbiAgICB2YXIgaXNQcmV2aW91c0NlbnR1cnkgPSB0d29EaWdpdFllYXIgPj0gcmFuZ2VFbmQgJSAxMDA7XG4gICAgcmVzdWx0ID0gdHdvRGlnaXRZZWFyICsgcmFuZ2VFbmRDZW50dXJ5IC0gKGlzUHJldmlvdXNDZW50dXJ5ID8gMTAwIDogMCk7XG4gIH1cblxuICByZXR1cm4gaXNDb21tb25FcmEgPyByZXN1bHQgOiAxIC0gcmVzdWx0O1xufVxuXG52YXIgREFZU19JTl9NT05USCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbnZhciBEQVlTX0lOX01PTlRIX0xFQVBfWUVBUiA9IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTsgLy8gVXNlciBmb3IgdmFsaWRhdGlvblxuXG5mdW5jdGlvbiBpc0xlYXBZZWFySW5kZXgoeWVhcikge1xuICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCB5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwO1xufVxuLypcbiAqIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgTWlsbGlzZWNvbmRzIGluIGRheSAgICAgICAgICAgIHxcbiAqIHwgIGIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgIHwgIEIgIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgIHxcbiAqIHwgIGMgIHwgU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWsgIHwgIEMqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHxcbiAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGUgIHwgTG9jYWwgZGF5IG9mIHdlZWsgICAgICAgICAgICAgIHwgIEUgIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGYgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEYqIHwgRGF5IG9mIHdlZWsgaW4gbW9udGggICAgICAgICAgIHxcbiAqIHwgIGcqIHwgTW9kaWZpZWQgSnVsaWFuIGRheSAgICAgICAgICAgIHwgIEcgIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGggIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgIHwgIEggIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGkhIHwgSVNPIGRheSBvZiB3ZWVrICAgICAgICAgICAgICAgIHwgIEkhIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgIHxcbiAqIHwgIGoqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHwgIEoqIHwgTG9jYWxpemVkIGhvdXIgdy9vIGRheSBwZXJpb2QgIHxcbiAqIHwgIGsgIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgIHwgIEsgIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGwqIHwgKGRlcHJlY2F0ZWQpICAgICAgICAgICAgICAgICAgIHwgIEwgIHwgU3RhbmQtYWxvbmUgbW9udGggICAgICAgICAgICAgIHxcbiAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG8hIHwgT3JkaW5hbCBudW1iZXIgbW9kaWZpZXIgICAgICAgIHwgIE8qIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHEgIHwgU3RhbmQtYWxvbmUgcXVhcnRlciAgICAgICAgICAgIHwgIFEgIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHIqIHwgUmVsYXRlZCBHcmVnb3JpYW4geWVhciAgICAgICAgIHwgIFIhIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgIHxcbiAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcbiAqIHwgIHQhIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgIHwgIFQhIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgIHxcbiAqIHwgIHUgIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgIHwgIFUqIHwgQ3ljbGljIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHYqIHwgVGltZXpvbmUgKGdlbmVyaWMgbm9uLWxvY2F0LikgIHwgIFYqIHwgVGltZXpvbmUgKGxvY2F0aW9uKSAgICAgICAgICAgIHxcbiAqIHwgIHcgIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgIHwgIFcqIHwgV2VlayBvZiBtb250aCAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHggIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgIHwgIFggIHwgVGltZXpvbmUgKElTTy04NjAxKSAgICAgICAgICAgIHxcbiAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgIHxcbiAqIHwgIHoqIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pIHwgIFoqIHwgVGltZXpvbmUgKGFsaWFzZXMpICAgICAgICAgICAgIHxcbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgISBhcmUgbm9uLXN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgZGF0ZS1mbnM6XG4gKiAtIGBvYCBtb2RpZmllcyB0aGUgcHJldmlvdXMgdG9rZW4gdG8gdHVybiBpdCBpbnRvIGFuIG9yZGluYWwgKHNlZSBgcGFyc2VgIGRvY3MpXG4gKiAtIGBpYCBpcyBJU08gZGF5IG9mIHdlZWsuIEZvciBgaWAgYW5kIGBpaWAgaXMgcmV0dXJucyBudW1lcmljIElTTyB3ZWVrIGRheXMsXG4gKiAgIGkuZS4gNyBmb3IgU3VuZGF5LCAxIGZvciBNb25kYXksIGV0Yy5cbiAqIC0gYElgIGlzIElTTyB3ZWVrIG9mIHllYXIsIGFzIG9wcG9zZWQgdG8gYHdgIHdoaWNoIGlzIGxvY2FsIHdlZWsgb2YgeWVhci5cbiAqIC0gYFJgIGlzIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyLCBhcyBvcHBvc2VkIHRvIGBZYCB3aGljaCBpcyBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyLlxuICogICBgUmAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBJYCBhbmQgYGlgXG4gKiAgIGZvciB1bml2ZXJzYWwgSVNPIHdlZWstbnVtYmVyaW5nIGRhdGUsIHdoZXJlYXNcbiAqICAgYFlgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgd2AgYW5kIGBlYFxuICogICBmb3Igd2Vlay1udW1iZXJpbmcgZGF0ZSBzcGVjaWZpYyB0byB0aGUgbG9jYWxlLlxuICovXG5cblxudmFyIHBhcnNlcnMgPSB7XG4gIC8vIEVyYVxuICBHOiB7XG4gICAgcHJpb3JpdHk6IDE0MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyBBRCwgQkNcbiAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgIGNhc2UgJ0dHJzpcbiAgICAgICAgY2FzZSAnR0dHJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZXJhKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5lcmEoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gQSwgQlxuXG4gICAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZXJhKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0XG5cbiAgICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmVyYShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5lcmEoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmVyYShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93J1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZmxhZ3MuZXJhID0gdmFsdWU7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHZhbHVlLCAwLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydSJywgJ3UnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gWWVhclxuICB5OiB7XG4gICAgLy8gRnJvbSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTMxL3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuICAgIC8vIHwgWWVhciAgICAgfCAgICAgeSB8IHl5IHwgICB5eXkgfCAgeXl5eSB8IHl5eXl5IHxcbiAgICAvLyB8LS0tLS0tLS0tLXwtLS0tLS0tfC0tLS18LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XG4gICAgLy8gfCBBRCAxICAgICB8ICAgICAxIHwgMDEgfCAgIDAwMSB8ICAwMDAxIHwgMDAwMDEgfFxuICAgIC8vIHwgQUQgMTIgICAgfCAgICAxMiB8IDEyIHwgICAwMTIgfCAgMDAxMiB8IDAwMDEyIHxcbiAgICAvLyB8IEFEIDEyMyAgIHwgICAxMjMgfCAyMyB8ICAgMTIzIHwgIDAxMjMgfCAwMDEyMyB8XG4gICAgLy8gfCBBRCAxMjM0ICB8ICAxMjM0IHwgMzQgfCAgMTIzNCB8ICAxMjM0IHwgMDEyMzQgfFxuICAgIC8vIHwgQUQgMTIzNDUgfCAxMjM0NSB8IDQ1IHwgMTIzNDUgfCAxMjM0NSB8IDEyMzQ1IHxcbiAgICBwcmlvcml0eTogMTMwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBpc1R3b0RpZ2l0WWVhcjogdG9rZW4gPT09ICd5eSdcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyg0LCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuXG4gICAgICAgIGNhc2UgJ3lvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd5ZWFyJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaXNUd29EaWdpdFllYXIgfHwgdmFsdWUueWVhciA+IDA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBmbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG5cbiAgICAgIGlmICh2YWx1ZS5pc1R3b0RpZ2l0WWVhcikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFR3b0RpZ2l0WWVhciA9IG5vcm1hbGl6ZVR3b0RpZ2l0WWVhcih2YWx1ZS55ZWFyLCBjdXJyZW50WWVhcik7XG4gICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIobm9ybWFsaXplZFR3b0RpZ2l0WWVhciwgMCwgMSk7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgeWVhciA9ICEoJ2VyYScgaW4gZmxhZ3MpIHx8IGZsYWdzLmVyYSA9PT0gMSA/IHZhbHVlLnllYXIgOiAxIC0gdmFsdWUueWVhcjtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3UnLCAndycsICdJJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXJcbiAgWToge1xuICAgIHByaW9yaXR5OiAxMzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgIGlzVHdvRGlnaXRZZWFyOiB0b2tlbiA9PT0gJ1lZJ1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKDQsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG5cbiAgICAgICAgY2FzZSAnWW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3llYXInLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5pc1R3b0RpZ2l0WWVhciB8fCB2YWx1ZS55ZWFyID4gMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIGZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGN1cnJlbnRZZWFyID0gZ2V0VVRDV2Vla1llYXIoZGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh2YWx1ZS5pc1R3b0RpZ2l0WWVhcikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFR3b0RpZ2l0WWVhciA9IG5vcm1hbGl6ZVR3b0RpZ2l0WWVhcih2YWx1ZS55ZWFyLCBjdXJyZW50WWVhcik7XG4gICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIobm9ybWFsaXplZFR3b0RpZ2l0WWVhciwgMCwgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpO1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gc3RhcnRPZlVUQ1dlZWsoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ZWFyID0gISgnZXJhJyBpbiBmbGFncykgfHwgZmxhZ3MuZXJhID09PSAxID8gdmFsdWUueWVhciA6IDEgLSB2YWx1ZS55ZWFyO1xuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZVVENXZWVrKGRhdGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnUicsICd1JywgJ1EnLCAncScsICdNJywgJ0wnLCAnSScsICdkJywgJ0QnLCAnaScsICd0JywgJ1QnXVxuICB9LFxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICBSOiB7XG4gICAgcHJpb3JpdHk6IDEzMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIGlmICh0b2tlbiA9PT0gJ1InKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHNTaWduZWQoNCwgc3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0c1NpZ25lZCh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChfZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBmaXJzdFdlZWtPZlllYXIgPSBuZXcgRGF0ZSgwKTtcbiAgICAgIGZpcnN0V2Vla09mWWVhci5zZXRVVENGdWxsWWVhcih2YWx1ZSwgMCwgNCk7XG4gICAgICBmaXJzdFdlZWtPZlllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gc3RhcnRPZlVUQ0lTT1dlZWsoZmlyc3RXZWVrT2ZZZWFyKTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydHJywgJ3knLCAnWScsICd1JywgJ1EnLCAncScsICdNJywgJ0wnLCAndycsICdkJywgJ0QnLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEV4dGVuZGVkIHllYXJcbiAgdToge1xuICAgIHByaW9yaXR5OiAxMzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBfbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBpZiAodG9rZW4gPT09ICd1Jykge1xuICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzU2lnbmVkKDQsIHN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZU5EaWdpdHNTaWduZWQodG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIodmFsdWUsIDAsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ0cnLCAneScsICdZJywgJ1InLCAndycsICdJJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFF1YXJ0ZXJcbiAgUToge1xuICAgIHByaW9yaXR5OiAxMjAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgY2FzZSAnUVEnOlxuICAgICAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuXG4gICAgICAgIGNhc2UgJ1FvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdxdWFydGVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuXG4gICAgICAgIGNhc2UgJ1FRUSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG5cbiAgICAgICAgY2FzZSAnUVFRUVEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG5cbiAgICAgICAgY2FzZSAnUVFRUSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTW9udGgoKHZhbHVlIC0gMSkgKiAzLCAxKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAncScsICdNJywgJ0wnLCAndycsICdJJywgJ2QnLCAnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBxdWFydGVyXG4gIHE6IHtcbiAgICBwcmlvcml0eTogMTIwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgIGNhc2UgJ3FxJzpcbiAgICAgICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcblxuICAgICAgICBjYXNlICdxbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAncXVhcnRlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gUTEsIFEyLCBRMywgUTRcblxuICAgICAgICBjYXNlICdxcXEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuXG4gICAgICAgIGNhc2UgJ3FxcXFxJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuXG4gICAgICAgIGNhc2UgJ3FxcXEnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01vbnRoKCh2YWx1ZSAtIDEpICogMywgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ1EnLCAnTScsICdMJywgJ3cnLCAnSScsICdkJywgJ0QnLCAnaScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gTW9udGhcbiAgTToge1xuICAgIHByaW9yaXR5OiAxMTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAtIDE7XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDEsIDIsIC4uLiwgMTJcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLm1vbnRoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcblxuICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cygyLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG5cbiAgICAgICAgY2FzZSAnTW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ21vbnRoJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG5cbiAgICAgICAgY2FzZSAnTU1NJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIEosIEYsIC4uLiwgRFxuXG4gICAgICAgIGNhc2UgJ01NTU1NJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcblxuICAgICAgICBjYXNlICdNTU1NJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLm1vbnRoKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTW9udGgodmFsdWUsIDEpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ1knLCAnUicsICdxJywgJ1EnLCAnTCcsICd3JywgJ0knLCAnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBtb250aFxuICBMOiB7XG4gICAgcHJpb3JpdHk6IDExMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gMTtcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gMSwgMiwgLi4uLCAxMlxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMubW9udGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxuXG4gICAgICAgIGNhc2UgJ0xMJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKDIsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcblxuICAgICAgICBjYXNlICdMbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnbW9udGgnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcblxuICAgICAgICBjYXNlICdMTEwnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gSiwgRiwgLi4uLCBEXG5cbiAgICAgICAgY2FzZSAnTExMTEwnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuXG4gICAgICAgIGNhc2UgJ0xMTEwnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5tb250aChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2gubW9udGgoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENNb250aCh2YWx1ZSwgMSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3EnLCAnUScsICdNJywgJ3cnLCAnSScsICdEJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIExvY2FsIHdlZWsgb2YgeWVhclxuICB3OiB7XG4gICAgcHJpb3JpdHk6IDEwMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMud2Vlaywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICd3byc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnd2VlaydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA1MztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzdGFydE9mVVRDV2VlayhzZXRVVENXZWVrKGRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsneScsICdSJywgJ3UnLCAncScsICdRJywgJ00nLCAnTCcsICdJJywgJ2QnLCAnRCcsICdpJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIElTTyB3ZWVrIG9mIHllYXJcbiAgSToge1xuICAgIHByaW9yaXR5OiAxMDAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLndlZWssIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnSW8nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ3dlZWsnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNTM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3RhcnRPZlVUQ0lTT1dlZWsoc2V0VVRDSVNPV2VlayhkYXRlLCB2YWx1ZSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnWScsICd1JywgJ3EnLCAnUScsICdNJywgJ0wnLCAndycsICdkJywgJ0QnLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIERheSBvZiB0aGUgbW9udGhcbiAgZDoge1xuICAgIHByaW9yaXR5OiA5MCxcbiAgICBzdWJQcmlvcml0eTogMSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuZGF0ZSwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdkbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnZGF0ZSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgdmFyIGlzTGVhcFllYXIgPSBpc0xlYXBZZWFySW5kZXgoeWVhcik7XG4gICAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG5cbiAgICAgIGlmIChpc0xlYXBZZWFyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSW21vbnRoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IERBWVNfSU5fTU9OVEhbbW9udGhdO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZSh2YWx1ZSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnWScsICdSJywgJ3EnLCAnUScsICd3JywgJ0knLCAnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBEYXkgb2YgeWVhclxuICBEOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHN1YlByaW9yaXR5OiAxLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICBjYXNlICdERCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmRheU9mWWVhciwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdEbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnZGF0ZSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgdmFyIGlzTGVhcFllYXIgPSBpc0xlYXBZZWFySW5kZXgoeWVhcik7XG5cbiAgICAgIGlmIChpc0xlYXBZZWFyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDM2NjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDM2NTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ01vbnRoKDAsIHZhbHVlKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydZJywgJ1InLCAncScsICdRJywgJ00nLCAnTCcsICd3JywgJ0knLCAnZCcsICdFJywgJ2knLCAnZScsICdjJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIERheSBvZiB3ZWVrXG4gIEU6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gVHVlXG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICBjYXNlICdFRSc6XG4gICAgICAgIGNhc2UgJ0VFRSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVFxuXG4gICAgICAgIGNhc2UgJ0VFRUVFJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1XG5cbiAgICAgICAgY2FzZSAnRUVFRUVFJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlc2RheVxuXG4gICAgICAgIGNhc2UgJ0VFRUUnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA2O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZSA9IHNldFVUQ0RheShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnRCcsICdpJywgJ2UnLCAnYycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBMb2NhbCBkYXkgb2Ygd2Vla1xuICBlOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB3aG9sZVdlZWtEYXlzID0gTWF0aC5mbG9vcigodmFsdWUgLSAxKSAvIDcpICogNztcbiAgICAgICAgcmV0dXJuICh2YWx1ZSArIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgNikgJSA3ICsgd2hvbGVXZWVrRGF5cztcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gM1xuICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgY2FzZSAnZWUnOlxuICAgICAgICAgIC8vIDAzXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjayk7XG4gICAgICAgIC8vIDNyZFxuXG4gICAgICAgIGNhc2UgJ2VvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdkYXknLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVcblxuICAgICAgICBjYXNlICdlZWUnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRcblxuICAgICAgICBjYXNlICdlZWVlZSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdVxuXG4gICAgICAgIGNhc2UgJ2VlZWVlZSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgICBjYXNlICdlZWVlJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGUgPSBzZXRVVENEYXkoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnUicsICd1JywgJ3EnLCAnUScsICdNJywgJ0wnLCAnSScsICdkJywgJ0QnLCAnRScsICdpJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWtcbiAgYzoge1xuICAgIHByaW9yaXR5OiA5MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgd2hvbGVXZWVrRGF5cyA9IE1hdGguZmxvb3IoKHZhbHVlIC0gMSkgLyA3KSAqIDc7XG4gICAgICAgIHJldHVybiAodmFsdWUgKyBvcHRpb25zLndlZWtTdGFydHNPbiArIDYpICUgNyArIHdob2xlV2Vla0RheXM7XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIDNcbiAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGNhc2UgJ2NjJzpcbiAgICAgICAgICAvLyAwM1xuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgICAgICAvLyAzcmRcblxuICAgICAgICBjYXNlICdjbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnZGF5JyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlXG5cbiAgICAgICAgY2FzZSAnY2NjJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUXG5cbiAgICAgICAgY2FzZSAnY2NjY2MnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVcblxuICAgICAgICBjYXNlICdjY2NjY2MnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdWVzZGF5XG5cbiAgICAgICAgY2FzZSAnY2NjYyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlID0gc2V0VVRDRGF5KGRhdGUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd5JywgJ1InLCAndScsICdxJywgJ1EnLCAnTScsICdMJywgJ0knLCAnZCcsICdEJywgJ0UnLCAnaScsICdlJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIElTTyBkYXkgb2Ygd2Vla1xuICBpOiB7XG4gICAgcHJpb3JpdHk6IDkwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gMlxuICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgY2FzZSAnaWknOlxuICAgICAgICAgIC8vIDAyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICAgIC8vIDJuZFxuXG4gICAgICAgIGNhc2UgJ2lvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdkYXknXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIFR1ZVxuXG4gICAgICAgIGNhc2UgJ2lpaSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVFxuXG4gICAgICAgIGNhc2UgJ2lpaWlpJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUdVxuXG4gICAgICAgIGNhc2UgJ2lpaWlpaSc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gVHVlc2RheVxuXG4gICAgICAgIGNhc2UgJ2lpaWknOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXkoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnLFxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheShzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJyxcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGUgPSBzZXRVVENJU09EYXkoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3knLCAnWScsICd1JywgJ3EnLCAnUScsICdNJywgJ0wnLCAndycsICdkJywgJ0QnLCAnRScsICdlJywgJ2MnLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gQU0gb3IgUE1cbiAgYToge1xuICAgIHByaW9yaXR5OiA4MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgY2FzZSAnYWEnOlxuICAgICAgICBjYXNlICdhYWEnOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ2FhYWFhJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnYWFhYSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoZGF5UGVyaW9kRW51bVRvSG91cnModmFsdWUpLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ2InLCAnQicsICdIJywgJ2snLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gQU0sIFBNLCBtaWRuaWdodFxuICBiOiB7XG4gICAgcHJpb3JpdHk6IDgwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ2InOlxuICAgICAgICBjYXNlICdiYic6XG4gICAgICAgIGNhc2UgJ2JiYic6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnYmJiYmInOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdiYmJiJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pIHx8IG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENIb3VycyhkYXlQZXJpb2RFbnVtVG9Ib3Vycyh2YWx1ZSksIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnYScsICdCJywgJ0gnLCAnaycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBpbiB0aGUgbW9ybmluZywgaW4gdGhlIGFmdGVybm9vbiwgaW4gdGhlIGV2ZW5pbmcsIGF0IG5pZ2h0XG4gIEI6IHtcbiAgICBwcmlvcml0eTogODAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnQic6XG4gICAgICAgIGNhc2UgJ0JCJzpcbiAgICAgICAgY2FzZSAnQkJCJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdCQkJCQic6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ0JCQkInOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgICAgfSkgfHwgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KSB8fCBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGRheVBlcmlvZEVudW1Ub0hvdXJzKHZhbHVlKSwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydhJywgJ2InLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gSG91ciBbMS0xMl1cbiAgaDoge1xuICAgIHByaW9yaXR5OiA3MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuaG91cjEyaCwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdobyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnaG91cidcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfZGF0ZSwgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSAxMjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgaXNQTSA9IGRhdGUuZ2V0VVRDSG91cnMoKSA+PSAxMjtcblxuICAgICAgaWYgKGlzUE0gJiYgdmFsdWUgPCAxMikge1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKHZhbHVlICsgMTIsIDAsIDAsIDApO1xuICAgICAgfSBlbHNlIGlmICghaXNQTSAmJiB2YWx1ZSA9PT0gMTIpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydIJywgJ0snLCAnaycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBIb3VyIFswLTIzXVxuICBIOiB7XG4gICAgcHJpb3JpdHk6IDcwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5ob3VyMjNoLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ0hvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDIzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsnYScsICdiJywgJ2gnLCAnSycsICdrJywgJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEhvdXIgWzAtMTFdXG4gIEs6IHtcbiAgICBwcmlvcml0eTogNzAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnSyc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmhvdXIxMWgsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnS28nOlxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGlzUE0gPSBkYXRlLmdldFVUQ0hvdXJzKCkgPj0gMTI7XG5cbiAgICAgIGlmIChpc1BNICYmIHZhbHVlIDwgMTIpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSArIDEyLCAwLCAwLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydoJywgJ0gnLCAnaycsICd0JywgJ1QnXVxuICB9LFxuICAvLyBIb3VyIFsxLTI0XVxuICBrOiB7XG4gICAgcHJpb3JpdHk6IDcwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIF9vcHRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5ob3VyMjRoLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ2tvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDI0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBob3VycyA9IHZhbHVlIDw9IDI0ID8gdmFsdWUgJSAyNCA6IHZhbHVlO1xuICAgICAgZGF0ZS5zZXRVVENIb3Vycyhob3VycywgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWydhJywgJ2InLCAnaCcsICdIJywgJ0snLCAndCcsICdUJ11cbiAgfSxcbiAgLy8gTWludXRlXG4gIG06IHtcbiAgICBwcmlvcml0eTogNjAsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLm1pbnV0ZSwgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdtbyc6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiAnbWludXRlJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9kYXRlLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDU5O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTWludXRlcyh2YWx1ZSwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd0JywgJ1QnXVxuICB9LFxuICAvLyBTZWNvbmRcbiAgczoge1xuICAgIHByaW9yaXR5OiA1MCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuc2Vjb25kLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3NvJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdzZWNvbmQnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoX2RhdGUsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNTk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgZGF0ZS5zZXRVVENTZWNvbmRzKHZhbHVlLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3QnLCAnVCddXG4gIH0sXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiB7XG4gICAgcHJpb3JpdHk6IDMwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKiBNYXRoLnBvdygxMCwgLXRva2VuLmxlbmd0aCArIDMpKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgX29wdGlvbnMpIHtcbiAgICAgIGRhdGUuc2V0VVRDTWlsbGlzZWNvbmRzKHZhbHVlKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiBbJ3QnLCAnVCddXG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gKzAwOjAwIGlzIGAnWidgKVxuICBYOiB7XG4gICAgcHJpb3JpdHk6IDEwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgX21hdGNoLCBfb3B0aW9ucykge1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsTWludXRlcywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICdYWCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnWFhYWCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWNPcHRpb25hbFNlY29uZHMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnWFhYWFgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ1hYWCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWQsIHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCBmbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICBpZiAoZmxhZ3MudGltZXN0YW1wSXNTZXQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIHZhbHVlKTtcbiAgICB9LFxuICAgIGluY29tcGF0aWJsZVRva2VuczogWyd0JywgJ1QnLCAneCddXG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMSlcbiAgeDoge1xuICAgIHByaW9yaXR5OiAxMCxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWNPcHRpb25hbE1pbnV0ZXMsIHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAneHgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmJhc2ljLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3h4eHgnOlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmJhc2ljT3B0aW9uYWxTZWNvbmRzLCBzdHJpbmcpO1xuXG4gICAgICAgIGNhc2UgJ3h4eHh4JzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5leHRlbmRlZE9wdGlvbmFsU2Vjb25kcywgc3RyaW5nKTtcblxuICAgICAgICBjYXNlICd4eHgnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmV4dGVuZGVkLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgZmxhZ3MsIHZhbHVlLCBfb3B0aW9ucykge1xuICAgICAgaWYgKGZsYWdzLnRpbWVzdGFtcElzU2V0KSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgLSB2YWx1ZSk7XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6IFsndCcsICdUJywgJ1gnXVxuICB9LFxuICAvLyBTZWNvbmRzIHRpbWVzdGFtcFxuICB0OiB7XG4gICAgcHJpb3JpdHk6IDQwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCBfdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiBwYXJzZUFueURpZ2l0c1NpZ25lZChzdHJpbmcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoX2RhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gW25ldyBEYXRlKHZhbHVlICogMTAwMCksIHtcbiAgICAgICAgdGltZXN0YW1wSXNTZXQ6IHRydWVcbiAgICAgIH1dO1xuICAgIH0sXG4gICAgaW5jb21wYXRpYmxlVG9rZW5zOiAnKidcbiAgfSxcbiAgLy8gTWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICBUOiB7XG4gICAgcHJpb3JpdHk6IDIwLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCBfdG9rZW4sIF9tYXRjaCwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiBwYXJzZUFueURpZ2l0c1NpZ25lZChzdHJpbmcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoX2RhdGUsIF9mbGFncywgdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgICByZXR1cm4gW25ldyBEYXRlKHZhbHVlKSwge1xuICAgICAgICB0aW1lc3RhbXBJc1NldDogdHJ1ZVxuICAgICAgfV07XG4gICAgfSxcbiAgICBpbmNvbXBhdGlibGVUb2tlbnM6ICcqJ1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgcGFyc2VyczsiLCJpbXBvcnQgZGVmYXVsdExvY2FsZSBmcm9tIFwiLi4vbG9jYWxlL2VuLVVTL2luZGV4LmpzXCI7XG5pbXBvcnQgc3ViTWlsbGlzZWNvbmRzIGZyb20gXCIuLi9zdWJNaWxsaXNlY29uZHMvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IGFzc2lnbiBmcm9tIFwiLi4vX2xpYi9hc3NpZ24vaW5kZXguanNcIjtcbmltcG9ydCBsb25nRm9ybWF0dGVycyBmcm9tIFwiLi4vX2xpYi9mb3JtYXQvbG9uZ0Zvcm1hdHRlcnMvaW5kZXguanNcIjtcbmltcG9ydCBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzIGZyb20gXCIuLi9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4sIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbiwgdGhyb3dQcm90ZWN0ZWRFcnJvciB9IGZyb20gXCIuLi9fbGliL3Byb3RlY3RlZFRva2Vucy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCBwYXJzZXJzIGZyb20gXCIuL19saWIvcGFyc2Vycy9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbnZhciBUSU1FWk9ORV9VTklUX1BSSU9SSVRZID0gMTA7IC8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XG4vLyAtIFt5WVFxTUx3SWREZWNpaEhLa21zXW8gbWF0Y2hlcyBhbnkgYXZhaWxhYmxlIG9yZGluYWwgbnVtYmVyIHRva2VuXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuXG52YXIgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IC9beVlRcU1Md0lkRGVjaWhIS2ttc11vfChcXHcpXFwxKnwnJ3wnKCcnfFteJ10pKygnfCQpfC4vZzsgLy8gVGhpcyBSZWdFeHAgY2F0Y2hlcyBzeW1ib2xzIGVzY2FwZWQgYnkgcXVvdGVzLCBhbmQgYWxzb1xuLy8gc2VxdWVuY2VzIG9mIHN5bWJvbHMgUCwgcCwgYW5kIHRoZSBjb21iaW5hdGlvbnMgbGlrZSBgUFBQUFBQUHBwcHBwYFxuXG52YXIgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvUCtwK3xQK3xwK3wnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcbnZhciBlc2NhcGVkU3RyaW5nUmVnRXhwID0gL14nKFteXSo/KSc/JC87XG52YXIgZG91YmxlUXVvdGVSZWdFeHAgPSAvJycvZztcbnZhciBub3RXaGl0ZXNwYWNlUmVnRXhwID0gL1xcUy87XG52YXIgdW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAgPSAvW2EtekEtWl0vO1xuLyoqXG4gKiBAbmFtZSBwYXJzZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBQYXJzZSB0aGUgZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZGF0ZSBwYXJzZWQgZnJvbSBzdHJpbmcgdXNpbmcgdGhlIGdpdmVuIGZvcm1hdCBzdHJpbmcuXG4gKlxuICogPiDimqDvuI8gUGxlYXNlIG5vdGUgdGhhdCB0aGUgYGZvcm1hdGAgdG9rZW5zIGRpZmZlciBmcm9tIE1vbWVudC5qcyBhbmQgb3RoZXIgbGlicmFyaWVzLlxuICogPiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogVGhlIGNoYXJhY3RlcnMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgd3JhcHBlZCBiZXR3ZWVuIHR3byBzaW5nbGUgcXVvdGVzIGNoYXJhY3RlcnMgKCcpIGFyZSBlc2NhcGVkLlxuICogVHdvIHNpbmdsZSBxdW90ZXMgaW4gYSByb3csIHdoZXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgYSBxdW90ZWQgc2VxdWVuY2UsIHJlcHJlc2VudCBhICdyZWFsJyBzaW5nbGUgcXVvdGUuXG4gKlxuICogRm9ybWF0IG9mIHRoZSBmb3JtYXQgc3RyaW5nIGlzIGJhc2VkIG9uIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcbiAqIHdpdGggYSBmZXcgYWRkaXRpb25zIChzZWUgbm90ZSA1IGJlbG93IHRoZSB0YWJsZSkuXG4gKlxuICogTm90IGFsbCB0b2tlbnMgYXJlIGNvbXBhdGlibGUuIENvbWJpbmF0aW9ucyB0aGF0IGRvbid0IG1ha2Ugc2Vuc2Ugb3IgY291bGQgbGVhZCB0byBidWdzIGFyZSBwcm9oaWJpdGVkXG4gKiBhbmQgd2lsbCB0aHJvdyBgUmFuZ2VFcnJvcmAuIEZvciBleGFtcGxlIHVzYWdlIG9mIDI0LWhvdXIgZm9ybWF0IHRva2VuIHdpdGggQU0vUE0gdG9rZW4gd2lsbCB0aHJvdyBhbiBleGNlcHRpb246XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcGFyc2UoJzIzIEFNJywgJ0hIIGEnLCBuZXcgRGF0ZSgpKVxuICogLy89PiBSYW5nZUVycm9yOiBUaGUgZm9ybWF0IHN0cmluZyBtdXN0bid0IGNvbnRhaW4gYEhIYCBhbmQgYGFgIGF0IHRoZSBzYW1lIHRpbWVcbiAqIGBgYFxuICpcbiAqIFNlZSB0aGUgY29tcGF0aWJpbGl0eSB0YWJsZTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvZS8yUEFDWC0xdlFPUFUzeFVocGxsbDZkeW9NbVZVWEhLbF84Q1JEczZfdWVMbWV4M1NvcXdodW9sa3VOM08wNWw0cnF4NWgxZEtYOGViNDZVbC1DQ1NycS9wdWJodG1sP2dpZD0wJnNpbmdsZT10cnVlXG4gKlxuICogQWNjZXB0ZWQgZm9ybWF0IHN0cmluZyBwYXR0ZXJuczpcbiAqIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8UHJpb3J8IFBhdHRlcm4gfCBSZXN1bHQgZXhhbXBsZXMgICAgICAgICAgICAgICAgICAgfCBOb3RlcyB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tfFxuICogfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMTQwIHwgRy4uR0dHICB8IEFELCBCQyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEdHR0cgICAgfCBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBHR0dHRyAgIHwgQSwgQiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBDYWxlbmRhciB5ZWFyICAgICAgICAgICAgICAgICAgIHwgMTMwIHwgeSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3LCA5OTk5ICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHlvICAgICAgfCA0NHRoLCAxc3QsIDE5MDB0aCwgOTk5OTk5OXRoICAgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXl5ICAgICB8IDA0NCwgMDAxLCAxMjMsIDk5OSAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5eXkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eXl5eSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0ICAgfFxuICogfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgIHwgMTMwIHwgWSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3LCA5MDAwICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlvICAgICAgfCA0NHRoLCAxc3QsIDE5MDB0aCwgOTk5OTk5OXRoICAgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNCw2ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVlZICAgICB8IDA0NCwgMDAxLCAxMjMsIDk5OSAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZWVkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA0LDYgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWVlZWSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0ICAgfFxuICogfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgIHwgMTMwIHwgUiAgICAgICB8IC00MywgMSwgMTkwMCwgMjAxNywgOTk5OSwgLTk5OTkgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSICAgICAgfCAtNDMsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUlIgICAgIHwgLTA0MywgMDAxLCAxMjMsIDk5OSwgLTk5OSAgICAgICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlJSUiAgICB8IC0wMDQzLCAwMDAxLCAyMDE3LCA5OTk5LCAtOTk5OSAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSUlJSICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQsNSB8XG4gKiB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICAgfCAxMzAgfCB1ICAgICAgIHwgLTQzLCAxLCAxOTAwLCAyMDE3LCA5OTk5LCAtOTk5ICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXUgICAgICB8IC00MywgMDEsIDk5LCAtOTkgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1dSAgICAgfCAtMDQzLCAwMDEsIDEyMywgOTk5LCAtOTk5ICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dXV1ICAgIHwgLTAwNDMsIDAwMDEsIDIwMTcsIDk5OTksIC05OTk5ICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXV1dXUgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCAgIHxcbiAqIHwgUXVhcnRlciAoZm9ybWF0dGluZykgICAgICAgICAgICB8IDEyMCB8IFEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRUSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUVFRICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVFRUVEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgUXVhcnRlciAoc3RhbmQtYWxvbmUpICAgICAgICAgICB8IDEyMCB8IHEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxcSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcXFxICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXFxcXEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDMgICAgIHxcbiAqIHwgTW9udGggKGZvcm1hdHRpbmcpICAgICAgICAgICAgICB8IDExMCB8IE0gICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU0gICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NTSAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTU1NICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU1NTU0gICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTW9udGggKHN0YW5kLWFsb25lKSAgICAgICAgICAgICB8IDExMCB8IEwgICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTEwgICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMTCAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTExMICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTExMTEwgICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgICB8IDEwMCB8IHcgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB3byAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgd3cgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgICB8IDEwMCB8IEkgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBJbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSUkgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgICB8ICA5MCB8IGQgICAgICAgfCAxLCAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBkbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzFzdCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZGQgICAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgICB8ICA5MCB8IEQgICAgICAgfCAxLCAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBEbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzY1dGgsIDM2NnRoICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgREQgICAgICB8IDAxLCAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IERERCAgICAgfCAwMDEsIDAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBEREREICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCBEYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgICAgIHwgIDkwIHwgRS4uRUVFICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEVFRUUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBFRUVFRSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRUVFRUVFICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICB8ICA5MCB8IGkgICAgICAgfCAxLCAyLCAzLCAuLi4sIDcgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgN3RoICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWkgICAgICB8IDAxLCAwMiwgLi4uLCAwNyAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWlpICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpaWkgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaWlpaSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCA1ICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgfCAgOTAgfCBlICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZW8gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWUgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlZSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZWVlICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWVlZWUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoc3RhbmQtYWxvbmUpIHwgIDkwIHwgYyAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjYyAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjY2MgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2NjYyAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjY2NjICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICB8ICA4MCB8IGEuLmFhYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYWFhYWEgICB8IGEsIHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICB8ICA4MCB8IGIuLmJiYiAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBiYmJiICAgIHwgYS5tLiwgcC5tLiwgbm9vbiwgbWlkbmlnaHQgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYmJiYmIgICB8IGEsIHAsIG4sIG1pICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgICB8ICA4MCB8IEIuLkJCQiAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBCQkJCICAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgQkJCQkIgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgICB8ICA3MCB8IGggICAgICAgfCAxLCAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBobyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTF0aCwgMTJ0aCAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaGggICAgICB8IDAxLCAwMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgICB8ICA3MCB8IEggICAgICAgfCAwLCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBIbyAgICAgIHwgMHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSEggICAgICB8IDAwLCAwMSwgMDIsIC4uLiwgMjMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgICB8ICA3MCB8IEsgICAgICAgfCAxLCAyLCAuLi4sIDExLCAwICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBLbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTF0aCwgMHRoICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgS0sgICAgICB8IDAxLCAwMiwgLi4uLCAxMSwgMDAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgICB8ICA3MCB8IGsgICAgICAgfCAyNCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBrbyAgICAgIHwgMjR0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwga2sgICAgICB8IDI0LCAwMSwgMDIsIC4uLiwgMjMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgICB8ICA2MCB8IG0gICAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBtbyAgICAgIHwgMHRoLCAxc3QsIC4uLiwgNTl0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgbW0gICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgICB8ICA1MCB8IHMgICAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBzbyAgICAgIHwgMHRoLCAxc3QsIC4uLiwgNTl0aCAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgc3MgICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgICB8ICA0MCB8IHQgICAgICAgfCA1MTI5Njk1MjAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB0dCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgIHwgIDMwIHwgUyAgICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFNTICAgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBTU1MgICAgIHwgMDAwLCAwMDEsIC4uLiwgOTk5ICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgU1NTUyAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8ICAyMCB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBUVCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy8gWikgICAgICAgIHwgIDEwIHwgWCAgICAgICB8IC0wOCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYICAgICAgfCAtMDgwMCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWFggICAgIHwgLTA4OjAwLCArMDU6MzAsIFogICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFhYWCAgICB8IC0wODAwLCArMDUzMCwgWiwgKzEyMzQ1NiAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYWFhYICAgfCAtMDg6MDAsICswNTozMCwgWiwgKzEyOjM0OjU2ICAgICAgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICAgfCAgMTAgfCB4ICAgICAgIHwgLTA4LCArMDUzMCwgKzAwICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHggICAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4eCAgICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eHh4ICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCwgKzEyMzQ1NiAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHh4eHggICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAsICsxMjozNDo1NiB8ICAgICAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgICB8ICBOQSB8IFAgICAgICAgfCAwNS8yOS8xNDUzICAgICAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUCAgICAgIHwgTWF5IDI5LCAxNDUzICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBQICAgICB8IE1heSAyOXRoLCAxNDUzICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQUFAgICAgfCBTdW5kYXksIE1heSAyOXRoLCAxNDUzICAgICAgICAgICAgfCAyLDUsOCB8XG4gKiB8IExvbmcgbG9jYWxpemVkIHRpbWUgICAgICAgICAgICAgfCAgTkEgfCBwICAgICAgIHwgMTI6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgNSw4ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcHAgICAgICB8IDEyOjAwOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQ29tYmluYXRpb24gb2YgZGF0ZSBhbmQgdGltZSAgICB8ICBOQSB8IFBwICAgICAgfCAwNS8yOS8xNDUzLCAxMjowMCBBTSAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUHBwICAgIHwgTWF5IDI5LCAxNDUzLCAxMjowMDowMCBBTSAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBQcHAgICB8IE1heSAyOXRoLCAxNDUzIGF0IC4uLiAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQUFBwcCAgfCBTdW5kYXksIE1heSAyOXRoLCAxNDUzIGF0IC4uLiAgICAgfCAyLDUsOCB8XG4gKiBOb3RlczpcbiAqIDEuIFwiRm9ybWF0dGluZ1wiIHVuaXRzIChlLmcuIGZvcm1hdHRpbmcgcXVhcnRlcikgaW4gdGhlIGRlZmF1bHQgZW4tVVMgbG9jYWxlXG4gKiAgICBhcmUgdGhlIHNhbWUgYXMgXCJzdGFuZC1hbG9uZVwiIHVuaXRzLCBidXQgYXJlIGRpZmZlcmVudCBpbiBzb21lIGxhbmd1YWdlcy5cbiAqICAgIFwiRm9ybWF0dGluZ1wiIHVuaXRzIGFyZSBkZWNsaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIG9mIHRoZSBsYW5ndWFnZVxuICogICAgaW4gdGhlIGNvbnRleHQgb2YgYSBkYXRlLiBcIlN0YW5kLWFsb25lXCIgdW5pdHMgYXJlIGFsd2F5cyBub21pbmF0aXZlIHNpbmd1bGFyLlxuICogICAgSW4gYGZvcm1hdGAgZnVuY3Rpb24sIHRoZXkgd2lsbCBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHQ6XG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBMTExMJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZCdgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBNTU1NJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZHUnYFxuICpcbiAqICAgIGBwYXJzZWAgd2lsbCB0cnkgdG8gbWF0Y2ggYm90aCBmb3JtYXR0aW5nIGFuZCBzdGFuZC1hbG9uZSB1bml0cyBpbnRlcmNoYW5nYWJseS5cbiAqXG4gKiAyLiBBbnkgc2VxdWVuY2Ugb2YgdGhlIGlkZW50aWNhbCBsZXR0ZXJzIGlzIGEgcGF0dGVybiwgdW5sZXNzIGl0IGlzIGVzY2FwZWQgYnlcbiAqICAgIHRoZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyAoc2VlIGJlbG93KS5cbiAqICAgIElmIHRoZSBzZXF1ZW5jZSBpcyBsb25nZXIgdGhhbiBsaXN0ZWQgaW4gdGFibGU6XG4gKiAgICAtIGZvciBudW1lcmljYWwgdW5pdHMgKGB5eXl5eXl5eWApIGBwYXJzZWAgd2lsbCB0cnkgdG8gbWF0Y2ggYSBudW1iZXJcbiAqICAgICAgYXMgd2lkZSBhcyB0aGUgc2VxdWVuY2VcbiAqICAgIC0gZm9yIHRleHQgdW5pdHMgKGBNTU1NTU1NTWApIGBwYXJzZWAgd2lsbCB0cnkgdG8gbWF0Y2ggdGhlIHdpZGVzdCB2YXJpYXRpb24gb2YgdGhlIHVuaXQuXG4gKiAgICAgIFRoZXNlIHZhcmlhdGlvbnMgYXJlIG1hcmtlZCB3aXRoIFwiMlwiIGluIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgdGFibGUuXG4gKlxuICogMy4gYFFRUVFRYCBhbmQgYHFxcXFxYCBjb3VsZCBiZSBub3Qgc3RyaWN0bHkgbnVtZXJpY2FsIGluIHNvbWUgbG9jYWxlcy5cbiAqICAgIFRoZXNlIHRva2VucyByZXByZXNlbnQgdGhlIHNob3J0ZXN0IGZvcm0gb2YgdGhlIHF1YXJ0ZXIuXG4gKlxuICogNC4gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIHBhdHRlcm5zIGFyZSBCLkMuIHllYXJzOlxuICpcbiAqICAgIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gKiAgICB8LS0tLS0tfC0tLS0tfC0tLS0tfFxuICogICAgfCBBQyAxIHwgICAxIHwgICAxIHxcbiAqICAgIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gKiAgICB8IEJDIDIgfCAgIDIgfCAgLTEgfFxuICpcbiAqICAgIEFsc28gYHl5YCB3aWxsIHRyeSB0byBndWVzcyB0aGUgY2VudHVyeSBvZiB0d28gZGlnaXQgeWVhciBieSBwcm94aW1pdHkgd2l0aCBgcmVmZXJlbmNlRGF0ZWA6XG4gKlxuICogICAgYHBhcnNlKCc1MCcsICd5eScsIG5ldyBEYXRlKDIwMTgsIDAsIDEpKSAvLz0+IFNhdCBKYW4gMDEgMjA1MCAwMDowMDowMGBcbiAqXG4gKiAgICBgcGFyc2UoJzc1JywgJ3l5JywgbmV3IERhdGUoMjAxOCwgMCwgMSkpIC8vPT4gV2VkIEphbiAwMSAxOTc1IDAwOjAwOjAwYFxuICpcbiAqICAgIHdoaWxlIGB1dWAgd2lsbCBqdXN0IGFzc2lnbiB0aGUgeWVhciBhcyBpczpcbiAqXG4gKiAgICBgcGFyc2UoJzUwJywgJ3V1JywgbmV3IERhdGUoMjAxOCwgMCwgMSkpIC8vPT4gU2F0IEphbiAwMSAwMDUwIDAwOjAwOjAwYFxuICpcbiAqICAgIGBwYXJzZSgnNzUnLCAndXUnLCBuZXcgRGF0ZSgyMDE4LCAwLCAxKSkgLy89PiBUdWUgSmFuIDAxIDAwNzUgMDA6MDA6MDBgXG4gKlxuICogICAgVGhlIHNhbWUgZGlmZmVyZW5jZSBpcyB0cnVlIGZvciBsb2NhbCBhbmQgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJzIChgWWAgYW5kIGBSYCksXG4gKiAgICBleGNlcHQgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhcnMgYXJlIGRlcGVuZGVudCBvbiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gXG4gKiAgICBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAoY29tcGFyZSBbc2V0SVNPV2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3Mvc2V0SVNPV2Vla1llYXJ9XG4gKiAgICBhbmQgW3NldFdlZWtZZWFyXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3NldFdlZWtZZWFyfSkuXG4gKlxuICogNS4gVGhlc2UgcGF0dGVybnMgYXJlIG5vdCBpbiB0aGUgVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogICAgLSBgaWA6IElTTyBkYXkgb2Ygd2Vla1xuICogICAgLSBgSWA6IElTTyB3ZWVrIG9mIHllYXJcbiAqICAgIC0gYFJgOiBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICogICAgLSBgb2A6IG9yZGluYWwgbnVtYmVyIG1vZGlmaWVyXG4gKiAgICAtIGBQYDogbG9uZyBsb2NhbGl6ZWQgZGF0ZVxuICogICAgLSBgcGA6IGxvbmcgbG9jYWxpemVkIHRpbWVcbiAqXG4gKiA2LiBgWVlgIGFuZCBgWVlZWWAgdG9rZW5zIHJlcHJlc2VudCB3ZWVrLW51bWJlcmluZyB5ZWFycyBidXQgdGhleSBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCB5ZWFycy5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiA3LiBgRGAgYW5kIGBERGAgdG9rZW5zIHJlcHJlc2VudCBkYXlzIG9mIHRoZSB5ZWFyIGJ1dCB0aGV5IGFyZSBvZnRoZW4gY29uZnVzZWQgd2l0aCBkYXlzIG9mIHRoZSBtb250aC5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogOC4gYFArYCB0b2tlbnMgZG8gbm90IGhhdmUgYSBkZWZpbmVkIHByaW9yaXR5IHNpbmNlIHRoZXkgYXJlIG1lcmVseSBhbGlhc2VzIHRvIG90aGVyIHRva2VucyBiYXNlZFxuICogICAgb24gdGhlIGdpdmVuIGxvY2FsZS5cbiAqXG4gKiAgICB1c2luZyBgZW4tVVNgIGxvY2FsZTogYFBgID0+IGBNTS9kZC95eXl5YFxuICogICAgdXNpbmcgYGVuLVVTYCBsb2NhbGU6IGBwYCA9PiBgaGg6bW0gYWBcbiAqICAgIHVzaW5nIGBwdC1CUmAgbG9jYWxlOiBgUGAgPT4gYGRkL01NL3l5eXlgXG4gKiAgICB1c2luZyBgcHQtQlJgIGxvY2FsZTogYHBgID0+IGBISDptbWBcbiAqXG4gKiBWYWx1ZXMgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgZGF0ZSBpbiB0aGUgZGVzY2VuZGluZyBvcmRlciBvZiBpdHMgdW5pdCdzIHByaW9yaXR5LlxuICogVW5pdHMgb2YgYW4gZXF1YWwgcHJpb3JpdHkgb3ZlcndyaXRlIGVhY2ggb3RoZXIgaW4gdGhlIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gKlxuICogSWYgbm8gdmFsdWVzIG9mIGhpZ2hlciBwcmlvcml0eSBhcmUgcGFyc2VkIChlLmcuIHdoZW4gcGFyc2luZyBzdHJpbmcgJ0phbnVhcnkgMXN0JyB3aXRob3V0IGEgeWVhciksXG4gKiB0aGUgdmFsdWVzIHdpbGwgYmUgdGFrZW4gZnJvbSAzcmQgYXJndW1lbnQgYHJlZmVyZW5jZURhdGVgIHdoaWNoIHdvcmtzIGFzIGEgY29udGV4dCBvZiBwYXJzaW5nLlxuICpcbiAqIGByZWZlcmVuY2VEYXRlYCBtdXN0IGJlIHBhc3NlZCBmb3IgY29ycmVjdCB3b3JrIG9mIHRoZSBmdW5jdGlvbi5cbiAqIElmIHlvdSdyZSBub3Qgc3VyZSB3aGljaCBgcmVmZXJlbmNlRGF0ZWAgdG8gc3VwcGx5LCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRGF0ZTpcbiAqIGBwYXJzZSgnMDIvMTEvMjAxNCcsICdNTS9kZC95eXl5JywgbmV3IERhdGUoKSlgXG4gKiBJbiB0aGlzIGNhc2UgcGFyc2luZyB3aWxsIGJlIGRvbmUgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgZGF0ZS5cbiAqIElmIGByZWZlcmVuY2VEYXRlYCBpcyBgSW52YWxpZCBEYXRlYCBvciBhIHZhbHVlIG5vdCBjb252ZXJ0aWJsZSB0byB2YWxpZCBgRGF0ZWAsXG4gKiB0aGVuIGBJbnZhbGlkIERhdGVgIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogVGhlIHJlc3VsdCBtYXkgdmFyeSBieSBsb2NhbGUuXG4gKlxuICogSWYgYGZvcm1hdFN0cmluZ2AgbWF0Y2hlcyB3aXRoIGBkYXRlU3RyaW5nYCBidXQgZG9lcyBub3QgcHJvdmlkZXMgdG9rZW5zLCBgcmVmZXJlbmNlRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBJZiBwYXJzaW5nIGZhaWxlZCwgYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEludmFsaWQgRGF0ZSBpcyBhIERhdGUsIHdob3NlIHRpbWUgdmFsdWUgaXMgTmFOLlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIE9sZCBgcGFyc2VgIHdhcyByZW5hbWVkIHRvIGB0b0RhdGVgLlxuICogICBOb3cgYHBhcnNlYCBpcyBhIG5ldyBmdW5jdGlvbiB3aGljaCBwYXJzZXMgYSBzdHJpbmcgdXNpbmcgYSBwcm92aWRlZCBmb3JtYXQuXG4gKlxuICogICBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIEJlZm9yZSB2Mi4wLjBcbiAqICAgcGFyc2UoJzIwMTYtMDEtMDEnKVxuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZCAodG9EYXRlIG5vIGxvbmdlciBhY2NlcHRzIGEgc3RyaW5nKVxuICogICB0b0RhdGUoMTM5MjA5ODQzMDAwMCkgLy8gVW5peCB0byB0aW1lc3RhbXBcbiAqICAgdG9EYXRlKG5ldyBEYXRlKDIwMTQsIDEsIDExLCAxMSwgMzAsIDMwKSkgLy8gQ2xvbmluZyB0aGUgZGF0ZVxuICogICBwYXJzZSgnMjAxNi0wMS0wMScsICd5eXl5LU1NLWRkJywgbmV3IERhdGUoKSlcbiAqICAgYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGVTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0U3RyaW5nIC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IHJlZmVyZW5jZURhdGUgLSBkZWZpbmVzIHZhbHVlcyBtaXNzaW5nIGZyb20gdGhlIHBhcnNlZCBkYXRlU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqIEBwYXJhbSB7TG9jYWxlfSBbb3B0aW9ucy5sb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSB0aGUgbG9jYWxlIG9iamVjdC4gU2VlIFtMb2NhbGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvTG9jYWxlfVxuICogQHBhcmFtIHswfDF8MnwzfDR8NXw2fSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcbiAqIEBwYXJhbSB7MXwyfDN8NHw1fDZ8N30gW29wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlPTFdIC0gdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zPWZhbHNlXSAtIGlmIHRydWUsIGFsbG93cyB1c2FnZSBvZiB0aGUgd2Vlay1udW1iZXJpbmcgeWVhciB0b2tlbnMgYFlZYCBhbmQgYFlZWVlgO1xuICogICBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM9ZmFsc2VdIC0gaWYgdHJ1ZSwgYWxsb3dzIHVzYWdlIG9mIHRoZSBkYXkgb2YgeWVhciB0b2tlbnMgYERgIGFuZCBgRERgO1xuICogICBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDMgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA3XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgbWF0Y2hgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYHl5eXlgIGluc3RlYWQgb2YgYFlZWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYHl5YCBpbnN0ZWFkIG9mIGBZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnMgdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgZGAgaW5zdGVhZCBvZiBgRGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGggdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgZGRgIGluc3RlYWQgb2YgYEREYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aCB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gZm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFBhcnNlIDExIEZlYnJ1YXJ5IDIwMTQgZnJvbSBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcbiAqIHZhciByZXN1bHQgPSBwYXJzZSgnMDIvMTEvMjAxNCcsICdNTS9kZC95eXl5JywgbmV3IERhdGUoKSlcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFBhcnNlIDI4dGggb2YgRmVicnVhcnkgaW4gRXNwZXJhbnRvIGxvY2FsZSBpbiB0aGUgY29udGV4dCBvZiAyMDEwIHllYXI6XG4gKiBpbXBvcnQgZW8gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogdmFyIHJlc3VsdCA9IHBhcnNlKCcyOC1hIGRlIGZlYnJ1YXJvJywgXCJkbyAnZGUnIE1NTU1cIiwgbmV3IERhdGUoMjAxMCwgMCwgMSksIHtcbiAqICAgbG9jYWxlOiBlb1xuICogfSlcbiAqIC8vPT4gU3VuIEZlYiAyOCAyMDEwIDAwOjAwOjAwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2UoZGlydHlEYXRlU3RyaW5nLCBkaXJ0eUZvcm1hdFN0cmluZywgZGlydHlSZWZlcmVuY2VEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgcmVxdWlyZWRBcmdzKDMsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlU3RyaW5nID0gU3RyaW5nKGRpcnR5RGF0ZVN0cmluZyk7XG4gIHZhciBmb3JtYXRTdHJpbmcgPSBTdHJpbmcoZGlydHlGb3JtYXRTdHJpbmcpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlIHx8IGRlZmF1bHRMb2NhbGU7XG5cbiAgaWYgKCFsb2NhbGUubWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBtYXRjaCBwcm9wZXJ0eScpO1xuICB9XG5cbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IDEgOiB0b0ludGVnZXIobG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlIDogdG9JbnRlZ2VyKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAxIGFuZCA3IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoIShmaXJzdFdlZWtDb250YWluc0RhdGUgPj0gMSAmJiBmaXJzdFdlZWtDb250YWluc0RhdGUgPD0gNykpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZmlyc3RXZWVrQ29udGFpbnNEYXRlIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA3IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgbG9jYWxlV2Vla1N0YXJ0c09uID0gbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT0gbnVsbCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiB0b0ludGVnZXIob3B0aW9ucy53ZWVrU3RhcnRzT24pOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIGlmIChmb3JtYXRTdHJpbmcgPT09ICcnKSB7XG4gICAgaWYgKGRhdGVTdHJpbmcgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdG9EYXRlKGRpcnR5UmVmZXJlbmNlRGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdWJGbk9wdGlvbnMgPSB7XG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiBmaXJzdFdlZWtDb250YWluc0RhdGUsXG4gICAgd2Vla1N0YXJ0c09uOiB3ZWVrU3RhcnRzT24sXG4gICAgbG9jYWxlOiBsb2NhbGVcbiAgfTsgLy8gSWYgdGltZXpvbmUgaXNuJ3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgc3lzdGVtIHRpbWV6b25lXG5cbiAgdmFyIHNldHRlcnMgPSBbe1xuICAgIHByaW9yaXR5OiBUSU1FWk9ORV9VTklUX1BSSU9SSVRZLFxuICAgIHN1YlByaW9yaXR5OiAtMSxcbiAgICBzZXQ6IGRhdGVUb1N5c3RlbVRpbWV6b25lLFxuICAgIGluZGV4OiAwXG4gIH1dO1xuICB2YXIgaTtcbiAgdmFyIHRva2VucyA9IGZvcm1hdFN0cmluZy5tYXRjaChsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCkubWFwKGZ1bmN0aW9uIChzdWJzdHJpbmcpIHtcbiAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XG5cbiAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09ICdwJyB8fCBmaXJzdENoYXJhY3RlciA9PT0gJ1AnKSB7XG4gICAgICB2YXIgbG9uZ0Zvcm1hdHRlciA9IGxvbmdGb3JtYXR0ZXJzW2ZpcnN0Q2hhcmFjdGVyXTtcbiAgICAgIHJldHVybiBsb25nRm9ybWF0dGVyKHN1YnN0cmluZywgbG9jYWxlLmZvcm1hdExvbmcsIHN1YkZuT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnN0cmluZztcbiAgfSkuam9pbignJykubWF0Y2goZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCk7XG4gIHZhciB1c2VkVG9rZW5zID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICghb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMgJiYgaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKHRva2VuKSkge1xuICAgICAgdGhyb3dQcm90ZWN0ZWRFcnJvcih0b2tlbiwgZm9ybWF0U3RyaW5nLCBkaXJ0eURhdGVTdHJpbmcpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zICYmIGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4odG9rZW4pKSB7XG4gICAgICB0aHJvd1Byb3RlY3RlZEVycm9yKHRva2VuLCBmb3JtYXRTdHJpbmcsIGRpcnR5RGF0ZVN0cmluZyk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0Q2hhcmFjdGVyID0gdG9rZW5bMF07XG4gICAgdmFyIHBhcnNlciA9IHBhcnNlcnNbZmlyc3RDaGFyYWN0ZXJdO1xuXG4gICAgaWYgKHBhcnNlcikge1xuICAgICAgdmFyIGluY29tcGF0aWJsZVRva2VucyA9IHBhcnNlci5pbmNvbXBhdGlibGVUb2tlbnM7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGluY29tcGF0aWJsZVRva2VucykpIHtcbiAgICAgICAgdmFyIGluY29tcGF0aWJsZVRva2VuID0gdm9pZCAwO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1c2VkVG9rZW5zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciB1c2VkVG9rZW4gPSB1c2VkVG9rZW5zW19pXS50b2tlbjtcblxuICAgICAgICAgIGlmIChpbmNvbXBhdGlibGVUb2tlbnMuaW5kZXhPZih1c2VkVG9rZW4pICE9PSAtMSB8fCB1c2VkVG9rZW4gPT09IGZpcnN0Q2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBpbmNvbXBhdGlibGVUb2tlbiA9IHVzZWRUb2tlbnNbX2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluY29tcGF0aWJsZVRva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgZm9ybWF0IHN0cmluZyBtdXN0bid0IGNvbnRhaW4gYFwiLmNvbmNhdChpbmNvbXBhdGlibGVUb2tlbi5mdWxsVG9rZW4sIFwiYCBhbmQgYFwiKS5jb25jYXQodG9rZW4sIFwiYCBhdCB0aGUgc2FtZSB0aW1lXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZXIuaW5jb21wYXRpYmxlVG9rZW5zID09PSAnKicgJiYgdXNlZFRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgZm9ybWF0IHN0cmluZyBtdXN0bid0IGNvbnRhaW4gYFwiLmNvbmNhdCh0b2tlbiwgXCJgIGFuZCBhbnkgb3RoZXIgdG9rZW4gYXQgdGhlIHNhbWUgdGltZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHVzZWRUb2tlbnMucHVzaCh7XG4gICAgICAgIHRva2VuOiBmaXJzdENoYXJhY3RlcixcbiAgICAgICAgZnVsbFRva2VuOiB0b2tlblxuICAgICAgfSk7XG4gICAgICB2YXIgcGFyc2VSZXN1bHQgPSBwYXJzZXIucGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIGxvY2FsZS5tYXRjaCwgc3ViRm5PcHRpb25zKTtcblxuICAgICAgaWYgKCFwYXJzZVJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICAgIH1cblxuICAgICAgc2V0dGVycy5wdXNoKHtcbiAgICAgICAgcHJpb3JpdHk6IHBhcnNlci5wcmlvcml0eSxcbiAgICAgICAgc3ViUHJpb3JpdHk6IHBhcnNlci5zdWJQcmlvcml0eSB8fCAwLFxuICAgICAgICBzZXQ6IHBhcnNlci5zZXQsXG4gICAgICAgIHZhbGlkYXRlOiBwYXJzZXIudmFsaWRhdGUsXG4gICAgICAgIHZhbHVlOiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgaW5kZXg6IHNldHRlcnMubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGRhdGVTdHJpbmcgPSBwYXJzZVJlc3VsdC5yZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIubWF0Y2godW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHApKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdGb3JtYXQgc3RyaW5nIGNvbnRhaW5zIGFuIHVuZXNjYXBlZCBsYXRpbiBhbHBoYWJldCBjaGFyYWN0ZXIgYCcgKyBmaXJzdENoYXJhY3RlciArICdgJyk7XG4gICAgICB9IC8vIFJlcGxhY2UgdHdvIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIHdpdGggb25lIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJcblxuXG4gICAgICBpZiAodG9rZW4gPT09IFwiJydcIikge1xuICAgICAgICB0b2tlbiA9IFwiJ1wiO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCInXCIpIHtcbiAgICAgICAgdG9rZW4gPSBjbGVhbkVzY2FwZWRTdHJpbmcodG9rZW4pO1xuICAgICAgfSAvLyBDdXQgdG9rZW4gZnJvbSBzdHJpbmcsIG9yLCBpZiBzdHJpbmcgZG9lc24ndCBtYXRjaCB0aGUgdG9rZW4sIHJldHVybiBJbnZhbGlkIERhdGVcblxuXG4gICAgICBpZiAoZGF0ZVN0cmluZy5pbmRleE9mKHRva2VuKSA9PT0gMCkge1xuICAgICAgICBkYXRlU3RyaW5nID0gZGF0ZVN0cmluZy5zbGljZSh0b2tlbi5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoZWNrIGlmIHRoZSByZW1haW5pbmcgaW5wdXQgY29udGFpbnMgc29tZXRoaW5nIG90aGVyIHRoYW4gd2hpdGVzcGFjZVxuXG5cbiAgaWYgKGRhdGVTdHJpbmcubGVuZ3RoID4gMCAmJiBub3RXaGl0ZXNwYWNlUmVnRXhwLnRlc3QoZGF0ZVN0cmluZykpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxuXG4gIHZhciB1bmlxdWVQcmlvcml0eVNldHRlcnMgPSBzZXR0ZXJzLm1hcChmdW5jdGlvbiAoc2V0dGVyKSB7XG4gICAgcmV0dXJuIHNldHRlci5wcmlvcml0eTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiIC0gYTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChwcmlvcml0eSwgaW5kZXgsIGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YocHJpb3JpdHkpID09PSBpbmRleDtcbiAgfSkubWFwKGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgIHJldHVybiBzZXR0ZXJzLmZpbHRlcihmdW5jdGlvbiAoc2V0dGVyKSB7XG4gICAgICByZXR1cm4gc2V0dGVyLnByaW9yaXR5ID09PSBwcmlvcml0eTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5zdWJQcmlvcml0eSAtIGEuc3ViUHJpb3JpdHk7XG4gICAgfSk7XG4gIH0pLm1hcChmdW5jdGlvbiAoc2V0dGVyQXJyYXkpIHtcbiAgICByZXR1cm4gc2V0dGVyQXJyYXlbMF07XG4gIH0pO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eVJlZmVyZW5jZURhdGUpO1xuXG4gIGlmIChpc05hTihkYXRlKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9IC8vIENvbnZlcnQgdGhlIGRhdGUgaW4gc3lzdGVtIHRpbWV6b25lIHRvIHRoZSBzYW1lIGRhdGUgaW4gVVRDKzAwOjAwIHRpbWV6b25lLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIFVUQyBmdW5jdGlvbnMgd2lsbCBiZSBpbXBsZW1lbnRlZCwgbG9jYWxlcyB3aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVtLlxuICAvLyBTZWUgYW4gaXNzdWUgYWJvdXQgVVRDIGZ1bmN0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zN1xuXG5cbiAgdmFyIHV0Y0RhdGUgPSBzdWJNaWxsaXNlY29uZHMoZGF0ZSwgZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhkYXRlKSk7XG4gIHZhciBmbGFncyA9IHt9O1xuXG4gIGZvciAoaSA9IDA7IGkgPCB1bmlxdWVQcmlvcml0eVNldHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2V0dGVyID0gdW5pcXVlUHJpb3JpdHlTZXR0ZXJzW2ldO1xuXG4gICAgaWYgKHNldHRlci52YWxpZGF0ZSAmJiAhc2V0dGVyLnZhbGlkYXRlKHV0Y0RhdGUsIHNldHRlci52YWx1ZSwgc3ViRm5PcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHNldHRlci5zZXQodXRjRGF0ZSwgZmxhZ3MsIHNldHRlci52YWx1ZSwgc3ViRm5PcHRpb25zKTsgLy8gUmVzdWx0IGlzIHR1cGxlIChkYXRlLCBmbGFncylcblxuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgIHV0Y0RhdGUgPSByZXN1bHRbMF07XG4gICAgICBhc3NpZ24oZmxhZ3MsIHJlc3VsdFsxXSk7IC8vIFJlc3VsdCBpcyBkYXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0Y0RhdGUgPSByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHV0Y0RhdGU7XG59XG5cbmZ1bmN0aW9uIGRhdGVUb1N5c3RlbVRpbWV6b25lKGRhdGUsIGZsYWdzKSB7XG4gIGlmIChmbGFncy50aW1lc3RhbXBJc1NldCkge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlZERhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgY29udmVydGVkRGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICBjb252ZXJ0ZWREYXRlLnNldEhvdXJzKGRhdGUuZ2V0VVRDSG91cnMoKSwgZGF0ZS5nZXRVVENNaW51dGVzKCksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLCBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpKTtcbiAgcmV0dXJuIGNvbnZlcnRlZERhdGU7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cClbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCwgXCInXCIpO1xufSIsImltcG9ydCB7IG1pbGxpc2Vjb25kc0luSG91ciwgbWlsbGlzZWNvbmRzSW5NaW51dGUgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgcGFyc2VJU09cbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2UgSVNPIHN0cmluZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQgYW5kIHJldHVybiBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEZ1bmN0aW9uIGFjY2VwdHMgY29tcGxldGUgSVNPIDg2MDEgZm9ybWF0cyBhcyB3ZWxsIGFzIHBhcnRpYWwgaW1wbGVtZW50YXRpb25zLlxuICogSVNPIDg2MDE6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDFcbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXNuJ3QgYSBzdHJpbmcsIHRoZSBmdW5jdGlvbiBjYW5ub3QgcGFyc2UgdGhlIHN0cmluZyBvclxuICogdGhlIHZhbHVlcyBhcmUgaW52YWxpZCwgaXQgcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIFRoZSBwcmV2aW91cyBgcGFyc2VgIGltcGxlbWVudGF0aW9uIHdhcyByZW5hbWVkIHRvIGBwYXJzZUlTT2AuXG4gKlxuICogICBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIEJlZm9yZSB2Mi4wLjBcbiAqICAgcGFyc2UoJzIwMTYtMDEtMDEnKVxuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZFxuICogICBwYXJzZUlTTygnMjAxNi0wMS0wMScpXG4gKiAgIGBgYFxuICpcbiAqIC0gYHBhcnNlSVNPYCBub3cgdmFsaWRhdGVzIHNlcGFyYXRlIGRhdGUgYW5kIHRpbWUgdmFsdWVzIGluIElTTy04NjAxIHN0cmluZ3NcbiAqICAgYW5kIHJldHVybnMgYEludmFsaWQgRGF0ZWAgaWYgdGhlIGRhdGUgaXMgaW52YWxpZC5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgcGFyc2VJU08oJzIwMTgtMTMtMzInKVxuICogICAvLz0+IEludmFsaWQgRGF0ZVxuICogICBgYGBcbiAqXG4gKiAtIGBwYXJzZUlTT2Agbm93IGRvZXNuJ3QgZmFsbCBiYWNrIHRvIGBuZXcgRGF0ZWAgY29uc3RydWN0b3JcbiAqICAgaWYgaXQgZmFpbHMgdG8gcGFyc2UgYSBzdHJpbmcgYXJndW1lbnQuIEluc3RlYWQsIGl0IHJldHVybnMgYEludmFsaWQgRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ3VtZW50IC0gdGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJzIwMTQtMDItMTFUMTE6MzA6MzAnIHRvIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBwYXJzZUlTTygnMjAxNC0wMi0xMVQxMTozMDozMCcpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnKzAyMDE0MTAxJyB0byBkYXRlLFxuICogLy8gaWYgdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXQgaXMgMTpcbiAqIGNvbnN0IHJlc3VsdCA9IHBhcnNlSVNPKCcrMDIwMTQxMDEnLCB7IGFkZGl0aW9uYWxEaWdpdHM6IDEgfSlcbiAqIC8vPT4gRnJpIEFwciAxMSAyMDE0IDAwOjAwOjAwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VJU08oYXJndW1lbnQsIGRpcnR5T3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09IG51bGwgPyAyIDogdG9JbnRlZ2VyKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyk7XG5cbiAgaWYgKGFkZGl0aW9uYWxEaWdpdHMgIT09IDIgJiYgYWRkaXRpb25hbERpZ2l0cyAhPT0gMSAmJiBhZGRpdGlvbmFsRGlnaXRzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2FkZGl0aW9uYWxEaWdpdHMgbXVzdCBiZSAwLCAxIG9yIDInKTtcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICB2YXIgZGF0ZVN0cmluZ3MgPSBzcGxpdERhdGVTdHJpbmcoYXJndW1lbnQpO1xuICB2YXIgZGF0ZTtcblxuICBpZiAoZGF0ZVN0cmluZ3MuZGF0ZSkge1xuICAgIHZhciBwYXJzZVllYXJSZXN1bHQgPSBwYXJzZVllYXIoZGF0ZVN0cmluZ3MuZGF0ZSwgYWRkaXRpb25hbERpZ2l0cyk7XG4gICAgZGF0ZSA9IHBhcnNlRGF0ZShwYXJzZVllYXJSZXN1bHQucmVzdERhdGVTdHJpbmcsIHBhcnNlWWVhclJlc3VsdC55ZWFyKTtcbiAgfVxuXG4gIGlmICghZGF0ZSB8fCBpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxuXG4gIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgdmFyIHRpbWUgPSAwO1xuICB2YXIgb2Zmc2V0O1xuXG4gIGlmIChkYXRlU3RyaW5ncy50aW1lKSB7XG4gICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKTtcblxuICAgIGlmIChpc05hTih0aW1lKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGVTdHJpbmdzLnRpbWV6b25lKSB7XG4gICAgb2Zmc2V0ID0gcGFyc2VUaW1lem9uZShkYXRlU3RyaW5ncy50aW1lem9uZSk7XG5cbiAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXJ0eURhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lKTsgLy8ganMgcGFyc2VkIHN0cmluZyBhc3N1bWluZyBpdCdzIGluIFVUQyB0aW1lem9uZVxuICAgIC8vIGJ1dCB3ZSBuZWVkIGl0IHRvIGJlIHBhcnNlZCBpbiBvdXIgdGltZXpvbmVcbiAgICAvLyBzbyB3ZSB1c2UgdXRjIHZhbHVlcyB0byBidWlsZCBkYXRlIGluIG91ciB0aW1lem9uZS5cbiAgICAvLyBZZWFyIHZhbHVlcyBmcm9tIDAgdG8gOTkgbWFwIHRvIHRoZSB5ZWFycyAxOTAwIHRvIDE5OTlcbiAgICAvLyBzbyBzZXQgeWVhciBleHBsaWNpdGx5IHdpdGggc2V0RnVsbFllYXIuXG5cbiAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoMCk7XG4gICAgcmVzdWx0LnNldEZ1bGxZZWFyKGRpcnR5RGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkaXJ0eURhdGUuZ2V0VVRDTW9udGgoKSwgZGlydHlEYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgcmVzdWx0LnNldEhvdXJzKGRpcnR5RGF0ZS5nZXRVVENIb3VycygpLCBkaXJ0eURhdGUuZ2V0VVRDTWludXRlcygpLCBkaXJ0eURhdGUuZ2V0VVRDU2Vjb25kcygpLCBkaXJ0eURhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSArIG9mZnNldCk7XG59XG52YXIgcGF0dGVybnMgPSB7XG4gIGRhdGVUaW1lRGVsaW1pdGVyOiAvW1QgXS8sXG4gIHRpbWVab25lRGVsaW1pdGVyOiAvW1ogXS9pLFxuICB0aW1lem9uZTogLyhbWistXS4qKSQvXG59O1xudmFyIGRhdGVSZWdleCA9IC9eLT8oPzooXFxkezN9KXwoXFxkezJ9KSg/Oi0/KFxcZHsyfSkpP3xXKFxcZHsyfSkoPzotPyhcXGR7MX0pKT98KSQvO1xudmFyIHRpbWVSZWdleCA9IC9eKFxcZHsyfSg/OlsuLF1cXGQqKT8pKD86Oj8oXFxkezJ9KD86Wy4sXVxcZCopPykpPyg/Ojo/KFxcZHsyfSg/OlsuLF1cXGQqKT8pKT8kLztcbnZhciB0aW1lem9uZVJlZ2V4ID0gL14oWystXSkoXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyQvO1xuXG5mdW5jdGlvbiBzcGxpdERhdGVTdHJpbmcoZGF0ZVN0cmluZykge1xuICB2YXIgZGF0ZVN0cmluZ3MgPSB7fTtcbiAgdmFyIGFycmF5ID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy5kYXRlVGltZURlbGltaXRlcik7XG4gIHZhciB0aW1lU3RyaW5nOyAvLyBUaGUgcmVnZXggbWF0Y2ggc2hvdWxkIG9ubHkgcmV0dXJuIGF0IG1heGltdW0gdHdvIGFycmF5IGVsZW1lbnRzLlxuICAvLyBbZGF0ZV0sIFt0aW1lXSwgb3IgW2RhdGUsIHRpbWVdLlxuXG4gIGlmIChhcnJheS5sZW5ndGggPiAyKSB7XG4gICAgcmV0dXJuIGRhdGVTdHJpbmdzO1xuICB9XG5cbiAgaWYgKC86Ly50ZXN0KGFycmF5WzBdKSkge1xuICAgIHRpbWVTdHJpbmcgPSBhcnJheVswXTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gYXJyYXlbMF07XG4gICAgdGltZVN0cmluZyA9IGFycmF5WzFdO1xuXG4gICAgaWYgKHBhdHRlcm5zLnRpbWVab25lRGVsaW1pdGVyLnRlc3QoZGF0ZVN0cmluZ3MuZGF0ZSkpIHtcbiAgICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLnRpbWVab25lRGVsaW1pdGVyKVswXTtcbiAgICAgIHRpbWVTdHJpbmcgPSBkYXRlU3RyaW5nLnN1YnN0cihkYXRlU3RyaW5ncy5kYXRlLmxlbmd0aCwgZGF0ZVN0cmluZy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aW1lU3RyaW5nKSB7XG4gICAgdmFyIHRva2VuID0gcGF0dGVybnMudGltZXpvbmUuZXhlYyh0aW1lU3RyaW5nKTtcblxuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpO1xuICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgPSB0b2tlblsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGVTdHJpbmdzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZGF0ZVN0cmluZywgYWRkaXRpb25hbERpZ2l0cykge1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdeKD86KFxcXFxkezR9fFsrLV1cXFxcZHsnICsgKDQgKyBhZGRpdGlvbmFsRGlnaXRzKSArICd9KXwoXFxcXGR7Mn18WystXVxcXFxkeycgKyAoMiArIGFkZGl0aW9uYWxEaWdpdHMpICsgJ30pJCknKTtcbiAgdmFyIGNhcHR1cmVzID0gZGF0ZVN0cmluZy5tYXRjaChyZWdleCk7IC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG5cbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIHtcbiAgICB5ZWFyOiBOYU4sXG4gICAgcmVzdERhdGVTdHJpbmc6ICcnXG4gIH07XG4gIHZhciB5ZWFyID0gY2FwdHVyZXNbMV0gPyBwYXJzZUludChjYXB0dXJlc1sxXSkgOiBudWxsO1xuICB2YXIgY2VudHVyeSA9IGNhcHR1cmVzWzJdID8gcGFyc2VJbnQoY2FwdHVyZXNbMl0pIDogbnVsbDsgLy8gZWl0aGVyIHllYXIgb3IgY2VudHVyeSBpcyBudWxsLCBub3QgYm90aFxuXG4gIHJldHVybiB7XG4gICAgeWVhcjogY2VudHVyeSA9PT0gbnVsbCA/IHllYXIgOiBjZW50dXJ5ICogMTAwLFxuICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKChjYXB0dXJlc1sxXSB8fCBjYXB0dXJlc1syXSkubGVuZ3RoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cmluZywgeWVhcikge1xuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuICBpZiAoeWVhciA9PT0gbnVsbCkgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIHZhciBjYXB0dXJlcyA9IGRhdGVTdHJpbmcubWF0Y2goZGF0ZVJlZ2V4KTsgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHN0cmluZ1xuXG4gIGlmICghY2FwdHVyZXMpIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB2YXIgaXNXZWVrRGF0ZSA9ICEhY2FwdHVyZXNbNF07XG4gIHZhciBkYXlPZlllYXIgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzFdKTtcbiAgdmFyIG1vbnRoID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1syXSkgLSAxO1xuICB2YXIgZGF5ID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1szXSk7XG4gIHZhciB3ZWVrID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1s0XSk7XG4gIHZhciBkYXlPZldlZWsgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzVdKSAtIDE7XG5cbiAgaWYgKGlzV2Vla0RhdGUpIHtcbiAgICBpZiAoIXZhbGlkYXRlV2Vla0RhdGUoeWVhciwgd2VlaywgZGF5T2ZXZWVrKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheU9mSVNPV2Vla1llYXIoeWVhciwgd2VlaywgZGF5T2ZXZWVrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDApO1xuXG4gICAgaWYgKCF2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgsIGRheSkgfHwgIXZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG5cbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoLCBNYXRoLm1heChkYXlPZlllYXIsIGRheSkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZVVuaXQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gcGFyc2VJbnQodmFsdWUpIDogMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lKHRpbWVTdHJpbmcpIHtcbiAgdmFyIGNhcHR1cmVzID0gdGltZVN0cmluZy5tYXRjaCh0aW1lUmVnZXgpO1xuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gTmFOOyAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgdGltZVxuXG4gIHZhciBob3VycyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbMV0pO1xuICB2YXIgbWludXRlcyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbMl0pO1xuICB2YXIgc2Vjb25kcyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbM10pO1xuXG4gIGlmICghdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICByZXR1cm4gaG91cnMgKiBtaWxsaXNlY29uZHNJbkhvdXIgKyBtaW51dGVzICogbWlsbGlzZWNvbmRzSW5NaW51dGUgKyBzZWNvbmRzICogMTAwMDtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lVW5pdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgcGFyc2VGbG9hdCh2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkgfHwgMDtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lem9uZSh0aW1lem9uZVN0cmluZykge1xuICBpZiAodGltZXpvbmVTdHJpbmcgPT09ICdaJykgcmV0dXJuIDA7XG4gIHZhciBjYXB0dXJlcyA9IHRpbWV6b25lU3RyaW5nLm1hdGNoKHRpbWV6b25lUmVnZXgpO1xuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gMDtcbiAgdmFyIHNpZ24gPSBjYXB0dXJlc1sxXSA9PT0gJysnID8gLTEgOiAxO1xuICB2YXIgaG91cnMgPSBwYXJzZUludChjYXB0dXJlc1syXSk7XG4gIHZhciBtaW51dGVzID0gY2FwdHVyZXNbM10gJiYgcGFyc2VJbnQoY2FwdHVyZXNbM10pIHx8IDA7XG5cbiAgaWYgKCF2YWxpZGF0ZVRpbWV6b25lKGhvdXJzLCBtaW51dGVzKSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIChob3VycyAqIG1pbGxpc2Vjb25kc0luSG91ciArIG1pbnV0ZXMgKiBtaWxsaXNlY29uZHNJbk1pbnV0ZSk7XG59XG5cbmZ1bmN0aW9uIGRheU9mSVNPV2Vla1llYXIoaXNvV2Vla1llYXIsIHdlZWssIGRheSkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGlzb1dlZWtZZWFyLCAwLCA0KTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgNztcbiAgdmFyIGRpZmYgPSAod2VlayAtIDEpICogNyArIGRheSArIDEgLSBmb3VydGhPZkphbnVhcnlEYXk7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZTtcbn0gLy8gVmFsaWRhdGlvbiBmdW5jdGlvbnNcbi8vIEZlYnJ1YXJ5IGlzIG51bGwgdG8gaGFuZGxlIHRoZSBsZWFwIHllYXIgKHVzaW5nIHx8KVxuXG5cbnZhciBkYXlzSW5Nb250aHMgPSBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcblxuZnVuY3Rpb24gaXNMZWFwWWVhckluZGV4KHllYXIpIHtcbiAgcmV0dXJuIHllYXIgJSA0MDAgPT09IDAgfHwgeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gIHJldHVybiBtb250aCA+PSAwICYmIG1vbnRoIDw9IDExICYmIGRhdGUgPj0gMSAmJiBkYXRlIDw9IChkYXlzSW5Nb250aHNbbW9udGhdIHx8IChpc0xlYXBZZWFySW5kZXgoeWVhcikgPyAyOSA6IDI4KSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpIHtcbiAgcmV0dXJuIGRheU9mWWVhciA+PSAxICYmIGRheU9mWWVhciA8PSAoaXNMZWFwWWVhckluZGV4KHllYXIpID8gMzY2IDogMzY1KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXZWVrRGF0ZShfeWVhciwgd2VlaywgZGF5KSB7XG4gIHJldHVybiB3ZWVrID49IDEgJiYgd2VlayA8PSA1MyAmJiBkYXkgPj0gMCAmJiBkYXkgPD0gNjtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gIGlmIChob3VycyA9PT0gMjQpIHtcbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCAmJiBzZWNvbmRzID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHNlY29uZHMgPj0gMCAmJiBzZWNvbmRzIDwgNjAgJiYgbWludXRlcyA+PSAwICYmIG1pbnV0ZXMgPCA2MCAmJiBob3VycyA+PSAwICYmIGhvdXJzIDwgMjU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZXpvbmUoX2hvdXJzLCBtaW51dGVzKSB7XG4gIHJldHVybiBtaW51dGVzID49IDAgJiYgbWludXRlcyA8PSA1OTtcbn0iLCJpbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IGdldERheSBmcm9tIFwiLi4vZ2V0RGF5L2luZGV4LmpzXCI7XG5pbXBvcnQgc3ViRGF5cyBmcm9tIFwiLi4vc3ViRGF5cy9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBuYW1lIHByZXZpb3VzRGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBXaGVuIGlzIHRoZSBwcmV2aW91cyBkYXkgb2YgdGhlIHdlZWs/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBXaGVuIGlzIHRoZSBwcmV2aW91cyBkYXkgb2YgdGhlIHdlZWs/IDAtNiB0aGUgZGF5IG9mIHRoZSB3ZWVrLCAwIHJlcHJlc2VudHMgU3VuZGF5LlxuICpcbiAqIEBwYXJhbSB7RGF0ZSB8IG51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0ge251bWJlcn0gZGF5IC0gZGF5IG9mIHRoZSB3ZWVrXG4gKiBAcmV0dXJucyB7RGF0ZX0gLSB0aGUgZGF0ZSBpcyB0aGUgcHJldmlvdXMgZGF5IG9mIHdlZWtcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gLSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGVuIGlzIHRoZSBwcmV2aW91cyBNb25kYXkgYmVmb3JlIE1hciwgMjAsIDIwMjA/XG4gKiBjb25zdCByZXN1bHQgPSBwcmV2aW91c0RheShuZXcgRGF0ZSgyMDIwLCAyLCAyMCksIDEpXG4gKiAvLz0+IE1vbiBNYXIgMTYgMjAyMCAwMDowMDowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGVuIGlzIHRoZSBwcmV2aW91cyBUdWVzZGF5IGJlZm9yZSBNYXIsIDIxLCAyMDIwP1xuICogY29uc3QgcmVzdWx0ID0gcHJldmlvdXNEYXkobmV3IERhdGUoMjAyMCwgMiwgMjEpLCAyKVxuICogLy89PiBUdWUgTWFyIDE3IDIwMjAgMDA6MDA6MDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJldmlvdXNEYXkoZGF0ZSwgZGF5KSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGVsdGEgPSBnZXREYXkoZGF0ZSkgLSBkYXk7XG4gIGlmIChkZWx0YSA8PSAwKSBkZWx0YSArPSA3O1xuICByZXR1cm4gc3ViRGF5cyhkYXRlLCBkZWx0YSk7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBzdGFydE9mRGF5XG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSBkYXkgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHN0YXJ0IG9mIGEgZGF5XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGEgZGF5IGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZkRheShuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDAyIDIwMTQgMDA6MDA6MDBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGFydE9mRGF5KGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBzdGFydE9mTW9udGhcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgbW9udGggZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhIG1vbnRoIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIG9yaWdpbmFsIGRhdGVcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgc3RhcnQgb2YgYSBtb250aFxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIG1vbnRoIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZk1vbnRoKG5ldyBEYXRlKDIwMTQsIDgsIDIsIDExLCA1NSwgMCkpXG4gKiAvLz0+IE1vbiBTZXAgMDEgMjAxNCAwMDowMDowMFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0YXJ0T2ZNb250aChkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIGRhdGUuc2V0RGF0ZSgxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgdG9JbnRlZ2VyIGZyb20gXCIuLi9fbGliL3RvSW50ZWdlci9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgc3RhcnRPZldlZWtcbiAqIEBjYXRlZ29yeSBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSB3ZWVrIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYSB3ZWVrIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHtMb2NhbGV9IFtvcHRpb25zLmxvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0LiBTZWUgW0xvY2FsZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9Mb2NhbGV9XG4gKiBAcGFyYW0gezB8MXwyfDN8NHw1fDZ9IFtvcHRpb25zLndlZWtTdGFydHNPbj0wXSAtIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwIC0gU3VuZGF5KVxuICogQHJldHVybnMge0RhdGV9IHRoZSBzdGFydCBvZiBhIHdlZWtcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMud2Vla1N0YXJ0c09uYCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYSB3ZWVrIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZldlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gU3VuIEF1ZyAzMSAyMDE0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRoZSB3ZWVrIHN0YXJ0cyBvbiBNb25kYXksIHRoZSBzdGFydCBvZiB0aGUgd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZXZWVrKG5ldyBEYXRlKDIwMTQsIDgsIDIsIDExLCA1NSwgMCksIHsgd2Vla1N0YXJ0c09uOiAxIH0pXG4gKiAvLz0+IE1vbiBTZXAgMDEgMjAxNCAwMDowMDowMFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0YXJ0T2ZXZWVrKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICB2YXIgbG9jYWxlV2Vla1N0YXJ0c09uID0gbG9jYWxlICYmIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLndlZWtTdGFydHNPbjtcbiAgdmFyIGRlZmF1bHRXZWVrU3RhcnRzT24gPSBsb2NhbGVXZWVrU3RhcnRzT24gPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIobG9jYWxlV2Vla1N0YXJ0c09uKTtcbiAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGwgPyBkZWZhdWx0V2Vla1N0YXJ0c09uIDogdG9JbnRlZ2VyKG9wdGlvbnMud2Vla1N0YXJ0c09uKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoISh3ZWVrU3RhcnRzT24gPj0gMCAmJiB3ZWVrU3RhcnRzT24gPD0gNikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xuICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCBhZGREYXlzIGZyb20gXCIuLi9hZGREYXlzL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBzdWJEYXlzXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBkYXlzIHRvIGJlIHN1YnRyYWN0ZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgZGF5cyBzdWJ0cmFjdGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN1YnRyYWN0IDEwIGRheXMgZnJvbSAxIFNlcHRlbWJlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gc3ViRGF5cyhuZXcgRGF0ZSgyMDE0LCA4LCAxKSwgMTApXG4gKiAvLz0+IEZyaSBBdWcgMjIgMjAxNCAwMDowMDowMFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN1YkRheXMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIGFtb3VudCA9IHRvSW50ZWdlcihkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBhZGREYXlzKGRpcnR5RGF0ZSwgLWFtb3VudCk7XG59IiwiaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCBhZGRNaWxsaXNlY29uZHMgZnJvbSBcIi4uL2FkZE1pbGxpc2Vjb25kcy9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgc3ViTWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgc3VidHJhY3RlZC4gUG9zaXRpdmUgZGVjaW1hbHMgd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmZsb29yYCwgZGVjaW1hbHMgbGVzcyB0aGFuIHplcm8gd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmNlaWxgLlxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgc3VidHJhY3RlZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdWJ0cmFjdCA3NTAgbWlsbGlzZWNvbmRzIGZyb20gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN1Yk1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjI5LjI1MFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN1Yk1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIGRpcnR5QW1vdW50KSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgYW1vdW50ID0gdG9JbnRlZ2VyKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIGFkZE1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIC1hbW91bnQpO1xufSIsImltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgbm9uZSBvZiB0aGUgYWJvdmUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIEludmFsaWQgRGF0ZS5cbiAqXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDbG9uZSB0aGUgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZShuZXcgRGF0ZSgyMDE0LCAxLCAxMSwgMTEsIDMwLCAzMCkpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZSgxMzkyMDk4NDMwMDAwKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0RhdGUoYXJndW1lbnQpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBhcmdTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpOyAvLyBDbG9uZSB0aGUgZGF0ZVxuXG4gIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGFyZ3VtZW50ID09PSAnb2JqZWN0JyAmJiBhcmdTdHIgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ251bWJlcicgfHwgYXJnU3RyID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgU3RyaW5nXScpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIHdpdGggdjIuMC4wLWJldGEuMSBkYXRlLWZucyBkb2Vzbid0IGFjY2VwdCBzdHJpbmdzIGFzIGRhdGUgYXJndW1lbnRzLiBQbGVhc2UgdXNlIGBwYXJzZUlTT2AgdG8gcGFyc2Ugc3RyaW5ncy4gU2VlOiBodHRwczovL2dpdC5pby9manVsZVwiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICogY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICBzdGFydCArPSBzdGVwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJhbmdlO1xuIiwidmFyIGJhc2VTb3J0ZWRJbmRleEJ5ID0gcmVxdWlyZSgnLi9fYmFzZVNvcnRlZEluZGV4QnknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICogcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gKiAgaW50byBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gIHZhciBsb3cgPSAwLFxuICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyBsb3cgOiBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSkge1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpZ2g7XG4gIH1cbiAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb3J0ZWRJbmRleDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAqIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICogIGludG8gYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICB2YXIgbG93ID0gMCxcbiAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuICB2YXIgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xuXG4gICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzTnVsbCk7XG4gICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoc2V0TG93KSB7XG4gICAgICBsb3cgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoID0gbWlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNvcnRlZEluZGV4Qnk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsInZhciB0cmltbWVkRW5kSW5kZXggPSByZXF1aXJlKCcuL190cmltbWVkRW5kSW5kZXgnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUcmltO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpLFxuICAgIGNyZWF0ZVNldCA9IHJlcXVpcmUoJy4vX2NyZWF0ZVNldCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgfVxuICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgfVxuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuaXE7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYmFzZVJhbmdlID0gcmVxdWlyZSgnLi9fYmFzZVJhbmdlJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpLFxuICAgIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmFuZ2U7XG4iLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2V0O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyaW1tZWRFbmRJbmRleDtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlSXNTZXQgPSByZXF1aXJlKCcuL19iYXNlSXNTZXQnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGNyZWF0ZVJhbmdlID0gcmVxdWlyZSgnLi9fY3JlYXRlUmFuZ2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICpcbiAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmFuZ2UoNCk7XG4gKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAqXG4gKiBfLnJhbmdlKC00KTtcbiAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICpcbiAqIF8ucmFuZ2UoMSwgNSk7XG4gKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAqXG4gKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gKlxuICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA0LCAwKTtcbiAqIC8vID0+IFsxLCAxLCAxXVxuICpcbiAqIF8ucmFuZ2UoMCk7XG4gKiAvLyA9PiBbXVxuICovXG52YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuIiwidmFyIGJhc2VTb3J0ZWRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VTb3J0ZWRJbmRleCcpO1xuXG4vKipcbiAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gKiAgaW50byBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gKiAvLyA9PiAxXG4gKi9cbmZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydGVkSW5kZXg7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVNvcnRlZEluZGV4QnkgPSByZXF1aXJlKCcuL19iYXNlU29ydGVkSW5kZXhCeScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAqICBpbnRvIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICpcbiAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gKiAvLyA9PiAwXG4gKi9cbmZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0ZWRJbmRleEJ5O1xuIiwidmFyIGJhc2VTb3J0ZWRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VTb3J0ZWRJbmRleCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gKiAgaW50byBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICogLy8gPT4gNFxuICovXG5mdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0ZWRMYXN0SW5kZXg7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIGJhc2VUcmltID0gcmVxdWlyZSgnLi9fYmFzZVRyaW0nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICogaW4gdGhlIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxKFsyLCAxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xuZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxO1xuIiwidmFyIGJhc2VVbmlxID0gcmVxdWlyZSgnLi9fYmFzZVVuaXEnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gKlxuICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICovXG5mdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcVdpdGg7XG4iLCIndXNlIHN0cmljdCdcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuXG5jb25zdCBNQVggPSBTeW1ib2woJ21heCcpXG5jb25zdCBMRU5HVEggPSBTeW1ib2woJ2xlbmd0aCcpXG5jb25zdCBMRU5HVEhfQ0FMQ1VMQVRPUiA9IFN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpXG5jb25zdCBBTExPV19TVEFMRSA9IFN5bWJvbCgnYWxsb3dTdGFsZScpXG5jb25zdCBNQVhfQUdFID0gU3ltYm9sKCdtYXhBZ2UnKVxuY29uc3QgRElTUE9TRSA9IFN5bWJvbCgnZGlzcG9zZScpXG5jb25zdCBOT19ESVNQT1NFX09OX1NFVCA9IFN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxuY29uc3QgTFJVX0xJU1QgPSBTeW1ib2woJ2xydUxpc3QnKVxuY29uc3QgQ0FDSEUgPSBTeW1ib2woJ2NhY2hlJylcbmNvbnN0IFVQREFURV9BR0VfT05fR0VUID0gU3ltYm9sKCd1cGRhdGVBZ2VPbkdldCcpXG5cbmNvbnN0IG5haXZlTGVuZ3RoID0gKCkgPT4gMVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cblxuICAgIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7fVxuXG4gICAgaWYgKG9wdGlvbnMubWF4ICYmICh0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICdudW1iZXInIHx8IG9wdGlvbnMubWF4IDwgMCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuICAgIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgICBjb25zdCBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heCB8fCBJbmZpbml0eVxuXG4gICAgY29uc3QgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gKHR5cGVvZiBsYyAhPT0gJ2Z1bmN0aW9uJykgPyBuYWl2ZUxlbmd0aCA6IGxjXG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlXG4gICAgaWYgKG9wdGlvbnMubWF4QWdlICYmIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG4gICAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlXG4gICAgdGhpc1tOT19ESVNQT1NFX09OX1NFVF0gPSBvcHRpb25zLm5vRGlzcG9zZU9uU2V0IHx8IGZhbHNlXG4gICAgdGhpc1tVUERBVEVfQUdFX09OX0dFVF0gPSBvcHRpb25zLnVwZGF0ZUFnZU9uR2V0IHx8IGZhbHNlXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuICBzZXQgbWF4IChtTCkge1xuICAgIGlmICh0eXBlb2YgbUwgIT09ICdudW1iZXInIHx8IG1MIDwgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF0gPSBtTCB8fCBJbmZpbml0eVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4ICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH1cblxuICBzZXQgYWxsb3dTdGFsZSAoYWxsb3dTdGFsZSkge1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlXG4gIH1cbiAgZ2V0IGFsbG93U3RhbGUgKCkge1xuICAgIHJldHVybiB0aGlzW0FMTE9XX1NUQUxFXVxuICB9XG5cbiAgc2V0IG1heEFnZSAobUEpIHtcbiAgICBpZiAodHlwZW9mIG1BICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF9BR0VdID0gbUFcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heEFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuICBzZXQgbGVuZ3RoQ2FsY3VsYXRvciAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKVxuICAgICAgbEMgPSBuYWl2ZUxlbmd0aFxuXG4gICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsQ1xuICAgICAgdGhpc1tMRU5HVEhdID0gMFxuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4ge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSlcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBsZW5ndGhDYWxjdWxhdG9yICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH1cblxuICBnZXQgbGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIXSB9XG4gIGdldCBpdGVtQ291bnQgKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH1cblxuICByZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0udGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cblxuICBmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gbmV4dFxuICAgIH1cbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay5rZXkpXG4gIH1cblxuICB2YWx1ZXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay52YWx1ZSlcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKSlcbiAgICB9XG5cbiAgICB0aGlzW0NBQ0hFXSA9IG5ldyBNYXAoKSAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICAgIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gICAgdGhpc1tMRU5HVEhdID0gMCAvLyBsZW5ndGggb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgfVxuXG4gIGR1bXAgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS5tYXAoaGl0ID0+XG4gICAgICBpc1N0YWxlKHRoaXMsIGhpdCkgPyBmYWxzZSA6IHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH0pLnRvQXJyYXkoKS5maWx0ZXIoaCA9PiBoKVxuICB9XG5cbiAgZHVtcExydSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG4gIH1cblxuICBzZXQgKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICAgIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdXG5cbiAgICBpZiAobWF4QWdlICYmIHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuXG4gICAgY29uc3Qgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgICBjb25zdCBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KVxuXG4gICAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgICBpZiAobGVuID4gdGhpc1tNQVhdKSB7XG4gICAgICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgICAgY29uc3QgaXRlbSA9IG5vZGUudmFsdWVcblxuICAgICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAgIC8vIHNwbGl0IG91dCBpbnRvIDIgaWZzIGZvciBiZXR0ZXIgY292ZXJhZ2UgdHJhY2tpbmdcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pXG4gICAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGl0ZW0ubm93ID0gbm93XG4gICAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlXG4gICAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGhcbiAgICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgICB0aGlzLmdldChrZXkpXG4gICAgICB0cmltKHRoaXMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gICAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pXG4gICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgICB0aGlzW0NBQ0hFXS5zZXQoa2V5LCB0aGlzW0xSVV9MSVNUXS5oZWFkKVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaGFzIChrZXkpIHtcbiAgICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBoaXQgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KS52YWx1ZVxuICAgIHJldHVybiAhaXNTdGFsZSh0aGlzLCBoaXQpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKVxuICB9XG5cbiAgcGVlayAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKVxuICB9XG5cbiAgcG9wICgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbFxuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBkZWwodGhpcywgbm9kZSlcbiAgICByZXR1cm4gbm9kZS52YWx1ZVxuICB9XG5cbiAgZGVsIChrZXkpIHtcbiAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gIH1cblxuICBsb2FkIChhcnIpIHtcbiAgICAvLyByZXNldCB0aGUgY2FjaGVcbiAgICB0aGlzLnJlc2V0KClcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICAgIGZvciAobGV0IGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgIGNvbnN0IGhpdCA9IGFycltsXVxuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgICAgaWYgKGV4cGlyZXNBdCA9PT0gMClcbiAgICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgICAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBydW5lICgpIHtcbiAgICB0aGlzW0NBQ0hFXS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBnZXQodGhpcywga2V5LCBmYWxzZSkpXG4gIH1cbn1cblxuY29uc3QgZ2V0ID0gKHNlbGYsIGtleSwgZG9Vc2UpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNlbGZbQ0FDSEVdLmdldChrZXkpXG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICAgIGRlbChzZWxmLCBub2RlKVxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgaWYgKHNlbGZbVVBEQVRFX0FHRV9PTl9HRVRdKVxuICAgICAgICAgIG5vZGUudmFsdWUubm93ID0gRGF0ZS5ub3coKVxuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGl0LnZhbHVlXG4gIH1cbn1cblxuY29uc3QgaXNTdGFsZSA9IChzZWxmLCBoaXQpID0+IHtcbiAgaWYgKCFoaXQgfHwgKCFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSlcbiAgICByZXR1cm4gZmFsc2VcblxuICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3dcbiAgcmV0dXJuIGhpdC5tYXhBZ2UgPyBkaWZmID4gaGl0Lm1heEFnZVxuICAgIDogc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG59XG5cbmNvbnN0IHRyaW0gPSBzZWxmID0+IHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGRlbChzZWxmLCB3YWxrZXIpXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRlbCA9IChzZWxmLCBub2RlKSA9PiB7XG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKVxuICAgICAgc2VsZltESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG5cbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aFxuICAgIHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KVxuICAgIHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSlcbiAgfVxufVxuXG5jbGFzcyBFbnRyeSB7XG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlLCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoaXMubm93ID0gbm93XG4gICAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxuICB9XG59XG5cbmNvbnN0IGZvckVhY2hTdGVwID0gKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkgPT4ge1xuICBsZXQgaGl0ID0gbm9kZS52YWx1ZVxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICB9XG4gIGlmIChoaXQpXG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG4iLCJ2YXIgaW5kaWNhdG9yID0gcmVxdWlyZSgnLi9pbmRpY2F0b3InKVxuXG5mdW5jdGlvbiBvcmRpbmFsIChpKSB7XG4gIGlmICh0eXBlb2YgaSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIE51bWJlciwgZ290ICcgKyAodHlwZW9mIGkpICsgJyAnICsgaSlcblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShpKSkgcmV0dXJuIGlcbiAgcmV0dXJuIGkgKyBpbmRpY2F0b3IoaSlcbn1cblxub3JkaW5hbC5pbmRpY2F0b3IgPSBpbmRpY2F0b3Jcbm1vZHVsZS5leHBvcnRzID0gb3JkaW5hbFxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmRpY2F0b3IgKGkpIHtcbiAgaSA9IE1hdGguYWJzKGkpXG4gIHZhciBjZW50ID0gaSAlIDEwMFxuICBpZiAoY2VudCA+PSAxMCAmJiBjZW50IDw9IDIwKSByZXR1cm4gJ3RoJ1xuICB2YXIgZGVjID0gaSAlIDEwXG4gIGlmIChkZWMgPT09IDEpIHJldHVybiAnc3QnXG4gIGlmIChkZWMgPT09IDIpIHJldHVybiAnbmQnXG4gIGlmIChkZWMgPT09IDMpIHJldHVybiAncmQnXG4gIHJldHVybiAndGgnXG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb25cbiAgICBjb25zdCBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8XG4gICAgICBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhblxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL3JhbmdlJylcbiIsIi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBSYW5nZSB7XG4gIGNvbnN0cnVjdG9yIChyYW5nZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiByYW5nZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgLy8ganVzdCBwdXQgaXQgaW4gdGhlIHNldCBhbmQgcmV0dXJuXG4gICAgICB0aGlzLnJhdyA9IHJhbmdlLnZhbHVlXG4gICAgICB0aGlzLnNldCA9IFtbcmFuZ2VdXVxuICAgICAgdGhpcy5mb3JtYXQoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gICAgdGhpcy5yYXcgPSByYW5nZVxuICAgIHRoaXMuc2V0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnfHwnKVxuICAgICAgLy8gbWFwIHRoZSByYW5nZSB0byBhIDJkIGFycmF5IG9mIGNvbXBhcmF0b3JzXG4gICAgICAubWFwKHIgPT4gdGhpcy5wYXJzZVJhbmdlKHIudHJpbSgpKSlcbiAgICAgIC8vIHRocm93IG91dCBhbnkgY29tcGFyYXRvciBsaXN0cyB0aGF0IGFyZSBlbXB0eVxuICAgICAgLy8gdGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCBpdCB3YXMgbm90IGEgdmFsaWQgcmFuZ2UsIHdoaWNoIGlzIGFsbG93ZWRcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIGJ1dCB3aWxsIHN0aWxsIHRocm93IGlmIHRoZSBXSE9MRSByYW5nZSBpcyBpbnZhbGlkLlxuICAgICAgLmZpbHRlcihjID0+IGMubGVuZ3RoKVxuXG4gICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgU2VtVmVyIFJhbmdlOiAke3JhbmdlfWApXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgbm90IHRoZSBudWxsIHNldCwgdGhyb3cgb3V0IG51bGwgc2V0cy5cbiAgICBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgLy8ga2VlcCB0aGUgZmlyc3Qgb25lLCBpbiBjYXNlIHRoZXkncmUgYWxsIG51bGwgc2V0c1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLnNldFswXVxuICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5maWx0ZXIoYyA9PiAhaXNOdWxsU2V0KGNbMF0pKVxuICAgICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldCA9IFtmaXJzdF1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldFxuICAgICAgLm1hcCgoY29tcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgICAgIH0pXG4gICAgICAuam9pbignfHwnKVxuICAgICAgLnRyaW0oKVxuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZS50cmltKClcblxuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5qb2luKCcsJylcbiAgICBjb25zdCBtZW1vS2V5ID0gYHBhcnNlUmFuZ2U6JHttZW1vT3B0c306JHtyYW5nZX1gXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSlcblxuICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG5cbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuXG4gICAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICAgIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJylcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgIGxldCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG5cbiAgICBpZiAobG9vc2UpIHtcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgICByYW5nZUxpc3QgPSByYW5nZUxpc3QuZmlsdGVyKGNvbXAgPT4ge1xuICAgICAgICBkZWJ1ZygnbG9vc2UgaW52YWxpZCBmaWx0ZXInLCBjb21wLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiAhIWNvbXAubWF0Y2gocmVbdC5DT01QQVJBVE9STE9PU0VdKVxuICAgICAgfSlcbiAgICB9XG4gICAgZGVidWcoJ3JhbmdlIGxpc3QnLCByYW5nZUxpc3QpXG5cbiAgICAvLyBpZiBhbnkgY29tcGFyYXRvcnMgYXJlIHRoZSBudWxsIHNldCwgdGhlbiByZXBsYWNlIHdpdGggSlVTVCBudWxsIHNldFxuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgY29tcGFyYXRvciwgcmVtb3ZlIGFueSAqIGNvbXBhcmF0b3JzXG4gICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlTGlzdC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wYXJhdG9ycykge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSkge1xuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICB9XG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpIHtcbiAgICAgIHJhbmdlTWFwLmRlbGV0ZSgnJylcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2UsXG59ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuY29uc3QgcmVwbGFjZVRpbGRlcyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuY29uc3QgcmVwbGFjZUNhcmV0cyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKChjKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8Jykge1xuICAgICAgICBwciA9ICctMCdcbiAgICAgIH1cblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IHsgTUFYX0xFTkdUSCwgTUFYX1NBRkVfSU5URUdFUiB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGB2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICR7TUFYX0xFTkdUSH0gY2hhcmFjdGVyc2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgLy8gZG9uJ3QgcnVuIGludG8gdHJvdWJsZSBwYXNzaW5nIHRoaXMub3B0aW9ucyBhcm91bmQuXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgY29uc3QgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXVxuICAgIHRoaXMubWlub3IgPSArbVsyXVxuICAgIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gICAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKChpZCkgPT4ge1xuICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICtpZFxuICAgICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICBjb21wYXJlIChvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbiAgfVxuXG4gIGNvbXBhcmVNYWluIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbiAgICApXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICAvLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4gIC8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cbiAgaW5jIChyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLmZvcm1hdCgpXG4gICAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb25cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgY2xlYW4gPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5cbiIsImNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL25lcScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZ3QnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9ndGUnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vbHRlJylcblxuY29uc3QgY21wID0gKGEsIG9wLCBiLCBsb29zZSkgPT4ge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7b3B9YClcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBjbXBcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gcGFyc2UoYCR7bWF0Y2hbMl19LiR7bWF0Y2hbM10gfHwgJzAnfS4ke21hdGNoWzRdIHx8ICcwJ31gLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHYxID0gcGFyc2UodmVyc2lvbjEpXG4gICAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMilcbiAgICBjb25zdCBoYXNQcmUgPSB2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aFxuICAgIGNvbnN0IHByZWZpeCA9IGhhc1ByZSA/ICdwcmUnIDogJydcbiAgICBjb25zdCBkZWZhdWx0UmVzdWx0ID0gaGFzUHJlID8gJ3ByZXJlbGVhc2UnIDogJydcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2MSkge1xuICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIGtleVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0IC8vIG1heSBiZSB1bmRlZmluZWRcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBkaWZmXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxubW9kdWxlLmV4cG9ydHMgPSBlcVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMFxubW9kdWxlLmV4cG9ydHMgPSBndGVcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgaW5jID0gKHZlcnNpb24sIHJlbGVhc2UsIG9wdGlvbnMsIGlkZW50aWZpZXIpID0+IHtcbiAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKFxuICAgICAgdmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlciA/IHZlcnNpb24udmVyc2lvbiA6IHZlcnNpb24sXG4gICAgICBvcHRpb25zXG4gICAgKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IHsgTUFYX0xFTkdUSCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBwYXJzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF1cbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGF0Y2ggPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgcHJlcmVsZWFzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gcHJlcmVsZWFzZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSlcbm1vZHVsZS5leHBvcnRzID0gcmNvbXBhcmVcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCByc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSByc29ydFxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHNhdGlzZmllc1xuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFxuIiwiLy8ganVzdCBwcmUtbG9hZCBhbGwgdGhlIHN0dWZmIHRoYXQgaW5kZXguanMgbGF6aWx5IGV4cG9ydHNcbmNvbnN0IGludGVybmFsUmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlJylcbm1vZHVsZS5leHBvcnRzID0ge1xuICByZTogaW50ZXJuYWxSZS5yZSxcbiAgc3JjOiBpbnRlcm5hbFJlLnNyYyxcbiAgdG9rZW5zOiBpbnRlcm5hbFJlLnQsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT046IHJlcXVpcmUoJy4vaW50ZXJuYWwvY29uc3RhbnRzJykuU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgU2VtVmVyOiByZXF1aXJlKCcuL2NsYXNzZXMvc2VtdmVyJyksXG4gIGNvbXBhcmVJZGVudGlmaWVyczogcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpLnJjb21wYXJlSWRlbnRpZmllcnMsXG4gIHBhcnNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpLFxuICB2YWxpZDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvdmFsaWQnKSxcbiAgY2xlYW46IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NsZWFuJyksXG4gIGluYzogcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJyksXG4gIGRpZmY6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2RpZmYnKSxcbiAgbWFqb3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21ham9yJyksXG4gIG1pbm9yOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpLFxuICBwYXRjaDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGF0Y2gnKSxcbiAgcHJlcmVsZWFzZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcHJlcmVsZWFzZScpLFxuICBjb21wYXJlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJyksXG4gIHJjb21wYXJlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yY29tcGFyZScpLFxuICBjb21wYXJlTG9vc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UnKSxcbiAgY29tcGFyZUJ1aWxkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJyksXG4gIHNvcnQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NvcnQnKSxcbiAgcnNvcnQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jzb3J0JyksXG4gIGd0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpLFxuICBsdDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHQnKSxcbiAgZXE6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2VxJyksXG4gIG5lcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJyksXG4gIGd0ZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3RlJyksXG4gIGx0ZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHRlJyksXG4gIGNtcDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJyksXG4gIGNvZXJjZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29lcmNlJyksXG4gIENvbXBhcmF0b3I6IHJlcXVpcmUoJy4vY2xhc3Nlcy9jb21wYXJhdG9yJyksXG4gIFJhbmdlOiByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKSxcbiAgc2F0aXNmaWVzOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKSxcbiAgdG9Db21wYXJhdG9yczogcmVxdWlyZSgnLi9yYW5nZXMvdG8tY29tcGFyYXRvcnMnKSxcbiAgbWF4U2F0aXNmeWluZzogcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKSxcbiAgbWluU2F0aXNmeWluZzogcmVxdWlyZSgnLi9yYW5nZXMvbWluLXNhdGlzZnlpbmcnKSxcbiAgbWluVmVyc2lvbjogcmVxdWlyZSgnLi9yYW5nZXMvbWluLXZlcnNpb24nKSxcbiAgdmFsaWRSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKSxcbiAgb3V0c2lkZTogcmVxdWlyZSgnLi9yYW5nZXMvb3V0c2lkZScpLFxuICBndHI6IHJlcXVpcmUoJy4vcmFuZ2VzL2d0cicpLFxuICBsdHI6IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpLFxuICBpbnRlcnNlY3RzOiByZXF1aXJlKCcuL3Jhbmdlcy9pbnRlcnNlY3RzJyksXG4gIHNpbXBsaWZ5UmFuZ2U6IHJlcXVpcmUoJy4vcmFuZ2VzL3NpbXBsaWZ5JyksXG4gIHN1YnNldDogcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0JyksXG59XG4iLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuY29uc3QgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxufVxuIiwiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsIi8vIHBhcnNlIG91dCBqdXN0IHRoZSBvcHRpb25zIHdlIGNhcmUgYWJvdXQgc28gd2UgYWx3YXlzIGdldCBhIGNvbnNpc3RlbnRcbi8vIG9iaiB3aXRoIGtleXMgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuY29uc3Qgb3B0cyA9IFsnaW5jbHVkZVByZXJlbGVhc2UnLCAnbG9vc2UnLCAncnRsJ11cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IG9wdGlvbnMgPT5cbiAgIW9wdGlvbnMgPyB7fVxuICA6IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyA/IHsgbG9vc2U6IHRydWUgfVxuICA6IG9wdHMuZmlsdGVyKGsgPT4gb3B0aW9uc1trXSkucmVkdWNlKChvLCBrKSA9PiB7XG4gICAgb1trXSA9IHRydWVcbiAgICByZXR1cm4gb1xuICB9LCB7fSlcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VPcHRpb25zXG4iLCJjb25zdCB7IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fVxuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxuY29uc3QgcmUgPSBleHBvcnRzLnJlID0gW11cbmNvbnN0IHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbmNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fVxubGV0IFIgPSAwXG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBpbmRleCA9IFIrK1xuICBkZWJ1ZyhuYW1lLCBpbmRleCwgdmFsdWUpXG4gIHRbbmFtZV0gPSBpbmRleFxuICBzcmNbaW5kZXhdID0gdmFsdWVcbiAgcmVbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUicsICcwfFsxLTldXFxcXGQqJylcbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1swLTldKycpXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdOT05OVU1FUklDSURFTlRJRklFUicsICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJylcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsICdbMC05QS1aYS16LV0rJylcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRCcsIGAoPzpcXFxcKygke3NyY1t0LkJVSUxESURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuQlVJTERJREVOVElGSUVSXX0pKikpYClcblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbmNyZWF0ZVRva2VuKCdGVUxMUExBSU4nLCBgdj8ke3NyY1t0Lk1BSU5WRVJTSU9OXVxufSR7c3JjW3QuUFJFUkVMRUFTRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0ZVTEwnLCBgXiR7c3JjW3QuRlVMTFBMQUlOXX0kYClcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxuY3JlYXRlVG9rZW4oJ0xPT1NFUExBSU4nLCBgW3Y9XFxcXHNdKiR7c3JjW3QuTUFJTlZFUlNJT05MT09TRV1cbn0ke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0xPT1NFJywgYF4ke3NyY1t0LkxPT1NFUExBSU5dfSRgKVxuXG5jcmVhdGVUb2tlbignR1RMVCcsICcoKD86PHw+KT89PyknKVxuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUkxPT1NFJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19fHh8WHxcXFxcKmApXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUicsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX18eHxYfFxcXFwqYClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOTE9PU0UnLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxuY3JlYXRlVG9rZW4oJ0NPRVJDRScsIGAkeycoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCd9JHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pYCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMJywgc3JjW3QuQ09FUkNFXSwgdHJ1ZSlcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbmNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpXG5cbmNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVUSUxERV19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbmNyZWF0ZVRva2VuKCdUSUxERScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKVxuXG5jcmVhdGVUb2tlbignQ0FSRVRUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FQ0FSRVRdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG5jcmVhdGVUb2tlbignQ0FSRVQnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9STE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKVxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuRlVMTFBMQUlOXX0pJHxeJGApXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkdUTFRdXG59XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKVxuZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbmNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKVxuLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuY3JlYXRlVG9rZW4oJ0dURTAnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMC0wXFxcXHMqJCcpXG4iLCIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpIHtcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICAgIH1cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IGZpcnN0ID0gbnVsbFxuICBsZXQgcHJldiA9IG51bGxcbiAgY29uc3QgdiA9IHZlcnNpb25zLnNvcnQoKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgb3B0aW9ucykpXG4gIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2KSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgaWYgKGluY2x1ZGVkKSB7XG4gICAgICBwcmV2ID0gdmVyc2lvblxuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IHZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2V0LnB1c2goW2ZpcnN0LCBwcmV2XSlcbiAgICAgIH1cbiAgICAgIHByZXYgPSBudWxsXG4gICAgICBmaXJzdCA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0KSB7XG4gICAgc2V0LnB1c2goW2ZpcnN0LCBudWxsXSlcbiAgfVxuXG4gIGNvbnN0IHJhbmdlcyA9IFtdXG4gIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBzZXQpIHtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKG1pbilcbiAgICB9IGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaCgnKicpXG4gICAgfSBlbHNlIGlmICghbWF4KSB7XG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIH0gZWxzZSBpZiAobWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaChgPD0ke21heH1gKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMucHVzaChgJHttaW59IC0gJHttYXh9YClcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBzaW1wbGVTdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdWIubGVuZ3RoID09PSAxICYmIHN1YlswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHN1YiA9IFtuZXcgQ29tcGFyYXRvcignPj0wLjAuMC0wJyldXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YiA9IFtuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXVxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKV1cbiAgICB9XG4gIH1cblxuICBjb25zdCBlcVNldCA9IG5ldyBTZXQoKVxuICBsZXQgZ3QsIGx0XG4gIGZvciAoY29uc3QgYyBvZiBzdWIpIHtcbiAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgbHQgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBlcVNldC5hZGQoYy5zZW12ZXIpXG4gICAgfVxuICB9XG5cbiAgaWYgKGVxU2V0LnNpemUgPiAxKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxldCBndGx0Q29tcFxuICBpZiAoZ3QgJiYgbHQpIHtcbiAgICBndGx0Q29tcCA9IGNvbXBhcmUoZ3Quc2VtdmVyLCBsdC5zZW12ZXIsIG9wdGlvbnMpXG4gICAgaWYgKGd0bHRDb21wID4gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2UgaWYgKGd0bHRDb21wID09PSAwICYmIChndC5vcGVyYXRvciAhPT0gJz49JyB8fCBsdC5vcGVyYXRvciAhPT0gJzw9JykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gd2lsbCBpdGVyYXRlIG9uZSBvciB6ZXJvIHRpbWVzXG4gIGZvciAoY29uc3QgZXEgb2YgZXFTZXQpIHtcbiAgICBpZiAoZ3QgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGd0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKGx0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhsdCksIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICAgIGlmICghc2F0aXNmaWVzKGVxLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBsZXQgaGlnaGVyLCBsb3dlclxuICBsZXQgaGFzRG9tTFQsIGhhc0RvbUdUXG4gIC8vIGlmIHRoZSBzdWJzZXQgaGFzIGEgcHJlcmVsZWFzZSwgd2UgbmVlZCBhIGNvbXBhcmF0b3IgaW4gdGhlIHN1cGVyc2V0XG4gIC8vIHdpdGggdGhlIHNhbWUgdHVwbGUgYW5kIGEgcHJlcmVsZWFzZSwgb3IgaXQncyBub3QgYSBzdWJzZXRcbiAgbGV0IG5lZWREb21MVFByZSA9IGx0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBsdC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBsdC5zZW12ZXIgOiBmYWxzZVxuICBsZXQgbmVlZERvbUdUUHJlID0gZ3QgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGd0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGd0LnNlbXZlciA6IGZhbHNlXG4gIC8vIGV4Y2VwdGlvbjogPDEuMi4zLTAgaXMgdGhlIHNhbWUgYXMgPDEuMi4zXG4gIGlmIChuZWVkRG9tTFRQcmUgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2UubGVuZ3RoID09PSAxICYmXG4gICAgICBsdC5vcGVyYXRvciA9PT0gJzwnICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlWzBdID09PSAwKSB7XG4gICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICBoYXNEb21HVCA9IGhhc0RvbUdUIHx8IGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nXG4gICAgaGFzRG9tTFQgPSBoYXNEb21MVCB8fCBjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9J1xuICAgIGlmIChndCkge1xuICAgICAgaWYgKG5lZWREb21HVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21HVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21HVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21HVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21HVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgICBoaWdoZXIgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGhpZ2hlciA9PT0gYyAmJiBoaWdoZXIgIT09IGd0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3Qub3BlcmF0b3IgPT09ICc+PScgJiYgIXNhdGlzZmllcyhndC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsdCkge1xuICAgICAgaWYgKG5lZWREb21MVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21MVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21MVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21MVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgICBsb3dlciA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChsb3dlciA9PT0gYyAmJiBsb3dlciAhPT0gbHQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsdC5vcGVyYXRvciA9PT0gJzw9JyAmJiAhc2F0aXNmaWVzKGx0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjLm9wZXJhdG9yICYmIChsdCB8fCBndCkgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZXJlIHdhcyBhIDwgb3IgPiwgYW5kIG5vdGhpbmcgaW4gdGhlIGRvbSwgdGhlbiBtdXN0IGJlIGZhbHNlXG4gIC8vIFVOTEVTUyBpdCB3YXMgbGltaXRlZCBieSBhbm90aGVyIHJhbmdlIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gIC8vIEVnLCA+MS4wLjAgPDEuMC4xIGlzIHN0aWxsIGEgc3Vic2V0IG9mIDwyLjAuMFxuICBpZiAoZ3QgJiYgaGFzRG9tTFQgJiYgIWx0ICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobHQgJiYgaGFzRG9tR1QgJiYgIWd0ICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyB3ZSBuZWVkZWQgYSBwcmVyZWxlYXNlIHJhbmdlIGluIGEgc3BlY2lmaWMgdHVwbGUsIGJ1dCBkaWRuJ3QgZ2V0IG9uZVxuICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBzdWJzZXQuICBlZyA+PTEuMi4zLXByZSBpcyBub3QgYSBzdWJzZXQgb2YgPj0xLjAuMCxcbiAgLy8gYmVjYXVzZSBpdCBpbmNsdWRlcyBwcmVyZWxlYXNlcyBpbiB0aGUgMS4yLjMgdHVwbGVcbiAgaWYgKG5lZWREb21HVFByZSB8fCBuZWVkRG9tTFRQcmUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vID49MS4yLjMgaXMgbG93ZXIgdGhhbiA+MS4yLjNcbmNvbnN0IGhpZ2hlckdUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKSB7XG4gICAgcmV0dXJuIGJcbiAgfVxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wID4gMCA/IGFcbiAgICA6IGNvbXAgPCAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJz4nICYmIGEub3BlcmF0b3IgPT09ICc+PScgPyBiXG4gICAgOiBhXG59XG5cbi8vIDw9MS4yLjMgaXMgaGlnaGVyIHRoYW4gPDEuMi4zXG5jb25zdCBsb3dlckxUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKSB7XG4gICAgcmV0dXJuIGJcbiAgfVxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wIDwgMCA/IGFcbiAgICA6IGNvbXAgPiAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJzwnICYmIGEub3BlcmF0b3IgPT09ICc8PScgPyBiXG4gICAgOiBhXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3Vic2V0XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgdmFsaWRSYW5nZSA9IChyYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkUmFuZ2VcbiIsImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbnZhciBnZXRSYW5kb21WYWx1ZXM7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247IiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZYWxsaXN0KSB7XG4gIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQsIC4uLm5vZGVzKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBub2Rlc1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiIsIi8qKlxuICogRGVmaW5lcyB0aGUgW0FwcF17QGxpbmsgbW9kdWxlOmFwcH5BcHB9IGNsYXNzLlxuICogQG1vZHVsZSBhcHBcbiAqL1xuXG5pbXBvcnQge1xuICBhZGQgYXMgYWRkVG9EYXRlLFxuICBlbmRPZkRheSxcbiAgc3RhcnRPZkRheSxcbn0gZnJvbSAnZGF0ZS1mbnMnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5pbXBvcnQgJy4uL3N0eWxlcy9yZXNldC5jc3MnO1xuaW1wb3J0ICcuLi9zdHlsZXMvbWFpbi5jc3MnO1xuaW1wb3J0IEFkZFByb2plY3RNb2RhbCBmcm9tICcuL21vZGFscy9hZGRQcm9qZWN0TW9kYWwnO1xuaW1wb3J0IEFkZFRhc2tNb2RhbCBmcm9tICcuL21vZGFscy9hZGRUYXNrTW9kYWwnO1xuaW1wb3J0IENvbmZpcm1Nb2RhbCBmcm9tICcuL21vZGFscy9jb25maXJtTW9kYWwnO1xuaW1wb3J0IERhdGFNb2RhbCBmcm9tICcuL21vZGFscy9kYXRhTW9kYWwnO1xuaW1wb3J0IEZpbHRlck1lbnUgZnJvbSAnLi9maWx0ZXJNZW51JztcbmltcG9ydCBJbmZvTW9kYWwgZnJvbSAnLi9tb2RhbHMvaW5mb01vZGFsJztcbmltcG9ydCBNb2RhbFN0YWNrIGZyb20gJy4vbW9kYWxTdGFjayc7XG5pbXBvcnQgUG9wdXBNZW51IGZyb20gJy4vcG9wdXBNZW51JztcbmltcG9ydCBQcm9qZWN0IGZyb20gJy4vcHJvamVjdCc7XG5pbXBvcnQgUHJvamVjdExpc3QgZnJvbSAnLi9wcm9qZWN0TGlzdCc7XG5pbXBvcnQgUmVjdXJyaW5nRGF0ZSBmcm9tICcuL3JlY3VycmluZ0RhdGUnO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IFNldHRpbmdzTW9kYWwgZnJvbSAnLi9tb2RhbHMvc2V0dGluZ3NNb2RhbCc7XG5pbXBvcnQgVGFzayBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IFRhc2tEaXNwbGF5IGZyb20gJy4vdGFza0Rpc3BsYXknO1xuaW1wb3J0IFRhc2tMaXN0IGZyb20gJy4vdGFza0xpc3QnO1xuaW1wb3J0IHsgZm9ybWF0RGF0ZSB9IGZyb20gJy4vdXRpbGl0eS9kYXRlcyc7XG5pbXBvcnQgeyBjcmVhdGVJY29uQnV0dG9uIH0gZnJvbSAnLi91dGlsaXR5L2RvbSc7XG5pbXBvcnQge1xuICBjbGVhckRhdGEsXG4gIGZvckVhY2hEYXRhSXRlbSxcbiAgZ2VuZXJhdGVGaWxlLFxuICBnZXRGaWxlRXh0ZW5zaW9uLFxuICBwYXJzZUNzdixcbiAgcmVtb3ZlRGF0YSxcbiAgcmV0cmlldmVEYXRhLFxuICBzdG9yZURhdGEsXG59IGZyb20gJy4vdXRpbGl0eS9zdG9yYWdlJztcblxuY29uc3QgQVBQX05BTUUgPSAnVGFzayBJdCBVcCc7XG5jb25zdCBBUFBfQVVUSE9SID0gUEFDS0FHRV9BVVRIT1JfTkFNRTtcbmNvbnN0IEFQUF9BVVRIT1JfV0VCU0lURSA9IFBBQ0tBR0VfQVVUSE9SX1dFQlNJVEU7XG5jb25zdCBBUFBfQ09QWVJJR0hUX1lFQVJTID0gJzIwMjEtMjAyMic7XG5jb25zdCBBUFBfVkVSU0lPTiA9IFBBQ0tBR0VfVkVSU0lPTjtcbmNvbnN0IEFQUF9TVE9SQUdFX1BSRUZJWCA9IFBBQ0tBR0VfTkFNRTtcblxuY29uc3QgTkFSUk9XX0xBWU9VVF9DVVRPRkYgPSA3MDA7XG5cbi8qKlxuICogT2JqZWN0IGhvbGRpbmcgcHJpdmF0ZSBtZW1iZXJzIGZvciB0aGUgW0FwcF17QGxpbmsgbW9kdWxlOmFwcH5BcHB9IGNsYXNzLlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmFwcH5BcHB+cHJpdmF0ZXNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fSB0YXNrcyBIb2xkcyB0aGUgdGFzayBjb250YWluZXIuXG4gKiBAcHJvcGVydHkge21vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH0gcHJvamVjdHMgSG9sZHMgdGhlIHByb2plY3RcbiAqICAgY29udGFpbmVyLlxuICogQHByb3BlcnR5IHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbFN0YWNrfSBtb2RhbFN0YWNrIFRoZSBzdGFjayBvZiBtb2RhbFxuICogICBkaWFsb2dzLlxuICogQHByb3BlcnR5IHttb2R1bGU6ZmlsdGVyTWVudX5GaWx0ZXJNZW51fSBmaWx0ZXJNZW51IFRoZSBtZW51IG9mIHRhc2sgZmlsdGVyc1xuICogICBpbiB0aGUgc2lkZSBwYW5lbC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmZpbHRlck1lbnV+RmlsdGVyTWVudX5maWx0ZXJJbmZvfSBjdXJyZW50RmlsdGVyIEhvbGRzIHRoZVxuICogICB0YXNrIGZpbHRlciB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQgaW4gdGhlIG1haW4gcGFuZWwuXG4gKiBAcHJvcGVydHkge21vZHVsZTp0YXNrRGlzcGxheX5UYXNrRGlzcGxheX0gdGFza0Rpc3BsYXkgSG9sZHMgdGhlIHRhc2tcbiAqICAgZGlzcGxheSBwYW5lbC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnNldHRpbmdzflNldHRpbmdzfSBzZXR0aW5ncyBIb2xkcyB1c2VyIGFwcCBzZXR0aW5ncy5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGFwcENvbnRhaW5lciBIb2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgRE9NIG5vZGVcbiAqICAgaG9sZGluZyB0aGUgcGFnZSBlbGVtZW50cyBmb3IgdGhlIGFwcC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHNpZGVQYW5lbCBIb2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgc2lkZSBwYW5lbFxuICogICBlbGVtZW50IGluIHRoZSBET00uXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSByZXNpemVyIEhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSByZXNpemluZyBiYXJcbiAqICAgZWxlbWVudCBmb3IgdGhlIHNpZGUgcGFuZWwuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBtYWluUGFuZWwgSG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIG1haW4gcGFuZWxcbiAqICAgZWxlbWVudCBpbiB0aGUgRE9NLlxuICogQHByb3BlcnR5IHttb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX0gbWFpblBhbmVsTWVudSBUaGUgcG9wdXAgbWVudSB0aGF0IGlzXG4gKiAgIHNob3duIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSAnbW9yZScgYnV0dG9uIGluIHRoZSBtYWluIHBhbmVsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBuYXJyb3dTY3JlZW4gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNjcmVlbiBzaXplIGlzXG4gKiAgIG5hcnJvdy4gVGhpcyBzaG91bGQgYmUgdHJ1ZSB3aGVuIHRoZSB2aWV3cG9ydCB3aWR0aCBpcyBsZXNzIHRoYW4gb3IgZXF1YWxcbiAqICAgdG8gTkFSUk9XX0xBWU9VVF9DVVRPRkYuXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBwcml2YXRlIGRhdGEgZm9yIHRoZSBbQXBwXXtAbGluayBtb2R1bGU6YXBwfkFwcH0gY2xhc3MuXG4gKiBAdHlwZSB7V2Vha01hcH1cbiAqIEBzZWUgbW9kdWxlOmFwcH5BcHB+cHJpdmF0ZXNcbiAqL1xuY29uc3QgcHJpdmF0ZU1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBhZGRSYW5kb21EYXRhKGluc3RhbmNlLCB0YXNrQ291bnQsIHByb2pDb3VudCkge1xuICBjb25zdCBnZXRSYW5kb20gPSAobWluLCBtYXgpID0+IChcbiAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pXG4gICk7XG4gIGNvbnN0IHBhc3NDaGVjayA9IChwcm9iYWJpbGl0eSkgPT4gTWF0aC5yYW5kb20oKSA8IHByb2JhYmlsaXR5O1xuXG4gIGNvbnN0IHNlbnRlbmNlcyA9IFtcbiAgICAnQ2FsbCBtZSBJc2htYWVsLicsXG4gICAgJ0l0IHdhcyB0aGUgYmVzdCBvZiB0aW1lcywgaXQgd2FzIHRoZSB3b3JzdCBvZiB0aW1lcywgaXQgd2FzIHRoZSBhZ2Ugb2Ygd2lzZG9tLCBpdCB3YXMgdGhlIGFnZSBvZiBmb29saXNobmVzcywgaXQgd2FzIHRoZSBlcG9jaCBvZiBiZWxpZWYsIGl0IHdhcyB0aGUgZXBvY2ggb2YgaW5jcmVkdWxpdHksIGl0IHdhcyB0aGUgc2Vhc29uIG9mIExpZ2h0LCBpdCB3YXMgdGhlIHNlYXNvbiBvZiBEYXJrbmVzcywgaXQgd2FzIHRoZSBzcHJpbmcgb2YgaG9wZSwgaXQgd2FzIHRoZSB3aW50ZXIgb2YgZGVzcGFpci4nLFxuICAgICdJdCBpcyBhIHRydXRoIHVuaXZlcnNhbGx5IGFja25vd2xlZGdlZCwgdGhhdCBhIHNpbmdsZSBtYW4gaW4gcG9zc2Vzc2lvbiBvZiBhIGdvb2QgZm9ydHVuZSwgbXVzdCBiZSBpbiB3YW50IG9mIGEgd2lmZS4nLFxuICAgICdJbiBteSB5b3VuZ2VyIGFuZCBtb3JlIHZ1bG5lcmFibGUgeWVhcnMgbXkgZmF0aGVyIGdhdmUgbWUgc29tZSBhZHZpY2UgdGhhdCBJXFwndmUgYmVlbiB0dXJuaW5nIG92ZXIgaW4gbXkgbWluZCBldmVyIHNpbmNlLicsXG4gICAgJ0l0IHdhcyBhIGJyaWdodCBjb2xkIGRheSBpbiBBcHJpbCwgYW5kIHRoZSBjbG9ja3Mgd2VyZSBzdHJpa2luZyB0aGlydGVlbi4nLFxuICAgICdJdCB3YXMgYSBwbGVhc3VyZSB0byBidXJuLicsXG4gICAgJ0FzIEdyZWdvciBTYW1zYSBhd29rZSBvbmUgbW9ybmluZyBmcm9tIHVuZWFzeSBkcmVhbXMgaGUgZm91bmQgaGltc2VsZiB0cmFuc2Zvcm1lZCBpbiBoaXMgYmVkIGludG8gYW4gZW5vcm1vdXMgaW5zZWN0LicsXG4gICAgJ0ZhciBvdXQgaW4gdGhlIHVuY2hhcnRlZCBiYWNrd2F0ZXJzIG9mIHRoZSB1bmZhc2hpb25hYmxlIGVuZCBvZiB0aGUgd2VzdGVybiBzcGlyYWwgYXJtIG9mIHRoZSBHYWxheHkgbGllcyBhIHNtYWxsLCB1bnJlZ2FyZGVkIHllbGxvdyBzdW4uJyxcbiAgICAnQWxsIGhhcHB5IGZhbWlsaWVzIGFyZSBhbGlrZTsgZWFjaCB1bmhhcHB5IGZhbWlseSBpcyB1bmhhcHB5IGluIGl0cyBvd24gd2F5JyxcbiAgICAnV2hldGhlciBJIHNoYWxsIHR1cm4gb3V0IHRvIGJlIHRoZSBoZXJvIG9mIG15IG93biBsaWZlLCBvciB3aGV0aGVyIHRoYXQgc3RhdGlvbiB3aWxsIGJlIGhlbGQgYnkgYW55Ym9keSBlbHNlLCB0aGVzZSBwYWdlcyBtdXN0IHNob3cuJyxcbiAgXTtcbiAgY29uc3QgcmFuZG9tU2VudGVuY2UgPSAoKSA9PiBzZW50ZW5jZXNbZ2V0UmFuZG9tKDAsIHNlbnRlbmNlcy5sZW5ndGggLSAxKV07XG5cbiAgY29uc3QgcmFuZG9tRGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIGFkZFRvRGF0ZSh0b2RheSwgeyBkYXlzOiBnZXRSYW5kb20oLTUsIDQwKSB9KTtcbiAgfTtcblxuICBjb25zdCByYW5kb21SZWN1cnJlbmNlID0gKCkgPT4ge1xuICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCk7XG4gICAgbGV0IHVuaXQ7XG4gICAgaWYgKHJhbmRvbSA8IDAuMjUpIHVuaXQgPSAnZGF5JztcbiAgICBlbHNlIGlmIChyYW5kb20gPCAwLjUpIHVuaXQgPSAnd2Vlayc7XG4gICAgZWxzZSBpZiAocmFuZG9tIDwgMC43NSkgdW5pdCA9ICdtb250aCc7XG4gICAgZWxzZSB1bml0ID0gJ3llYXInO1xuXG4gICAgcmV0dXJuIG5ldyBSZWN1cnJpbmdEYXRlKHVuaXQsIHtcbiAgICAgIGludGVydmFsTGVuZ3RoOiBwYXNzQ2hlY2soMC41KSA/IDEgOiBnZXRSYW5kb20oMiwgMTApLFxuICAgICAgc3RhcnREYXRlOiBwYXNzQ2hlY2soMC41KSA/IHJhbmRvbURhdGUoKSA6IG51bGwsXG4gICAgICBiYXNlT25Db21wbGV0aW9uOiBwYXNzQ2hlY2soMC4yNSksXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCBwcm9qZWN0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2pDb3VudDsgaSArPSAxKSB7XG4gICAgY29uc3QgcHJvamVjdCA9IG5ldyBQcm9qZWN0KGBQcm9qZWN0ICR7aSArIDF9YCwge1xuICAgICAgZGVzY3JpcHRpb246IHBhc3NDaGVjaygwLjUpID8gcmFuZG9tU2VudGVuY2UoKSA6IG51bGwsXG4gICAgfSk7XG4gICAgcHJvamVjdHMucHVzaChwcml2YXRlcy5wcm9qZWN0cy5hZGRQcm9qZWN0KHByb2plY3QpKTtcbiAgfVxuICBjb25zdCByYW5kb21Qcm9qZWN0ID0gKCkgPT4gcHJvamVjdHNbZ2V0UmFuZG9tKDAsIHByb2plY3RzLmxlbmd0aCAtIDEpXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhc2tDb3VudDsgaSArPSAxKSB7XG4gICAgY29uc3QgdGFzayA9IG5ldyBUYXNrKGBUYXNrICR7aSArIDF9YCwge1xuICAgICAgZHVlRGF0ZTogcGFzc0NoZWNrKDAuNSkgPyByYW5kb21EYXRlKCkgOiBudWxsLFxuICAgICAgY29tcGxldGlvbkRhdGU6IHBhc3NDaGVjaygwLjEpID8gbmV3IERhdGUoKSA6IG51bGwsXG4gICAgICBwcmlvcml0eTogZ2V0UmFuZG9tKC0yLCAyKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBwYXNzQ2hlY2soMC41KSA/IHJhbmRvbVNlbnRlbmNlKCkgOiBudWxsLFxuICAgICAgcmVjdXJyaW5nRGF0ZTogcGFzc0NoZWNrKDAuNSkgPyByYW5kb21SZWN1cnJlbmNlKCkgOiBudWxsLFxuICAgICAgcHJvamVjdDogcGFzc0NoZWNrKDAuNSkgPyByYW5kb21Qcm9qZWN0KCkgOiBudWxsLFxuICAgIH0pO1xuICAgIHByaXZhdGVzLnRhc2tzLmFkZFRhc2sodGFzayk7XG4gIH1cbn1cblxuLyoqXG4gKiBPcGVuIHRoZSBzaWRlIHBhbmVsLCBzbyB0aGF0IHRoZSBmaWx0ZXIgbWVudSBpcyB2aXNpYmxlLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZVxuICogICBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3BlblNpZGVQYW5lbChpbnN0YW5jZSkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIHByaXZhdGVzLnNpZGVQYW5lbC5jbGFzc0xpc3QucmVtb3ZlKCdjbG9zZWQnKTtcbiAgcHJpdmF0ZXMucmVzaXplci5jbGFzc0xpc3QucmVtb3ZlKCdjbG9zZWQnKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgc2lkZSBwYW5lbCwgc28gdGhhdCB0aGUgZmlsdGVyIG1lbnUgaXMgaGlkZGVuLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZVxuICogICBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2xvc2VTaWRlUGFuZWwoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBwcml2YXRlcy5zaWRlUGFuZWwuY2xhc3NMaXN0LmFkZCgnY2xvc2VkJyk7XG4gIHByaXZhdGVzLnJlc2l6ZXIuY2xhc3NMaXN0LmFkZCgnY2xvc2VkJyk7XG59XG5cbi8qKlxuICogVG9nZ2xlIHRoZSBzaWRlIHBhbmVsJ3MgdmlzaWJpbGl0eS5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZVNpZGVQYW5lbChpbnN0YW5jZSkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGNvbnN0IGNsb3NlZCA9IHByaXZhdGVzLnNpZGVQYW5lbC5jbGFzc0xpc3QudG9nZ2xlKCdjbG9zZWQnKTtcbiAgaWYgKGNsb3NlZCkgcHJpdmF0ZXMucmVzaXplci5jbGFzc0xpc3QuYWRkKCdjbG9zZWQnKTtcbiAgZWxzZSBwcml2YXRlcy5yZXNpemVyLmNsYXNzTGlzdC5yZW1vdmUoJ2Nsb3NlZCcpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgbWVudSBpdGVtcyBpbiB0aGUgcG9wdXAgbWVudSBmb3IgdGhlIG1haW4gcGFuZWwgYmFzZWQgb24gdGhlXG4gKiBzZWxlY3RlZCBmaWx0ZXIuXG4gKiBAcGFyYW0ge21vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG8gYXBwbHkgdGhlXG4gKiAgIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB1cGRhdGVNYWluUGFuZWxNZW51KGluc3RhbmNlKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgeyBncm91cCwgZmlsdGVyIH0gPSBwcml2YXRlcy5jdXJyZW50RmlsdGVyO1xuICBjb25zdCBmaWx0ZXJPcHRpb25zID0gcHJpdmF0ZXMuc2V0dGluZ3MuZ2V0RmlsdGVyT3B0aW9ucyhncm91cCk7XG5cbiAgY29uc3QgR1JPVVBfSUNPTiA9ICdjYXRlZ29yeSc7XG4gIGNvbnN0IFNPUlRfSUNPTiA9ICdzb3J0JztcblxuICBjb25zdCB7XG4gICAgZ3JvdXBCeSwgc29ydEJ5LCBzb3J0RGVzY2VuZGluZywgc2hvd0NvbXBsZXRlZCxcbiAgfSA9IGZpbHRlck9wdGlvbnM7XG4gIGNvbnN0IG9wdGlvbkl0ZW1zID0gW1xuICAgIHsgbGFiZWw6ICdBZGQgVGFzay4uLicsIGlkOiAnYWRkLXRhc2snLCBpY29uVHlwZTogJ2FkZCcgfSxcbiAgICB7IGxhYmVsOiAnQWRkIFByb2plY3QuLi4nLCBpZDogJ2FkZC1wcm9qZWN0JywgaWNvblR5cGU6ICdhZGQnIH0sXG4gIF07XG4gIGNvbnN0IGdyb3VwQnlJdGVtcyA9IFtdO1xuICBjb25zdCBzb3J0QnlJdGVtcyA9IFtdO1xuXG4gIGlmIChncm91cCA9PT0gJ3Byb2plY3RzJyAmJiBmaWx0ZXIgIT09ICdub25lJykge1xuICAgIG9wdGlvbkl0ZW1zLnB1c2goe1xuICAgICAgbGFiZWw6ICdFZGl0IFByb2plY3QuLi4nLFxuICAgICAgaWQ6ICdlZGl0LXByb2plY3QnLFxuICAgICAgaWNvblR5cGU6ICdlZGl0JyxcbiAgICB9KTtcbiAgICBvcHRpb25JdGVtcy5wdXNoKHtcbiAgICAgIGxhYmVsOiAnRGVsZXRlIFByb2plY3QuLi4nLFxuICAgICAgaWQ6ICdkZWxldGUtcHJvamVjdCcsXG4gICAgICBpY29uVHlwZTogJ2RlbGV0ZScsXG4gICAgfSk7XG4gIH1cblxuICBvcHRpb25JdGVtcy5wdXNoKFxuICAgIHtcbiAgICAgIGxhYmVsOiBzaG93Q29tcGxldGVkID8gJ0hpZGUgQ29tcGxldGVkIFRhc2tzJyA6ICdTaG93IENvbXBsZXRlZCBUYXNrcycsXG4gICAgICBpZDogc2hvd0NvbXBsZXRlZCA/ICdoaWRlLWNvbXBsZXRlZCcgOiAnc2hvdy1jb21wbGV0ZWQnLFxuICAgICAgaWNvblR5cGU6ICdkb25lJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBzb3J0RGVzY2VuZGluZyA/ICdTb3J0IEFzY2VuZGluZycgOiAnU29ydCBEZXNjZW5kaW5nJyxcbiAgICAgIGlkOiBzb3J0RGVzY2VuZGluZyA/ICdzb3J0LWFzY2VuZGluZycgOiAnc29ydC1kZXNjZW5kaW5nJyxcbiAgICAgIGljb25UeXBlOiAnc3dhcF92ZXJ0JyxcbiAgICB9LFxuICApO1xuXG4gIGlmIChncm91cEJ5ICE9PSAnZGVmYXVsdCcpIHtcbiAgICBncm91cEJ5SXRlbXMucHVzaCh7XG4gICAgICBsYWJlbDogJ1VzZSBEZWZhdWx0IEdyb3VwaW5nJyxcbiAgICAgIGlkOiAnZ3JvdXAtYnktZGVmYXVsdCcsXG4gICAgICBpY29uVHlwZTogR1JPVVBfSUNPTixcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChncm91cEJ5ICE9PSAnbm9uZScpIHtcbiAgICBncm91cEJ5SXRlbXMucHVzaCh7XG4gICAgICBsYWJlbDogJ0RvIE5vdCBHcm91cCBUYXNrcycsXG4gICAgICBpZDogJ2dyb3VwLWJ5LW5vbmUnLFxuICAgICAgaWNvblR5cGU6IEdST1VQX0lDT04sXG4gICAgfSk7XG4gIH1cblxuICBpZiAoc29ydEJ5ICE9PSAnY3JlYXRlLWRhdGUnKSB7XG4gICAgc29ydEJ5SXRlbXMucHVzaCh7XG4gICAgICBsYWJlbDogJ1NvcnQgYnkgRGF0ZSBBZGRlZCcsXG4gICAgICBpZDogJ3NvcnQtYnktY3JlYXRlLWRhdGUnLFxuICAgICAgaWNvblR5cGU6IFNPUlRfSUNPTixcbiAgICB9KTtcbiAgfVxuXG4gIGlmICgoZ3JvdXAgIT09ICdkYXRlcycgfHwgZmlsdGVyICE9PSAncGFzdC1kdWUnKSAmJiBncm91cEJ5ICE9PSAnZHVlLWRhdGUnKSB7XG4gICAgZ3JvdXBCeUl0ZW1zLnB1c2goe1xuICAgICAgbGFiZWw6ICdHcm91cCBieSBEdWUgRGF0ZScsXG4gICAgICBpZDogJ2dyb3VwLWJ5LWR1ZS1kYXRlJyxcbiAgICAgIGljb25UeXBlOiBHUk9VUF9JQ09OLFxuICAgIH0pO1xuICAgIGlmIChzb3J0QnkgIT09ICdkdWUtZGF0ZScpIHtcbiAgICAgIHNvcnRCeUl0ZW1zLnB1c2goe1xuICAgICAgICBsYWJlbDogJ1NvcnQgYnkgRHVlIERhdGUnLFxuICAgICAgICBpZDogJ3NvcnQtYnktZHVlLWRhdGUnLFxuICAgICAgICBpY29uVHlwZTogU09SVF9JQ09OLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGdyb3VwICE9PSAncHJvamVjdHMnICYmIGdyb3VwQnkgIT09ICdwcm9qZWN0Jykge1xuICAgIGdyb3VwQnlJdGVtcy5wdXNoKHtcbiAgICAgIGxhYmVsOiAnR3JvdXAgYnkgUHJvamVjdCcsXG4gICAgICBpZDogJ2dyb3VwLWJ5LXByb2plY3QnLFxuICAgICAgaWNvblR5cGU6IEdST1VQX0lDT04sXG4gICAgfSk7XG4gICAgaWYgKHNvcnRCeSAhPT0gJ3Byb2plY3QnKSB7XG4gICAgICBzb3J0QnlJdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWw6ICdTb3J0IGJ5IFByb2plY3QnLFxuICAgICAgICBpZDogJ3NvcnQtYnktcHJvamVjdCcsXG4gICAgICAgIGljb25UeXBlOiBTT1JUX0lDT04sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZ3JvdXAgIT09ICdwcmlvcml0aWVzJyAmJiBncm91cEJ5ICE9PSAncHJpb3JpdHknKSB7XG4gICAgZ3JvdXBCeUl0ZW1zLnB1c2goe1xuICAgICAgbGFiZWw6ICdHcm91cCBieSBQcmlvcml0eScsXG4gICAgICBpZDogJ2dyb3VwLWJ5LXByaW9yaXR5JyxcbiAgICAgIGljb25UeXBlOiBHUk9VUF9JQ09OLFxuICAgIH0pO1xuICAgIGlmIChzb3J0QnkgIT09ICdwcmlvcml0eScpIHtcbiAgICAgIHNvcnRCeUl0ZW1zLnB1c2goe1xuICAgICAgICBsYWJlbDogJ1NvcnQgYnkgUHJpb3JpdHknLFxuICAgICAgICBpZDogJ3NvcnQtYnktcHJpb3JpdHknLFxuICAgICAgICBpY29uVHlwZTogU09SVF9JQ09OLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWVudUl0ZW1zID0gWy4uLm9wdGlvbkl0ZW1zLCAuLi5ncm91cEJ5SXRlbXMsIC4uLnNvcnRCeUl0ZW1zXTtcbiAgcHJpdmF0ZXMubWFpblBhbmVsTWVudS5zZXRNZW51SXRlbXMobWVudUl0ZW1zKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGhlYWRpbmcgaW4gdGhlIG1haW4gcGFuZWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGluZyBUaGUgbmV3IGhlYWRpbmcgdG8gZGlzcGxheS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3ViaGVhZGluZ10gVGhlIG5ldyBzdWJoZWFkaW5nIHRvIGRpc3BsYXksIGlmIGFueS5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlTWFpbkhlYWRpbmcoaGVhZGluZywgc3ViaGVhZGluZykge1xuICBjb25zdCBoZWFkaW5nRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluLXBhbmVsLWhlYWRpbmcnKTtcbiAgY29uc3Qgc3ViaGVhZGluZ0VsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbi1wYW5lbC1zdWJoZWFkaW5nJyk7XG4gIGhlYWRpbmdFbGVtLnRleHRDb250ZW50ID0gaGVhZGluZztcbiAgaWYgKHN1YmhlYWRpbmcpIHtcbiAgICBzdWJoZWFkaW5nRWxlbS50ZXh0Q29udGVudCA9IHN1YmhlYWRpbmc7XG4gICAgc3ViaGVhZGluZ0VsZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH0gZWxzZSB7XG4gICAgc3ViaGVhZGluZ0VsZW0udGV4dENvbnRlbnQgPSAnJztcbiAgICBzdWJoZWFkaW5nRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgbWFpbiBwYW5lbC5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIEFuIG9iamVjdCBob2xkaW5nIG9wdGlvbnMgZm9yIHRoZSBtYWluIHBhbmVsLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNldFNjcm9sbD10cnVlXSBJZiBzZXQgdG8gdHJ1ZSAodGhlIGRlZmF1bHQpLFxuICogICB0aGVuIHRoZSBwYW5lbCdzIHNjcm9sbCBwb3NpdGlvbiB3aWxsIGJlIHJlc2V0IGJhY2sgdG8gdGhlIHRvcC4gT3RoZXJ3aXNlXG4gKiAgIHRoZSBzY3JvbGwgcG9zaXRpb24gd2lsbCBub3QgYmUgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlTWFpblBhbmVsKGluc3RhbmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCB7IGdyb3VwLCBmaWx0ZXIgfSA9IHByaXZhdGVzLmN1cnJlbnRGaWx0ZXI7XG5cbiAgbGV0IGhlYWRpbmcgPSBudWxsO1xuICBsZXQgc3ViaGVhZGluZyA9IG51bGw7XG4gIGNvbnN0IGRpc3BsYXlPcHRpb25zID0ge1xuICAgIGdyb3VwQnk6ICdub25lJyxcbiAgICByZXNldFNjcm9sbDogb3B0aW9ucy5yZXNldFNjcm9sbCA/PyB0cnVlLFxuICAgIGRhdGVGb3JtYXQ6IHByaXZhdGVzLnNldHRpbmdzLmRhdGVGb3JtYXQsXG4gIH07XG4gIGxldCBmaWx0ZXJPcHRpb25zO1xuICBzd2l0Y2ggKGdyb3VwKSB7XG4gICAgY2FzZSAnZGF0ZXMnOiB7XG4gICAgICBmaWx0ZXJPcHRpb25zID0gcHJpdmF0ZXMuc2V0dGluZ3MuZ2V0RmlsdGVyT3B0aW9ucygnZGF0ZXMnKTtcbiAgICAgIGNvbnN0IHRvZGF5ID0gc3RhcnRPZkRheShuZXcgRGF0ZSgpKTtcbiAgICAgIGNvbnN0IHRvZGF5RW5kID0gZW5kT2ZEYXkodG9kYXkpO1xuXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHt9O1xuICAgICAgc3dpdGNoIChmaWx0ZXIpIHtcbiAgICAgICAgY2FzZSAndG9kYXknOlxuICAgICAgICAgIGhlYWRpbmcgPSAnVG9kYXknO1xuICAgICAgICAgIHN1YmhlYWRpbmcgPSBmb3JtYXREYXRlKHRvZGF5LCAnZWVlZSwgTU1NTSBkLCB5eXl5Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgIGhlYWRpbmcgPSAnVGhpcyBXZWVrJztcbiAgICAgICAgICBkaXNwbGF5T3B0aW9ucy5ncm91cEJ5ID0gJ2R1ZS1kYXRlJztcbiAgICAgICAgICBkdXJhdGlvbi53ZWVrcyA9IDE7XG4gICAgICAgICAgZHVyYXRpb24uZGF5cyA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgaGVhZGluZyA9ICdUaGlzIE1vbnRoJztcbiAgICAgICAgICBkaXNwbGF5T3B0aW9ucy5ncm91cEJ5ID0gJ2R1ZS1kYXRlJztcbiAgICAgICAgICBkdXJhdGlvbi5tb250aHMgPSAxO1xuICAgICAgICAgIGR1cmF0aW9uLmRheXMgPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncGFzdC1kdWUnOlxuICAgICAgICAgIGhlYWRpbmcgPSAnUGFzdCBEdWUnO1xuICAgICAgICAgIGR1cmF0aW9uLmRheXMgPSAtMTtcbiAgICAgICAgICBkaXNwbGF5T3B0aW9ucy5yZXF1aXJlRHVlRGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkaXNwbGF5T3B0aW9ucy5lbmREYXRlID0gYWRkVG9EYXRlKHRvZGF5RW5kLCBkdXJhdGlvbik7XG5cbiAgICAgIGlmIChmaWx0ZXIgIT09ICd0b2RheScgJiYgZmlsdGVyICE9PSAncGFzdC1kdWUnKSB7XG4gICAgICAgIGNvbnN0IGRhdGVGb3JtYXQgPSBwcml2YXRlcy5zZXR0aW5ncy5kYXRlRm9ybWF0Lm91dHB1dFBhdHRlcm47XG4gICAgICAgIGNvbnN0IHN0YXJ0U3RyID0gZm9ybWF0RGF0ZSh0b2RheSwgZGF0ZUZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGVuZFN0ciA9IGZvcm1hdERhdGUoZGlzcGxheU9wdGlvbnMuZW5kRGF0ZSwgZGF0ZUZvcm1hdCk7XG4gICAgICAgIHN1YmhlYWRpbmcgPSBgJHtzdGFydFN0cn0gdG8gJHtlbmRTdHJ9YDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdwcm9qZWN0cyc6XG4gICAgICBmaWx0ZXJPcHRpb25zID0gcHJpdmF0ZXMuc2V0dGluZ3MuZ2V0RmlsdGVyT3B0aW9ucygncHJvamVjdHMnKTtcbiAgICAgIGRpc3BsYXlPcHRpb25zLnByb2plY3QgPSBmaWx0ZXI7XG4gICAgICBpZiAoZmlsdGVyID09PSAnbm9uZScpIHtcbiAgICAgICAgaGVhZGluZyA9ICdVbmNhdGVnb3JpemVkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb2plY3QgPSBwcml2YXRlcy5wcm9qZWN0cy5nZXRQcm9qZWN0KGZpbHRlcik7XG4gICAgICAgIGhlYWRpbmcgPSBwcm9qZWN0Lm5hbWU7XG4gICAgICAgIHN1YmhlYWRpbmcgPSBwcm9qZWN0LmRlc2NyaXB0aW9uIHx8IG51bGw7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcmlvcml0aWVzJzoge1xuICAgICAgZmlsdGVyT3B0aW9ucyA9IHByaXZhdGVzLnNldHRpbmdzLmdldEZpbHRlck9wdGlvbnMoJ3ByaW9yaXRpZXMnKTtcbiAgICAgIGNvbnN0IHByaW9yaXR5ID0gVGFzay5jb252ZXJ0U3RyaW5nVG9Qcmlvcml0eShmaWx0ZXIpO1xuICAgICAgZGlzcGxheU9wdGlvbnMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgIGhlYWRpbmcgPSBgJHtUYXNrLmNvbnZlcnRQcmlvcml0eVRvUHJldHR5U3RyaW5nKHByaW9yaXR5KX0gUHJpb3JpdHlgO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgIGRlZmF1bHQ6XG4gICAgICBmaWx0ZXJPcHRpb25zID0gcHJpdmF0ZXMuc2V0dGluZ3MuZ2V0RmlsdGVyT3B0aW9ucygnZGVmYXVsdCcpO1xuICAgICAgaGVhZGluZyA9ICdBbGwgVGFza3MnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBPdmVycmlkZSBncm91cGluZyBpZiBuZWVkZWRcbiAgaWYgKGZpbHRlck9wdGlvbnMuZ3JvdXBCeSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgZGlzcGxheU9wdGlvbnMuZ3JvdXBCeSA9IGZpbHRlck9wdGlvbnMuZ3JvdXBCeTtcbiAgfVxuXG4gIGRpc3BsYXlPcHRpb25zLnNvcnRCeSA9IGZpbHRlck9wdGlvbnMuc29ydEJ5O1xuICBkaXNwbGF5T3B0aW9ucy5jb21wbGV0ZWQgPSBmaWx0ZXJPcHRpb25zLnNob3dDb21wbGV0ZWQ7XG4gIGRpc3BsYXlPcHRpb25zLnNvcnREZXNjZW5kaW5nID0gZmlsdGVyT3B0aW9ucy5zb3J0RGVzY2VuZGluZztcblxuICB1cGRhdGVNYWluSGVhZGluZyhoZWFkaW5nLCBzdWJoZWFkaW5nKTtcbiAgcHJpdmF0ZXMudGFza0Rpc3BsYXkudXBkYXRlKGRpc3BsYXlPcHRpb25zKTtcblxuICB1cGRhdGVNYWluUGFuZWxNZW51KGluc3RhbmNlKTtcbn1cblxuLyoqXG4gKiBSZWZyZXNoIHRoZSBsaXN0IG9mIHByb2plY3RzIGluIHRoZSBmaWx0ZXIgbWVudS5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVByb2plY3RGaWx0ZXJzKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3Qgc2VsZWN0aW9uID0gcHJpdmF0ZXMuZmlsdGVyTWVudS5nZXRTZWxlY3Rpb24oKTtcblxuICBwcml2YXRlcy5maWx0ZXJNZW51LnJlbW92ZUFsbEZpbHRlcnMoJ3Byb2plY3RzJyk7XG4gIHByaXZhdGVzLmZpbHRlck1lbnUuYWRkRmlsdGVyKCdwcm9qZWN0cycsICdub25lJywgJ1VuY2F0ZWdvcml6ZWQnKTtcbiAgcHJpdmF0ZXMucHJvamVjdHMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICBwcml2YXRlcy5maWx0ZXJNZW51LmFkZEZpbHRlcigncHJvamVjdHMnLCBlbnRyeS5pZCwgZW50cnkucHJvamVjdC5uYW1lKTtcbiAgfSk7XG5cbiAgLy8gUmVzdG9yZSBzZWxlY3Rpb25cbiAgaWYgKHNlbGVjdGlvbi5ncm91cCA9PT0gJ3Byb2plY3RzJykge1xuICAgIGNvbnN0IHsgZmlsdGVyIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKHByaXZhdGVzLmZpbHRlck1lbnUuaGFzRmlsdGVyKCdwcm9qZWN0cycsIGZpbHRlcikpIHtcbiAgICAgIHByaXZhdGVzLmZpbHRlck1lbnUuc2VsZWN0RmlsdGVyKCdwcm9qZWN0cycsIGZpbHRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaXZhdGVzLmZpbHRlck1lbnUuc2VsZWN0RmlsdGVyKCdwcm9qZWN0cycsICdub25lJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwb3J0IGFwcCBkYXRhIHRvIGEgSlNPTiBmaWxlLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIFtBcHBde0BsaW5rIG1vZHVsZTphcHB+QXBwfSBpbnN0YW5jZVxuICogICB3aG9zZSBkYXRhIGlzIHRvIGJlIGV4cG9ydGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3QgaG9sZGluZyBhZGRpdGlvbmFsIGZpbGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uZXdsaW5lU2VxdWVuY2VdIFRoZSBjaGFyYWN0ZXIgc2VxdWVuY2UgdG8gdXNlIGZvclxuICogICBuZXdsaW5lcy5cbiAqL1xuZnVuY3Rpb24gZXhwb3J0VG9Kc29uKGluc3RhbmNlLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IG91dHB1dCA9IGAke0pTT04uc3RyaW5naWZ5KGluc3RhbmNlLCBudWxsLCAyKX1cXG5gO1xuXG4gIGlmIChvcHRpb25zLm5ld2xpbmVTZXF1ZW5jZSkge1xuICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXG4vZywgb3B0aW9ucy5uZXdsaW5lU2VxdWVuY2UpO1xuICB9XG5cbiAgZ2VuZXJhdGVGaWxlKFxuICAgIG91dHB1dCxcbiAgICAndGFza3MuanNvbicsXG4gICAgJ2FwcGxpY2F0aW9uL2pzb24nLFxuICApO1xufVxuXG4vKipcbiAqIEV4cG9ydCBhcHAgZGF0YSB0byBhIENTViBmaWxlLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIFtBcHBde0BsaW5rIG1vZHVsZTphcHB+QXBwfSBpbnN0YW5jZVxuICogICB3aG9zZSBkYXRhIGlzIHRvIGJlIGV4cG9ydGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3QgaG9sZGluZyBhZGRpdGlvbmFsIGZpbGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uZXdsaW5lU2VxdWVuY2VdIFRoZSBjaGFyYWN0ZXIgc2VxdWVuY2UgdG8gdXNlIGZvclxuICogICBuZXdsaW5lcy5cbiAqL1xuZnVuY3Rpb24gZXhwb3J0VG9Dc3YoaW5zdGFuY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHRhc2tzLCBwcm9qZWN0cyB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3Qgb3V0cHV0ID0gdGFza3MudG9Dc3Yoe1xuICAgIG5ld2xpbmVTZXF1ZW5jZTogb3B0aW9ucy5uZXdsaW5lU2VxdWVuY2UgPz8gJ1xcclxcbicsXG4gICAgcHJvamVjdExpc3Q6IHByb2plY3RzLFxuICB9KTtcblxuICBnZW5lcmF0ZUZpbGUoXG4gICAgb3V0cHV0LFxuICAgICd0YXNrcy5jc3YnLFxuICAgICd0ZXh0L2NzdicsXG4gICk7XG59XG5cbi8qKlxuICogSW1wb3J0IGFwcCBkYXRhIGZyb20gYSBzdHJpbmcgaW4gSlNPTiBmb3JtYXQuXG4gKiBAcGFyYW0ge21vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBUaGUgW0FwcF17QGxpbmsgbW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIGluXG4gKiAgIHdoaWNoIHRvIGltcG9ydCB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBhcHAgZGF0YSBpbiBKU09OIGZvcm1hdC5cbiAqIEByZXR1cm5zIHttb2R1bGU6YXBwfkFwcH5pbXBvcnRTdGF0dXN9IEFuIG9iamVjdCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0XG4gKiAgIHRoZSBzdGF0dXMgb2YgdGhlIGltcG9ydC5cbiAqL1xuZnVuY3Rpb24gaW1wb3J0RnJvbUpzb24oaW5zdGFuY2UsIGRhdGEpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCB0YXNrQ291bnRzID0ge1xuICAgIGFkZGVkOiAwLFxuICAgIHVwZGF0ZWQ6IDAsXG4gICAgZmFpbGVkOiAwLFxuICAgIHRvdGFsOiAwLFxuICB9O1xuICBjb25zdCBwcm9qZWN0Q291bnRzID0geyAuLi50YXNrQ291bnRzIH07XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gIHRyeSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwLFxuICAgICAgc2V0dGluZ3MsXG4gICAgICB0YXNrcyxcbiAgICAgIHByb2plY3RzLFxuICAgIH0gPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgaWYgKGFwcD8ubmFtZSAhPT0gQVBQX05BTUUgfHwgIXNlbXZlci52YWxpZChhcHA/LnZlcnNpb24pKSB7XG4gICAgICBlcnJvcnMucHVzaCgnV2FybmluZzogSW1wb3J0ZWQgZGF0YSBkb2VzIG5vdCBmb2xsb3cgdGhlIGV4cGVjdGVkIHNjaGVtYS4gVGhlIGRhdGEgbWF5IGhhdmUgYmVlbiBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50IGFwcGxpY2F0aW9uLCBvciBtYXkgaGF2ZSBiZWVuIGFsdGVyZWQuJyk7XG4gICAgfSBlbHNlIGlmIChzZW12ZXIuZ3QoYXBwLnZlcnNpb24sIEFQUF9WRVJTSU9OKSkge1xuICAgICAgZXJyb3JzLnB1c2goJ1dhcm5pbmc6IEltcG9ydGVkIGRhdGEgc2VlbXMgdG8gaGF2ZSBiZWVuIGNyZWF0ZWQgYnkgYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBhcHBsaWNhdGlvbi4gU29tZSBpbmZvcm1hdGlvbiBtaWdodCBub3QgYmUgaW1wb3J0ZWQgb3IgbWlnaHQgYmUgaW1wb3J0ZWQgaW5jb3JyZWN0bHkuJyk7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHByaXZhdGVzLnNldHRpbmdzLmltcG9ydEZyb21Kc29uKHNldHRpbmdzKTtcbiAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgIH1cblxuICAgIGlmIChwcm9qZWN0cyAhPSBudWxsKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwcml2YXRlcy5wcm9qZWN0cy5pbXBvcnRGcm9tSnNvbihwcm9qZWN0cyk7XG4gICAgICBPYmplY3QuYXNzaWduKHByb2plY3RDb3VudHMsIHJlc3VsdC5wcm9qZWN0cyk7XG4gICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICB9XG5cbiAgICBpZiAodGFza3MgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcHJpdmF0ZXMudGFza3MuaW1wb3J0RnJvbUpzb24odGFza3MsIHtcbiAgICAgICAgcHJvamVjdExpc3Q6IHByaXZhdGVzLnByb2plY3RzLFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuYXNzaWduKHRhc2tDb3VudHMsIHJlc3VsdC50YXNrcyk7XG4gICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2Vzc2Z1bDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogJ2pzb24nLFxuICAgICAgdGFza3M6IHRhc2tDb3VudHMsXG4gICAgICBwcm9qZWN0czogcHJvamVjdENvdW50cyxcbiAgICAgIGVycm9ycyxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogJ2pzb24nLFxuICAgICAgICB0YXNrczogdGFza0NvdW50cyxcbiAgICAgICAgcHJvamVjdHM6IHByb2plY3RDb3VudHMsXG4gICAgICAgIGVycm9yczogW2BGYXRhbCBFcnJvcjogJHtlLm1lc3NhZ2V9YF0sXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogSW1wb3J0IGFwcCBkYXRhIGZyb20gYSBDU1Ygc3RyaW5nLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIFtBcHBde0BsaW5rIG1vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBpblxuICogICB3aGljaCB0byBpbXBvcnQgdGhlIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBUaGUgYXBwIGRhdGEgaW4gQ1NWIGZvcm1hdC5cbiAqIEByZXR1cm5zIHttb2R1bGU6YXBwfkFwcH5pbXBvcnRTdGF0dXN9IEFuIG9iamVjdCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0XG4gKiAgIHRoZSBzdGF0dXMgb2YgdGhlIGltcG9ydC5cbiAqL1xuZnVuY3Rpb24gaW1wb3J0RnJvbUNzdihpbnN0YW5jZSwgZGF0YSkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGNvbnN0IHRhc2tDb3VudHMgPSB7XG4gICAgYWRkZWQ6IDAsXG4gICAgdXBkYXRlZDogMCxcbiAgICBmYWlsZWQ6IDAsXG4gICAgdG90YWw6IDAsXG4gIH07XG4gIGNvbnN0IHByb2plY3RDb3VudHMgPSB7IC4uLnRhc2tDb3VudHMgfTtcbiAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgY29uc3QgcGFyc2VkRGF0YSA9IHBhcnNlQ3N2KGRhdGEpO1xuICBsZXQgcmVzdWx0O1xuXG4gIHJlc3VsdCA9IHByaXZhdGVzLnByb2plY3RzLmltcG9ydEZyb21Dc3YocGFyc2VkRGF0YSk7XG4gIE9iamVjdC5hc3NpZ24ocHJvamVjdENvdW50cywgcmVzdWx0LnByb2plY3RzKTtcbiAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG5cbiAgcmVzdWx0ID0gcHJpdmF0ZXMudGFza3MuaW1wb3J0RnJvbUNzdihcbiAgICBwYXJzZWREYXRhLFxuICAgIHsgcHJvamVjdExpc3Q6IHByaXZhdGVzLnByb2plY3RzIH0sXG4gICk7XG4gIE9iamVjdC5hc3NpZ24odGFza0NvdW50cywgcmVzdWx0LnRhc2tzKTtcbiAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzZnVsOiB0cnVlLFxuICAgIGZvcm1hdDogJ2NzdicsXG4gICAgdGFza3M6IHRhc2tDb3VudHMsXG4gICAgcHJvamVjdHM6IHByb2plY3RDb3VudHMsXG4gICAgZXJyb3JzLFxuICB9O1xufVxuXG4vKipcbiAqIEltcG9ydCBhcHAgZGF0YSBmcm9tIGEgZmlsZS4gVGhpcyBmdW5jdGlvbiB3aWxsIGF0dGVtcHQgdG8gZGV0ZXJtaW5lIHdoZXRoZXJcbiAqIHRoZSBmaWxlIGlzIGluIEpTT04gb3IgQ1NWIGZvcm1hdCwgZmlyc3QgdXNpbmcgdGhlIGZpbGUgZXh0ZW5zaW9uIGFuZCxcbiAqIGZhaWxpbmcgdGhhdCwgYnkgZXhhbWluaW5nIHRoZSBjb250ZW50cy5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBbQXBwXXtAbGluayBtb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgaW5cbiAqICAgd2hpY2ggdG8gaW1wb3J0IHRoZSBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgVGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIGJlaW5nIGltcG9ydGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSBUaGUgbmFtZSBvZiB0aGUgZmlsZSBiZWluZyBpbXBvcnRlZC5cbiAqIEByZXR1cm5zIHttb2R1bGU6YXBwfkFwcH5pbXBvcnRTdGF0dXN9IEFuIG9iamVjdCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0XG4gKiAgIHRoZSBzdGF0dXMgb2YgdGhlIGltcG9ydC5cbiAqL1xuZnVuY3Rpb24gaW1wb3J0RnJvbUZpbGUoaW5zdGFuY2UsIGNvbnRlbnQsIG5hbWUpIHtcbiAgY29uc3QgZmlsZUV4dCA9IG5hbWUgPyBnZXRGaWxlRXh0ZW5zaW9uKG5hbWUpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgc3dpdGNoIChmaWxlRXh0KSB7XG4gICAgY2FzZSAnLmpzb24nOiByZXR1cm4gaW1wb3J0RnJvbUpzb24oaW5zdGFuY2UsIGNvbnRlbnQpO1xuICAgIGNhc2UgJy5jc3YnOiByZXR1cm4gaW1wb3J0RnJvbUNzdihpbnN0YW5jZSwgY29udGVudCk7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IHJlc3VsdCA9IGltcG9ydEZyb21Kc29uKGluc3RhbmNlLCBjb250ZW50KTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgcmVzdWx0ID0gaW1wb3J0RnJvbUNzdihpbnN0YW5jZSwgY29udGVudCk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICBjb25zdCBjb3VudHMgPSB7XG4gICAgICAgICAgICBhZGRlZDogMCxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IDAsXG4gICAgICAgICAgICBmYWlsZWQ6IDAsXG4gICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcm1hdDogJ3Vua25vd24nLFxuICAgICAgICAgICAgdGFza3M6IHsgLi4uY291bnRzIH0sXG4gICAgICAgICAgICBwcm9qZWN0czogeyAuLi5jb3VudHMgfSxcbiAgICAgICAgICAgIGVycm9yczogWydGYXRhbCBFcnJvcjogVW5hYmxlIHRvIGRldGVybWluZSBmaWxlIGZvcm1hdC4gSW1wb3J0ZWQgZGF0YSBtdXN0IGJlIGluIGVpdGhlciBKU09OIG9yIENTViBmb3JtYXQuJ10sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYWxsIHVzZXIgZGF0YS5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZUFsbERhdGEoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBwcml2YXRlcy5zZXR0aW5ncy5yZXNldFRvRGVmYXVsdCgpO1xuICBwcml2YXRlcy50YXNrcy5kZWxldGVBbGwoKTtcbiAgcHJpdmF0ZXMucHJvamVjdHMuZGVsZXRlQWxsKCk7XG4gIHVwZGF0ZVByb2plY3RGaWx0ZXJzKGluc3RhbmNlKTtcbiAgdXBkYXRlTWFpblBhbmVsKGluc3RhbmNlKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGEgbW9kYWwgY29uZmlybWF0aW9uIGRpYWxvZy5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5IHRvIHRoZSB1c2VyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29uQ29uZmlybV0gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlXG4gKiAgIHVzZXIgY29uZmlybXMgdGhlIG1vZGFsLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29uQ2FuY2VsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgdXNlclxuICogICBjYW5jZWxzIHRoZSBtb2RhbC5cbiAqL1xuZnVuY3Rpb24gc2hvd0NvbmZpcm1hdGlvbihpbnN0YW5jZSwgbWVzc2FnZSwgb25Db25maXJtLCBvbkNhbmNlbCkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGNvbnN0IG1vZGFsID0gbmV3IENvbmZpcm1Nb2RhbChtZXNzYWdlLCB7XG4gICAgY29uZmlybTogb25Db25maXJtIHx8IG51bGwsXG4gICAgY2FuY2VsOiBvbkNhbmNlbCB8fCBudWxsLFxuICB9KTtcbiAgcHJpdmF0ZXMubW9kYWxTdGFjay5zaG93TW9kYWwobW9kYWwpO1xufVxuXG4vKipcbiAqIERpc3BsYXkgdGhlIG1vZGFsIGRpYWxvZyBmb3IgYWRkaW5nIG9yIGVkaXRpbmcgYSB0YXNrLiBBZnRlciB0aGUgdXNlclxuICogY29uZmlybXMgdGhlIGRpYWxvZywgdGhlIHRhc2sgaXMgYWRkZWQgdG8gdGhlIHRhc2sgbGlzdC5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIEFuIG9iamVjdCBob2xkaW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZVxuICogICBtb2RhbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50YXNrSWRdIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgdGFzayB0byBlZGl0LCBpZlxuICogICBhbnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvamVjdElkXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGRlZmF1bHQgcHJvamVjdFxuICogICB0aGF0IHRoZSB0YXNrIHNob3VsZCBiZSBhc3NpZ25lZCB0bywgaWYgYW55LiBJZiBhIHRhc2sgaWQgd2FzIGdpdmVuLFxuICogICB0aGVuIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucHJpb3JpdHk9MF0gVGhlIGRlZmF1bHQgcHJpb3JpdHkgZm9yIHRoZSB0YXNrLiBJZlxuICogICBhIHRhc2sgaWQgd2FzIGdpdmVuLCB0aGVuIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIHNob3dBZGRUYXNrTW9kYWwoaW5zdGFuY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGNvbnN0IG1vZGFsID0gbmV3IEFkZFRhc2tNb2RhbChwcml2YXRlcy50YXNrcywgcHJpdmF0ZXMucHJvamVjdHMsIHtcbiAgICB0YXNrSWQ6IG9wdGlvbnMudGFza0lkIHx8IG51bGwsXG4gICAgcHJvamVjdElkOiBvcHRpb25zLnByb2plY3RJZCB8fCBudWxsLFxuICAgIHByaW9yaXR5OiBvcHRpb25zLnByaW9yaXR5ID8/IDAsXG4gICAgZGF0ZUZvcm1hdDogcHJpdmF0ZXMuc2V0dGluZ3MuZGF0ZUZvcm1hdCxcbiAgICBjb25maXJtOiAoKSA9PiB1cGRhdGVNYWluUGFuZWwoaW5zdGFuY2UsIHsgcmVzZXRTY3JvbGw6IGZhbHNlIH0pLFxuICAgIG5ld1Byb2plY3Q6ICgpID0+IHVwZGF0ZVByb2plY3RGaWx0ZXJzKGluc3RhbmNlKSxcbiAgfSk7XG4gIHByaXZhdGVzLm1vZGFsU3RhY2suc2hvd01vZGFsKG1vZGFsKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IHRoZSBtb2RhbCBkaWFsb2cgZm9yIGFkZGluZyBvciBlZGl0aW5nIGEgcHJvamVjdC4gQWZ0ZXIgdGhlIHVzZXJcbiAqIGNvbmZpcm1zIHRoZSBkaWFsb2csIHRoZSBwcm9qZWN0IGlzIGFkZGVkIHRvIHRoZSBwcm9qZWN0IGxpc3QuXG4gKiBAcGFyYW0ge21vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG8gYXBwbHkgdGhlXG4gKiAgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3QgaG9sZGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0aGVcbiAqICAgbW9kYWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvamVjdElkXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIHByb2plY3QgdG9cbiAqICAgZWRpdCwgaWYgYW55LiBJZiBub3QgZ2l2ZW4sIGEgbmV3IHByb2plY3QgaXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gc2hvd0FkZFByb2plY3RNb2RhbChpbnN0YW5jZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcblxuICBsZXQgcHJvamVjdFRvVXBkYXRlID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMucHJvamVjdElkKSB7XG4gICAgcHJvamVjdFRvVXBkYXRlID0gcHJpdmF0ZXMucHJvamVjdHMuZ2V0UHJvamVjdChvcHRpb25zLnByb2plY3RJZCk7XG4gIH1cblxuICBjb25zdCBtb2RhbCA9IG5ldyBBZGRQcm9qZWN0TW9kYWwoe1xuICAgIGNvbmZpcm06IChwcm9qZWN0KSA9PiB7XG4gICAgICBsZXQgbmV3SWQgPSBudWxsO1xuICAgICAgaWYgKG9wdGlvbnMucHJvamVjdElkKSB7XG4gICAgICAgIHByaXZhdGVzLnByb2plY3RzLnVwZGF0ZVByb2plY3Qob3B0aW9ucy5wcm9qZWN0SWQsIHByb2plY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SWQgPSBwcml2YXRlcy5wcm9qZWN0cy5hZGRQcm9qZWN0KHByb2plY3QpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVQcm9qZWN0RmlsdGVycyhpbnN0YW5jZSk7XG4gICAgICBpZiAobmV3SWQpIHByaXZhdGVzLmZpbHRlck1lbnUuc2VsZWN0RmlsdGVyKCdwcm9qZWN0cycsIG5ld0lkKTtcbiAgICB9LFxuICAgIHByb2plY3Q6IHByb2plY3RUb1VwZGF0ZSxcbiAgfSk7XG4gIHByaXZhdGVzLm1vZGFsU3RhY2suc2hvd01vZGFsKG1vZGFsKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IHRoZSBtb2RhbCBkaWFsb2cgZm9yIG1vZGlmeWluZyB1c2VyIHNldHRpbmdzLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZVxuICogICBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvd1NldHRpbmdzTW9kYWwoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCBtb2RhbCA9IG5ldyBTZXR0aW5nc01vZGFsKHByaXZhdGVzLnNldHRpbmdzLCB7XG4gICAgY29uZmlybTogKCkgPT4gdXBkYXRlTWFpblBhbmVsKGluc3RhbmNlLCB7IHJlc2V0U2Nyb2xsOiBmYWxzZSB9KSxcbiAgfSk7XG4gIHByaXZhdGVzLm1vZGFsU3RhY2suc2hvd01vZGFsKG1vZGFsKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IHRoZSBtb2RhbCBkaWFsb2cgZm9yIG1hbmFnaW5nIHVzZXIgZGF0YS5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3dEYXRhTW9kYWwoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCBtb2RhbCA9IG5ldyBEYXRhTW9kYWwoe1xuICAgIGltcG9ydERhdGE6IChjb250ZW50LCB7IG5hbWUgfSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wb3J0RnJvbUZpbGUoaW5zdGFuY2UsIGNvbnRlbnQsIG5hbWUpO1xuICAgICAgaWYgKHJlc3VsdC5wcm9qZWN0cy50b3RhbCA+IDApIHVwZGF0ZVByb2plY3RGaWx0ZXJzKGluc3RhbmNlKTtcbiAgICAgIGlmIChyZXN1bHQudGFza3MudG90YWwgPiAwKSB7XG4gICAgICAgIHVwZGF0ZU1haW5QYW5lbChpbnN0YW5jZSwgeyByZXNldFNjcm9sbDogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IHN0YXR1c01zZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3RhdHVzTXNnLmNsYXNzTGlzdC5hZGQoJ2RhdGEtaW1wb3J0LXJlc3VsdHMnKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0dXNNc2cpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzZnVsKSB7XG4gICAgICAgIHN0YXR1c01zZy50ZXh0Q29udGVudCA9IFtcbiAgICAgICAgICAnRGF0YSBpbXBvcnQgc3VjY2VlZGVkLicsXG4gICAgICAgICAgYFByb2Nlc3NlZCAke3Jlc3VsdC50YXNrcy50b3RhbH0gJHtyZXN1bHQudGFza3MudG90YWwgIT09IDEgPyAndGFza3MnIDogJ3Rhc2snfTogJHtyZXN1bHQudGFza3MuYWRkZWR9IGFkZGVkLCAke3Jlc3VsdC50YXNrcy51cGRhdGVkfSB1cGRhdGVkLCAke3Jlc3VsdC50YXNrcy5mYWlsZWR9IGZhaWxlZC5gLFxuICAgICAgICAgIGBQcm9jZXNzZWQgJHtyZXN1bHQucHJvamVjdHMudG90YWx9ICR7cmVzdWx0LnByb2plY3RzLnRvdGFsICE9PSAxID8gJ3Byb2plY3RzJyA6ICdwcm9qZWN0J306ICR7cmVzdWx0LnByb2plY3RzLmFkZGVkfSBhZGRlZCwgJHtyZXN1bHQucHJvamVjdHMudXBkYXRlZH0gdXBkYXRlZCwgJHtyZXN1bHQucHJvamVjdHMuZmFpbGVkfSBmYWlsZWQuYCxcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXR1c01zZy50ZXh0Q29udGVudCA9ICdEYXRhIGltcG9ydCBmYWlsZWQuJztcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3JMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgZXJyb3JMaXN0LmNsYXNzTGlzdC5hZGQoJ2RhdGEtaW1wb3J0LWVycm9yLWxpc3QnKTtcbiAgICAgICAgcmVzdWx0LmVycm9ycy5mb3JFYWNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICBsaXN0SXRlbS5jbGFzc0xpc3QuYWRkKCdkYXRhLWltcG9ydC1yZXN1bHRzJyk7XG4gICAgICAgICAgbGlzdEl0ZW0udGV4dENvbnRlbnQgPSBlcnJvcjtcbiAgICAgICAgICBlcnJvckxpc3QuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9yTGlzdCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmZvTW9kYWwgPSBuZXcgSW5mb01vZGFsKGNvbnRhaW5lciwgeyB0aXRsZTogJ0ltcG9ydCBTdGF0dXMnIH0pO1xuICAgICAgcHJpdmF0ZXMubW9kYWxTdGFjay5zaG93TW9kYWwoaW5mb01vZGFsKTtcbiAgICB9LFxuICAgIGV4cG9ydERhdGE6IChmaWxlVHlwZSwgZmlsZU9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChmaWxlVHlwZSA9PT0gJ2NzdicpIGV4cG9ydFRvQ3N2KGluc3RhbmNlLCBmaWxlT3B0aW9ucyk7XG4gICAgICBlbHNlIGV4cG9ydFRvSnNvbihpbnN0YW5jZSwgZmlsZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgZGVsZXRlQWxsOiAoKSA9PiBkZWxldGVBbGxEYXRhKGluc3RhbmNlKSxcbiAgfSk7XG4gIHByaXZhdGVzLm1vZGFsU3RhY2suc2hvd01vZGFsKG1vZGFsKTtcbn1cblxuLyoqXG4gKiBSZXNwb25kIHRvIGEgc2VsZWN0aW9uIGluIHRoZSBtYWluIHBhbmVsIG1lbnUuXG4gKiBAcGFyYW0ge21vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG8gYXBwbHkgdGhlXG4gKiAgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1JZCBUaGUgaWRlbnRpZmllciBmb3IgdGhlIG1lbnUgaXRlbSB0aGF0IHdhcyBzZWxlY3RlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlTWFpblBhbmVsTWVudVNlbGVjdGlvbihpbnN0YW5jZSwgaXRlbUlkKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgeyBncm91cCwgZmlsdGVyIH0gPSBwcml2YXRlcy5jdXJyZW50RmlsdGVyO1xuICBjb25zdCBmaWx0ZXJPcHRpb25zID0gcHJpdmF0ZXMuc2V0dGluZ3MuZ2V0RmlsdGVyT3B0aW9ucyhncm91cCk7XG5cbiAgbGV0IG5lZWRQYW5lbFVwZGF0ZSA9IHRydWU7XG4gIGxldCBuZWVkRmlsdGVyT3B0aW9uVXBkYXRlID0gdHJ1ZTtcbiAgc3dpdGNoIChpdGVtSWQpIHtcbiAgICBjYXNlICdhZGQtdGFzayc6IHtcbiAgICAgIGNvbnN0IG1vZGFsT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKGdyb3VwID09PSAncHJvamVjdHMnICYmIGZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICAgIG1vZGFsT3B0aW9ucy5wcm9qZWN0SWQgPSBmaWx0ZXI7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwID09PSAncHJpb3JpdGllcycpIHtcbiAgICAgICAgbW9kYWxPcHRpb25zLnByaW9yaXR5ID0gVGFzay5jb252ZXJ0U3RyaW5nVG9Qcmlvcml0eShmaWx0ZXIpO1xuICAgICAgfVxuICAgICAgc2hvd0FkZFRhc2tNb2RhbChpbnN0YW5jZSwgbW9kYWxPcHRpb25zKTtcbiAgICAgIG5lZWRQYW5lbFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgbmVlZEZpbHRlck9wdGlvblVwZGF0ZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ2FkZC1wcm9qZWN0JzpcbiAgICAgIHNob3dBZGRQcm9qZWN0TW9kYWwoaW5zdGFuY2UpO1xuICAgICAgbmVlZFBhbmVsVXBkYXRlID0gZmFsc2U7XG4gICAgICBuZWVkRmlsdGVyT3B0aW9uVXBkYXRlID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlZGl0LXByb2plY3QnOlxuICAgICAgc2hvd0FkZFByb2plY3RNb2RhbChpbnN0YW5jZSwgeyBwcm9qZWN0SWQ6IGZpbHRlciB9KTtcbiAgICAgIG5lZWRGaWx0ZXJPcHRpb25VcGRhdGUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RlbGV0ZS1wcm9qZWN0Jzoge1xuICAgICAgY29uc3QgcHJvamVjdCA9IHByaXZhdGVzLnByb2plY3RzLmdldFByb2plY3QoZmlsdGVyKTtcbiAgICAgIGlmICghcHJvamVjdCkgYnJlYWs7XG4gICAgICBzaG93Q29uZmlybWF0aW9uKFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgdGhlIHByb2plY3QgJyR7cHJvamVjdC5uYW1lfSc/YCxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHByaXZhdGVzLnRhc2tzLmNsZWFyUHJvamVjdChmaWx0ZXIpO1xuICAgICAgICAgIHByaXZhdGVzLnByb2plY3RzLmRlbGV0ZVByb2plY3QoZmlsdGVyKTtcbiAgICAgICAgICB1cGRhdGVQcm9qZWN0RmlsdGVycyhpbnN0YW5jZSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgbmVlZFBhbmVsVXBkYXRlID0gZmFsc2U7XG4gICAgICBuZWVkRmlsdGVyT3B0aW9uVXBkYXRlID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnc2hvdy1jb21wbGV0ZWQnOlxuICAgICAgZmlsdGVyT3B0aW9ucy5zaG93Q29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2hpZGUtY29tcGxldGVkJzpcbiAgICAgIGZpbHRlck9wdGlvbnMuc2hvd0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc29ydC1hc2NlbmRpbmcnOlxuICAgICAgZmlsdGVyT3B0aW9ucy5zb3J0RGVzY2VuZGluZyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc29ydC1kZXNjZW5kaW5nJzpcbiAgICAgIGZpbHRlck9wdGlvbnMuc29ydERlc2NlbmRpbmcgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZ3JvdXAtYnktZGVmYXVsdCc6XG4gICAgICBmaWx0ZXJPcHRpb25zLmdyb3VwQnkgPSAnZGVmYXVsdCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdncm91cC1ieS1ub25lJzpcbiAgICAgIGZpbHRlck9wdGlvbnMuZ3JvdXBCeSA9ICdub25lJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2dyb3VwLWJ5LWR1ZS1kYXRlJzpcbiAgICAgIGZpbHRlck9wdGlvbnMuZ3JvdXBCeSA9ICdkdWUtZGF0ZSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdncm91cC1ieS1wcm9qZWN0JzpcbiAgICAgIGZpbHRlck9wdGlvbnMuZ3JvdXBCeSA9ICdwcm9qZWN0JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2dyb3VwLWJ5LXByaW9yaXR5JzpcbiAgICAgIGZpbHRlck9wdGlvbnMuZ3JvdXBCeSA9ICdwcmlvcml0eSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3J0LWJ5LWNyZWF0ZS1kYXRlJzpcbiAgICAgIGZpbHRlck9wdGlvbnMuc29ydEJ5ID0gJ2NyZWF0ZS1kYXRlJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvcnQtYnktZHVlLWRhdGUnOlxuICAgICAgZmlsdGVyT3B0aW9ucy5zb3J0QnkgPSAnZHVlLWRhdGUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc29ydC1ieS1wcm9qZWN0JzpcbiAgICAgIGZpbHRlck9wdGlvbnMuc29ydEJ5ID0gJ3Byb2plY3QnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc29ydC1ieS1wcmlvcml0eSc6XG4gICAgICBmaWx0ZXJPcHRpb25zLnNvcnRCeSA9ICdwcmlvcml0eSc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAobmVlZEZpbHRlck9wdGlvblVwZGF0ZSkge1xuICAgIHByaXZhdGVzLnNldHRpbmdzLnNldEZpbHRlck9wdGlvbnMoZ3JvdXAsIGZpbHRlck9wdGlvbnMpO1xuICB9XG4gIGlmIChuZWVkUGFuZWxVcGRhdGUpIHVwZGF0ZU1haW5QYW5lbChpbnN0YW5jZSwgeyByZXNldFNjcm9sbDogZmFsc2UgfSk7XG59XG5cbi8qKlxuICogQ29tcGxldGUgYSB0YXNrIGluIHRoZSB0YXNrIGxpc3QuXG4gKiBAcGFyYW0ge21vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG8gYXBwbHkgdGhlXG4gKiAgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFzayB0byBjb21wbGV0ZS5cbiAqL1xuZnVuY3Rpb24gY29tcGxldGVUYXNrKGluc3RhbmNlLCBpZCkge1xuICBjb25zdCB7IHRhc2tzOiB0YXNrTGlzdCB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgdGFzayA9IHRhc2tMaXN0LmdldFRhc2soaWQpO1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIGlmICh0YXNrLnJlY3VycmluZ0RhdGUpIHtcbiAgICBsZXQgYmFzZURhdGUgPSBub3c7XG4gICAgaWYgKHRhc2suZHVlRGF0ZSAmJiAhdGFzay5yZWN1cnJpbmdEYXRlLmJhc2VPbkNvbXBsZXRpb24pIHtcbiAgICAgIGJhc2VEYXRlID0gdGFzay5kdWVEYXRlO1xuICAgIH1cbiAgICBjb25zdCBuZXdEdWVEYXRlID0gdGFzay5yZWN1cnJpbmdEYXRlLmdldE5leHRPY2N1cnJlbmNlKGJhc2VEYXRlKTtcbiAgICBpZiAoIW5ld0R1ZURhdGUpIHtcbiAgICAgIHRhc2subWFya0NvbXBsZXRlKCk7XG4gICAgICB0YXNrLnJlY3VycmluZ0RhdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXNrLm1hcmtJbmNvbXBsZXRlKCk7XG4gICAgICB0YXNrLnJlY3VycmluZ0RhdGUuYWR2YW5jZSgpO1xuICAgICAgdGFzay5kdWVEYXRlID0gbmV3RHVlRGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFzay5tYXJrQ29tcGxldGUoKTtcbiAgfVxuXG4gIHRhc2tMaXN0LnVwZGF0ZVRhc2soaWQsIHRhc2spO1xufVxuXG4vKipcbiAqIFJlc3BvbmQgdG8gYW4gYWN0aW9uIHRoYXQgdGhlIHVzZXIgcGVyZm9ybWVkIG9uIGEgdGFzay5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBhY3Rpb24gYmVpbmcgcGVyZm9ybWVkOiAnbWFyay1jb21wbGV0ZScsXG4gKiAgICdtYXJrLWluY29tcGxldGUnLCAnZWRpdCcsIG9yICdkZWxldGUnLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFzayBiZWluZyB1cGRhdGVkLlxuICogQHBhcmFtIHttb2R1bGU6dGFza35UYXNrfSB0YXNrIFRoZSB0YXNrIGJlaW5nIHVwZGF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVRhc2tVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIGlkLCB0YXNrKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgbGV0IG5lZWRVcGRhdGUgPSB0cnVlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdtYXJrLWNvbXBsZXRlJzpcbiAgICAgIGNvbXBsZXRlVGFzayhpbnN0YW5jZSwgaWQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWFyay1pbmNvbXBsZXRlJzpcbiAgICAgIHRhc2subWFya0luY29tcGxldGUoKTtcbiAgICAgIHByaXZhdGVzLnRhc2tzLnVwZGF0ZVRhc2soaWQsIHRhc2spO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZWRpdCc6XG4gICAgICBzaG93QWRkVGFza01vZGFsKGluc3RhbmNlLCB7IHRhc2tJZDogaWQgfSk7XG4gICAgICBuZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjbG9uZSc6XG4gICAgICBwcml2YXRlcy50YXNrcy5hZGRUYXNrKHRhc2spO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgIHNob3dDb25maXJtYXRpb24oXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGUgdGFzayAnJHt0YXNrLm5hbWV9Jz9gLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgcHJpdmF0ZXMudGFza3MuZGVsZXRlVGFzayhpZCk7XG4gICAgICAgICAgdXBkYXRlTWFpblBhbmVsKGluc3RhbmNlLCB7IHJlc2V0U2Nyb2xsOiBmYWxzZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBuZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdnby10by1wcm9qZWN0JzpcbiAgICAgIHByaXZhdGVzLmZpbHRlck1lbnUuc2VsZWN0RmlsdGVyKCdwcm9qZWN0cycsIHRhc2sucHJvamVjdCB8fCAnbm9uZScpO1xuICAgICAgbmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG5lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKG5lZWRVcGRhdGUpIHVwZGF0ZU1haW5QYW5lbChpbnN0YW5jZSwgeyByZXNldFNjcm9sbDogZmFsc2UgfSk7XG59XG5cbi8qKlxuICogUmVzcG9uZCB0byBhIGNoYW5nZSBpbiB0aGUgZmlsdGVyIG1lbnUgc2VsZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZVxuICogICBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtldmVudC5ncm91cElkXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwIGNvbnRhaW5pbmcgdGhlXG4gKiAgIGZpbHRlciB0aGF0IHdhcyBzZWxlY3RlZCwgaWYgYW55LlxuICogQHBhcmFtIHtzdHJpbmd9IFtldmVudC5maWx0ZXJJZF0gVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBmaWx0ZXIgdGhhdCB3YXNcbiAqICAgc2VsZWN0ZWQsIGlmIGFueS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnQuZmlsdGVyTGFiZWxdIFRoZSBkaXNwbGF5ZWQgbGFiZWwgZm9yIHRoZSBzZWxlY3RlZFxuICogICBmaWx0ZXIsIGlmIGFueS5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRmlsdGVyQ2hhbmdlKGluc3RhbmNlLCBldmVudCkge1xuICBpZiAoIWV2ZW50Lmdyb3VwSWQgfHwgIWV2ZW50LmZpbHRlcklkKSByZXR1cm47XG5cbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBwcml2YXRlcy5jdXJyZW50RmlsdGVyLmdyb3VwID0gZXZlbnQuZ3JvdXBJZDtcbiAgcHJpdmF0ZXMuY3VycmVudEZpbHRlci5maWx0ZXIgPSBldmVudC5maWx0ZXJJZDtcblxuICB1cGRhdGVNYWluUGFuZWwoaW5zdGFuY2UpO1xufVxuXG4vKipcbiAqIFJlc3BvbmQgdG8gYSBzZWxlY3Rpb24gaW4gdGhlIFVzZXIgbWVudS5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gaXRlbUlkIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBtZW51IGl0ZW0gdGhhdCB3YXMgc2VsZWN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVVzZXJNZW51U2VsZWN0aW9uKGluc3RhbmNlLCBpdGVtSWQpIHtcbiAgc3dpdGNoIChpdGVtSWQpIHtcbiAgICBjYXNlICdzZXR0aW5ncyc6XG4gICAgICBzaG93U2V0dGluZ3NNb2RhbChpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkYXRhJzpcbiAgICAgIHNob3dEYXRhTW9kYWwoaW5zdGFuY2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWJvdXQnOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8qKlxuICogTWFrZSBzdXJlIGFwcCBpbmZvcm1hdGlvbiBhbmQgc2V0dGluZ3MgYXJlIHN0b3JlZCBpbiBsb2NhbCBzdG9yYWdlIGlmXG4gKiBuZWVkZWQuXG4gKiBAcGFyYW0ge21vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG8gYXBwbHkgdGhlXG4gKiAgIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplU3RvcmFnZShpbnN0YW5jZSkge1xuICBzdG9yZURhdGEoQVBQX1NUT1JBR0VfUFJFRklYLCAnYXBwLnZlcnNpb24nLCBBUFBfVkVSU0lPTik7XG5cbiAgY29uc3Qgc3RvcmFnZU1ldGhvZCA9IHJldHJpZXZlRGF0YShcbiAgICBBUFBfU1RPUkFHRV9QUkVGSVgsXG4gICAgJ3NldHRpbmcuc3RvcmFnZU1ldGhvZCcsXG4gICk7XG4gIGlmIChzdG9yYWdlTWV0aG9kICYmIHN0b3JhZ2VNZXRob2QgIT09ICdsb2NhbCcpIHJldHVybjtcblxuICAvLyBTdG9yZSBhbnkgc2V0dGluZ3MgdGhhdCBhcmUgbm90IGFscmVhZHkgaW4gbG9jYWwgc3RvcmFnZVxuICBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpLnNldHRpbmdzLmZvckVhY2goKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYHNldHRpbmcuJHtuYW1lfWA7XG4gICAgaWYgKCFyZXRyaWV2ZURhdGEoQVBQX1NUT1JBR0VfUFJFRklYLCBrZXkpKSB7XG4gICAgICBzdG9yZURhdGEoQVBQX1NUT1JBR0VfUFJFRklYLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIExvYWQgYWxsIGl0ZW1zIGZyb20gbG9jYWwgc3RvcmFnZSBpbnRvIHRoZSBhcHAuXG4gKiBAcGFyYW0ge21vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG8gYXBwbHkgdGhlXG4gKiAgIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBsb2FkQWxsU3RvcmFnZURhdGEoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuXG4gIGZvckVhY2hEYXRhSXRlbShBUFBfU1RPUkFHRV9QUkVGSVgsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgZG90SW5kZXggPSBrZXkuaW5kZXhPZignLicpO1xuICAgIGNvbnN0IHR5cGUgPSBrZXkuc3Vic3RyaW5nKDAsIGRvdEluZGV4KTtcbiAgICBjb25zdCBpZCA9IGtleS5zdWJzdHJpbmcoZG90SW5kZXggKyAxKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAndGFzayc6XG4gICAgICAgIHByaXZhdGVzLnRhc2tzLmFkZE9yVXBkYXRlVGFzayhpZCwgVGFzay5mcm9tSnNvbih2YWx1ZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Byb2plY3QnOlxuICAgICAgICBwcml2YXRlcy5wcm9qZWN0cy5hZGRPclVwZGF0ZVByb2plY3QoaWQsIFByb2plY3QuZnJvbUpzb24odmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZXR0aW5nJzpcbiAgICAgICAgcHJpdmF0ZXMuc2V0dGluZ3Muc2V0U2V0dGluZyhpZCwgdmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU3RvcmUgYWxsIHVzZXIgZGF0YSBpbiBsb2NhbCBzdG9yYWdlLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZVxuICogICBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc3RvcmVBbGxEYXRhKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcblxuICBzdG9yZURhdGEoQVBQX1NUT1JBR0VfUFJFRklYLCAnYXBwLnZlcnNpb24nLCBBUFBfVkVSU0lPTik7XG5cbiAgaWYgKHByaXZhdGVzLnNldHRpbmdzLnN0b3JhZ2VNZXRob2QgPT09ICdsb2NhbCcpIHtcbiAgICBwcml2YXRlcy50YXNrcy5mb3JFYWNoKCh7IGlkLCB0YXNrIH0pID0+IHtcbiAgICAgIHN0b3JlRGF0YShBUFBfU1RPUkFHRV9QUkVGSVgsIGB0YXNrLiR7aWR9YCwgdGFzayk7XG4gICAgfSk7XG5cbiAgICBwcml2YXRlcy5wcm9qZWN0cy5mb3JFYWNoKCh7IGlkLCBwcm9qZWN0IH0pID0+IHtcbiAgICAgIHN0b3JlRGF0YShBUFBfU1RPUkFHRV9QUkVGSVgsIGBwcm9qZWN0LiR7aWR9YCwgcHJvamVjdCk7XG4gICAgfSk7XG5cbiAgICBwcml2YXRlcy5zZXR0aW5ncy5mb3JFYWNoKChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgc3RvcmVEYXRhKEFQUF9TVE9SQUdFX1BSRUZJWCwgYHNldHRpbmcuJHtuYW1lfWAsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzdG9yZURhdGEoQVBQX1NUT1JBR0VfUFJFRklYLCAnc2V0dGluZy5zdG9yYWdlTWV0aG9kJywgJ25vbmUnKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBsb2NhbCBzdG9yYWdlIGFmdGVyIGRhdGEgaGFzIGJlZW4gY2hhbmdlZC5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBkYXRhIHRoYXQgd2FzIGNoYW5nZWQ6ICdzZXR0aW5nJywgJ3Rhc2snLFxuICogICBvciAncHJvamVjdCcuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhIFRoZSBldmVudCBvYmplY3Qgc3BlY2lmeWluZyB0aGUgZGF0YSB0aGF0IHdhc1xuICogICBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiB1cGRhdGVTdG9yYWdlKGluc3RhbmNlLCB0eXBlLCBldmVudERhdGEpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuXG4gIC8vIElmIHN0b3JhZ2UgbWV0aG9kIGlzIGNoYW5naW5nLCB3ZSBuZWVkIHRvIGRlbGV0ZSBvciByZXN0b3JlIGV2ZXJ5dGhpbmdcbiAgaWYgKHR5cGUgPT09ICdzZXR0aW5nJyAmJiBldmVudERhdGEubmFtZSA9PT0gJ3N0b3JhZ2VNZXRob2QnKSB7XG4gICAgaWYgKGV2ZW50RGF0YS52YWx1ZSAhPT0gJ2xvY2FsJykgY2xlYXJEYXRhKEFQUF9TVE9SQUdFX1BSRUZJWCk7XG4gICAgc3RvcmVBbGxEYXRhKGluc3RhbmNlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJpdmF0ZXMuc2V0dGluZ3Muc3RvcmFnZU1ldGhvZCAhPT0gJ2xvY2FsJykgcmV0dXJuO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3Rhc2snOiB7XG4gICAgICBjb25zdCB7IHR5cGU6IGV2ZW50VHlwZSwgaWQsIHRhc2sgfSA9IGV2ZW50RGF0YTtcbiAgICAgIGNvbnN0IGtleSA9IGB0YXNrLiR7aWR9YDtcbiAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2FkZC10YXNrJzpcbiAgICAgICAgY2FzZSAndXBkYXRlLXRhc2snOlxuICAgICAgICAgIHN0b3JlRGF0YShBUFBfU1RPUkFHRV9QUkVGSVgsIGtleSwgdGFzayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RlbGV0ZS10YXNrJzpcbiAgICAgICAgICByZW1vdmVEYXRhKEFQUF9TVE9SQUdFX1BSRUZJWCwga2V5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdwcm9qZWN0Jzoge1xuICAgICAgY29uc3QgeyB0eXBlOiBldmVudFR5cGUsIGlkLCBwcm9qZWN0IH0gPSBldmVudERhdGE7XG4gICAgICBjb25zdCBrZXkgPSBgcHJvamVjdC4ke2lkfWA7XG4gICAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgICAgICBjYXNlICdhZGQtcHJvamVjdCc6XG4gICAgICAgIGNhc2UgJ3VwZGF0ZS1wcm9qZWN0JzpcbiAgICAgICAgICBzdG9yZURhdGEoQVBQX1NUT1JBR0VfUFJFRklYLCBrZXksIHByb2plY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZWxldGUtcHJvamVjdCc6XG4gICAgICAgICAgcmVtb3ZlRGF0YShBUFBfU1RPUkFHRV9QUkVGSVgsIGtleSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnc2V0dGluZyc6IHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUgfSA9IGV2ZW50RGF0YTtcbiAgICAgIHN0b3JlRGF0YShBUFBfU1RPUkFHRV9QUkVGSVgsIGBzZXR0aW5nLiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBhcHAncyB0YXNrIGZpbHRlciBtZW51LlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlcyBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlck1lbnUoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuXG4gIGNvbnN0IGZpbHRlckdyb3VwcyA9IFtcbiAgICB7IGlkOiAnZGVmYXVsdCcsIGxhYmVsOiBudWxsIH0sXG4gICAgeyBpZDogJ2RhdGVzJywgbGFiZWw6ICdEYXRlcycgfSxcbiAgICB7IGlkOiAncHJvamVjdHMnLCBsYWJlbDogJ1Byb2plY3RzJyB9LFxuICAgIHsgaWQ6ICdwcmlvcml0aWVzJywgbGFiZWw6ICdQcmlvcml0aWVzJyB9LFxuICBdO1xuXG4gIGNvbnN0IGZpbHRlck1lbnUgPSBuZXcgRmlsdGVyTWVudShwcml2YXRlcy5zaWRlUGFuZWwsIGZpbHRlckdyb3Vwcyk7XG5cbiAgY29uc3QgZmlsdGVycyA9IFtcbiAgICB7IGdyb3VwSWQ6ICdkZWZhdWx0JywgZmlsdGVySWQ6ICdhbGwnLCBsYWJlbDogJ0FsbCBUYXNrcycgfSxcbiAgICB7IGdyb3VwSWQ6ICdkYXRlcycsIGZpbHRlcklkOiAndG9kYXknLCBsYWJlbDogJ1RvZGF5JyB9LFxuICAgIHsgZ3JvdXBJZDogJ2RhdGVzJywgZmlsdGVySWQ6ICd3ZWVrJywgbGFiZWw6ICdUaGlzIFdlZWsnIH0sXG4gICAgeyBncm91cElkOiAnZGF0ZXMnLCBmaWx0ZXJJZDogJ21vbnRoJywgbGFiZWw6ICdUaGlzIE1vbnRoJyB9LFxuICAgIHsgZ3JvdXBJZDogJ2RhdGVzJywgZmlsdGVySWQ6ICdwYXN0LWR1ZScsIGxhYmVsOiAnUGFzdCBEdWUnIH0sXG4gICAgeyBncm91cElkOiAncHJpb3JpdGllcycsIGZpbHRlcklkOiAndmVyeS1oaWdoJywgbGFiZWw6ICdWZXJ5IEhpZ2gnIH0sXG4gICAgeyBncm91cElkOiAncHJpb3JpdGllcycsIGZpbHRlcklkOiAnaGlnaCcsIGxhYmVsOiAnSGlnaCcgfSxcbiAgICB7IGdyb3VwSWQ6ICdwcmlvcml0aWVzJywgZmlsdGVySWQ6ICdtZWRpdW0nLCBsYWJlbDogJ01lZGl1bScgfSxcbiAgICB7IGdyb3VwSWQ6ICdwcmlvcml0aWVzJywgZmlsdGVySWQ6ICdsb3cnLCBsYWJlbDogJ0xvdycgfSxcbiAgICB7IGdyb3VwSWQ6ICdwcmlvcml0aWVzJywgZmlsdGVySWQ6ICd2ZXJ5LWxvdycsIGxhYmVsOiAnVmVyeSBMb3cnIH0sXG4gIF07XG5cbiAgZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICBmaWx0ZXJNZW51LmFkZEZpbHRlcihmaWx0ZXIuZ3JvdXBJZCwgZmlsdGVyLmZpbHRlcklkLCBmaWx0ZXIubGFiZWwpO1xuICB9KTtcblxuICBmaWx0ZXJNZW51LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdC1maWx0ZXInLCAoZSkgPT4ge1xuICAgIGhhbmRsZUZpbHRlckNoYW5nZShpbnN0YW5jZSwgZSk7XG4gIH0pO1xuICBmaWx0ZXJNZW51LmFkZEdyb3VwSWNvbkJ1dHRvbigncHJvamVjdHMnLCAnYWRkJywge1xuICAgIGNhbGxiYWNrOiAoKSA9PiBzaG93QWRkUHJvamVjdE1vZGFsKGluc3RhbmNlKSxcbiAgfSk7XG5cbiAgcHJpdmF0ZXMuZmlsdGVyTWVudSA9IGZpbHRlck1lbnU7XG4gIHVwZGF0ZVByb2plY3RGaWx0ZXJzKGluc3RhbmNlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIGFwcCdzIGhlYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOmFwcH5BcHB9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0byBhcHBseSB0aGVcbiAqICAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgVGhlIHBhcmVudCBlbGVtZW50IHVuZGVyIHdoaWNoIHRoZSBoZWFkZXJcbiAqICAgc2hvdWxkIGJlIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXIoaW5zdGFuY2UsIHBhcmVudCkge1xuICAvLyBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG5cbiAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaGVhZGVyJyk7XG4gIGhlYWRlci5pZCA9ICdoZWFkZXInO1xuXG4gIGNvbnN0IHRpdGxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRpdGxlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3RpdGxlLWNvbnRhaW5lcicpO1xuICB0aXRsZUNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVJY29uQnV0dG9uKCdtZW51JykpO1xuICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgdGl0bGUuY2xhc3NMaXN0LmFkZCgndGl0bGUnKTtcbiAgdGl0bGUudGV4dENvbnRlbnQgPSBBUFBfTkFNRTtcbiAgdGl0bGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICBoZWFkZXIuYXBwZW5kQ2hpbGQodGl0bGVDb250YWluZXIpO1xuXG4gIGNvbnN0IHRvb2xDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdG9vbENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCd0b29scycpO1xuICB0b29sQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUljb25CdXR0b24oJ2FjY291bnRfY2lyY2xlJykpO1xuICBoZWFkZXIuYXBwZW5kQ2hpbGQodG9vbENvbnRhaW5lcik7XG5cbiAgcGFyZW50LmFwcGVuZENoaWxkKGhlYWRlcik7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBhcHAncyBzaWRlIHBhbmVsLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZVxuICogICBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBUaGUgcGFyZW50IGVsZW1lbnQgdW5kZXIgd2hpY2ggdGhlIHNpZGUgcGFuZWxcbiAqICAgc2hvdWxkIGJlIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTaWRlUGFuZWwoaW5zdGFuY2UsIHBhcmVudCkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG5cbiAgcHJpdmF0ZXMuc2lkZVBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXNpZGUnKTtcbiAgcHJpdmF0ZXMuc2lkZVBhbmVsLmlkID0gJ3NpZGUtcGFuZWwnO1xuICBjcmVhdGVGaWx0ZXJNZW51KGluc3RhbmNlKTtcbiAgcGFyZW50LmFwcGVuZENoaWxkKHByaXZhdGVzLnNpZGVQYW5lbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSByZXNpemluZyBiYXIgZm9yIHRoZSBzaWRlIHBhbmVsLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZVxuICogICBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBUaGUgcGFyZW50IGVsZW1lbnQgdW5kZXIgd2hpY2ggdGhlIHJlc2l6ZXIgaXNcbiAqICAgdG8gYmUgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZXIoaW5zdGFuY2UsIHBhcmVudCkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG5cbiAgcHJpdmF0ZXMucmVzaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcml2YXRlcy5yZXNpemVyLmNsYXNzTGlzdC5hZGQoJ3Jlc2l6ZXInKTtcblxuICBjb25zdCBoYW5kbGVyID0gKGUpID0+IHtcbiAgICBjb25zdCBzaXplID0gYCR7ZS54fXB4YDtcbiAgICBwcml2YXRlcy5zaWRlUGFuZWwuc3R5bGUud2lkdGggPSBzaXplO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICBwcml2YXRlcy5yZXNpemVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgLy8gQ2hlY2sgZm9yIGxlZnQtY2xpY2tcbiAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXIpO1xuICAgICAgZS50YXJnZXQuY2xhc3NMaXN0LmFkZCgnZHJhZ2dpbmcnKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZSkgPT4ge1xuICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICBwcml2YXRlcy5yZXNpemVyLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdnaW5nJyk7XG4gICAgfVxuICB9KTtcblxuICBwYXJlbnQuYXBwZW5kQ2hpbGQocHJpdmF0ZXMucmVzaXplcik7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBhcHAncyBtYWluIHBhbmVsLlxuICogQHBhcmFtIHttb2R1bGU6YXBwfkFwcH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZVxuICogICBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBUaGUgcGFyZW50IGVsZW1lbnQgdW5kZXIgd2hpY2ggdGhlIG1haW4gcGFuZWxcbiAqICAgaXMgdG8gYmUgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1haW5QYW5lbChpbnN0YW5jZSwgcGFyZW50KSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcblxuICBwcml2YXRlcy5tYWluUGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJpdmF0ZXMubWFpblBhbmVsLmlkID0gJ21haW4tcGFuZWwnO1xuXG4gIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBoZWFkZXIuaWQgPSAnbWFpbi1wYW5lbC1oZWFkZXInO1xuICBjb25zdCBoZWFkaW5nQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGhlYWRpbmdDb250YWluZXIuaWQgPSAnbWFpbi1wYW5lbC1oZWFkaW5nLWNvbnRhaW5lcic7XG4gIGhlYWRlci5hcHBlbmRDaGlsZChoZWFkaW5nQ29udGFpbmVyKTtcbiAgY29uc3QgaGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyk7XG4gIGhlYWRpbmcuaWQgPSAnbWFpbi1wYW5lbC1oZWFkaW5nJztcbiAgaGVhZGluZ0NvbnRhaW5lci5hcHBlbmRDaGlsZChoZWFkaW5nKTtcbiAgY29uc3Qgc3ViaGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gIHN1YmhlYWRpbmcuaWQgPSAnbWFpbi1wYW5lbC1zdWJoZWFkaW5nJztcbiAgaGVhZGluZ0NvbnRhaW5lci5hcHBlbmRDaGlsZChzdWJoZWFkaW5nKTtcblxuICBjb25zdCBtZW51ID0gbmV3IFBvcHVwTWVudSh7IGNsb3NlSWZTY3JvbGxlZDogcHJpdmF0ZXMubWFpblBhbmVsIH0pO1xuICBwcml2YXRlcy5tYWluUGFuZWxNZW51ID0gbWVudTtcblxuICBjb25zdCBpY29uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGljb25Db250YWluZXIuY2xhc3NMaXN0LmFkZCgnaWNvbi1jb250YWluZXInKTtcbiAgaWNvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVJY29uQnV0dG9uKCdhZGQnKSk7XG4gIGljb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlSWNvbkJ1dHRvbignbW9yZV9ob3JpeicpKTtcbiAgaGVhZGVyLmFwcGVuZENoaWxkKGljb25Db250YWluZXIpO1xuXG4gIHByaXZhdGVzLm1haW5QYW5lbC5hcHBlbmRDaGlsZChoZWFkZXIpO1xuXG4gIGNvbnN0IHRhc2tEaXNwbGF5T3B0aW9ucyA9IHtcbiAgICB0YXNrQ2FsbGJhY2s6ICh0eXBlLCBpZCwgdGFzaykgPT4ge1xuICAgICAgaGFuZGxlVGFza1VwZGF0ZShpbnN0YW5jZSwgdHlwZSwgaWQsIHRhc2spO1xuICAgIH0sXG4gIH07XG4gIHByaXZhdGVzLnRhc2tEaXNwbGF5ID0gbmV3IFRhc2tEaXNwbGF5KFxuICAgIHByaXZhdGVzLm1haW5QYW5lbCxcbiAgICBwcml2YXRlcy50YXNrcyxcbiAgICBwcml2YXRlcy5wcm9qZWN0cyxcbiAgICB0YXNrRGlzcGxheU9wdGlvbnMsXG4gICk7XG5cbiAgcGFyZW50LmFwcGVuZENoaWxkKHByaXZhdGVzLm1haW5QYW5lbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBhcHAncyBmb290ZXIuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgVGhlIHBhcmVudCBlbGVtZW50IHVuZGVyIHdoaWNoIHRoZSBmb290ZXIgaXNcbiAqICAgdG8gYmUgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvb3RlcihwYXJlbnQpIHtcbiAgY29uc3QgZm9vdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9vdGVyJyk7XG4gIGZvb3Rlci5pZCA9ICdmb290ZXInO1xuXG4gIGNvbnN0IGNvcHlyaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb3B5cmlnaHQuY2xhc3NMaXN0LmFkZCgnY29weXJpZ2h0Jyk7XG4gIGNvcHlyaWdodC5pbm5lckhUTUwgPSBgQ29weXJpZ2h0ICZjb3B5OyAke0FQUF9DT1BZUklHSFRfWUVBUlN9IGBcbiAgICArIGA8YSBocmVmPVwiJHtBUFBfQVVUSE9SX1dFQlNJVEV9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+YFxuICAgICsgYCR7QVBQX0FVVEhPUn08L2E+YDtcbiAgZm9vdGVyLmFwcGVuZENoaWxkKGNvcHlyaWdodCk7XG5cbiAgcGFyZW50LmFwcGVuZENoaWxkKGZvb3Rlcik7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBET00gZWxlbWVudHMgZm9yIHRoZSBwYWdlIGNvbnRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTphcHB+QXBwfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG8gYXBwbHkgdGhlXG4gKiAgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBjb250YWluZXIgZWxlbWVudCB1bmRlciB3aGljaCB0aGUgcGFnZVxuICogICBlbGVtZW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhZ2VFbGVtZW50cyhpbnN0YW5jZSwgcGFyZW50KSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcblxuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udGFpbmVyLmlkID0gJ2FwcCc7XG4gIHByaXZhdGVzLmFwcENvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICBjcmVhdGVIZWFkZXIoaW5zdGFuY2UsIGNvbnRhaW5lcik7XG5cbiAgY29uc3QgbWlkZGxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG1pZGRsZUNvbnRhaW5lci5pZCA9ICdtaWRkbGUtY29udGFpbmVyJztcbiAgY3JlYXRlU2lkZVBhbmVsKGluc3RhbmNlLCBtaWRkbGVDb250YWluZXIpO1xuICBjcmVhdGVSZXNpemVyKGluc3RhbmNlLCBtaWRkbGVDb250YWluZXIpO1xuICBjcmVhdGVNYWluUGFuZWwoaW5zdGFuY2UsIG1pZGRsZUNvbnRhaW5lcik7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtaWRkbGVDb250YWluZXIpO1xuXG4gIGNyZWF0ZUZvb3Rlcihjb250YWluZXIpO1xuXG4gIHBhcmVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gIHByaXZhdGVzLm1vZGFsU3RhY2sgPSBuZXcgTW9kYWxTdGFjayhwYXJlbnQsIGNvbnRhaW5lcik7XG59XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBET00gZWxlbWVudHMgZm9yIHRoZSBhcHAgYW5kIHJ1bm5pbmcgdGhlXG4gKiBldmVudC1kcml2ZW4gbG9naWMuXG4gKi9cbmNsYXNzIEFwcCB7XG4gIC8qKlxuICAgKiBBbiBvYmplY3QgaG9sZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3RhdHVzIG9mIGEgZGF0YSBpbXBvcnQsIGluY2x1ZGluZ1xuICAgKiB3aGV0aGVyIG9yIG5vdCB0aGUgaW1wb3J0IHdhcyBzdWNjZXNzZnVsIGFuZCBhbnkgZXJyb3JzIHRoYXQgd2VyZVxuICAgKiBlbmNvdW50ZXJlZC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmFwcH5BcHB+aW1wb3J0U3RhdHVzXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3VjY2Vzc2Z1bCBXaWxsIGJlIHRydWUgaWYgZGF0YSB3YXMgaW1wb3J0ZWQsIG9yIGZhbHNlXG4gICAqICAgaWYgZGF0YSBjb3VsZCBub3QgYmUgaW1wb3J0ZWQgZHVlIHRvIGEgZmF0YWwgZXJyb3IuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb3JtYXQgVGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBzdHJpbmcgdGhhdCB3YXMgaW1wb3J0ZWQuXG4gICAqICAgV2lsbCBiZSAnanNvbicsICdjc3YnLCBvciAndW5rbm93bicuIEEgdmFsdWUgb2YgJ3Vua25vd24nIGluZGljYXRlcyB0aGF0XG4gICAqICAgdGhlIGZvcm1hdCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBkZXRlcm1pbmVkLlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gdGFza3MgQW4gb2JqZWN0IGhvbGRpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG51bWJlciBvZlxuICAgKiAgIHRhc2tzIHRoYXQgd2VyZSBpbXBvcnRlZC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRhc2tzLmFkZGVkIFRoZSBudW1iZXIgb2YgbmV3IHRhc2tzIHRoYXQgd2VyZSBhZGRlZCB0b1xuICAgKiAgIHRoZSB0YXNrIGxpc3QuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0YXNrcy51cGRhdGVkIFRoZSBudW1iZXIgb2YgZXhpc3RpbmcgdGFza3MgaW4gdGhlIHRhc2tcbiAgICogICBsaXN0IHRoYXQgd2VyZSB1cGRhdGVkLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdGFza3MuZmFpbGVkIFRoZSBudW1iZXIgb2YgdGFza3MgdGhhdCBmYWlsZWQgdG8gaW1wb3J0LlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdGFza3MudG90YWwgVGhlIHRvdGFsIG51bWJlciBvZiB0YXNrcyB0aGF0IHdlcmVcbiAgICogICBwcm9jZXNzZWQuXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwcm9qZWN0cyBBbiBvYmplY3QgaG9sZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbnVtYmVyXG4gICAqICAgb2YgcHJvamVjdHMgdGhhdCB3ZXJlIGltcG9ydGVkLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcHJvamVjdHMuYWRkZWQgVGhlIG51bWJlciBvZiBuZXcgcHJvamVjdHMgdGhhdCB3ZXJlXG4gICAqICAgYWRkZWQgdG8gdGhlIHByb2plY3QgbGlzdC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2plY3RzLnVwZGF0ZWQgVGhlIG51bWJlciBvZiBleGlzdGluZyBwcm9qZWN0cyBpbiB0aGVcbiAgICogICBwcm9qZWN0IGxpc3QgdGhhdCB3ZXJlIHVwZGF0ZWQuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9qZWN0cy5mYWlsZWQgVGhlIG51bWJlciBvZiBwcm9qZWN0cyB0aGF0IGZhaWxlZCB0b1xuICAgKiAgIGltcG9ydC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2plY3RzLnRvdGFsIFRoZSB0b3RhbCBudW1iZXIgb2YgcHJvamVjdHMgdGhhdCB3ZXJlXG4gICAqICAgcHJvY2Vzc2VkLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBlcnJvcnMgQW4gYXJyYXkgb2YgZXJyb3IgbWVzc2FnZXMgZGVzY3JpYmluZyBhbnlcbiAgICogICBlcnJvcnMgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhlIGltcG9ydC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgRE9NIGVsZW1lbnRzIGZvciB0aGUgYXBwIHRvIHRoZSBnaXZlbiBwYXJlbnQgbm9kZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBET00gbm9kZSB3aGVyZSB0aGUgYXBwIGVsZW1lbnRzIHNob3VsZCBiZVxuICAgKiAgIGFwcGVuZGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSB7XG4gICAgICB0YXNrczogbmV3IFRhc2tMaXN0KCksXG4gICAgICBwcm9qZWN0czogbmV3IFByb2plY3RMaXN0KCksXG4gICAgICBtb2RhbFN0YWNrOiBudWxsLFxuICAgICAgZmlsdGVyTWVudTogbnVsbCxcbiAgICAgIGN1cnJlbnRGaWx0ZXI6IHsgZ3JvdXA6IG51bGwsIGZpbHRlcjogbnVsbCB9LFxuICAgICAgdGFza0Rpc3BsYXk6IG51bGwsXG4gICAgICBzZXR0aW5nczogbmV3IFNldHRpbmdzKCksXG4gICAgICBhcHBDb250YWluZXI6IG51bGwsXG4gICAgICBzaWRlUGFuZWw6IG51bGwsXG4gICAgICByZXNpemVyOiBudWxsLFxuICAgICAgbWFpblBhbmVsOiBudWxsLFxuICAgICAgbWFpblBhbmVsTWVudTogbnVsbCxcbiAgICAgIG5hcnJvd1NjcmVlbjogZmFsc2UsXG4gICAgfTtcbiAgICBwcml2YXRlTWVtYmVycy5zZXQodGhpcywgcHJpdmF0ZXMpO1xuXG4gICAgY3JlYXRlUGFnZUVsZW1lbnRzKHRoaXMsIHBhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIHRoZSBhcHAuIFRoaXMgbWV0aG9kIHNldHMgdXAgdGhlIGV2ZW50IGhhbmRsZXJzIGFuZCBwZXJmb3Jtc1xuICAgKiBoaWdoLWxldmVsIGxvZ2ljLiBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIHVudGlsIHRoZSBwYWdlIGVsZW1lbnRzIGhhdmVcbiAgICogYmVlbiBhZGRlZCB0byB0aGUgRE9NLlxuICAgKi9cbiAgcnVuKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgbmFycm93ID0gd2lkdGggPD0gTkFSUk9XX0xBWU9VVF9DVVRPRkY7XG5cbiAgICAgIC8vIEFkanVzdCBzaWRlIHBhbmVsIGlmIHNjcmVlbiBjaGFuZ2VzIGZyb20gbmFycm93IHRvIHdpZGUgb3IgdmljZSB2ZXJzYVxuICAgICAgaWYgKG5hcnJvdyAmJiAhcHJpdmF0ZXMubmFycm93U2NyZWVuKSB7XG4gICAgICAgIGNsb3NlU2lkZVBhbmVsKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghbmFycm93ICYmIHByaXZhdGVzLm5hcnJvd1NjcmVlbikge1xuICAgICAgICBvcGVuU2lkZVBhbmVsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBwcml2YXRlcy5uYXJyb3dTY3JlZW4gPSBuYXJyb3c7XG4gICAgfSk7XG5cbiAgICBwcml2YXRlcy5maWx0ZXJNZW51LmV4cGFuZEdyb3VwKCdkYXRlcycpO1xuICAgIHByaXZhdGVzLmZpbHRlck1lbnUuZXhwYW5kR3JvdXAoJ3Byb2plY3RzJyk7XG4gICAgcHJpdmF0ZXMuZmlsdGVyTWVudS5zZWxlY3RGaWx0ZXIoJ2RhdGVzJywgJ3RvZGF5Jyk7XG5cbiAgICBjb25zdCBtZW51U2VsZWN0b3IgPSAnLnRpdGxlLWNvbnRhaW5lciAuaWNvbltkYXRhLWljb24tdHlwZT1cIm1lbnVcIl0nO1xuICAgIGNvbnN0IG1lbnVJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihtZW51U2VsZWN0b3IpO1xuICAgIG1lbnVJY29uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdG9nZ2xlU2lkZVBhbmVsKHRoaXMpKTtcblxuICAgIGNvbnN0IHVzZXJNZW51ID0gbmV3IFBvcHVwTWVudSh7XG4gICAgICBtZW51SXRlbXM6IFtcbiAgICAgICAgeyBsYWJlbDogJ1NldHRpbmdzLi4uJywgaWQ6ICdzZXR0aW5ncycsIGljb25UeXBlOiAnc2V0dGluZ3MnIH0sXG4gICAgICAgIHsgbGFiZWw6ICdEYXRhIE1hbmFnZW1lbnQuLi4nLCBpZDogJ2RhdGEnLCBpY29uVHlwZTogJ3NhdmUnIH0sXG4gICAgICAgIHsgbGFiZWw6ICdBYm91dC4uLicsIGlkOiAnYWJvdXQnLCBpY29uVHlwZTogJ2luZm8nIH0sXG4gICAgICBdLFxuICAgIH0pO1xuICAgIGNvbnN0IHVzZXJJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICcjaGVhZGVyIC5pY29uW2RhdGEtaWNvbi10eXBlPVwiYWNjb3VudF9jaXJjbGVcIl0nLFxuICAgICk7XG4gICAgdXNlckljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB1c2VyTWVudS5vcGVuKFxuICAgICAgICAoaXRlbUlkKSA9PiBoYW5kbGVVc2VyTWVudVNlbGVjdGlvbih0aGlzLCBpdGVtSWQpLFxuICAgICAgICB7IHJlZmVyZW5jZUVsZW1lbnQ6IHVzZXJJY29uIH0sXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbWFpblBhbmVsSGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4tcGFuZWwtaGVhZGVyJyk7XG4gICAgY29uc3QgYWRkVGFza0ljb24gPSBtYWluUGFuZWxIZWFkZXIucXVlcnlTZWxlY3RvcihcbiAgICAgICcuaWNvbltkYXRhLWljb24tdHlwZT1cImFkZFwiXScsXG4gICAgKTtcbiAgICBhZGRUYXNrSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGhhbmRsZU1haW5QYW5lbE1lbnVTZWxlY3Rpb24odGhpcywgJ2FkZC10YXNrJyk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBtb3JlSWNvbiA9IG1haW5QYW5lbEhlYWRlci5xdWVyeVNlbGVjdG9yKFxuICAgICAgJy5pY29uW2RhdGEtaWNvbi10eXBlPVwibW9yZV9ob3JpelwiXScsXG4gICAgKTtcbiAgICBtb3JlSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHByaXZhdGVzLm1haW5QYW5lbE1lbnUub3BlbihcbiAgICAgICAgKGl0ZW0pID0+IGhhbmRsZU1haW5QYW5lbE1lbnVTZWxlY3Rpb24odGhpcywgaXRlbSksXG4gICAgICAgIHsgcmVmZXJlbmNlRWxlbWVudDogbW9yZUljb24gfSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpbml0aWFsaXplU3RvcmFnZSh0aGlzKTtcbiAgICBsb2FkQWxsU3RvcmFnZURhdGEodGhpcyk7XG5cbiAgICBjb25zdCB0YXNrQ2FsbGJhY2sgPSAoZXZlbnQpID0+IHVwZGF0ZVN0b3JhZ2UodGhpcywgJ3Rhc2snLCBldmVudCk7XG4gICAgcHJpdmF0ZXMudGFza3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkLXRhc2snLCB0YXNrQ2FsbGJhY2spO1xuICAgIHByaXZhdGVzLnRhc2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZS10YXNrJywgdGFza0NhbGxiYWNrKTtcbiAgICBwcml2YXRlcy50YXNrcy5hZGRFdmVudExpc3RlbmVyKCdkZWxldGUtdGFzaycsIHRhc2tDYWxsYmFjayk7XG5cbiAgICBjb25zdCBwcm9qQ2FsbGJhY2sgPSAoZXZlbnQpID0+IHVwZGF0ZVN0b3JhZ2UodGhpcywgJ3Byb2plY3QnLCBldmVudCk7XG4gICAgcHJpdmF0ZXMucHJvamVjdHMuYWRkRXZlbnRMaXN0ZW5lcignYWRkLXByb2plY3QnLCBwcm9qQ2FsbGJhY2spO1xuICAgIHByaXZhdGVzLnByb2plY3RzLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZS1wcm9qZWN0JywgcHJvakNhbGxiYWNrKTtcbiAgICBwcml2YXRlcy5wcm9qZWN0cy5hZGRFdmVudExpc3RlbmVyKCdkZWxldGUtcHJvamVjdCcsIHByb2pDYWxsYmFjayk7XG5cbiAgICBjb25zdCBzZXR0aW5nc0NhbGxiYWNrID0gKGV2ZW50KSA9PiB1cGRhdGVTdG9yYWdlKHRoaXMsICdzZXR0aW5nJywgZXZlbnQpO1xuICAgIHByaXZhdGVzLnNldHRpbmdzLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZS1zZXR0aW5nJywgc2V0dGluZ3NDYWxsYmFjayk7XG5cbiAgICAvKiBBZGQgcmFuZG9tIHRhc2sgYW5kIHByb2plY3QgZGF0YSBmb3IgdGVzdGluZyAqL1xuICAgIC8vIFRPRE86IHJlbW92ZVxuICAgIGFkZFJhbmRvbURhdGEodGhpcywgMCwgMCk7XG5cbiAgICB1cGRhdGVQcm9qZWN0RmlsdGVycyh0aGlzKTtcbiAgICBwcml2YXRlcy5maWx0ZXJNZW51LnNlbGVjdEZpbHRlcignZGVmYXVsdCcsICdhbGwnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGRhdGEgdG8gYW4gb2JqZWN0IHN1aXRhYmxlIGZvciBzZXJpYWxpemF0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHNlcmlhbGl6YWJsZSBkYXRhIGZvciB0aGUgY2xhc3MuXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXBwOiB7XG4gICAgICAgIG5hbWU6IEFQUF9OQU1FLFxuICAgICAgICB2ZXJzaW9uOiBBUFBfVkVSU0lPTixcbiAgICAgIH0sXG4gICAgICBzZXR0aW5nczogcHJpdmF0ZXMuc2V0dGluZ3MsXG4gICAgICB0YXNrczogcHJpdmF0ZXMudGFza3MsXG4gICAgICBwcm9qZWN0czogcHJpdmF0ZXMucHJvamVjdHMsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBcHA7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtDb2xsYXBzaWJsZV17QGxpbmsgbW9kdWxlOmNvbGxhcHNpYmxlfkNvbGxhcHNpYmxlfSBjbGFzcy5cbiAqIEBtb2R1bGUgY29sbGFwc2libGVcbiAqL1xuXG5jb25zdCBGT0NVU0FCTEVfU0VMRUNUT1IgPSBbXG4gICdhW2hyZWZdJyxcbiAgJ2lucHV0JyxcbiAgJ3NlbGVjdCcsXG4gICd0ZXh0YXJlYScsXG4gICdidXR0b24nLFxuXS5qb2luKCcsICcpO1xuXG4vKipcbiAqIE9iamVjdCBob2xkaW5nIHByaXZhdGUgbWVtYmVycyBmb3IgdGhlXG4gKiBbQ29sbGFwc2libGVde0BsaW5rIG1vZHVsZTpjb2xsYXBzaWJsZX5Db2xsYXBzaWJsZX0gY2xhc3MuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6Y29sbGFwc2libGV+Q29sbGFwc2libGV+cHJpdmF0ZXNcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgY29sbGFwc2libGUgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRlbnQgVGhlIGlubmVyIGNvbnRhaW5lciBob2xkaW5nIHRoZSBjb2xsYXBzaWJsZVxuICogICBjb250ZW50cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29sbGFwc2VkIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjb250YWluZXIgaXMgY3VycmVudGx5XG4gKiAgIGNvbGxhcHNlZCBvciBub3QuXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBwcml2YXRlIGRhdGEgZm9yIHRoZVxuICogW0NvbGxhcHNpYmxlXXtAbGluayBtb2R1bGU6Y29sbGFwc2libGV+Q29sbGFwc2libGV9IGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTpjb2xsYXBzaWJsZX5Db2xsYXBzaWJsZX5wcml2YXRlc1xuICovXG5jb25zdCBwcml2YXRlTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQSBjb250YWluZXIgb24gdGhlIHBhZ2UgdGhhdCBjYW4gYmUgZXhwYW5kZWQgb3IgY29sbGFwc2VkLlxuICovXG5jbGFzcyBDb2xsYXBzaWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjb2xsYXBzaWJsZSBwYW5lbCBhbmQgYWRkIGl0IHRvIHRoZSBET00uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBUaGUgcGFyZW50IG5vZGUgdW5kZXIgd2hpY2ggdGhlIGNvbGxhcHNpYmxlIGlzXG4gICAqICAgdG8gYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtyZWZlcmVuY2VOb2RlPW51bGxdIFRoZSBjaGlsZCBub2RlIGJlZm9yZSB3aGljaCB0aGVcbiAgICogICBjb2xsYXBzaWJsZSBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGNvbGxhcHNpYmxlIHdpbGwgYmVcbiAgICogICBhcHBlbmRlZCBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQncyBjaGlsZCBub2Rlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBTcGVjaWZpZXMgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF0gVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBjb2xsYXBzaWJsZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmNsYXNzTGlzdF0gQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gYmVcbiAgICogICBhcHBsaWVkIHRvIHRoZSBjb2xsYXBzaWJsZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29sbGFwc2VkXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgcGFuZWwgc2hvdWxkIGJlXG4gICAqICAgaW5pdGlhbGx5IGNvbGxhcHNlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgcmVmZXJlbmNlTm9kZSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGlmIChvcHRpb25zLmlkKSBjb250YWluZXIuaWQgPSBvcHRpb25zLmlkO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaWJsZScpO1xuICAgIGlmIChvcHRpb25zLmNsYXNzTGlzdCkgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4ub3B0aW9ucy5jbGFzc0xpc3QpO1xuXG4gICAgY29uc3QgaW5uZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaWJsZS1jb250ZW50Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlubmVyQ29udGFpbmVyKTtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgcmVmZXJlbmNlTm9kZSk7XG5cbiAgICBjb25zdCBwcml2YXRlcyA9IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGNvbnRlbnQ6IGlubmVyQ29udGFpbmVyLFxuICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICB9O1xuICAgIHByaXZhdGVNZW1iZXJzLnNldCh0aGlzLCBwcml2YXRlcyk7XG5cbiAgICBpZiAoJ2NvbGxhcHNlZCcgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmNvbGxhcHNlZCkgdGhpcy5jb2xsYXBzZSgpO1xuICAgIGVsc2UgdGhpcy5leHBhbmQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbnRhaW5lciBpcyBjdXJyZW50bHkgY29sbGFwc2VkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBjb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5jb2xsYXBzZWQ7XG4gIH1cblxuICBzZXQgY29sbGFwc2VkKGNvbGxhcHNlZCkge1xuICAgIGlmIChjb2xsYXBzZWQpIHRoaXMuY29sbGFwc2UoKTtcbiAgICBlbHNlIHRoaXMuZXhwYW5kKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlubmVyIGNvbnRhaW5lciBlbGVtZW50IGhvbGRpbmcgdGhlIHBhbmVsJ3MgY29udGVudC5cbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5jb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZCB0aGUgcGFuZWwsIHNvIHRoYXQgaXRzIGNvbnRlbnRzIGFyZSB2aXNpYmxlLlxuICAgKi9cbiAgZXhwYW5kKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChwcml2YXRlcy5jb2xsYXBzZWQpIHtcbiAgICAgIHByaXZhdGVzLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgcHJpdmF0ZXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNlZCcpO1xuICAgICAgcHJpdmF0ZXMuY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIHByaXZhdGVzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9TRUxFQ1RPUikuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGFwc2UgdGhlIHBhbmVsLCBzbyB0aGF0IGl0cyBjb250ZW50cyBhcmUgaGlkZGVuLlxuICAgKi9cbiAgY29sbGFwc2UoKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgaWYgKCFwcml2YXRlcy5jb2xsYXBzZWQpIHtcbiAgICAgIHByaXZhdGVzLmNvbGxhcHNlZCA9IHRydWU7XG4gICAgICBwcml2YXRlcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2VkJyk7XG4gICAgICBwcml2YXRlcy5jb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICBwcml2YXRlcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfU0VMRUNUT1IpLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgY29sbGFwc2VkIHN0YXRlIG9mIHRoZSBwYW5lbC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBhbmVsIGlzIGluIHRoZSBjb2xsYXBzZWQgc3RhdGUgYWZ0ZXIgdGhlXG4gICAqICAgdG9nZ2xlLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChwcml2YXRlcy5jb2xsYXBzZWQpIHRoaXMuZXhwYW5kKCk7XG4gICAgZWxzZSB0aGlzLmNvbGxhcHNlKCk7XG4gICAgcmV0dXJuIHByaXZhdGVzLmNvbGxhcHNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbGxhcHNpYmxlIGNvbnRhaW5lciB0byBhY2NvdW50IGZvciBjaGFuZ2VzIHRvIGl0cyBjb250ZW50LlxuICAgKiBUaGlzIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyIGFuZCBzaG91bGQgYmUgY2FsbGVkXG4gICAqIHdoZW5ldmVyIHRoZSBwYW5lbCdzIGNvbnRlbnQgaXMgYWx0ZXJlZC5cbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcbiAgICBjb25zdCBoZWlnaHQgPSBwcml2YXRlcy5jb2xsYXBzZWRcbiAgICAgID8gJzAnIDogYCR7cHJpdmF0ZXMuY29udGVudC5vZmZzZXRIZWlnaHR9cHhgO1xuICAgIHByaXZhdGVzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sbGFwc2libGU7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtEYXRlUGlja2VyXXtAbGluayBtb2R1bGU6ZGF0ZVBpY2tlcn5EYXRlUGlja2VyfSBjbGFzcy5cbiAqIEBtb2R1bGUgZGF0ZVBpY2tlclxuICovXG5cbmltcG9ydCB7XG4gIGFkZCxcbiAgaXNCZWZvcmUsXG4gIGlzU2FtZURheSxcbiAgaXNTYW1lTW9udGgsXG4gIGlzVG9kYXksXG4gIHN0YXJ0T2ZNb250aCxcbiAgc3RhcnRPZldlZWssXG59IGZyb20gJ2RhdGUtZm5zJztcblxuaW1wb3J0IHsgY3JlYXRlRm9ybUNvbnRyb2wsIGNyZWF0ZUljb25CdXR0b24gfSBmcm9tICcuL3V0aWxpdHkvZG9tJztcblxuY29uc3QgTU9OVEhTID0gW1xuICAnSmFudWFyeScsXG4gICdGZWJydWFyeScsXG4gICdNYXJjaCcsXG4gICdBcHJpbCcsXG4gICdNYXknLFxuICAnSnVuZScsXG4gICdKdWx5JyxcbiAgJ0F1Z3VzdCcsXG4gICdTZXB0ZW1iZXInLFxuICAnT2N0b2JlcicsXG4gICdOb3ZlbWJlcicsXG4gICdEZWNlbWJlcicsXG5dO1xuXG4vKipcbiAqIE9iamVjdCBob2xkaW5nIHByaXZhdGUgbWVtYmVycyBmb3IgdGhlXG4gKiBbRGF0ZVBpY2tlcl17QGxpbmsgbW9kdWxlOmRhdGVQaWNrZXJ+RGF0ZVBpY2tlcn0gY2xhc3MuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZGF0ZVBpY2tlcn5EYXRlUGlja2VyfnByaXZhdGVzXG4gKiBAcHJvcGVydHkge251bWJlcn0geWVhciBUaGUgeWVhciB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb250aCBUaGUgbW9udGggdGhhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQsIHJlcHJlc2VudGVkXG4gKiAgIGFzIGEgdmFsdWUgZnJvbSAwIHRvIDExLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRheSBUaGUgZGF5IG9mIHRoZSBtb250aCB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZCxcbiAqICAgcmVwcmVzZW50ZWQgYXMgYSB2YWx1ZSBmcm9tIDEgdG8gMzEuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlzcGxheWVkTW9udGggVGhlIG1vbnRoIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nXG4gKiAgIGRpc3BsYXllZCBpbiB0aGUgY2FsZW5kYXIgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXNwbGF5ZWRZZWFyIFRoZSB5ZWFyIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZFxuICogICBpbiB0aGUgY2FsZW5kYXIgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IG1vbnRoSW5wdXQgVGhlIHNlbGVjdCBib3ggZWxlbWVudCB0aGF0IGlzIHNob3duIGluXG4gKiAgIHRoZSBoZWFkZXIgYW5kIGlzIHVzZWQgdG8gc2VsZWN0IHRoZSBtb250aC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IHllYXJJbnB1dCBUaGUgaW5wdXQgZWxlbWVudCB0aGF0IGlzIHNob3duIGluIHRoZVxuICogICBoZWFkZXIgYW5kIGlzIHVzZWQgdG8gc2VsZWN0IHRoZSB5ZWFyLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF5R3JpZCBUaGUgY29udGFpbmVyIGVsZW1lbnQgaG9sZGluZyB0aGUgZ3JpZCBvZlxuICogICBjYWxlbmRhciBkYXlzLlxuICovXG5cbi8qKlxuICogSG9sZHMgcHJpdmF0ZSBkYXRhIGZvciB0aGUgW0RhdGVQaWNrZXJde0BsaW5rIG1vZHVsZTpkYXRlUGlja2VyfkRhdGVQaWNrZXJ9XG4gKiBjbGFzcy5cbiAqIEB0eXBlIHtXZWFrTWFwfVxuICogQHNlZSBtb2R1bGU6ZGF0ZVBpY2tlcn5EYXRlUGlja2VyfnByaXZhdGVzXG4gKi9cbmNvbnN0IHByaXZhdGVNZW1iZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDbGVhciB0aGUgZ3JpZCBvZiBjYWxlbmRhciBkYXlzIGFuZCByZWJ1aWxkIGl0IHVzaW5nIHRoZSBjdXJyZW50IGRpc3BsYXlcbiAqIG1vbnRoIGFuZCBkaXNwbGF5IHllYXIuXG4gKiBAcGFyYW0ge21vZHVsZTpkYXRlUGlja2VyfkRhdGVQaWNrZXJ9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZURheUdyaWQoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBwcml2YXRlcy5kYXlHcmlkLmlubmVySFRNTCA9ICcnO1xuXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShwcml2YXRlcy5kaXNwbGF5ZWRZZWFyLCBwcml2YXRlcy5kaXNwbGF5ZWRNb250aCwgMSk7XG4gIGlmIChwcml2YXRlcy5kaXNwbGF5ZWRZZWFyIDwgMTAwKSB7XG4gICAgLy8gRml4IGZvciB0d28tZGlnaXQgeWVhcnNcbiAgICBkYXRlLnNldEZ1bGxZZWFyKHByaXZhdGVzLmRpc3BsYXllZFllYXIpO1xuICB9XG5cbiAgY29uc3Qgc2VsZWN0ZWQgPSBpbnN0YW5jZS5kYXRlO1xuICBjb25zdCBtb250aFN0YXJ0ID0gc3RhcnRPZk1vbnRoKGRhdGUpO1xuICBjb25zdCBzdGFydCA9IHN0YXJ0T2ZXZWVrKG1vbnRoU3RhcnQpO1xuICBjb25zdCBlbmQgPSBhZGQoc3RhcnQsIHsgd2Vla3M6IDUsIGRheXM6IDYsIGhvdXJzOiAxMSB9KTtcblxuICBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXS5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgIGNvbnN0IGRheUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGRheUxhYmVsLmNsYXNzTGlzdC5hZGQoJ2RhdGUtcGlja2VyLWRheS1oZWFkZXInKTtcbiAgICBkYXlMYWJlbC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIHByaXZhdGVzLmRheUdyaWQuYXBwZW5kQ2hpbGQoZGF5TGFiZWwpO1xuICB9KTtcblxuICBsZXQgY3VycmVudERheSA9IHN0YXJ0O1xuICB3aGlsZSAoaXNCZWZvcmUoY3VycmVudERheSwgZW5kKSkge1xuICAgIGNvbnN0IGRheUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoJ2RhdGUtcGlja2VyLWRheScpO1xuXG4gICAgaWYgKGlzU2FtZURheShzZWxlY3RlZCwgY3VycmVudERheSkpIGRheUVsZW0uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICBlbHNlIGlmIChpc1RvZGF5KGN1cnJlbnREYXkpKSBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoJ3RvZGF5Jyk7XG5cbiAgICBpZiAoIWlzU2FtZU1vbnRoKGRhdGUsIGN1cnJlbnREYXkpKSB7XG4gICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoJ2RpZmZlcmVudC1tb250aCcpO1xuICAgIH1cblxuICAgIGRheUVsZW0udGV4dENvbnRlbnQgPSBjdXJyZW50RGF5LmdldERhdGUoKTtcbiAgICBkYXlFbGVtLmRhdGFzZXQueWVhciA9IGN1cnJlbnREYXkuZ2V0RnVsbFllYXIoKTtcbiAgICBkYXlFbGVtLmRhdGFzZXQubW9udGggPSBjdXJyZW50RGF5LmdldE1vbnRoKCk7XG4gICAgZGF5RWxlbS5kYXRhc2V0LmRheSA9IGN1cnJlbnREYXkuZ2V0RGF0ZSgpO1xuICAgIHByaXZhdGVzLmRheUdyaWQuYXBwZW5kQ2hpbGQoZGF5RWxlbSk7XG5cbiAgICBjdXJyZW50RGF5ID0gYWRkKGN1cnJlbnREYXksIHsgZGF5czogMSB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgbW9udGggYW5kIHllYXIgaW5wdXQgY29udHJvbHMgdG8gbWF0Y2ggdGhlIHNlbGVjdGVkIGRhdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpkYXRlUGlja2VyfkRhdGVQaWNrZXJ9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUlucHV0cyhpbnN0YW5jZSkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIHByaXZhdGVzLm1vbnRoSW5wdXQudmFsdWUgPSBwcml2YXRlcy5kaXNwbGF5ZWRNb250aC50b1N0cmluZygpO1xuICBwcml2YXRlcy55ZWFySW5wdXQudmFsdWUgPSBwcml2YXRlcy5kaXNwbGF5ZWRZZWFyLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBmb3JtIGVsZW1lbnRzIGZvciB0aGUgZGF0ZSBwaWNrZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpkYXRlUGlja2VyfkRhdGVQaWNrZXJ9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgVGhlIHBhcmVudCBET00gbm9kZSB1bmRlciB3aGljaCB0aGUgZm9ybVxuICogICBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1FbGVtZW50cyhpbnN0YW5jZSwgcGFyZW50KSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcblxuICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgnZGF0ZS1waWNrZXItaGVhZGluZycpO1xuXG4gIGNvbnN0IG1lbnVJdGVtcyA9IE1PTlRIUy5tYXAoKG1vbnRoLCBpbmRleCkgPT4gKFxuICAgIHsgdmFsdWU6IGluZGV4LnRvU3RyaW5nKCksIGxhYmVsOiBtb250aCB9XG4gICkpO1xuICBwcml2YXRlcy5tb250aElucHV0ID0gY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgIGlkOiAnZGF0ZS1waWNrZXItbW9udGgtc2VsZWN0JyxcbiAgICBuYW1lOiAnZGF0ZS1waWNrZXItbW9udGgtc2VsZWN0JyxcbiAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QtaW5saW5lJ10sXG4gICAgbWVudUl0ZW1zLFxuICB9KTtcblxuICBwcml2YXRlcy55ZWFySW5wdXQgPSBjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgaWQ6ICdkYXRlLXBpY2tlci15ZWFyLWlucHV0JyxcbiAgICBuYW1lOiAnZGF0ZS1waWNrZXIteWVhci1pbnB1dCcsXG4gICAgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtaW5saW5lJywgJ2Zvcm0taW5wdXQtY291bnQnXSxcbiAgfSk7XG5cbiAgY29uc3QgbW9udGhZZWFyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG1vbnRoWWVhckNvbnRhaW5lci5hcHBlbmRDaGlsZChwcml2YXRlcy5tb250aElucHV0KTtcbiAgY29uc3Qgc3BhY2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBzcGFjZXIuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgc3BhY2VyLnRleHRDb250ZW50ID0gJyAnO1xuICBtb250aFllYXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc3BhY2VyKTtcbiAgbW9udGhZZWFyQ29udGFpbmVyLmFwcGVuZENoaWxkKHByaXZhdGVzLnllYXJJbnB1dCk7XG4gIGhlYWRpbmcuYXBwZW5kQ2hpbGQobW9udGhZZWFyQ29udGFpbmVyKTtcblxuICBjb25zdCBidXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29uc3QgYmFja0J1dHRvbiA9IGNyZWF0ZUljb25CdXR0b24oJ25hdmlnYXRlX2JlZm9yZScpO1xuICBjb25zdCB0b2RheUJ1dHRvbiA9IGNyZWF0ZUljb25CdXR0b24oJ3RvZGF5Jyk7XG4gIGNvbnN0IGZvcndhcmRCdXR0b24gPSBjcmVhdGVJY29uQnV0dG9uKCduYXZpZ2F0ZV9uZXh0Jyk7XG4gIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChiYWNrQnV0dG9uKTtcbiAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHRvZGF5QnV0dG9uKTtcbiAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGZvcndhcmRCdXR0b24pO1xuICBoZWFkaW5nLmFwcGVuZENoaWxkKGJ1dHRvbkNvbnRhaW5lcik7XG5cbiAgcGFyZW50LmFwcGVuZENoaWxkKGhlYWRpbmcpO1xuXG4gIGNvbnN0IGdyaWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZ3JpZC5jbGFzc0xpc3QuYWRkKCdkYXRlLXBpY2tlci1ncmlkJyk7XG4gIHBhcmVudC5hcHBlbmRDaGlsZChncmlkKTtcbiAgcHJpdmF0ZXMuZGF5R3JpZCA9IGdyaWQ7XG5cbiAgdXBkYXRlSW5wdXRzKGluc3RhbmNlKTtcbiAgdXBkYXRlRGF5R3JpZChpbnN0YW5jZSk7XG5cbiAgYmFja0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGluc3RhbmNlLmdvVG9QcmV2aW91c01vbnRoKCkpO1xuICB0b2RheUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGluc3RhbmNlLmdvVG9UaGlzTW9udGgoKSk7XG4gIGZvcndhcmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBpbnN0YW5jZS5nb1RvTmV4dE1vbnRoKCkpO1xuICBwcml2YXRlcy5tb250aElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgcHJpdmF0ZXMuZGlzcGxheWVkTW9udGggPSBOdW1iZXIoZS50YXJnZXQudmFsdWUpO1xuICAgIHVwZGF0ZURheUdyaWQoaW5zdGFuY2UpO1xuICB9KTtcblxuICBjb25zdCB5ZWFyTGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgIGlmIChlLnR5cGUgPT09ICdjaGFuZ2UnIHx8IGUudGFyZ2V0LnZhbHVlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIoZS50YXJnZXQudmFsdWUpO1xuICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDAgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHByaXZhdGVzLmRpc3BsYXllZFllYXIgIT09IHZhbHVlKSB7XG4gICAgICAgICAgcHJpdmF0ZXMuZGlzcGxheWVkWWVhciA9IHZhbHVlO1xuICAgICAgICAgIHVwZGF0ZURheUdyaWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ2NoYW5nZScpIHtcbiAgICAgICAgZS50YXJnZXQudmFsdWUgPSBwcml2YXRlcy5kaXNwbGF5ZWRZZWFyLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBwcml2YXRlcy55ZWFySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB5ZWFyTGlzdGVuZXIpO1xuICBwcml2YXRlcy55ZWFySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgeWVhckxpc3RlbmVyKTtcblxuICBwcml2YXRlcy5kYXlHcmlkLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICBjb25zdCBlbGVtID0gZS50YXJnZXQ7XG4gICAgaWYgKGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdkYXRlLXBpY2tlci1kYXknKSkge1xuICAgICAgcHJpdmF0ZXMueWVhciA9IE51bWJlcihlbGVtLmRhdGFzZXQueWVhcik7XG4gICAgICBwcml2YXRlcy5tb250aCA9IE51bWJlcihlbGVtLmRhdGFzZXQubW9udGgpO1xuICAgICAgcHJpdmF0ZXMuZGF5ID0gTnVtYmVyKGVsZW0uZGF0YXNldC5kYXkpO1xuXG4gICAgICBpZiAocHJpdmF0ZXMuZGlzcGxheWVkTW9udGggIT09IHByaXZhdGVzLm1vbnRoXG4gICAgICAgIHx8IHByaXZhdGVzLmRpc3BsYXllZFllYXIgIT09IHByaXZhdGVzLnllYXIpIHtcbiAgICAgICAgcHJpdmF0ZXMuZGlzcGxheWVkTW9udGggPSBwcml2YXRlcy5tb250aDtcbiAgICAgICAgcHJpdmF0ZXMuZGlzcGxheWVkWWVhciA9IHByaXZhdGVzLnllYXI7XG4gICAgICAgIHVwZGF0ZUlucHV0cyhpbnN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZURheUdyaWQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ29udHJvbHMgYSBmb3JtIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSB0byBzZWxlY3QgYSBjYWxlbmRhciBkYXRlLlxuICovXG5jbGFzcyBEYXRlUGlja2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZGF0ZSBwaWNrZXIgZm9ybS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgRE9NIG5vZGUgdW5kZXIgd2hpY2ggdGhlIGZvcm1cbiAgICogICBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0RGF0ZV0gVGhlIGRhdGUgdGhhdCB3aWxsIGJlIGluaXRpYWxseSBzZWxlY3RlZC4gSWYgbm90XG4gICAqICAgZ2l2ZW4sIHRoZW4gdGhlIHByZXNlbnQgZGF0ZSBpcyB1c2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyZW50LCBzdGFydERhdGUpIHtcbiAgICBjb25zdCBkYXRlID0gc3RhcnREYXRlIHx8IG5ldyBEYXRlKCk7XG5cbiAgICBjb25zdCBwcml2YXRlcyA9IHtcbiAgICAgIHllYXI6IGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgIG1vbnRoOiBkYXRlLmdldE1vbnRoKCksXG4gICAgICBkYXk6IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgZGlzcGxheWVkTW9udGg6IGRhdGUuZ2V0TW9udGgoKSxcbiAgICAgIGRpc3BsYXllZFllYXI6IGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgIG1vbnRoSW5wdXQ6IG51bGwsXG4gICAgICB5ZWFySW5wdXQ6IG51bGwsXG4gICAgICBkYXlHcmlkOiBudWxsLFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcblxuICAgIGNyZWF0ZUZvcm1FbGVtZW50cyh0aGlzLCBwYXJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRlIHRoYXQgaXMgY3VycmVudGx5IHNlbGVjdGVkIGluIHRoZSBmb3JtLlxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG4gIGdldCBkYXRlKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgRGF0ZShwcml2YXRlcy55ZWFyLCBwcml2YXRlcy5tb250aCwgcHJpdmF0ZXMuZGF5KTtcbiAgICBpZiAocHJpdmF0ZXMueWVhciA8IDEwMCkge1xuICAgICAgLy8gRml4IGZvciB0d28tZGlnaXQgeWVhcnNcbiAgICAgIHZhbHVlLnNldEZ1bGxZZWFyKHByaXZhdGVzLnllYXIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHllYXIgdGhhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQgaW4gdGhlIGZvcm0uIEZvciBmb3VyLWRpZ2l0IHllYXJzLFxuICAgKiB0aGlzIHdpbGwgYmUgYSBmb3VyLWRpZ2l0IG51bWJlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFyKCkge1xuICAgIHJldHVybiBwcml2YXRlTWVtYmVycy5nZXQodGhpcykueWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbW9udGggdGhhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQgaW4gdGhlIGZvcm0sIGFzIGEgbnVtYmVyIGJldHdlZW4gMFxuICAgKiBhbmQgMTEsIHdpdGggSmFudWFyeSBjb3JyZXNwb25kaW5nIHRvIGEgdmFsdWUgb2YgMC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aCgpIHtcbiAgICByZXR1cm4gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLm1vbnRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXkgb2YgdGhlIG1vbnRoIHRoYXQgaXMgY3VycmVudGx5IHNlbGVjdGVkIGluIHRoZSBmb3JtLCBhcyBhIG51bWJlclxuICAgKiBiZXR3ZWVuIDEgYW5kIDMxLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICByZXR1cm4gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmRheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggdG8gdGhlIHByZXNlbnQgbW9udGguXG4gICAqL1xuICBnb1RvVGhpc01vbnRoKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgcHJpdmF0ZXMuZGlzcGxheWVkWWVhciA9IG5vdy5nZXRGdWxsWWVhcigpO1xuICAgIHByaXZhdGVzLmRpc3BsYXllZE1vbnRoID0gbm93LmdldE1vbnRoKCk7XG5cbiAgICB1cGRhdGVJbnB1dHModGhpcyk7XG4gICAgdXBkYXRlRGF5R3JpZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggdG8gdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgKi9cbiAgZ29Ub1ByZXZpb3VzTW9udGgoKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgaWYgKHByaXZhdGVzLmRpc3BsYXllZE1vbnRoID4gMCkge1xuICAgICAgcHJpdmF0ZXMuZGlzcGxheWVkTW9udGggLT0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpdmF0ZXMuZGlzcGxheWVkWWVhciAtPSAxO1xuICAgICAgcHJpdmF0ZXMuZGlzcGxheWVkTW9udGggPSAxMTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbnB1dHModGhpcyk7XG4gICAgdXBkYXRlRGF5R3JpZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggdG8gdGhlIG5leHQgbW9udGguXG4gICAqL1xuICBnb1RvTmV4dE1vbnRoKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChwcml2YXRlcy5kaXNwbGF5ZWRNb250aCA8IDExKSB7XG4gICAgICBwcml2YXRlcy5kaXNwbGF5ZWRNb250aCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcml2YXRlcy5kaXNwbGF5ZWRZZWFyICs9IDE7XG4gICAgICBwcml2YXRlcy5kaXNwbGF5ZWRNb250aCA9IDA7XG4gICAgfVxuXG4gICAgdXBkYXRlSW5wdXRzKHRoaXMpO1xuICAgIHVwZGF0ZURheUdyaWQodGhpcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0ZVBpY2tlcjtcbiIsIi8qKlxuICogRGVmaW5lcyB0aGUgW0ZpbHRlck1lbnVde0BsaW5rIG1vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV9IGNsYXNzLlxuICogQG1vZHVsZSBmaWx0ZXJNZW51XG4gKi9cblxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcblxuaW1wb3J0IENvbGxhcHNpYmxlIGZyb20gJy4vY29sbGFwc2libGUnO1xuaW1wb3J0IHsgY3JlYXRlSWNvbkJ1dHRvbiB9IGZyb20gJy4vdXRpbGl0eS9kb20nO1xuXG5jb25zdCBJQ09OX0VYUEFOREVEID0gJ2V4cGFuZF9tb3JlJztcbmNvbnN0IElDT05fQ09MTEFQU0VEID0gJ2NoZXZyb25fcmlnaHQnO1xuXG4vKipcbiAqIE9iamVjdCBob2xkaW5nIHByaXZhdGUgbWVtYmVycyBmb3IgdGhlXG4gKiBbRmlsdGVyTWVudV17QGxpbmsgbW9kdWxlOmZpbHRlck1lbnV+RmlsdGVyTWVudX0gY2xhc3MuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZmlsdGVyTWVudX5GaWx0ZXJNZW51fnByaXZhdGVzXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250YWluZXIgVGhlIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1lbnUuXG4gKiBAcHJvcGVydHkge21vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV+ZmlsdGVySW5mb30gc2VsZWN0ZWRGaWx0ZXIgRGVzY3JpYmVzXG4gKiAgIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFzayBmaWx0ZXIsIGlmIGFueS5cbiAqIEBwcm9wZXJ0eSB7TWFwfSBncm91cEVsZW1lbnRzIEEgbWFwIGFzc29jaWF0aW5nIGZpbHRlciBncm91cCBpZGVudGlmaWVycyB0b1xuICogICBbZ3JvdXBFbGVtZW50c117QGxpbmsgbW9kdWxlOmZpbHRlck1lbnV+RmlsdGVyTWVudX5ncm91cEVsZW1lbnRzfSBvYmplY3RzLlxuICogQHByb3BlcnR5IHtFdmVudEVtaXR0ZXJ9IGV2ZW50RW1pdHRlciBIb2xkcyB0aGUgZXZlbnQgZW1pdHRlci4gVGhlIGV2ZW50XG4gKiAgIGVtaXR0ZXIgZGlzcGF0Y2hlcyBldmVudHMgdG8gYW55IGF0dGFjaGVkIGV2ZW50IGxpc3RlbmVycy5cbiAqL1xuXG4vKipcbiAqIEhvbGRzIHByaXZhdGVzIGRhdGEgZm9yIHRoZSBbRmlsdGVyTWVudV17QGxpbmsgbW9kdWxlOmZpbHRlck1lbnV+RmlsdGVyTWVudX1cbiAqIGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV+cHJpdmF0ZXNcbiAqL1xuY29uc3QgcHJpdmF0ZU1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEdldCB0aGUgW2dyb3VwRWxlbWVudHNde0BsaW5rIG1vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV+Z3JvdXBFbGVtZW50c31cbiAqIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggYSBmaWx0ZXIgZ3JvdXAuXG4gKiBAcGFyYW0ge21vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBJZCBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwIHdob3NlIGVsZW1lbnRzIGFyZSB0b1xuICogICBiZSByZXRyaWV2ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6ZmlsdGVyTWVudX5GaWx0ZXJNZW51fmdyb3VwRWxlbWVudHN9IFRoZSBvYmplY3QgY29udGFpbmluZ1xuICogICB0aGUgZ3JvdXAncyBET00gZWxlbWVudHMuXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiB0aGUgZ2l2ZW4gZ3JvdXAgaWRlbnRpZmllciBpcyBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBnZXRHcm91cEVsZW1lbnRzKGluc3RhbmNlLCBncm91cElkKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKS5ncm91cEVsZW1lbnRzLmdldChncm91cElkKTtcbiAgaWYgKCFlbGVtZW50cykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgbG9jYXRlIGZpbHRlciBncm91cCBcIiR7Z3JvdXBJZH1cImApO1xuICB9XG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGxpc3QgaXRlbSBlbGVtZW50IGluIHRoZSBET00gYmVsb25naW5nIHRvIGEgcGFydGljdWxhciBmaWx0ZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBJZCBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwIGNvbnRhaW5pbmcgdGhlXG4gKiAgIGZpbHRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWx0ZXJJZCBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGZpbHRlci5cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGxpc3QgaXRlbSBlbGVtZW50IGZvciB0aGUgZmlsdGVyLlxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgZWl0aGVyIHRoZSBncm91cCBvciBmaWx0ZXIgaWRlbnRpZmllcnMgYXJlXG4gKiAgIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGdldEZpbHRlckl0ZW1FbGVtZW50KGluc3RhbmNlLCBncm91cElkLCBmaWx0ZXJJZCkge1xuICBjb25zdCBpdGVtID0gZ2V0R3JvdXBFbGVtZW50cyhpbnN0YW5jZSwgZ3JvdXBJZCkuZmlsdGVySXRlbXMuZ2V0KGZpbHRlcklkKTtcbiAgaWYgKCFpdGVtKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCBsb2NhdGUgZmlsdGVyIFwiJHtmaWx0ZXJJZH1cIiBpbiBncm91cCBgXG4gICAgICArIGBcIiR7Z3JvdXBJZH1cImApO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSBmaWx0ZXIgc2VsZWN0aW9uLCBidXQgZG8gc28gd2l0aG91dCBmaXJpbmcgYW55IGV2ZW50cy5cbiAqIEBwYXJhbSB7bW9kdWxlOmZpbHRlck1lbnV+RmlsdGVyTWVudX0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoXG4gKiAgIHRvIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2lsZW50Q2xlYXJTZWxlY3Rpb24oaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBpZiAocHJpdmF0ZXMuc2VsZWN0ZWRGaWx0ZXIuZ3JvdXAgJiYgcHJpdmF0ZXMuc2VsZWN0ZWRGaWx0ZXIuZmlsdGVyKSB7XG4gICAgY29uc3QgbGlzdEl0ZW0gPSBnZXRGaWx0ZXJJdGVtRWxlbWVudChcbiAgICAgIGluc3RhbmNlLFxuICAgICAgcHJpdmF0ZXMuc2VsZWN0ZWRGaWx0ZXIuZ3JvdXAsXG4gICAgICBwcml2YXRlcy5zZWxlY3RlZEZpbHRlci5maWx0ZXIsXG4gICAgKTtcbiAgICBsaXN0SXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICB9XG5cbiAgcHJpdmF0ZXMuc2VsZWN0ZWRGaWx0ZXIuZ3JvdXAgPSBudWxsO1xuICBwcml2YXRlcy5zZWxlY3RlZEZpbHRlci5maWx0ZXIgPSBudWxsO1xufVxuXG4vKipcbiAqIEEgY3VzdG9taXphYmxlIG1lbnUgb2YgdGFzayBmaWx0ZXJzLlxuICovXG5jbGFzcyBGaWx0ZXJNZW51IHtcbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBhIGZpbHRlciBpdGVtIGlzIHNlbGVjdGVkLCBvciB3aGVuIHRoZSBzZWxlY3Rpb25cbiAgICogaXMgY2xlYXJlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV+c2VsZWN0RmlsdGVyXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlOiBzZWxlY3QtZmlsdGVyLlxuICAgKiBAcHJvcGVydHkge21vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV9IHRhcmdldCBUaGUgZmlsdGVyIG1lbnUgdGhhdCBmaXJlZFxuICAgKiAgIHRoZSBldmVudC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtncm91cElkXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGZpbHRlciBncm91cFxuICAgKiAgIGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIGZpbHRlciwgaWYgYW55LlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpbHRlcklkXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGZpbHRlciB0aGF0IHdhc1xuICAgKiAgIHNlbGVjdGVkLCBpZiBhbnkuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmlsdGVyTGFiZWxdIFRoZSBkaXNwbGF5ZWQgbGFiZWwgZm9yIHRoZSBmaWx0ZXIgdGhhdFxuICAgKiAgIHdhcyBzZWxlY3RlZCwgaWYgYW55LlxuICAgKi9cblxuICAvKipcbiAgICogSWRlbnRpZmllcyBhIHRhc2sgZmlsdGVyIGluIHRoZSBtZW51LlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZmlsdGVyTWVudX5GaWx0ZXJNZW51fmZpbHRlckluZm9cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtncm91cF0gVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBmaWx0ZXIgZ3JvdXBcbiAgICogICBjb250YWluaW5nIHRoZSBmaWx0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmlsdGVyXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGZpbHRlci5cbiAgICovXG5cbiAgLyoqXG4gICAqIEhvbGRzIHJlZmVyZW5jZXMgdG8gRE9NIGVsZW1lbnRzIHJlbGF0ZWQgdG8gYSBwYXJ0aWN1bGFyIGZpbHRlciBncm91cCBpblxuICAgKiB0aGUgZmlsdGVyIG1lbnUuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV+Z3JvdXBFbGVtZW50c1xuICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250YWluZXIgVGhlIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgZ3JvdXAuXG4gICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IFtleHBhbmRJY29uXSBUaGUgZXhwYW5kL2NvbGxhcHNlIGljb24gZWxlbWVudCBpblxuICAgKiAgIHRoZSBncm91cCBoZWFkaW5nIChpZiBhbnkpLlxuICAgKiBAcHJvcGVydHkge21vZHVsZTpjb2xsYXBzaWJsZX5Db2xsYXBzaWJsZX0gW2NvbGxhcHNpYmxlXSBUaGUgY29sbGFwc2libGVcbiAgICogICBwYW5lbCBjb250YWluaW5nIHRoZSBncm91cCdzIGZpbHRlciBsaXN0LiBJZiB0aGUgZ3JvdXAgY2Fubm90IGJlXG4gICAqICAgY29sbGFwc2VkLCB0aGlzIHNob3VsZCBiZSBudWxsLlxuICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBmaWx0ZXJMaXN0IFRoZSBsaXN0IGVsZW1lbnQgY29udGFpbmluZyB0aGVcbiAgICogICBmaWx0ZXIgaXRlbXMgYmVsb25naW5nIHRvIHRoZSBncm91cC5cbiAgICogQHByb3BlcnR5IHtNYXB9IGZpbHRlckl0ZW1zIEEgbWFwIGFzc29jaWF0aW5nIGZpbHRlciBpZGVudGlmaWVycyB0byB0aGVcbiAgICogICBsaXN0IGl0ZW0gZWxlbWVudHMgaW4gdGhlIERPTSBiZWxvbmdpbmcgdG8gZWFjaCBmaWx0ZXIgaXRlbSBpbiB0aGVcbiAgICogICBncm91cC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZpbHRlciBtZW51IGFuZCBhZGQgaXQgdG8gdGhlIERPTS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgRE9NIG5vZGUgdGhhdCB3aWxsIGNvbnRhaW4gdGhlXG4gICAqICAgbWVudS5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gW2dyb3Vwc10gQW4gYXJyYXkgb2YgZmlsdGVyIGdyb3VwcyB0byBhZGQgdG8gdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cHNbXS5pZCBUaGUgaWRlbnRpZmllciBvZiB0aGUgZmlsdGVyIGdyb3VwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2dyb3Vwc1tdLmxhYmVsXSBUaGUgZGlzcGxheWVkIGxhYmVsIGZvciB0aGUgZmlsdGVyIGdyb3VwLlxuICAgKiAgIElmIG5vdCBnaXZlbiwgdGhlIGdyb3VwIHdpbGwgaGF2ZSBubyBoZWFkaW5nIGFuZCB3aWxsIG5vdCBiZVxuICAgKiAgIGNvbGxhcHNpYmxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyZW50LCBncm91cHMpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHtcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIHNlbGVjdGVkRmlsdGVyOiB7IGdyb3VwOiBudWxsLCBmaWx0ZXI6IG51bGwgfSxcbiAgICAgIGdyb3VwRWxlbWVudHM6IG5ldyBNYXAoKSxcbiAgICAgIGV2ZW50RW1pdHRlcjogbmV3IEV2ZW50RW1pdHRlcigpLFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcblxuICAgIHByaXZhdGVzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHByaXZhdGVzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmaWx0ZXItbWVudScpO1xuXG4gICAgaWYgKGdyb3Vwcykge1xuICAgICAgZ3JvdXBzLmZvckVhY2goKGdyb3VwKSA9PiB0aGlzLmFkZEdyb3VwKGdyb3VwLmlkLCBncm91cC5sYWJlbCkpO1xuICAgIH1cblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChwcml2YXRlcy5jb250YWluZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGZpbHRlciBncm91cCB0byB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgZ3JvdXAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdIFRoZSBkaXNwbGF5ZWQgbGFiZWwgZm9yIHRoZSBncm91cC4gSWYgbm90IGdpdmVuLFxuICAgKiAgIHRoZSBncm91cCB3aWxsIGhhdmUgbm8gaGVhZGluZyBhbmQgd2lsbCBub3QgYmUgY29sbGFwc2libGUuXG4gICAqL1xuICBhZGRHcm91cChpZCwgbGFiZWwpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcblxuICAgIGNvbnN0IGdyb3VwQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZ3JvdXBDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZmlsdGVyLWdyb3VwJyk7XG4gICAgZ3JvdXBDb250YWluZXIuZGF0YXNldC5ncm91cElkID0gaWQ7XG5cbiAgICBsZXQgdG9nZ2xlID0gbnVsbDtcbiAgICBsZXQgYXJyb3cgPSBudWxsO1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgY29uc3QgaGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCdmaWx0ZXItZ3JvdXAtaGVhZGluZycpO1xuICAgICAgZ3JvdXBDb250YWluZXIuYXBwZW5kQ2hpbGQoaGVhZGluZyk7XG5cbiAgICAgIHRvZ2dsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgdG9nZ2xlLmNsYXNzTGlzdC5hZGQoJ2ZpbHRlci1ncm91cC10b2dnbGUnKTtcbiAgICAgIGhlYWRpbmcuYXBwZW5kQ2hpbGQodG9nZ2xlKTtcblxuICAgICAgY29uc3QgaWNvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaWNvbkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdpY29uLWNvbnRhaW5lcicpO1xuICAgICAgaGVhZGluZy5hcHBlbmRDaGlsZChpY29uQ29udGFpbmVyKTtcblxuICAgICAgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBhcnJvdy5jbGFzc0xpc3QuYWRkKCdpY29uJywgJ21hdGVyaWFsLWljb25zJywgJ2ZpbHRlci1ncm91cC1leHBhbmQtaWNvbicpO1xuICAgICAgYXJyb3cudGV4dENvbnRlbnQgPSBJQ09OX0NPTExBUFNFRDtcbiAgICAgIHRvZ2dsZS5hcHBlbmRDaGlsZChhcnJvdyk7XG5cbiAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICB0ZXh0LmNsYXNzTGlzdC5hZGQoJ2ZpbHRlci1ncm91cC1sYWJlbCcpO1xuICAgICAgdGV4dC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgdG9nZ2xlLmFwcGVuZENoaWxkKHRleHQpO1xuICAgIH1cblxuICAgIGxldCBjb2xsYXBzaWJsZTtcbiAgICBsZXQgbGlzdENvbnRhaW5lcjtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIGNvbGxhcHNpYmxlID0gbmV3IENvbGxhcHNpYmxlKGdyb3VwQ29udGFpbmVyLCBudWxsLCB7IGNvbGxhcHNlZDogdHJ1ZSB9KTtcbiAgICAgIGxpc3RDb250YWluZXIgPSBjb2xsYXBzaWJsZS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xsYXBzaWJsZSA9IG51bGw7XG4gICAgICBsaXN0Q29udGFpbmVyID0gZ3JvdXBDb250YWluZXI7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgbGlzdC5jbGFzc0xpc3QuYWRkKCdmaWx0ZXItbGlzdCcpO1xuICAgIGxpc3RDb250YWluZXIuYXBwZW5kQ2hpbGQobGlzdCk7XG5cbiAgICBwcml2YXRlcy5ncm91cEVsZW1lbnRzLnNldChpZCwge1xuICAgICAgY29udGFpbmVyOiBncm91cENvbnRhaW5lcixcbiAgICAgIGV4cGFuZEljb246IGFycm93LFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBmaWx0ZXJMaXN0OiBsaXN0LFxuICAgICAgZmlsdGVySXRlbXM6IG5ldyBNYXAoKSxcbiAgICB9KTtcblxuICAgIGlmICh0b2dnbGUpIHRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMudG9nZ2xlR3JvdXAoaWQpKTtcblxuICAgIHByaXZhdGVzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChncm91cENvbnRhaW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZmlsdGVyIHRvIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBJZCBUaGUgaWRlbnRpZmllciBvZiB0aGUgZ3JvdXAgaW4gd2hpY2ggdG8gaW5zZXJ0IHRoZVxuICAgKiAgIGZpbHRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlcklkIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgVGhlIGRpc3BsYXllZCBsYWJlbCBmb3IgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3QgaG9sZGluZyBvcHRpb25zIGNvbnRyb2xsaW5nIHRoZVxuICAgKiAgIGZpbHRlciBpbnNlcnRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb3VudD0wXSBUaGUgbnVtYmVyIG9mIHRhc2tzIG1hdGNoaW5nIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbnNlcnRCZWZvcmVdIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgZmlsdGVyXG4gICAqICAgYmVmb3JlIHdoaWNoIHRoZSBuZXcgZmlsdGVyIHNob3VsZCBiZSBpbnNlcnRlZC4gSWYgbm90IGdpdmVuLCB0aGVuIHRoZVxuICAgKiAgIGZpbHRlciB3aWxsIGJlIGluc2VydGVkIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIHRoZSBncm91cCBpZGVudGlmaWVyIGlzIGludmFsaWQuXG4gICAqL1xuICBhZGRGaWx0ZXIoZ3JvdXBJZCwgZmlsdGVySWQsIGxhYmVsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBncm91cEVsZW1lbnRzID0gZ2V0R3JvdXBFbGVtZW50cyh0aGlzLCBncm91cElkKTtcblxuICAgIGNvbnN0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnZmlsdGVyLWl0ZW0nKTtcbiAgICBpdGVtLmRhdGFzZXQuZmlsdGVySWQgPSBmaWx0ZXJJZDtcbiAgICBpdGVtLmRhdGFzZXQuZmlsdGVyTGFiZWwgPSBsYWJlbDtcblxuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdmaWx0ZXItaXRlbS1zZWxlY3RvcicpO1xuICAgIGl0ZW0uYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgIGNvbnN0IGxhYmVsRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBsYWJlbEVsZW0uY2xhc3NMaXN0LmFkZCgnZmlsdGVyLWl0ZW0tbGFiZWwnKTtcbiAgICBsYWJlbEVsZW0udGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICBidXR0b24uYXBwZW5kQ2hpbGQobGFiZWxFbGVtKTtcblxuICAgIGNvbnN0IGNvdW50RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBjb3VudEVsZW0uY2xhc3NMaXN0LmFkZCgnZmlsdGVyLWl0ZW0tY291bnQnKTtcbiAgICBjb3VudEVsZW0udGV4dENvbnRlbnQgPSBvcHRpb25zLmNvdW50IHx8ICcnO1xuICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChjb3VudEVsZW0pO1xuXG4gICAgbGV0IHJlZmVyZW5jZU5vZGUgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmluc2VydEJlZm9yZSkge1xuICAgICAgcmVmZXJlbmNlTm9kZSA9IGdldEZpbHRlckl0ZW1FbGVtZW50KHRoaXMsIGdyb3VwSWQsIG9wdGlvbnMuaW5zZXJ0QmVmb3JlKTtcbiAgICB9XG5cbiAgICBncm91cEVsZW1lbnRzLmZpbHRlckxpc3QuaW5zZXJ0QmVmb3JlKGl0ZW0sIHJlZmVyZW5jZU5vZGUpO1xuICAgIGdyb3VwRWxlbWVudHMuZmlsdGVySXRlbXMuc2V0KGZpbHRlcklkLCBpdGVtKTtcblxuICAgIGdyb3VwRWxlbWVudHMuY29sbGFwc2libGU/LnVwZGF0ZSgpO1xuXG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5zZWxlY3RGaWx0ZXIoZ3JvdXBJZCwgZmlsdGVySWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZpbHRlciBmcm9tIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBJZCBUaGUgaWRlbnRpZmllciBvZiB0aGUgZ3JvdXAgY29udGFpbmluZyB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsdGVySWQgVGhlIGlkZW50aWZpZXIgb2YgdGhlIGZpbHRlciB0byByZW1vdmUuXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGVpdGhlciB0aGUgZ3JvdXAgb3IgZmlsdGVyIGlkZW50aWZpZXJzIGFyZVxuICAgKiAgIGludmFsaWQuXG4gICAqL1xuICByZW1vdmVGaWx0ZXIoZ3JvdXBJZCwgZmlsdGVySWQpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcblxuICAgIC8vIElmIGZpbHRlciBpcyBzZWxlY3RlZCwgY2xlYXIgc2VsZWN0aW9uXG4gICAgaWYgKHByaXZhdGVzLnNlbGVjdGVkRmlsdGVyLmdyb3VwID09PSBncm91cElkXG4gICAgICAmJiBwcml2YXRlcy5zZWxlY3RlZEZpbHRlci5maWx0ZXIgPT09IGZpbHRlcklkKSB7XG4gICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3JvdXBFbGVtZW50cyA9IGdldEdyb3VwRWxlbWVudHModGhpcywgZ3JvdXBJZCk7XG4gICAgY29uc3QgaXRlbSA9IGdldEZpbHRlckl0ZW1FbGVtZW50KHRoaXMsIGdyb3VwSWQsIGZpbHRlcklkKTtcbiAgICBncm91cEVsZW1lbnRzLmZpbHRlckxpc3QucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgZ3JvdXBFbGVtZW50cy5maWx0ZXJJdGVtcy5kZWxldGUoZmlsdGVySWQpO1xuICAgIGdyb3VwRWxlbWVudHMuY29sbGFwc2libGU/LnVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgdGhlIGZpbHRlcnMgaW4gYSBmaWx0ZXIgZ3JvdXAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwIHRvIGVtcHR5LlxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiB0aGUgZ3JvdXAgaWRlbnRpZmllciBpcyBpbnZhbGlkLlxuICAgKi9cbiAgcmVtb3ZlQWxsRmlsdGVycyhpZCkge1xuICAgIC8vIElmIGEgZmlsdGVyIGluIHRoZSBncm91cCBpcyBzZWxlY3RlZCwgY2xlYXIgc2VsZWN0aW9uXG4gICAgaWYgKHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5zZWxlY3RlZEZpbHRlci5ncm91cCA9PT0gaWQpIHtcbiAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBjb25zdCBncm91cEVsZW1lbnRzID0gZ2V0R3JvdXBFbGVtZW50cyh0aGlzLCBpZCk7XG4gICAgY29uc3QgbGlzdCA9IGdyb3VwRWxlbWVudHMuZmlsdGVyTGlzdDtcbiAgICBncm91cEVsZW1lbnRzLmZpbHRlckl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IGxpc3QucmVtb3ZlQ2hpbGQoaXRlbSkpO1xuICAgIGdyb3VwRWxlbWVudHMuZmlsdGVySXRlbXMuY2xlYXIoKTtcbiAgICBncm91cEVsZW1lbnRzLmNvbGxhcHNpYmxlPy51cGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBmaWx0ZXIgZXhpc3RzIGluIGEgZmlsdGVyIGdyb3VwLiBUaGlzIG1ldGhvZFxuICAgKiB3aWxsIHJldHVybiBmYWxzZSBpZiBlaXRoZXIgdGhlIGdyb3VwIGRvZXMgbm90IGV4aXN0LCBvciBpZiB0aGUgZmlsdGVyXG4gICAqIGRvZXMgbm90IGV4aXN0IHdpdGhpbiB0aGUgZ3JvdXAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cElkIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBncm91cCBjb250YWluaW5nIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWx0ZXJJZCBUaGUgaWRlbnRpZmllciBvZiB0aGUgZmlsdGVyIHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBncm91cCBhbmQgZmlsdGVyIGV4aXN0IGluIHRoZSBmaWx0ZXJcbiAgICogICBtZW51LlxuICAgKi9cbiAgaGFzRmlsdGVyKGdyb3VwSWQsIGZpbHRlcklkKSB7XG4gICAgY29uc3QgZ3JvdXBFbGVtZW50cyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5ncm91cEVsZW1lbnRzLmdldChncm91cElkKTtcbiAgICByZXR1cm4gZ3JvdXBFbGVtZW50cyA/IGdyb3VwRWxlbWVudHMuZmlsdGVySXRlbXMuaGFzKGZpbHRlcklkKSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZCBhIGZpbHRlciBncm91cCwgc28gdGhhdCBpdHMgZmlsdGVyIGl0ZW1zIGFyZSB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cCB0byBiZSBleHBhbmRlZC5cbiAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgdGhlIGdyb3VwIGlkZW50aWZpZXIgaXMgaW52YWxpZC5cbiAgICovXG4gIGV4cGFuZEdyb3VwKGlkKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBnZXRHcm91cEVsZW1lbnRzKHRoaXMsIGlkKTtcbiAgICBjb25zdCB7IGNvbGxhcHNpYmxlIH0gPSBlbGVtZW50cztcbiAgICBpZiAoY29sbGFwc2libGUpIHtcbiAgICAgIGNvbGxhcHNpYmxlLmV4cGFuZCgpO1xuICAgICAgZWxlbWVudHMuZXhwYW5kSWNvbi50ZXh0Q29udGVudCA9IElDT05fRVhQQU5ERUQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxhcHNlIGEgZmlsdGVyIGdyb3VwLCBzbyB0aGF0IGl0cyBmaWx0ZXIgaXRlbXMgYXJlIGhpZGRlbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAgdG8gYmUgY29sbGFwc2VkLlxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiB0aGUgZ3JvdXAgaWRlbnRpZmllciBpcyBpbnZhbGlkLlxuICAgKi9cbiAgY29sbGFwc2VHcm91cChpZCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZ2V0R3JvdXBFbGVtZW50cyh0aGlzLCBpZCk7XG4gICAgY29uc3QgeyBjb2xsYXBzaWJsZSB9ID0gZWxlbWVudHM7XG4gICAgaWYgKGNvbGxhcHNpYmxlKSB7XG4gICAgICBjb2xsYXBzaWJsZS5jb2xsYXBzZSgpO1xuICAgICAgZWxlbWVudHMuZXhwYW5kSWNvbi50ZXh0Q29udGVudCA9IElDT05fQ09MTEFQU0VEO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIGNvbGxhcHNlZCBzdGF0ZSBvZiBhIGZpbHRlciBncm91cC4gSWYgdGhlIGdyb3VwIGlzIGNvbGxhcHNlZCxcbiAgICogaXQgd2lsbCBiZSBleHBhbmRlZCBhbmQgdmljZSB2ZXJzYS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAgdG8gZXhwYW5kIG9yIGNvbGxhcHNlLlxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiB0aGUgZ3JvdXAgaWRlbnRpZmllciBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdG9nZ2xlR3JvdXAoaWQpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGdldEdyb3VwRWxlbWVudHModGhpcywgaWQpO1xuICAgIGNvbnN0IHsgY29sbGFwc2libGUgfSA9IGVsZW1lbnRzO1xuICAgIGlmIChjb2xsYXBzaWJsZSkge1xuICAgICAgaWYgKGNvbGxhcHNpYmxlLmNvbGxhcHNlZCkgdGhpcy5leHBhbmRHcm91cChpZCk7XG4gICAgICBlbHNlIHRoaXMuY29sbGFwc2VHcm91cChpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBpY29uIGJ1dHRvbiB0byBhIGdyb3VwIGhlYWRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cElkIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBncm91cCBpbiB3aGljaCB0byBpbnNlcnQgdGhlXG4gICAqICAgaWNvbiBidXR0b24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpY29uVHlwZSBUaGUgdHlwZSBvZiBpY29uIHRvIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gQW4gb2JqZWN0IGhvbGRpbmcgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvclxuICAgKiAgIHRoZSBidXR0b24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgYnV0dG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RpdGxlXSBUaGUgdGl0bGUgb2YgdGhlIGJ1dHRvbiwgdXN1YWxseSBkaXNwbGF5ZWQgYnkgdGhlXG4gICAqICAgYnJvd3NlciBhcyBhIHRvb2x0aXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuXG4gICAqICAgdGhlIGJ1dHRvbiBpcyBjbGlja2VkLiBUaGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBzdGFuZGFyZCBFdmVudFxuICAgKiAgIG9iamVjdCBhcyBhbiBhcmd1bWVudCB3aGVuIGludm9rZWQuXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIHRoZSBncm91cCBpZGVudGlmaWVyIGlzIGludmFsaWQuXG4gICAqL1xuICBhZGRHcm91cEljb25CdXR0b24oZ3JvdXBJZCwgaWNvblR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSBnZXRHcm91cEVsZW1lbnRzKHRoaXMsIGdyb3VwSWQpO1xuICAgIGNvbnN0IGljb25Db250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmljb24tY29udGFpbmVyJyk7XG4gICAgY29uc3QgYnV0dG9uID0gY3JlYXRlSWNvbkJ1dHRvbihpY29uVHlwZSwge1xuICAgICAgaWQ6IG9wdGlvbnMuaWQgfHwgbnVsbCxcbiAgICAgIHRpdGxlOiBvcHRpb25zLnRpdGxlIHx8IG51bGwsXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9wdGlvbnMuY2FsbGJhY2spO1xuXG4gICAgaWNvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChidXR0b24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIGZpbHRlciBpbiB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwSWQgVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cCBjb250YWluaW5nIHRoZSBmaWx0ZXJcbiAgICogICB0byBiZSBzZWxlY3RlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlcklkIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgZmlsdGVyIHRvIGJlIHNlbGVjdGVkLlxuICAgKiBAZmlyZXMgbW9kdWxlOmZpbHRlck1lbnV+RmlsdGVyTWVudX5zZWxlY3RGaWx0ZXJcbiAgICovXG4gIHNlbGVjdEZpbHRlcihncm91cElkLCBmaWx0ZXJJZCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIHNpbGVudENsZWFyU2VsZWN0aW9uKHRoaXMpO1xuXG4gICAgLy8gRXhwYW5kIHRoZSBjb250YWluaW5nIGdyb3VwIGlmIGl0IGlzIG5vdCBhbHJlYWR5XG4gICAgdGhpcy5leHBhbmRHcm91cChncm91cElkKTtcblxuICAgIGNvbnN0IGxpc3RJdGVtID0gZ2V0RmlsdGVySXRlbUVsZW1lbnQodGhpcywgZ3JvdXBJZCwgZmlsdGVySWQpO1xuICAgIGxpc3RJdGVtLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgcHJpdmF0ZXMuc2VsZWN0ZWRGaWx0ZXIuZ3JvdXAgPSBncm91cElkO1xuICAgIHByaXZhdGVzLnNlbGVjdGVkRmlsdGVyLmZpbHRlciA9IGZpbHRlcklkO1xuICAgIGNvbnN0IHsgZmlsdGVyTGFiZWwgfSA9IGxpc3RJdGVtLmRhdGFzZXQ7XG4gICAgcHJpdmF0ZXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3NlbGVjdC1maWx0ZXInLCB7XG4gICAgICB0eXBlOiAnc2VsZWN0LWZpbHRlcicsXG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICBncm91cElkLFxuICAgICAgZmlsdGVySWQsXG4gICAgICBmaWx0ZXJMYWJlbCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgZmlsdGVyIHNlbGVjdGlvbiwgc28gdGhhdCBub25lIG9mIHRoZSBmaWx0ZXJzIGluIHRoZSBtZW51IGFyZVxuICAgKiBzZWxlY3RlZC5cbiAgICogQGZpcmVzIG1vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV+c2VsZWN0RmlsdGVyXG4gICAqL1xuICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICBzaWxlbnRDbGVhclNlbGVjdGlvbih0aGlzKTtcbiAgICBwcml2YXRlTWVtYmVycy5nZXQodGhpcykuZXZlbnRFbWl0dGVyLmVtaXQoJ3NlbGVjdC1maWx0ZXInLCB7XG4gICAgICB0eXBlOiAnc2VsZWN0LWZpbHRlcicsXG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICBncm91cElkOiBudWxsLFxuICAgICAgZmlsdGVySWQ6IG51bGwsXG4gICAgICBmaWx0ZXJMYWJlbDogbnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgdGFzayBmaWx0ZXIgdGhhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQgaW4gdGhlIG1lbnUsIGlmIGFueS5cbiAgICogQHJldHVybnMge21vZHVsZTpmaWx0ZXJNZW51fkZpbHRlck1lbnV+ZmlsdGVySW5mb30gQW4gb2JqZWN0IGRlc2NyaWJpbmdcbiAgICogICB0aGUgc2VsZWN0ZWQgZmlsdGVyLlxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiBfLmNsb25lRGVlcChwcml2YXRlTWVtYmVycy5nZXQodGhpcykuc2VsZWN0ZWRGaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGV2ZW50IGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudFxuICAgKiAgIGlzIGZpcmVkLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5ldmVudEVtaXR0ZXIub24odHlwZSwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlck1lbnU7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtNb2RhbFN0YWNrXXtAbGluayBtb2R1bGU6bW9kYWxTdGFja35Nb2RhbFN0YWNrfSBjbGFzcy5cbiAqIEBtb2R1bGUgbW9kYWxTdGFja1xuICovXG5cbmltcG9ydCB7IGNyZWF0ZUljb25CdXR0b24gfSBmcm9tICcuL3V0aWxpdHkvZG9tJztcblxuY29uc3QgRk9DVVNBQkxFX1NFTEVDVE9SID0gW1xuICAnYVtocmVmXScsXG4gICdpbnB1dCcsXG4gICdzZWxlY3QnLFxuICAndGV4dGFyZWEnLFxuICAnYnV0dG9uJyxcbl0uam9pbignLCAnKTtcbmNvbnN0IFpfSU5ERVhfU1RBUlQgPSA1MDA7XG5jb25zdCBaX0lOREVYX1NURVAgPSAxMDA7XG5jb25zdCBaX0lOREVYX09WRVJMQVlfU1RFUCA9IDUwO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgY2xhc3NlcyB0aGF0IHJlcHJlc2VudCBhIG1vZGFsIGRpYWxvZy5cbiAqIEBpbnRlcmZhY2UgTW9kYWxcbiAqL1xuXG4vKipcbiAqIFRoZSB0aXRsZSBvZiB0aGUgbW9kYWwuXG4gKiBAbWVtYmVyIHtzdHJpbmd9IG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsI3RpdGxlXG4gKi9cblxuLyoqXG4gKiBUaGUgbGFiZWwgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGNvbmZpcm0gYnV0dG9uLCBzaG93biBhdCB0aGUgYm90dG9tIG9mXG4gKiB0aGUgbW9kYWwuXG4gKiBAbWVtYmVyIHtzdHJpbmd9IG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsI2NvbmZpcm1MYWJlbFxuICogQGRlZmF1bHQgT2theVxuICovXG5cbi8qKlxuICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBjYW5jZWwgYnV0dG9uLCBzaG93biBhdCB0aGUgYm90dG9tIG9mXG4gKiB0aGUgbW9kYWwuXG4gKiBAbWVtYmVyIHtzdHJpbmd9IG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsI2NhbmNlbExhYmVsXG4gKiBAZGVmYXVsdCBDYW5jZWxcbiAqL1xuXG4vKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIHRvIHNob3cgdGhlIGNhbmNlbCBidXR0b24gaW4gdGhlIG1vZGFsIHdpbmRvdy4gSWYgc2V0IHRvXG4gKiB0cnVlLCB0aGVuIHRoZSBidXR0b24gc2hvdWxkIG5vdCBiZSBkaXNwbGF5ZWQuXG4gKiBAbWVtYmVyIHtib29sZWFufSBtb2R1bGU6bW9kYWxTdGFja35Nb2RhbCNub0NhbmNlbEJ1dHRvblxuICogQGRlZmF1bHQgZmFsc2VcbiAqL1xuXG4vKipcbiAqIEluZGljYXRlcyB3aGljaCBlbGVtZW50IHRvIGZvY3VzIGFmdGVyIHRoZSBtb2RhbCBoYXMgYmVlbiBvcGVuZWQuIFRoaXNcbiAqIHByb3BlcnR5IGNhbiBlaXRoZXIgZ2l2ZSB0aGUgZWxlbWVudCBpdHNlbGYsIG9yIGNhbiBiZSBhIHN0cmluZyB3aXRoIG9uZSBvZlxuICogdGhlIGZvbGxvd2luZyBvcHRpb25zOiAnY29uZmlybScgd2lsbCBmb2N1cyB0aGUgQ29uZmlybSBidXR0b24gaW4gdGhlIG1vZGFsLFxuICogJ2NhbmNlbCcgd2lsbCBmb2N1cyB0aGUgQ2FuY2VsIGJ1dHRvbiwgYW5kICdub25lJyB3aWxsIGZvY3VzIG5vdGhpbmcuXG4gKiBAbWVtYmVyIHtIVE1MRWxlbWVudHxzdHJpbmd9IG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsI2luaXRGb2N1c1xuICogQGRlZmF1bHQgY29uZmlybVxuICovXG5cbi8qKlxuICogQ3JlYXRlIGFuZCBkaXNwbGF5IHRoZSBtb2RhbCdzIG1haW4gY29udGVudC5cbiAqIEBmdW5jdGlvbiBtb2R1bGU6bW9kYWxTdGFja35Nb2RhbCNhZGRDb250ZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgVGhlIHBhcmVudCBET00gbm9kZSB1bmRlciB3aGljaCB0aGUgbW9kYWwncyBtYWluXG4gKiAgIGNvbnRlbnQgd2lsbCBiZSBpbnNlcnRlZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja30gbW9kYWxTdGFjayBUaGUgbW9kYWwgc3RhY2sgaW4gd2hpY2hcbiAqICAgdGhlIG1vZGFsIGlzIGJlaW5nIGluc2VydGVkLlxuICovXG5cbi8qKlxuICogQ29uZmlybSB0aGUgbW9kYWwuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIG1vZGFsIGlzXG4gKiBzdWNjZXNmdWxseSBjb25maXJtZWQgYnkgdGhlIHVzZXIuXG4gKiBAZnVuY3Rpb24gbW9kdWxlOm1vZGFsU3RhY2t+TW9kYWwjY29uZmlybVxuICovXG5cbi8qKlxuICogQ2FuY2VsIHRoZSBtb2RhbC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGludm9rZWQgd2hlbiB0aGUgbW9kYWwgaXMgY2FuY2VsZWRcbiAqIGJ5IHRoZSB1c2VyLlxuICogQGZ1bmN0aW9uIG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsI2NhbmNlbFxuICovXG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIG1vZGFsLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZCB3aGVuIHRoZSB1c2VyIGF0dGVtcHRzIHRvXG4gKiBjb25maXJtIHRoZSBtb2RhbC5cbiAqIEBmdW5jdGlvbiBtb2R1bGU6bW9kYWxTdGFja35Nb2RhbCN2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHVzZXIncyBzZWxlY3Rpb25zIGhhdmUgcGFzc2VkIHZhbGlkYXRpb24sIGFuZFxuICogICBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuLyoqXG4gKiBPYmplY3QgaG9sZGluZyBwcml2YXRlIG1lbWJlcnMgZm9yIHRoZVxuICogW01vZGFsU3RhY2tde0BsaW5rIG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsU3RhY2t9IGNsYXNzLlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja35wcml2YXRlc1xuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gb3ZlcmxheSBUaGUgc2NyZWVuIG92ZXJsYXkgZWxlbWVudCBpbiB0aGUgRE9NLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgZWxlbWVudCB1bmRlciB3aGljaCBtb2RhbHMgc2hvdWxkXG4gKiAgIGJlIGluc2VydGVkLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gW2JhY2tncm91bmRdIENvbnRhaW5lciBob2xkaW5nIGJhY2tncm91bmQgZWxlbWVudHNcbiAqICAgdGhhdCBzaG91bGQgYmUgaGlkZGVuIHdoZW4gYSBtb2RhbCBpcyBvcGVuLlxuICogQHByb3BlcnR5IHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbFN0YWNrfm1vZGFsSW5mb1tdfSBtb2RhbHMgVGhlIHN0YWNrIG9mXG4gKiAgIG1vZGFsIGRpYWxvZ3MuXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBwcml2YXRlIGRhdGEgZm9yIHRoZSBbTW9kYWxTdGFja117QGxpbmsgbW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja31cbiAqIGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsU3RhY2t+cHJpdmF0ZXNcbiAqL1xuY29uc3QgcHJpdmF0ZU1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgei1pbmRleCBmb3IgYSBtb2RhbCBkaWFsb2cuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBkaWFsb2cgaW4gdGhlIHN0YWNrLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHotaW5kZXggdGhhdCB0aGUgbW9kYWwgc2hvdWxkIGJlIHNldCB0by5cbiAqL1xuZnVuY3Rpb24gZ2V0WkluZGV4KGluZGV4KSB7XG4gIHJldHVybiBaX0lOREVYX1NUQVJUICsgKGluZGV4IC0gMSkgKiBaX0lOREVYX1NURVA7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBtb2RhbCBvdmVybGF5LiBUaGUgb3ZlcmxheSB3aWxsIGJlIHNob3duIG9yIGhpZGRlbiBkZXBlbmRpbmcgb25cbiAqIHdoZXRoZXIgYW55IG1vZGFscyBhcmUgb3BlbiwgYW5kIGl0cyB6LWluZGV4IHdpbGwgYmUgYWRqdXN0ZWQgdG8gc2l0IGJlbG93XG4gKiB0aGUgdG9wbW9zdCBtb2RhbC5cbiAqIEBwYXJhbSB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja30gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoXG4gKiAgIHRvIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3ZlcmxheShpbnN0YW5jZSkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGNvbnN0IGNvdW50ID0gcHJpdmF0ZXMubW9kYWxzLmxlbmd0aDtcbiAgaWYgKGNvdW50ID4gMCkge1xuICAgIGNvbnN0IHpJbmRleCA9IGdldFpJbmRleChjb3VudCkgLSBaX0lOREVYX09WRVJMQVlfU1RFUDtcbiAgICBwcml2YXRlcy5vdmVybGF5LnN0eWxlLnpJbmRleCA9IHpJbmRleC50b1N0cmluZygpO1xuICAgIHByaXZhdGVzLm92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgnY2xvc2VkJyk7XG4gIH0gZWxzZSB7XG4gICAgcHJpdmF0ZXMub3ZlcmxheS5jbGFzc0xpc3QuYWRkKCdjbG9zZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3cgdGhlIG1vZGFsIG92ZXJsYXkgYW5kIGhpZGUgYW55IGJhY2tncm91bmQgZWxlbWVudHMuXG4gKiBAcGFyYW0ge21vZHVsZTptb2RhbFN0YWNrfk1vZGFsU3RhY2t9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGhpZGVCYWNrZ3JvdW5kKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgbGV0IHRvSGlkZSA9IG51bGw7XG5cbiAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgbW9kYWwsIGhpZGUgcGFnZSBiYWNrZ3JvdW5kXG4gIGlmIChwcml2YXRlcy5tb2RhbHMubGVuZ3RoIDw9IDEpIHtcbiAgICB0b0hpZGUgPSBwcml2YXRlcy5iYWNrZ3JvdW5kO1xuICB9IGVsc2UgeyAvLyBPdGhlcndpc2UsIGhpZGUgdGhlIG1vZGFsIGJlbG93IHRoZSB0b3Btb3N0IG9uZVxuICAgIHRvSGlkZSA9IHByaXZhdGVzLm1vZGFsc1twcml2YXRlcy5tb2RhbHMubGVuZ3RoIC0gMl0ud3JhcHBlcjtcbiAgfVxuXG4gIGlmICh0b0hpZGUpIHtcbiAgICB0b0hpZGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICBjb25zdCB7IG9sZFRhYkluZGV4IH0gPSBwcml2YXRlcy5tb2RhbHNbcHJpdmF0ZXMubW9kYWxzLmxlbmd0aCAtIDFdO1xuICAgIHRvSGlkZS5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9TRUxFQ1RPUikuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgdGFiSW5kZXggPSBlbGVtLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSA/IGVsZW0udGFiSW5kZXggOiBudWxsO1xuICAgICAgb2xkVGFiSW5kZXgucHVzaCh7IGVsZW1lbnQ6IGVsZW0sIHRhYkluZGV4IH0pO1xuICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVPdmVybGF5KGluc3RhbmNlKTtcbn1cblxuLyoqXG4gKiBSZXN0b3JlIGJhY2tncm91bmQgZWxlbWVudCB2aXNpYmlsaXR5LiBJZiB0aGVyZSBhcmUgc3RpbGwgbW9kYWxzIG9wZW4sXG4gKiBvbmx5IHRoZSB0b3Btb3N0IG1vZGFsJ3MgZWxlbWVudHMgd2lsbCBiZWNvbWUgdmlzaWJsZS4gSWYgYWxsIG1vZGFscyBhcmVcbiAqIGNsb3NlZCwgdGhlbiB0aGUgb3ZlcmxheSB3aWxsIGJlIGhpZGRlbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja30gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoXG4gKiAgIHRvIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja35lbGVtVGFiSW5kZXhbXX0gb2xkVGFiSW5kZXggQW4gYXJyYXkgb2ZcbiAqICAgb2JqZWN0cyBzcGVjaWZ5aW5nIGVsZW1lbnRzIHdob3NlIHRhYmluZGV4IGF0dHJpYnV0ZXMgbmVlZCB0byBiZSByZXN0b3JlZC5cbiAqL1xuZnVuY3Rpb24gcmVzdG9yZUJhY2tncm91bmQoaW5zdGFuY2UsIG9sZFRhYkluZGV4KSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgbGV0IHRvUmVzdG9yZSA9IG51bGw7XG5cbiAgLy8gSWYgbm8gbW9kYWxzIHJlbWFpbiBvcGVuLCByZXN0b3JlIHRoZSBwYWdlIGJhY2tncm91bmRcbiAgaWYgKHByaXZhdGVzLm1vZGFscy5sZW5ndGggPT09IDApIHtcbiAgICB0b1Jlc3RvcmUgPSBwcml2YXRlcy5iYWNrZ3JvdW5kO1xuICB9IGVsc2Uge1xuICAgIHRvUmVzdG9yZSA9IHByaXZhdGVzLm1vZGFsc1twcml2YXRlcy5tb2RhbHMubGVuZ3RoIC0gMV0ud3JhcHBlcjtcbiAgfVxuXG4gIGlmICh0b1Jlc3RvcmUpIHtcbiAgICB0b1Jlc3RvcmUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgIG9sZFRhYkluZGV4LmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCB7IGVsZW1lbnQsIHRhYkluZGV4IH0gPSBlbnRyeTtcbiAgICAgIGlmICh0YWJJbmRleCAhPT0gbnVsbCkgZWxlbWVudC50YWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZU92ZXJsYXkoaW5zdGFuY2UpO1xufVxuXG4vKipcbiAqIE1hbmFnZXMgYW5kIGRpc3BsYXlzIGEgc3RhY2sgb2YgbW9kYWwgZGlhbG9nIHdpbmRvd3MuXG4gKi9cbmNsYXNzIE1vZGFsU3RhY2sge1xuICAvKipcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgYW4gZWxlbWVudCdzIHRhYiBpbmRleCwgdXNlZCBmb3IgY2hhbmdpbmcgYW5kXG4gICAqIHJlc3RvcmluZyB0YWIgb3JkZXIgd2hlbiBtb2RhbHMgYXJlIG9wZW5lZCBvciBjbG9zZWQuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsU3RhY2t+ZWxlbVRhYkluZGV4XG4gICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgQW4gZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3RhYkluZGV4XSBUaGUgdGFiIGluZGV4IG9mIHRoZSBlbGVtZW50LCBvciBudWxsIGlmIGl0XG4gICAqICAgaXMgbm90IHNldC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGEgbW9kYWwgZGlhbG9nIGluIHRoZSBzdGFjay5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja35tb2RhbEluZm9cbiAgICogQHByb3BlcnR5IHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbH0gbW9kYWwgVGhlIG1vZGFsIGluc3RhbmNlLlxuICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB3cmFwcGVyIFRoZSBvdXRlciB3cmFwcGVyIG5vZGUgd2hpY2ggY29udGFpbnMgdGhlXG4gICAqICAgbW9kYWwgd2luZG93IGNvbnRhaW5lci5cbiAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBjb250YWluZXIgbm9kZSBob2xkaW5nIHRoZSBtb2RhbFxuICAgKiAgIGRpYWxvZy5cbiAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udGVudCBUaGUgRE9NIG5vZGUgaG9sZGluZyB0aGUgbWFpbiBjb250ZW50cyBvZlxuICAgKiAgIHRoZSBtb2RhbCBkaWFsb2cuXG4gICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IFtvbGRBY3RpdmVdIFRoZSBlbGVtZW50IHRoYXQgaGFkIGtleWJvYXJkIGZvY3VzXG4gICAqICAgYmVmb3JlIHRoZSBtb2RhbCB3YXMgb3BlbmVkLCBpZiBhbnkuXG4gICAqIEBwcm9wZXJ0eSB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja35lbGVtVGFiSW5kZXhbXX0gb2xkVGFiSW5kZXggQW5cbiAgICogICBhcnJheSBvZiBvYmplY3RzIHNwZWNpZnlpbmcgZWxlbWVudHMgd2hvc2UgdGFiaW5kZXggYXR0cmlidXRlcyBuZWVkIHRvXG4gICAqICAgYmUgcmVzdG9yZWQgYWZ0ZXIgdGhlIG1vZGFsIGlzIGNsb3NlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIG1vZGFsIHN0YWNrLiBBIGhpZGRlbiBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICogRE9NLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbcGFyZW50PWRvY3VtZW50LmJvZHldIFRoZSBwYXJlbnQgbm9kZSB1bmRlciB3aGljaFxuICAgKiAgIHRoZSBtb2RhbCBvdmVybGF5IGlzIHRvIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbYmFja2dyb3VuZF0gQSBET00gbm9kZSBjb250YWluaW5nIGVsZW1lbnRzIHRoYXRcbiAgICogICBzaG91bGQgYmUgaGlkZGVuIGZyb20gc2NyZWVuIHJlYWRlcnMgYW5kIG1hZGUgdW5mb2N1c2FibGUgd2hpbGUgYSBtb2RhbFxuICAgKiAgIGlzIG9wZW4uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJlbnQgPSBkb2N1bWVudC5ib2R5LCBiYWNrZ3JvdW5kID0gbnVsbCkge1xuICAgIGNvbnN0IG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ21vZGFsLW92ZXJsYXknLCAnY2xvc2VkJyk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKG92ZXJsYXkpO1xuXG4gICAgY29uc3QgcHJpdmF0ZXMgPSB7XG4gICAgICBvdmVybGF5LFxuICAgICAgcGFyZW50LFxuICAgICAgYmFja2dyb3VuZDogYmFja2dyb3VuZCB8fCBudWxsLFxuICAgICAgbW9kYWxzOiBbXSxcbiAgICB9O1xuICAgIHByaXZhdGVNZW1iZXJzLnNldCh0aGlzLCBwcml2YXRlcyk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgIGlmIChwcml2YXRlcy5tb2RhbHMubGVuZ3RoID4gMFxuICAgICAgICAmJiAoZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJykpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxNb2RhbCgpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSBhIG1vZGFsIGRpYWxvZy5cbiAgICogQHBhcmFtIHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbH0gbW9kYWwgVGhlIG1vZGFsIGRpYWxvZyB0byBzaG93LlxuICAgKi9cbiAgc2hvd01vZGFsKG1vZGFsKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG5cbiAgICBjb25zdCBvbGRBY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChvbGRBY3RpdmUpIG9sZEFjdGl2ZS5ibHVyKCk7XG5cbiAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdtb2RhbC13cmFwcGVyJyk7XG4gICAgd3JhcHBlci5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgocHJpdmF0ZXMubW9kYWxzLmxlbmd0aCArIDEpO1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21vZGFsJyk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgY29uc3QgdGl0bGVCYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aXRsZUJhci5jbGFzc0xpc3QuYWRkKCdtb2RhbC10aXRsZS1iYXInKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGl0bGVCYXIpO1xuXG4gICAgY29uc3QgdGl0bGVUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGl0bGVUZXh0LmNsYXNzTGlzdC5hZGQoJ21vZGFsLXRpdGxlJyk7XG4gICAgdGl0bGVUZXh0LnRleHRDb250ZW50ID0gbW9kYWwudGl0bGU7XG4gICAgdGl0bGVCYXIuYXBwZW5kQ2hpbGQodGl0bGVUZXh0KTtcbiAgICBjb25zdCBjbG9zZUljb24gPSBjcmVhdGVJY29uQnV0dG9uKCdjbG9zZScpO1xuICAgIGNsb3NlSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuY2FuY2VsTW9kYWwoKSk7XG4gICAgdGl0bGVCYXIuYXBwZW5kQ2hpbGQoY2xvc2VJY29uKTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsLWNvbnRlbnQnKTtcbiAgICBtb2RhbC5hZGRDb250ZW50KGNvbnRlbnQsIHRoaXMpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ1dHRvbkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtb2RhbC1idXR0b24tY29udGFpbmVyJyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbkNvbnRhaW5lcik7XG5cbiAgICBsZXQgY2FuY2VsQnV0dG9uID0gbnVsbDtcbiAgICBpZiAoIW1vZGFsLm5vQ2FuY2VsQnV0dG9uKSB7XG4gICAgICBjYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgIGNhbmNlbEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtb2RhbC1idXR0b24nKTtcbiAgICAgIGNhbmNlbEJ1dHRvbi50ZXh0Q29udGVudCA9IG1vZGFsLmNhbmNlbExhYmVsIHx8ICdDYW5jZWwnO1xuICAgICAgY2FuY2VsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5jYW5jZWxNb2RhbCgpKTtcbiAgICAgIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW5jZWxCdXR0b24pO1xuICAgIH1cblxuICAgIGNvbnN0IG9rYXlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBva2F5QnV0dG9uLmNsYXNzTGlzdC5hZGQoJ21vZGFsLWJ1dHRvbicsICdtb2RhbC1va2F5Jyk7XG4gICAgb2theUJ1dHRvbi50ZXh0Q29udGVudCA9IG1vZGFsLmNvbmZpcm1MYWJlbCB8fCAnT2theSc7XG4gICAgb2theUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuY29uZmlybU1vZGFsKCkpO1xuICAgIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChva2F5QnV0dG9uKTtcblxuICAgIGNvbnN0IG1vZGFsSW5mbyA9IHtcbiAgICAgIG1vZGFsLFxuICAgICAgd3JhcHBlcixcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGNvbnRlbnQsXG4gICAgICBvbGRBY3RpdmUsXG4gICAgICBvbGRUYWJJbmRleDogW10sXG4gICAgfTtcblxuICAgIHByaXZhdGVzLm1vZGFscy5wdXNoKG1vZGFsSW5mbyk7XG4gICAgcHJpdmF0ZXMucGFyZW50LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgIGhpZGVCYWNrZ3JvdW5kKHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZiBtb2RhbC5pbml0Rm9jdXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzd2l0Y2ggKG1vZGFsLmluaXRGb2N1cykge1xuICAgICAgICBjYXNlICdjb25maXJtJzpcbiAgICAgICAgICBva2F5QnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NhbmNlbCc6XG4gICAgICAgICAgaWYgKGNhbmNlbEJ1dHRvbikgY2FuY2VsQnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobW9kYWwuaW5pdEZvY3VzKSB7XG4gICAgICBtb2RhbC5pbml0Rm9jdXMuZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2theUJ1dHRvbi5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgdG9wbW9zdCBtb2RhbCBkaWFsb2cuIFRoaXMgd2lsbCBub3QgaW52b2tlIHRoZSBhc3NvY2lhdGVkXG4gICAqIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgY2xvc2VNb2RhbCgpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcbiAgICBjb25zdCBtb2RhbEluZm8gPSBwcml2YXRlcy5tb2RhbHMucG9wKCk7XG4gICAgaWYgKG1vZGFsSW5mbykge1xuICAgICAgcHJpdmF0ZXMucGFyZW50LnJlbW92ZUNoaWxkKG1vZGFsSW5mby53cmFwcGVyKTtcbiAgICAgIHJlc3RvcmVCYWNrZ3JvdW5kKHRoaXMsIG1vZGFsSW5mby5vbGRUYWJJbmRleCk7XG4gICAgICBpZiAobW9kYWxJbmZvLm9sZEFjdGl2ZSkgbW9kYWxJbmZvLm9sZEFjdGl2ZS5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGNvbmZpcm0gdGhlIHRvcG1vc3QgbW9kYWwgZGlhbG9nLiBUaGUgbW9kYWwnc1xuICAgKiBbdmFsaWRhdGVde0BsaW5rIG1vZHVsZTptb2RhbFN0YWNrfk1vZGFsI3ZhbGlkYXRlfSBtZXRob2Qgd2lsbCBmaXJzdCBiZVxuICAgKiBpbnZva2VkLiBJZiB0aGUgbW9kYWwgcGFzc2VzIHZhbGlkYXRpb24sIHRoZW4gaXRzXG4gICAqIFtjb25maXJtXXtAbGluayBtb2R1bGU6bW9kYWxTdGFja35Nb2RhbCNjb25maXJtfSBtZXRob2QgaXMgaW52b2tlZCwgYW5kXG4gICAqIHRoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1vZGFsIHdhcyBzdWNjZXNzZnVsbHkgY29uZmlybWVkLCBhbmQgZmFsc2VcbiAgICogICBpZiB0aGUgbW9kYWwgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqL1xuICBjb25maXJtTW9kYWwoKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgaWYgKHByaXZhdGVzLm1vZGFscy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IHsgbW9kYWwgfSA9IHByaXZhdGVzLm1vZGFsc1twcml2YXRlcy5tb2RhbHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFtb2RhbC52YWxpZGF0ZSgpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBtb2RhbC5jb25maXJtKCk7XG4gICAgdGhpcy5jbG9zZU1vZGFsKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHRoZSB0b3Btb3N0IG1vZGFsIGRpYWxvZy4gVGhpcyB3aWxsIGludm9rZSB0aGUgbW9kYWwnc1xuICAgKiBbY2FuY2VsXXtAbGluayBtb2R1bGU6bW9kYWxTdGFja35Nb2RhbCNjYW5jZWx9IG1ldGhvZCwgYW5kIHRoZW4gdGhlIG1vZGFsXG4gICAqIHdpbGwgYmUgY2xvc2VkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZmFsc2UgaWYgaXQgaXMgY2FsbGVkIHdoZW5cbiAgICogICB0aGVyZSBhcmUgbm8gbW9kYWxzIGluIHRoZSBzdGFjay4gT3RoZXJ3aXNlIGl0IHJldHVybnMgdHJ1ZS5cbiAgICovXG4gIGNhbmNlbE1vZGFsKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChwcml2YXRlcy5tb2RhbHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBwcml2YXRlcy5tb2RhbHNbcHJpdmF0ZXMubW9kYWxzLmxlbmd0aCAtIDFdLm1vZGFsLmNhbmNlbCgpO1xuICAgIHRoaXMuY2xvc2VNb2RhbCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsU3RhY2s7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtBZGRQcm9qZWN0TW9kYWxde0BsaW5rIG1vZHVsZTphZGRQcm9qZWN0TW9kYWx+QWRkUHJvamVjdE1vZGFsfVxuICogY2xhc3MuXG4gKiBAbW9kdWxlIGFkZFByb2plY3RNb2RhbFxuICovXG5cbmltcG9ydCBQcm9qZWN0IGZyb20gJy4uL3Byb2plY3QnO1xuaW1wb3J0IHsgY3JlYXRlRm9ybUNvbnRyb2wgfSBmcm9tICcuLi91dGlsaXR5L2RvbSc7XG5cbi8qKlxuICogT2JqZWN0IGhvbGRpbmcgcHJpdmF0ZSBtZW1iZXJzIGZvciB0aGVcbiAqIFtBZGRQcm9qZWN0TW9kYWxde0BsaW5rIG1vZHVsZTphZGRQcm9qZWN0TW9kYWx+QWRkUHJvamVjdE1vZGFsfSBjbGFzcy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTphZGRQcm9qZWN0TW9kYWx+QWRkUHJvamVjdE1vZGFsfnByaXZhdGVzXG4gKiBAcHJvcGVydHkge21vZHVsZTpwcm9qZWN0flByb2plY3R9IFtwcm9qZWN0XSBUaGUgcHJvamVjdCBiZWluZyBlZGl0ZWQsIGlmXG4gKiAgIGFueS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtb2RlIEluZGljYXRlcyB0aGUgc3RhdHVzIG9mIHRoZSBwcm9qZWN0IGJlaW5nIGVudGVyZWQuXG4gKiAgIElmIHNldCB0byAnYWRkJywgYSBuZXcgcHJvamVjdCBpcyBiZWluZyBjcmVhdGVkLCBhbmQgaWYgc2V0IHRvICdlZGl0JyxcbiAqICAgdGhlbiBhbiBleGlzdGluZyBwcm9qZWN0IGlzIGJlaW5nIHVwZGF0ZWQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2FsbGJhY2tzIEFuIG9iamVjdCBob2xkaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuY29uZmlybV0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb25maXJtcyB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLmNhbmNlbF0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIG1vZGFsLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGNvbnRyb2xzIEFuIG9iamVjdCBob2xkaW5nIHRoZSBmb3JtIGlucHV0IGVsZW1lbnRzIGZvclxuICogICB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250cm9scy5uYW1lIFRoZSB0ZXh0IGlucHV0IGVsZW1lbnQgZm9yIHRoZSBwcm9qZWN0XG4gKiAgIG5hbWUuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250cm9scy5kZXNjcmlwdGlvbiBUaGUgdGV4dGFyZWEgZWxlbWVudCBmb3IgdGhlXG4gKiAgIHByb2plY3QgZGVzY3JpcHRpb24uXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBwcml2YXRlIGRhdGEgZm9yIHRoZVxuICogW0FkZFByb2plY3RNb2RhbF17QGxpbmsgbW9kdWxlOmFkZFByb2plY3RNb2RhbH5BZGRQcm9qZWN0TW9kYWx9IGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTphZGRQcm9qZWN0TW9kYWx+QWRkUHJvamVjdE1vZGFsfnByaXZhdGVzXG4gKi9cbmNvbnN0IHByaXZhdGVNZW1iZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSB2YWx1ZXMgb2YgdGhlIGZvcm0gZWxlbWVudHMgYmFzZWQgb24gdGhlIGluaXRpYWwgcHJvamVjdCB0aGF0XG4gKiB3YXMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciwgaWYgYW55LlxuICogQHBhcmFtIHttb2R1bGU6YWRkUHJvamVjdE1vZGFsfkFkZFByb2plY3RNb2RhbH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlXG4gKiAgIG9uIHdoaWNoIHRvIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5pdEZvcm1WYWx1ZXMoaW5zdGFuY2UpIHtcbiAgY29uc3QgeyBwcm9qZWN0LCBjb250cm9scyB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcblxuICBpZiAocHJvamVjdCkge1xuICAgIGNvbnRyb2xzLm5hbWUudmFsdWUgPSBwcm9qZWN0Lm5hbWUgfHwgJyc7XG4gICAgY29udHJvbHMuZGVzY3JpcHRpb24udmFsdWUgPSBwcm9qZWN0LmRlc2NyaXB0aW9uIHx8ICcnO1xuICB9XG59XG5cbi8qKlxuICogQSBtb2RhbCBkaWFsb2cgZm9yIGFkZGluZyBvciBlZGl0aW5nIGEgcHJvamVjdC5cbiAqIEBpbXBsZW1lbnRzIHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbH1cbiAqL1xuY2xhc3MgQWRkUHJvamVjdE1vZGFsIHtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyBvcHRpb25zIGZvciB0aGUgbW9kYWwuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTphZGRQcm9qZWN0TW9kYWx+QWRkUHJvamVjdE1vZGFsfm9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NvbmZpcm1dIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAgICogICB3aGVuIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb25maXJtcyB0aGUgbW9kYWwuIFRoZSBmdW5jdGlvbiB3aWxsIGJlXG4gICAqICAgcGFzc2VkIHRoZSBuZXcgKG9yIG1vZGlmaWVkKSBwcm9qZWN0LlxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY2FuY2VsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkXG4gICAqICAgd2hlbiB0aGUgdXNlciBjYW5jZWxzIHRoZSBtb2RhbC5cbiAgICogQHByb3BlcnR5IHttb2R1bGU6cHJvamVjdH5Qcm9qZWN0fSBbcHJvamVjdF0gVGhlIHByb2plY3QgdG8gZWRpdC4gSWYgbm90XG4gICAqICAgZ2l2ZW4sIHRoZW4gYSBuZXcgcHJvamVjdCBpcyBjcmVhdGVkLlxuICAgKi9cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7bW9kdWxlOmFkZFByb2plY3RNb2RhbH5BZGRQcm9qZWN0TW9kYWx+b3B0aW9uc30gW29wdGlvbnM9e31dIEFuXG4gICAqICAgb2JqZWN0IGhvbGRpbmcgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgbW9kYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHtcbiAgICAgIHByb2plY3Q6IG9wdGlvbnMucHJvamVjdCB8fCBudWxsLFxuICAgICAgbW9kZTogb3B0aW9ucy5wcm9qZWN0ID8gJ2VkaXQnIDogJ2FkZCcsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgY29uZmlybTogb3B0aW9ucy5jb25maXJtIHx8IG51bGwsXG4gICAgICAgIGNhbmNlbDogb3B0aW9ucy5jYW5jZWwgfHwgbnVsbCxcbiAgICAgIH0sXG4gICAgICBjb250cm9sczoge1xuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBwcml2YXRlTWVtYmVycy5zZXQodGhpcywgcHJpdmF0ZXMpO1xuICB9XG5cbiAgZ2V0IHRpdGxlKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIHJldHVybiAocHJpdmF0ZXMubW9kZSA9PT0gJ2VkaXQnKSA/ICdFZGl0IFByb2plY3QnIDogJ0FkZCBQcm9qZWN0JztcbiAgfVxuXG4gIGdldCBjb25maXJtTGFiZWwoKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgcmV0dXJuIChwcml2YXRlcy5tb2RlID09PSAnZWRpdCcpID8gJ1VwZGF0ZScgOiAnQWRkJztcbiAgfVxuXG4gIGdldCBpbml0Rm9jdXMoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5jb250cm9scy5uYW1lO1xuICB9XG5cbiAgYWRkQ29udGVudChwYXJlbnQpIHtcbiAgICBjb25zdCBjb250YWluZXJUeXBlID0geyBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1jb250YWluZXInXSB9O1xuICAgIGNvbnN0IGxhYmVsVHlwZSA9ICh2YWx1ZSkgPT4gKHsgdmFsdWUsIGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWxhYmVsJ10gfSk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIGlkOiAncHJvamVjdC1uYW1lJyxcbiAgICAgIG5hbWU6ICdwcm9qZWN0LW5hbWUnLFxuICAgICAgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQnXSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgbGFiZWw6IGxhYmVsVHlwZSgnTmFtZScpLFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXJUeXBlLFxuICAgIH0pKTtcblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgaWQ6ICdwcm9qZWN0LWRlc2NyaXB0aW9uJyxcbiAgICAgIG5hbWU6ICdwcm9qZWN0LWRlc2NyaXB0aW9uJyxcbiAgICAgIGNsYXNzTGlzdDogWydmb3JtLXRleHRhcmVhJ10sXG4gICAgICBsYWJlbDogbGFiZWxUeXBlKCdEZXNjcmlwdGlvbicpLFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXJUeXBlLFxuICAgICAgc2l6ZTogeyByb3dzOiA0LCBjb2xzOiAyMCB9LFxuICAgIH0pKTtcblxuICAgIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5jb250cm9scyA9IHtcbiAgICAgIG5hbWU6IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjcHJvamVjdC1uYW1lJyksXG4gICAgICBkZXNjcmlwdGlvbjogcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJyNwcm9qZWN0LWRlc2NyaXB0aW9uJyksXG4gICAgfTtcblxuICAgIGluaXRGb3JtVmFsdWVzKHRoaXMpO1xuICB9XG5cbiAgY29uZmlybSgpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcbiAgICBjb25zdCB7IGNvbnRyb2xzIH0gPSBwcml2YXRlcztcbiAgICBjb25zdCBwcm9qZWN0ID0gbmV3IFByb2plY3QoY29udHJvbHMubmFtZS52YWx1ZSwge1xuICAgICAgZGVzY3JpcHRpb246IGNvbnRyb2xzLmRlc2NyaXB0aW9uLnZhbHVlIHx8IG51bGwsXG4gICAgfSk7XG5cbiAgICBpZiAocHJpdmF0ZXMuY2FsbGJhY2tzLmNvbmZpcm0pIHByaXZhdGVzLmNhbGxiYWNrcy5jb25maXJtKHByb2plY3QpO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChwcml2YXRlcy5jYWxsYmFja3MuY2FuY2VsKSBwcml2YXRlcy5jYWxsYmFja3MuY2FuY2VsKCk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5jb250cm9scy5uYW1lLnJlcG9ydFZhbGlkaXR5KCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBZGRQcm9qZWN0TW9kYWw7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtBZGRUYXNrTW9kYWxde0BsaW5rIG1vZHVsZTphZGRUYXNrTW9kYWx+QWRkVGFza01vZGFsfSBjbGFzcy5cbiAqIEBtb2R1bGUgYWRkVGFza01vZGFsXG4gKi9cblxuaW1wb3J0IEFkZFByb2plY3RNb2RhbCBmcm9tICcuL2FkZFByb2plY3RNb2RhbCc7XG5pbXBvcnQgRGF0ZVBpY2tlck1vZGFsIGZyb20gJy4vZGF0ZVBpY2tlck1vZGFsJztcbmltcG9ydCBSZWN1cnJlbmNlTW9kYWwgZnJvbSAnLi9yZWN1cnJlbmNlTW9kYWwnO1xuaW1wb3J0IFJlY3VycmluZ0RhdGUgZnJvbSAnLi4vcmVjdXJyaW5nRGF0ZSc7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MnO1xuaW1wb3J0IFRhc2sgZnJvbSAnLi4vdGFzayc7XG5pbXBvcnQgeyBmb3JtYXREYXRlLCBwYXJzZURhdGUgfSBmcm9tICcuLi91dGlsaXR5L2RhdGVzJztcbmltcG9ydCB7IGNyZWF0ZURhdGVJbnB1dEZpZWxkLCBjcmVhdGVGb3JtQ29udHJvbCB9IGZyb20gJy4uL3V0aWxpdHkvZG9tJztcblxuLyoqXG4gKiBPYmplY3QgaG9sZGluZyBwcml2YXRlIG1lbWJlcnMgZm9yIHRoZVxuICogW0FkZFRhc2tNb2RhbF17QGxpbmsgbW9kdWxlOmFkZFRhc2tNb2RhbH5BZGRUYXNrTW9kYWx9IGNsYXNzLlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmFkZFRhc2tNb2RhbH5BZGRUYXNrTW9kYWx+cHJpdmF0ZXNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fSB0YXNrcyBUaGUgdGFzayBsaXN0IHRvIHVwZGF0ZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fSBwcm9qZWN0cyBUaGUgcHJvamVjdCBsaXN0IHRvIHVzZVxuICogICBmb3IgdGhlIFByb2plY3QgZmllbGQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Rhc2tJZF0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFzayBiZWluZyBlZGl0ZWQsXG4gKiAgIGlmIGFueS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvamVjdElkXSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBkZWZhdWx0XG4gKiAgIHByb2plY3QsIGlmIGFueS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmlvcml0eSBUaGUgZGVmYXVsdCBwcmlvcml0eS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtb2RlIEluZGljYXRlcyB0aGUgc3RhdHVzIG9mIHRoZSB0YXNrIGJlaW5nIGVudGVyZWQuIElmXG4gKiAgIHNldCB0byAnYWRkJywgYSBuZXcgdGFzayBpcyBiZWluZyBjcmVhdGVkLCBhbmQgaWYgc2V0IHRvICdlZGl0JywgdGhlbiBhblxuICogICBleGlzdGluZyB0YXNrIGlzIGJlaW5nIHVwZGF0ZWQuXG4gKiBAcHJvcGVydHkge21vZHVsZTpyZWN1cnJpbmdEYXRlflJlY3VycmluZ0RhdGV9IFtjdXN0b21SZWN1cnJlbmNlXSBUaGUgY3VzdG9tXG4gKiAgIHJlY3VycmVuY2UgdGhhdCB0aGUgdXNlciBhZGRlZCwgaWYgYW55LlxuICogQHByb3BlcnR5IHttb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+ZGF0ZUZvcm1hdH0gZGF0ZUZvcm1hdCBBbiBvYmplY3QgaG9sZGluZ1xuICogICBkYXRlIGZvcm1hdCBpbmZvcm1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjYWxsYmFja3MgQW4gb2JqZWN0IGhvbGRpbmcgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5jb25maXJtXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIHdoZW4gdGhlIHVzZXIgc3VjY2Vzc2Z1bGx5IGNvbmZpcm1zIHRoZSBtb2RhbC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuY2FuY2VsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm5ld1Byb2plY3RdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gKiAgIGludm9rZWQgd2hlbiB0aGUgdXNlciBhZGRzIGEgbmV3IHByb2plY3QuXG4gKiBAcHJvcGVydHkge09iamVjdH0gY29udHJvbHMgQW4gb2JqZWN0IGhvbGRpbmcgdGhlIGZvcm0gaW5wdXQgZWxlbWVudHMgZm9yXG4gKiAgIHRoZSBtb2RhbC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLm5hbWUgVGhlIHRleHQgaW5wdXQgZWxlbWVudCBmb3IgdGhlIHRhc2tcbiAqICAgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLmR1ZURhdGUgVGhlIHRleHQgaW5wdXQgZWxlbWVudCBmb3IgdGhlIHRhc2tcbiAqICAgZHVlIGRhdGUuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250cm9scy5yZWN1cnJpbmdEYXRlIFRoZSBzZWxlY3QgZWxlbWVudCBmb3IgdGhlXG4gKiAgIHRhc2sgcmVjdXJyaW5nIGRhdGUuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250cm9scy5wcmlvcml0eSBUaGUgc2VsZWN0IGVsZW1lbnQgZm9yIHRoZSB0YXNrXG4gKiAgIHByaW9yaXR5LlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udHJvbHMucHJvamVjdCBUaGUgc2VsZWN0IGVsZW1lbnQgZm9yIHRoZSB0YXNrJ3NcbiAqICAgY29udGFpbmluZyBwcm9qZWN0LlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udHJvbHMuZGVzY3JpcHRpb24gVGhlIHRleHRhcmVhIGVsZW1lbnQgZm9yIHRoZVxuICogICB0YXNrIGRlc2NyaXB0aW9uLlxuICovXG5cbi8qKlxuICogSG9sZHMgcHJpdmF0ZSBkYXRhIGZvciB0aGVcbiAqIFtBZGRUYXNrTW9kYWxde0BsaW5rIG1vZHVsZTphZGRUYXNrTW9kYWx+QWRkVGFza01vZGFsfSBjbGFzcy5cbiAqIEB0eXBlIHtXZWFrTWFwfVxuICogQHNlZSBtb2R1bGU6YWRkVGFza01vZGFsfkFkZFRhc2tNb2RhbH5wcml2YXRlc1xuICovXG5jb25zdCBwcml2YXRlTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBwcm9qZWN0IHNlbGVjdCBib3ggb3B0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOmFkZFRhc2tNb2RhbH5BZGRUYXNrTW9kYWx9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvblxuICogICB3aGljaCB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVByb2plY3RzKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgcHJvamVjdEl0ZW1zID0gW3sgdmFsdWU6ICdub25lJywgbGFiZWw6ICdOb25lJyB9XTtcbiAgcHJpdmF0ZXMucHJvamVjdHMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICBwcm9qZWN0SXRlbXMucHVzaCh7IHZhbHVlOiBlbnRyeS5pZCwgbGFiZWw6IGVudHJ5LnByb2plY3QubmFtZSB9KTtcbiAgfSk7XG4gIHByb2plY3RJdGVtcy5wdXNoKHsgdmFsdWU6ICduZXcnLCBsYWJlbDogJ05ldyBQcm9qZWN0Li4uJyB9KTtcblxuICBjb25zdCBzZWxlY3RCb3ggPSBwcml2YXRlcy5jb250cm9scy5wcm9qZWN0O1xuICBzZWxlY3RCb3guaW5uZXJIVE1MID0gJyc7XG4gIHByb2plY3RJdGVtcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IG9wdEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBvcHRFbGVtLnZhbHVlID0gZW50cnkudmFsdWU7XG4gICAgb3B0RWxlbS50ZXh0Q29udGVudCA9IGVudHJ5LmxhYmVsO1xuICAgIHNlbGVjdEJveC5hcHBlbmRDaGlsZChvcHRFbGVtKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgdmFsdWVzIG9mIHRoZSBmb3JtIGVsZW1lbnRzIGJhc2VkIG9uIHRoZSBpbml0aWFsIHRhc2sgdGhhdFxuICogd2FzIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IsIGlmIGFueS5cbiAqIEBwYXJhbSB7bW9kdWxlOmFkZFRhc2tNb2RhbH5BZGRUYXNrTW9kYWx9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvblxuICogICB3aGljaCB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGluaXRGb3JtVmFsdWVzKGluc3RhbmNlKSB7XG4gIHVwZGF0ZVByb2plY3RzKGluc3RhbmNlKTtcblxuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGNvbnN0IHsgY29udHJvbHMgfSA9IHByaXZhdGVzO1xuICBsZXQgdGFzayA9IG51bGw7XG4gIGlmIChwcml2YXRlcy50YXNrSWQpIHRhc2sgPSBwcml2YXRlcy50YXNrcy5nZXRUYXNrKHByaXZhdGVzLnRhc2tJZCk7XG5cbiAgaWYgKHRhc2s/Lm5hbWUpIGNvbnRyb2xzLm5hbWUudmFsdWUgPSB0YXNrLm5hbWU7XG5cbiAgaWYgKHRhc2s/LmR1ZURhdGUpIHtcbiAgICBjb250cm9scy5kdWVEYXRlLnZhbHVlID0gZm9ybWF0RGF0ZShcbiAgICAgIHRhc2suZHVlRGF0ZSxcbiAgICAgIHByaXZhdGVzLmRhdGVGb3JtYXQub3V0cHV0UGF0dGVybixcbiAgICApO1xuICB9XG5cbiAgaWYgKHRhc2s/LnJlY3VycmluZ0RhdGUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHRhc2sucmVjdXJyaW5nRGF0ZS5pc0RlZmF1bHQoKSkge1xuICAgICAgc3dpdGNoICh0YXNrLnJlY3VycmluZ0RhdGUuaW50ZXJ2YWxVbml0KSB7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgdmFsdWUgPSAnZGFpbHknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICB2YWx1ZSA9ICd3ZWVrbHknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgdmFsdWUgPSAnbW9udGhseSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIHZhbHVlID0gJ2FubnVhbGx5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9ICdjdXN0b20nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9ICdjdXN0b20nO1xuICAgIH1cbiAgICBjb250cm9scy5yZWN1cnJpbmdEYXRlLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlID09PSAnY3VzdG9tJykgcHJpdmF0ZXMuY3VzdG9tUmVjdXJyZW5jZSA9IHRhc2sucmVjdXJyaW5nRGF0ZTtcbiAgfVxuXG4gIGlmICh0YXNrPy5wcmlvcml0eVN0cmluZyAmJiB0YXNrLnByaW9yaXR5U3RyaW5nICE9PSAndW5rbm93bicpIHtcbiAgICBjb250cm9scy5wcmlvcml0eS52YWx1ZSA9IHRhc2sucHJpb3JpdHlTdHJpbmc7XG4gIH0gZWxzZSB7XG4gICAgY29udHJvbHMucHJpb3JpdHkudmFsdWUgPSBUYXNrLmNvbnZlcnRQcmlvcml0eVRvU3RyaW5nKHByaXZhdGVzLnByaW9yaXR5KTtcbiAgfVxuXG4gIGxldCB7IHByb2plY3RJZCB9ID0gcHJpdmF0ZXM7XG4gIGlmICh0YXNrPy5wcm9qZWN0KSBwcm9qZWN0SWQgPSB0YXNrLnByb2plY3Q7XG4gIGlmIChwcm9qZWN0SWQpIGNvbnRyb2xzLnByb2plY3QudmFsdWUgPSBwcm9qZWN0SWQ7XG5cbiAgaWYgKHRhc2s/LmRlc2NyaXB0aW9uKSBjb250cm9scy5kZXNjcmlwdGlvbi52YWx1ZSA9IHRhc2suZGVzY3JpcHRpb247XG59XG5cbi8qKlxuICogT3BlbnMgYSBkYXRlIHBpY2tlciBhbmQgdXBkYXRlcyB0aGUgZHVlIGRhdGUgZmllbGQuXG4gKiBAcGFyYW0ge21vZHVsZTphZGRUYXNrTW9kYWx+QWRkVGFza01vZGFsfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb25cbiAqICAgd2hpY2ggdG8gYXBwbHkgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbFN0YWNrfSBtb2RhbFN0YWNrIFRoZSBtb2RhbCBzdGFjayBpbiB3aGljaFxuICogICB0aGUgbW9kYWwgaGFzIGJlZW4gaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIHBpY2tEdWVEYXRlKGluc3RhbmNlLCBtb2RhbFN0YWNrKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgaW5wdXQgPSBwcml2YXRlcy5jb250cm9scy5kdWVEYXRlO1xuICBsZXQgc3RhcnREYXRlID0gbnVsbDtcbiAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgc3RhcnREYXRlID0gcGFyc2VEYXRlKGlucHV0LnZhbHVlLCBwcml2YXRlcy5kYXRlRm9ybWF0LmlucHV0UGF0dGVybnMpO1xuICB9XG5cbiAgbW9kYWxTdGFjay5zaG93TW9kYWwobmV3IERhdGVQaWNrZXJNb2RhbCh7XG4gICAgY29uZmlybTogKGRhdGUpID0+IHtcbiAgICAgIGlucHV0LnZhbHVlID0gZm9ybWF0RGF0ZShkYXRlLCBwcml2YXRlcy5kYXRlRm9ybWF0Lm91dHB1dFBhdHRlcm4pO1xuICAgICAgaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgIH0sXG4gICAgc3RhcnREYXRlLFxuICAgIHRpdGxlOiAnU2VsZWN0IER1ZSBEYXRlJyxcbiAgfSkpO1xufVxuXG4vKipcbiAqIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBmb3JtIGNvbnRyb2xzIGluIHRoZSBtb2RhbC5cbiAqIEBwYXJhbSB7bW9kdWxlOmFkZFRhc2tNb2RhbH5BZGRUYXNrTW9kYWx9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvblxuICogICB3aGljaCB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTptb2RhbFN0YWNrfk1vZGFsU3RhY2t9IG1vZGFsU3RhY2sgVGhlIG1vZGFsIHN0YWNrIGluIHdoaWNoXG4gKiAgIHRoZSBtb2RhbCBpcyBiZWluZyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGluc3RhbmNlLCBtb2RhbFN0YWNrKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgeyBjb250cm9scywgZGF0ZUZvcm1hdCB9ID0gcHJpdmF0ZXM7XG5cbiAgLy8gSGFuZGxlIHJlY3VycmVuY2Ugc2VsZWN0aW9uXG4gIGNvbnN0IHsgcmVjdXJyaW5nRGF0ZSB9ID0gY29udHJvbHM7XG4gIGxldCByZWN1cnJlbmNlVmFsdWUgPSByZWN1cnJpbmdEYXRlLnZhbHVlO1xuICBjb25zdCBwcm9jZXNzUmVjdXJyZW5jZSA9IChyZWN1cnJlbmNlKSA9PiB7XG4gICAgcHJpdmF0ZXMuY3VzdG9tUmVjdXJyZW5jZSA9IHJlY3VycmVuY2U7XG5cbiAgICBsZXQgbmV3VmFsdWUgPSAnY3VzdG9tLXJlc3VsdCc7XG4gICAgaWYgKHJlY3VycmVuY2UuaXNEZWZhdWx0KCkpIHtcbiAgICAgIHN3aXRjaCAocmVjdXJyZW5jZS5pbnRlcnZhbFVuaXQpIHtcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICBuZXdWYWx1ZSA9ICdkYWlseSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgIG5ld1ZhbHVlID0gJ3dlZWtseSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICBuZXdWYWx1ZSA9ICdtb250aGx5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgbmV3VmFsdWUgPSAnYW5udWFsbHknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzZWxlY3QgYm94IG9wdGlvbnNcbiAgICBjb25zdCBzZWxlY3RvciA9ICdvcHRpb25bdmFsdWU9XCJjdXN0b20tcmVzdWx0XCJdJztcbiAgICBsZXQgb3B0RWxlbSA9IHJlY3VycmluZ0RhdGUucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKG9wdEVsZW0gJiYgbmV3VmFsdWUgIT09ICdjdXN0b20tcmVzdWx0Jykge1xuICAgICAgcmVjdXJyaW5nRGF0ZS5yZW1vdmVDaGlsZChvcHRFbGVtKTtcbiAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlID09PSAnY3VzdG9tLXJlc3VsdCcpIHtcbiAgICAgIGlmICghb3B0RWxlbSkge1xuICAgICAgICBvcHRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgIG9wdEVsZW0udmFsdWUgPSAnY3VzdG9tLXJlc3VsdCc7XG4gICAgICAgIHJlY3VycmluZ0RhdGUuaW5zZXJ0QmVmb3JlKG9wdEVsZW0sIHJlY3VycmluZ0RhdGUubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGVGb3JtYXRTdHIgPSBkYXRlRm9ybWF0Lm91dHB1dFBhdHRlcm47XG4gICAgICBvcHRFbGVtLnRleHRDb250ZW50ID0gcmVjdXJyZW5jZS50b1N0cmluZ1ZlcmJvc2UoZGF0ZUZvcm1hdFN0cik7XG4gICAgfVxuXG4gICAgcmVjdXJyaW5nRGF0ZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHJlY3VycmVuY2VWYWx1ZSA9IG5ld1ZhbHVlO1xuICB9O1xuXG4gIGlmIChwcml2YXRlcy5jdXN0b21SZWN1cnJlbmNlKSBwcm9jZXNzUmVjdXJyZW5jZShwcml2YXRlcy5jdXN0b21SZWN1cnJlbmNlKTtcblxuICBjb25zdCBjYW5jZWxSZWN1cnJlbmNlID0gKCkgPT4geyByZWN1cnJpbmdEYXRlLnZhbHVlID0gcmVjdXJyZW5jZVZhbHVlOyB9O1xuXG4gIHJlY3VycmluZ0RhdGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09ICdjdXN0b20nKSB7XG4gICAgICAvLyBHZXQgZHVlIGRhdGUsIGlmIGFueVxuICAgICAgY29uc3QgZGF0ZUlucHV0ID0gY29udHJvbHMuZHVlRGF0ZTtcbiAgICAgIGxldCBiYXNlRGF0ZSA9IG51bGw7XG4gICAgICBpZiAoZGF0ZUlucHV0LnZhbHVlKSB7XG4gICAgICAgIGJhc2VEYXRlID0gcGFyc2VEYXRlKGRhdGVJbnB1dC52YWx1ZSwgZGF0ZUZvcm1hdC5pbnB1dFBhdHRlcm5zKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbW9kYWwgPSBuZXcgUmVjdXJyZW5jZU1vZGFsKHtcbiAgICAgICAgY29uZmlybTogcHJvY2Vzc1JlY3VycmVuY2UsXG4gICAgICAgIGNhbmNlbDogY2FuY2VsUmVjdXJyZW5jZSxcbiAgICAgICAgaW5pdGlhbDogcHJpdmF0ZXMuY3VzdG9tUmVjdXJyZW5jZSxcbiAgICAgICAgYmFzZURhdGUsXG4gICAgICAgIGRhdGVGb3JtYXQsXG4gICAgICB9KTtcbiAgICAgIG1vZGFsU3RhY2suc2hvd01vZGFsKG1vZGFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdXJyZW5jZVZhbHVlID0gZS50YXJnZXQudmFsdWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBIYW5kbGUgcHJvamVjdCBzZWxlY3Rpb25cbiAgbGV0IHByb2plY3RWYWx1ZSA9IGNvbnRyb2xzLnByb2plY3QudmFsdWU7XG4gIGNvbnRyb2xzLnByb2plY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09ICduZXcnKSB7XG4gICAgICBjb25zdCBtb2RhbCA9IG5ldyBBZGRQcm9qZWN0TW9kYWwoe1xuICAgICAgICBjb25maXJtOiAocHJvamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gcHJpdmF0ZXMucHJvamVjdHMuYWRkUHJvamVjdChwcm9qZWN0KTtcbiAgICAgICAgICB1cGRhdGVQcm9qZWN0cyhpbnN0YW5jZSk7XG4gICAgICAgICAgY29udHJvbHMucHJvamVjdC52YWx1ZSA9IGlkO1xuICAgICAgICAgIHByb2plY3RWYWx1ZSA9IGlkO1xuICAgICAgICAgIGlmIChwcml2YXRlcy5jYWxsYmFja3MubmV3UHJvamVjdCkgcHJpdmF0ZXMuY2FsbGJhY2tzLm5ld1Byb2plY3QoaWQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6ICgpID0+IHsgY29udHJvbHMucHJvamVjdC52YWx1ZSA9IHByb2plY3RWYWx1ZTsgfSxcbiAgICAgIH0pO1xuICAgICAgbW9kYWxTdGFjay5zaG93TW9kYWwobW9kYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9qZWN0VmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENoZWNrIGRhdGUgdmFsaWRpdHlcbiAgY29udHJvbHMuZHVlRGF0ZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGUudGFyZ2V0O1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgaWYgKCFwYXJzZURhdGUodmFsdWUsIGRhdGVGb3JtYXQuaW5wdXRQYXR0ZXJucykpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZGF0ZUZvcm1hdC52aXN1YWxQYXR0ZXJuO1xuICAgICAgICBtZXNzYWdlID0gYFBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGUgaW4gJHtmb3JtYXR9IGZvcm1hdC5gO1xuICAgICAgfVxuICAgICAgZS50YXJnZXQuc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBBIG1vZGFsIGRpYWxvZyBmb3IgYWRkaW5nIG9yIGVkaXRpbmcgYSB0YXNrLlxuICogQGltcGxlbWVudHMge21vZHVsZTptb2RhbFN0YWNrfk1vZGFsfVxuICovXG5jbGFzcyBBZGRUYXNrTW9kYWwge1xuICAvKipcbiAgICogU3BlY2lmaWVzIG9wdGlvbnMgZm9yIHRoZSBtb2RhbC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmFkZFRhc2tNb2RhbH5BZGRUYXNrTW9kYWx+b3B0aW9uc1xuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY29uZmlybV0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICAgKiAgIHdoZW4gdGhlIHVzZXIgc3VjY2Vzc2Z1bGx5IGNvbmZpcm1zIHRoZSBtb2RhbC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmVcbiAgICogICBwYXNzZWQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXNrIHRoYXQgd2FzIGluc2VydGVkIGludG8gdGhlIHRhc2tcbiAgICogICBsaXN0IChvciB0aGUgaWRlbnRpZmllciBvZiB0aGUgZXhpc3RpbmcgdGFzayB0aGF0IHdhcyBtb2RpZmllZCkuXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYW5jZWxdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAgICogICB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIG1vZGFsLlxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbmV3UHJvamVjdF0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICAgKiAgIHdoZW4gdGhlIHVzZXIgYWRkcyBhIG5ldyBwcm9qZWN0IHRvIHRoZSBwcm9qZWN0IGxpc3QuIFRoZSB1bmlxdWVcbiAgICogICBpZGVudGlmaWVyIGZvciB0aGUgcHJvamVjdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gYXMgYW5cbiAgICogICBhcmd1bWVudC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0YXNrSWRdIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhc2sgdGhhdCBpc1xuICAgKiAgIGJlaW5nIGVkaXRlZCwgaWYgYW55LiBJZiBub3QgcHJvdmlkZWQsIHRoZW4gYSBuZXcgdGFzayB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvamVjdElkXSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBwcm9qZWN0IHRvXG4gICAqICAgdXNlIGFzIHRoZSBkZWZhdWx0IHNlbGVjdGlvbiBpbiB0aGUgUHJvamVjdCBmaWVsZC4gSWYgbm90IHByb3ZpZGVkLCB0aGVuXG4gICAqICAgdGhlIHRhc2sgd2lsbCBkZWZhdWx0IHRvIGhhdmluZyBubyBwcm9qZWN0LiBUaGlzIHByb3BlcnR5IGlzIGlnbm9yZWQgaWZcbiAgICogICBhbiBleGlzdGluZyB0YXNrIGlzIGJlaW5nIGVkaXRlZC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmlvcml0eT0wXSBUaGUgZGVmYXVsdCBwcmlvcml0eSB0byB1c2UgZm9yIHRoZSB0YXNrLlxuICAgKiAgIFRoaXMgaXMgaWdub3JlZCBpZiBhbiBleGlzdGluZyB0YXNrIGlzIGJlaW5nIGVkaXRlZC5cbiAgICogQHByb3BlcnR5IHttb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+ZGF0ZUZvcm1hdH0gW2RhdGVGb3JtYXRdIEFuIG9iamVjdFxuICAgKiAgIGhvbGRpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbGVuZGFyIGRhdGUgZm9ybWF0IHRvIHVzZSBmb3IgZGF0ZVxuICAgKiAgIGZpZWxkcy4gSWYgbm90IGdpdmVuLCB0aGVuIHRoZSBicm93c2VyIGRlZmF1bHQgaXMgdXNlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIG1vZGFsLlxuICAgKiBAcGFyYW0ge21vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH0gdGFza0xpc3QgVGhlIHRhc2sgbGlzdCBpbiB3aGljaCB0aGUgbmV3XG4gICAqICAgdGFzayBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fSBwcm9qZWN0TGlzdCBUaGUgcHJvamVjdCBsaXN0IHRoYXRcbiAgICogICB3aWxsIGJlIHVzZWQgdG8gcG9wdWxhdGUgdGhlIFByb2plY3Qgc2VsZWN0IGJveC4gVGhlIHVzZXIgY2FuIGFsc29cbiAgICogICBjcmVhdGUgYSBuZXcgcHJvamVjdCwgd2hpY2ggd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHttb2R1bGU6YWRkVGFza01vZGFsfkFkZFRhc2tNb2RhbH5vcHRpb25zfSBbb3B0aW9ucz17fV0gSG9sZHNcbiAgICogICBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBtb2RhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhc2tMaXN0LCBwcm9qZWN0TGlzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSB7XG4gICAgICB0YXNrczogdGFza0xpc3QsXG4gICAgICBwcm9qZWN0czogcHJvamVjdExpc3QsXG4gICAgICB0YXNrSWQ6IG9wdGlvbnMudGFza0lkIHx8IG51bGwsXG4gICAgICBwcm9qZWN0SWQ6IG9wdGlvbnMucHJvamVjdElkIHx8IG51bGwsXG4gICAgICBwcmlvcml0eTogb3B0aW9ucy5wcmlvcml0eSA/PyAwLFxuICAgICAgbW9kZTogb3B0aW9ucy50YXNrSWQgPyAnZWRpdCcgOiAnYWRkJyxcbiAgICAgIGN1c3RvbVJlY3VycmVuY2U6IG51bGwsXG4gICAgICBkYXRlRm9ybWF0OiBvcHRpb25zLmRhdGVGb3JtYXQgfHwgU2V0dGluZ3MubG9va3VwRGF0ZUZvcm1hdCgpLFxuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIGNvbmZpcm06IG9wdGlvbnMuY29uZmlybSB8fCBudWxsLFxuICAgICAgICBjYW5jZWw6IG9wdGlvbnMuY2FuY2VsIHx8IG51bGwsXG4gICAgICAgIG5ld1Byb2plY3Q6IG9wdGlvbnMubmV3UHJvamVjdCB8fCBudWxsLFxuICAgICAgfSxcbiAgICAgIGNvbnRyb2xzOiB7XG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIGR1ZURhdGU6IG51bGwsXG4gICAgICAgIHJlY3VycmluZ0RhdGU6IG51bGwsXG4gICAgICAgIHByaW9yaXR5OiBudWxsLFxuICAgICAgICBwcm9qZWN0OiBudWxsLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBwcml2YXRlTWVtYmVycy5zZXQodGhpcywgcHJpdmF0ZXMpO1xuICB9XG5cbiAgZ2V0IHRpdGxlKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIHJldHVybiAocHJpdmF0ZXMubW9kZSA9PT0gJ2VkaXQnKSA/ICdFZGl0IFRhc2snIDogJ0FkZCBUYXNrJztcbiAgfVxuXG4gIGdldCBjb25maXJtTGFiZWwoKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgcmV0dXJuIChwcml2YXRlcy5tb2RlID09PSAnZWRpdCcpID8gJ1VwZGF0ZScgOiAnQWRkJztcbiAgfVxuXG4gIGdldCBpbml0Rm9jdXMoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5jb250cm9scy5uYW1lO1xuICB9XG5cbiAgYWRkQ29udGVudChwYXJlbnQsIG1vZGFsU3RhY2spIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcblxuICAgIGNvbnN0IGNvbnRhaW5lclR5cGUgPSB7IGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWNvbnRhaW5lciddIH07XG4gICAgY29uc3QgbGFiZWxUeXBlID0gKHZhbHVlKSA9PiAoeyB2YWx1ZSwgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtbGFiZWwnXSB9KTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgaWQ6ICd0YXNrLW5hbWUnLFxuICAgICAgbmFtZTogJ3Rhc2stbmFtZScsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dCddLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBsYWJlbDogbGFiZWxUeXBlKCdOYW1lJyksXG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lclR5cGUsXG4gICAgfSkpO1xuXG4gICAgY29uc3QgZGF0ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRhdGVDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi5jb250YWluZXJUeXBlLmNsYXNzTGlzdCk7XG4gICAgY29uc3QgZGF0ZUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBkYXRlTGFiZWwudGV4dENvbnRlbnQgPSAnRHVlIERhdGUnO1xuICAgIGRhdGVMYWJlbC5odG1sRm9yID0gJ3Rhc2stZHVlLWRhdGUnO1xuICAgIGRhdGVMYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsJyk7XG4gICAgZGF0ZUNvbnRhaW5lci5hcHBlbmRDaGlsZChkYXRlTGFiZWwpO1xuXG4gICAgZGF0ZUNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVEYXRlSW5wdXRGaWVsZCh7XG4gICAgICBpZDogJ3Rhc2stZHVlLWRhdGUnLFxuICAgICAgbmFtZTogJ3Rhc2stZHVlLWRhdGUnLFxuICAgICAgcGxhY2Vob2xkZXI6IHByaXZhdGVzLmRhdGVGb3JtYXQudmlzdWFsUGF0dGVybixcbiAgICAgIGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWlubGluZSddLFxuICAgICAgY29udGFpbmVyOiB7IGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWRhdGUtY29udGFpbmVyJ10gfSxcbiAgICAgIGJ1dHRvbjoge1xuICAgICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1idXR0b24nXSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHBpY2tEdWVEYXRlKHRoaXMsIG1vZGFsU3RhY2spLFxuICAgICAgfSxcbiAgICB9KSk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGRhdGVDb250YWluZXIpO1xuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgaWQ6ICd0YXNrLXJlY3VycmluZy1kYXRlJyxcbiAgICAgIG5hbWU6ICd0YXNrLXJlY3VycmluZy1kYXRlJyxcbiAgICAgIGNsYXNzTGlzdDogWydmb3JtLXNlbGVjdCddLFxuICAgICAgbGFiZWw6IGxhYmVsVHlwZSgnUmVjdXJyaW5nIERhdGUnKSxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyVHlwZSxcbiAgICAgIG1lbnVJdGVtczogW1xuICAgICAgICB7IHZhbHVlOiAnbm9uZScsIGxhYmVsOiAnTmV2ZXIgUmVwZWF0Jywgc2VsZWN0ZWQ6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogJ2RhaWx5JywgbGFiZWw6ICdSZXBlYXQgRGFpbHknIH0sXG4gICAgICAgIHsgdmFsdWU6ICd3ZWVrbHknLCBsYWJlbDogJ1JlcGVhdCBXZWVrbHknIH0sXG4gICAgICAgIHsgdmFsdWU6ICdtb250aGx5JywgbGFiZWw6ICdSZXBlYXQgTW9udGhseScgfSxcbiAgICAgICAgeyB2YWx1ZTogJ2FubnVhbGx5JywgbGFiZWw6ICdSZXBlYXQgQW5udWFsbHknIH0sXG4gICAgICAgIHsgdmFsdWU6ICdjdXN0b20nLCBsYWJlbDogJ0N1c3RvbSBSZWN1cnJlbmNlLi4uJyB9LFxuICAgICAgXSxcbiAgICB9KSk7XG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICBpZDogJ3Rhc2stcHJpb3JpdHknLFxuICAgICAgbmFtZTogJ3Rhc2stcHJpb3JpdHknLFxuICAgICAgY2xhc3NMaXN0OiBbJ2Zvcm0tc2VsZWN0J10sXG4gICAgICBsYWJlbDogbGFiZWxUeXBlKCdQcmlvcml0eScpLFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXJUeXBlLFxuICAgICAgbWVudUl0ZW1zOiBbXG4gICAgICAgIHsgdmFsdWU6ICd2ZXJ5LWhpZ2gnLCBsYWJlbDogJ1ZlcnkgSGlnaCcgfSxcbiAgICAgICAgeyB2YWx1ZTogJ2hpZ2gnLCBsYWJlbDogJ0hpZ2gnIH0sXG4gICAgICAgIHsgdmFsdWU6ICdtZWRpdW0nLCBsYWJlbDogJ01lZGl1bScsIHNlbGVjdGVkOiB0cnVlIH0sXG4gICAgICAgIHsgdmFsdWU6ICdsb3cnLCBsYWJlbDogJ0xvdycgfSxcbiAgICAgICAgeyB2YWx1ZTogJ3ZlcnktbG93JywgbGFiZWw6ICdWZXJ5IExvdycgfSxcbiAgICAgIF0sXG4gICAgfSkpO1xuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgaWQ6ICd0YXNrLXByb2plY3QnLFxuICAgICAgbmFtZTogJ3Rhc2stcHJvamVjdCcsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QnXSxcbiAgICAgIGxhYmVsOiBsYWJlbFR5cGUoJ1Byb2plY3QnKSxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyVHlwZSxcbiAgICAgIG1lbnVJdGVtczogW3sgdmFsdWU6ICdub25lJywgbGFiZWw6ICdOb25lJyB9XSxcbiAgICB9KSk7XG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ3RleHRhcmVhJyxcbiAgICAgIGlkOiAndGFzay1kZXNjcmlwdGlvbicsXG4gICAgICBuYW1lOiAndGFzay1kZXNjcmlwdGlvbicsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS10ZXh0YXJlYSddLFxuICAgICAgbGFiZWw6IGxhYmVsVHlwZSgnRGVzY3JpcHRpb24nKSxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyVHlwZSxcbiAgICAgIHNpemU6IHsgcm93czogNCwgY29sczogMjAgfSxcbiAgICB9KSk7XG5cbiAgICBwcml2YXRlcy5jb250cm9scyA9IHtcbiAgICAgIG5hbWU6IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjdGFzay1uYW1lJyksXG4gICAgICBkdWVEYXRlOiBwYXJlbnQucXVlcnlTZWxlY3RvcignI3Rhc2stZHVlLWRhdGUnKSxcbiAgICAgIHJlY3VycmluZ0RhdGU6IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjdGFzay1yZWN1cnJpbmctZGF0ZScpLFxuICAgICAgcHJpb3JpdHk6IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjdGFzay1wcmlvcml0eScpLFxuICAgICAgcHJvamVjdDogcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJyN0YXNrLXByb2plY3QnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBwYXJlbnQucXVlcnlTZWxlY3RvcignI3Rhc2stZGVzY3JpcHRpb24nKSxcbiAgICB9O1xuICAgIGluaXRGb3JtVmFsdWVzKHRoaXMpO1xuICAgIGFkZExpc3RlbmVycyh0aGlzLCBtb2RhbFN0YWNrKTtcbiAgfVxuXG4gIGNvbmZpcm0oKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgY29uc3QgeyBjb250cm9scywgZGF0ZUZvcm1hdCB9ID0gcHJpdmF0ZXM7XG5cbiAgICBsZXQgZHVlRGF0ZSA9IG51bGw7XG4gICAgaWYgKGNvbnRyb2xzLmR1ZURhdGUudmFsdWUpIHtcbiAgICAgIGR1ZURhdGUgPSBwYXJzZURhdGUoY29udHJvbHMuZHVlRGF0ZS52YWx1ZSwgZGF0ZUZvcm1hdC5pbnB1dFBhdHRlcm5zKTtcbiAgICB9XG5cbiAgICBsZXQgY3JlYXRpb25EYXRlID0gbnVsbDtcbiAgICBsZXQgY29tcGxldGlvbkRhdGUgPSBudWxsO1xuICAgIGlmIChwcml2YXRlcy50YXNrSWQpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSBwcml2YXRlcy50YXNrcy5nZXRUYXNrKHByaXZhdGVzLnRhc2tJZCk7XG4gICAgICBjcmVhdGlvbkRhdGUgPSB0YXNrLmNyZWF0aW9uRGF0ZTtcbiAgICAgIGNvbXBsZXRpb25EYXRlID0gdGFzay5jb21wbGV0aW9uRGF0ZTtcbiAgICB9XG5cbiAgICBsZXQgcmVjdXJyaW5nRGF0ZSA9IG51bGw7XG4gICAgc3dpdGNoIChjb250cm9scy5yZWN1cnJpbmdEYXRlLnZhbHVlKSB7XG4gICAgICBjYXNlICdkYWlseSc6XG4gICAgICAgIHJlY3VycmluZ0RhdGUgPSBuZXcgUmVjdXJyaW5nRGF0ZSgnZGF5Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2Vla2x5JzpcbiAgICAgICAgcmVjdXJyaW5nRGF0ZSA9IG5ldyBSZWN1cnJpbmdEYXRlKCd3ZWVrJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGhseSc6XG4gICAgICAgIHJlY3VycmluZ0RhdGUgPSBuZXcgUmVjdXJyaW5nRGF0ZSgnbW9udGgnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhbm51YWxseSc6XG4gICAgICAgIHJlY3VycmluZ0RhdGUgPSBuZXcgUmVjdXJyaW5nRGF0ZSgneWVhcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2N1c3RvbS1yZXN1bHQnOlxuICAgICAgICByZWN1cnJpbmdEYXRlID0gcHJpdmF0ZXMuY3VzdG9tUmVjdXJyZW5jZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBsZXQgcHJvamVjdCA9IG51bGw7XG4gICAgc3dpdGNoIChjb250cm9scy5wcm9qZWN0LnZhbHVlKSB7XG4gICAgICBjYXNlICdub25lJzpcbiAgICAgIGNhc2UgJ25ldyc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHJvamVjdCA9IGNvbnRyb2xzLnByb2plY3QudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IHRhc2sgPSBuZXcgVGFzayhjb250cm9scy5uYW1lLnZhbHVlLCB7XG4gICAgICBkdWVEYXRlLFxuICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgY29tcGxldGlvbkRhdGUsXG4gICAgICBwcmlvcml0eTogY29udHJvbHMucHJpb3JpdHkudmFsdWUsXG4gICAgICBkZXNjcmlwdGlvbjogY29udHJvbHMuZGVzY3JpcHRpb24udmFsdWUgfHwgbnVsbCxcbiAgICAgIHJlY3VycmluZ0RhdGUsXG4gICAgICBwcm9qZWN0LFxuICAgIH0pO1xuXG4gICAgbGV0IGlkO1xuICAgIGlmIChwcml2YXRlcy50YXNrSWQpIHtcbiAgICAgIGlkID0gcHJpdmF0ZXMudGFza0lkO1xuICAgICAgcHJpdmF0ZXMudGFza3MudXBkYXRlVGFzayhpZCwgdGFzayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gcHJpdmF0ZXMudGFza3MuYWRkVGFzayh0YXNrKTtcbiAgICB9XG5cbiAgICBpZiAocHJpdmF0ZXMuY2FsbGJhY2tzLmNvbmZpcm0pIHByaXZhdGVzLmNhbGxiYWNrcy5jb25maXJtKGlkKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrcyB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChjYWxsYmFja3MuY2FuY2VsKSBjYWxsYmFja3MuY2FuY2VsKCk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCB7IGNvbnRyb2xzIH0gPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgaWYgKCFjb250cm9scy5uYW1lLnJlcG9ydFZhbGlkaXR5KCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWNvbnRyb2xzLmR1ZURhdGUucmVwb3J0VmFsaWRpdHkoKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFkZFRhc2tNb2RhbDtcbiIsIi8qKlxuICogRGVmaW5lcyB0aGUgW0NvbmZpcm1Nb2RhbF17QGxpbmsgbW9kdWxlOmNvbmZpcm1Nb2RhbH5Db25maXJtTW9kYWx9IGNsYXNzLlxuICogQG1vZHVsZSBjb25maXJtTW9kYWxcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVGb3JtQ29udHJvbCB9IGZyb20gJy4uL3V0aWxpdHkvZG9tJztcblxuLyoqXG4gKiBPYmplY3QgaG9sZGluZyB0aGUgcHJpdmF0ZSBtZW1iZXJzIGZvciB0aGVcbiAqIFtDb25maXJtTW9kYWxde0BsaW5rIG1vZHVsZTpjb25maXJtTW9kYWx+Q29uZmlybU1vZGFsfSBjbGFzcy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpjb25maXJtTW9kYWx+Q29uZmlybU1vZGFsfnByaXZhdGVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGl0bGUgVGhlIHRpdGxlIGZvciB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGNvbnRlbnQgb2YgdGhlXG4gKiAgIG1vZGFsLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbmZpcm1MYWJlbCBUaGUgbGFiZWwgdG8gYmUgdXNlZCBmb3IgdGhlIGNvbmZpcm0gYnV0dG9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNhbmNlbExhYmVsIFRoZSBsYWJlbCB0byBiZSB1c2VkIGZvciB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbml0Rm9jdXMgV2hpY2ggYnV0dG9uIHRvIGdpdmUgaW5pdGlhbCBrZXlib2FyZCBmb2N1czpcbiAqICAgJ2NvbmZpcm0nLCAnY2FuY2VsJywgb3IgJ25vbmUnLlxuICogQHByb3BlcnR5IHttb2R1bGU6Y29uZmlybU1vZGFsfkNvbmZpcm1Nb2RhbH5jb25maXJtQm94fSBbY29uZmlybUJveF0gSG9sZHNcbiAqICAgb3B0aW9ucyBjb250cm9sbGluZyB0ZXh0IHRoYXQgdGhlIHVzZXIgbXVzdCBlbnRlciB0byBjb25maXJtIHRoZSBtb2RhbC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjYWxsYmFja3MgQW4gb2JqZWN0IGhvbGRpbmcgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5jb25maXJtXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIHdoZW4gdGhlIHVzZXIgc3VjY2Vzc2Z1bGx5IGNvbmZpcm1zIHRoZSBtb2RhbC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuY2FuY2VsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge09iamVjdH0gY29udHJvbHMgQW4gb2JqZWN0IGhvbGRpbmcgdGhlIGZvcm0gaW5wdXQgZWxlbWVudHMgZm9yXG4gKiAgIHRoZSBtb2RhbC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IFtjb250cm9scy5jb25maXJtQm94XSBUaGUgdGV4dCBpbnB1dCBlbGVtZW50IGZvciB0aGVcbiAqICAgY29uZmlybWF0aW9uIHRleHQgdGhhdCB0aGUgdXNlciBtdXN0IGVudGVyLCBpZiBhcHBsaWNhYmxlLlxuICovXG5cbi8qKlxuICogSG9sZHMgcHJpdmF0ZSBkYXRhIGZvciB0aGVcbiAqIFtDb25maXJtTW9kYWxde0BsaW5rIG1vZHVsZTpjb25maXJtTW9kYWx+Q29uZmlybU1vZGFsfSBjbGFzcy5cbiAqIEB0eXBlIHtXZWFrTWFwfVxuICogQHNlZSBtb2R1bGU6Y29uZmlybU1vZGFsfkNvbmZpcm1Nb2RhbH5wcml2YXRlc1xuICovXG5jb25zdCBwcml2YXRlTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50cyBmb3IgdGhlIG1vZGFsLlxuICogQHBhcmFtIHttb2R1bGU6Y29uZmlybU1vZGFsfkNvbmZpcm1Nb2RhbH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uXG4gKiAgIHdoaWNoIHRvIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5pdEZvcm1Db250cm9scyhpbnN0YW5jZSkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGNvbnN0IHsgY29udHJvbHMgfSA9IHByaXZhdGVzO1xuXG4gIGlmIChjb250cm9scy5jb25maXJtQm94KSB7XG4gICAgY29uc3QgeyBjb25maXJtQm94IH0gPSBwcml2YXRlcztcblxuICAgIGNvbnRyb2xzLmNvbmZpcm1Cb3gudmFsdWUgPSAnJztcbiAgICBjb250cm9scy5jb25maXJtQm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHZhbHVlIH0gPSBlLnRhcmdldDtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gY29uZmlybUJveC52YWx1ZSkgbWVzc2FnZSA9IGNvbmZpcm1Cb3guZXJyb3JNZXNzYWdlO1xuICAgICAgICBlLnRhcmdldC5zZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEEgbW9kYWwgZGlhbG9nIHByb21wdGluZyB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uLlxuICogQGltcGxlbWVudHMge21vZHVsZTptb2RhbFN0YWNrfk1vZGFsfVxuICovXG5jbGFzcyBDb25maXJtTW9kYWwge1xuICAvKipcbiAgICogU3BlY2lmaWVzIG9wdGlvbnMgZm9yIHRleHQgdGhhdCB0aGUgdXNlciBtdXN0IGVudGVyIHRvIGNvbmZpcm0gdGhlIGFjdGlvbi5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmNvbmZpcm1Nb2RhbH5Db25maXJtTW9kYWx+Y29uZmlybUJveFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ZhbHVlPWNvbmZpcm1dIEEgdmFsdWUgdGhhdCB0aGUgdXNlciBtdXN0IGVudGVyIGluIGFcbiAgICogICB0ZXh0IGJveCBpbiBvcmRlciB0byBjb25maXJtIHRoZSBhY3Rpb24uXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWxdIFRoZSBsYWJlbCBmb3IgdGhlIHRleHQgYm94LiBJZiBub3QgZ2l2ZW4sIGFcbiAgICogICBnZW5lcmljIGxhYmVsIGlzIGNyZWF0ZWQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JNZXNzYWdlXSBUaGUgdmFsaWRhdGlvbiBtZXNzYWdlIHRoYXQgc2hvdWxkIGJlXG4gICAqICAgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgdHJpZXMgdG8gY29uZmlybSB0aGUgbW9kYWwgd2l0aG91dCBlbnRlcmluZyB0aGVcbiAgICogICBjb3JyZWN0IHZhbHVlLiBJZiBub3QgZ2l2ZW4sIGEgZ2VuZXJpYyBtZXNzYWdlIGlzIHVzZWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgb3B0aW9ucyBmb3IgdGhlIG1vZGFsLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6Y29uZmlybU1vZGFsfkNvbmZpcm1Nb2RhbH5vcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGU9Q29uZmlybV0gVGhlIHRpdGxlIGZvciB0aGUgbW9kYWwuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29uZmlybUxhYmVsPVllc10gVGhlIGxhYmVsIHRvIGJlIHVzZWQgZm9yIHRoZSBjb25maXJtXG4gICAqICAgYnV0dG9uLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NhbmNlbExhYmVsPU5vXSBUaGUgbGFiZWwgdG8gYmUgdXNlZCBmb3IgdGhlIGNhbmNlbFxuICAgKiAgIGJ1dHRvbi5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpbml0Rm9jdXM9Y2FuY2VsXSBXaGljaCBlbGVtZW50IHRvIGdpdmUgaW5pdGlhbFxuICAgKiAgIGtleWJvYXJkIGZvY3VzOiAnY29uZmlybScgKHRoZSBDb25maXJtIGJ1dHRvbiksICdjYW5jZWwnICh0aGUgQ2FuY2VsXG4gICAqICAgYnV0dG9uKSwgJ2NvbmZpcm0tYm94JyAodGhlIGNvbmZpcm1hdGlvbiB0ZXh0IGJveCksIG9yICdub25lJy5cbiAgICogQHByb3BlcnR5IHttb2R1bGU6Y29uZmlybU1vZGFsfkNvbmZpcm1Nb2RhbH5jb25maXJtQm94fSBbY29uZmlybUJveF0gQW5cbiAgICogICBvYmplY3Qgc3BlY2lmeWluZyBvcHRpb25zIGZvciB0ZXh0IHRoYXQgdGhlIHVzZXIgbXVzdCBlbnRlciBpbiBvcmRlciB0b1xuICAgKiAgIGNvbmZpcm0gdGhlIGFjdGlvbi4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBwcm92aWRlZCwgdGhlbiBhIHRleHRib3ggd2lsbCBiZVxuICAgKiAgIGRpc3BsYXllZCBhbmQgdGhlIHVzZXIgd2lsbCBiZSByZXF1aXJlZCB0byB0eXBlIGluIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiAgIGJlZm9yZSBjb25maXJtaW5nIHRoZSBtb2RhbC5cbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NvbmZpcm1dIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAgICogICB3aGVuIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb25maXJtcyB0aGUgbW9kYWwuXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYW5jZWxdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAgICogICB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIG1vZGFsLlxuICAgKi9cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlci5cbiAgICogQHBhcmFtIHttb2R1bGU6Y29uZmlybU1vZGFsfkNvbmZpcm1Nb2RhbH5vcHRpb25zfSBbb3B0aW9ucz17fV0gSG9sZHNcbiAgICogICBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBtb2RhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZhdGVzID0ge1xuICAgICAgdGl0bGU6IG9wdGlvbnMudGl0bGUgPz8gJ0NvbmZpcm0nLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGNvbmZpcm1MYWJlbDogb3B0aW9ucy5jb25maXJtTGFiZWwgfHwgJ1llcycsXG4gICAgICBjYW5jZWxMYWJlbDogb3B0aW9ucy5jYW5jZWxMYWJlbCB8fCAnTm8nLFxuICAgICAgaW5pdEZvY3VzOiBvcHRpb25zLmluaXRGb2N1cyB8fCAnY2FuY2VsJyxcbiAgICAgIGNvbmZpcm1Cb3g6IG51bGwsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgY29uZmlybTogb3B0aW9ucy5jb25maXJtIHx8IG51bGwsXG4gICAgICAgIGNhbmNlbDogb3B0aW9ucy5jYW5jZWwgfHwgbnVsbCxcbiAgICAgIH0sXG4gICAgICBjb250cm9sczoge1xuICAgICAgICBjb25maXJtQm94OiBudWxsLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgeyBjb25maXJtQm94IH0gPSBvcHRpb25zO1xuICAgIGlmIChvcHRpb25zLmNvbmZpcm1Cb3gpIHtcbiAgICAgIHByaXZhdGVzLmNvbmZpcm1Cb3ggPSB7XG4gICAgICAgIHZhbHVlOiBjb25maXJtQm94LnZhbHVlIHx8ICdjb25maXJtJyxcbiAgICAgICAgbGFiZWw6IGNvbmZpcm1Cb3gubGFiZWwgfHwgYFBsZWFzZSBlbnRlciAnJHtjb25maXJtQm94LnZhbHVlfSc6YCxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBjb25maXJtQm94LmVycm9yTWVzc2FnZVxuICAgICAgICAgIHx8IGBQbGVhc2UgZW50ZXIgJyR7Y29uZmlybUJveC52YWx1ZX0nLmAsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGVNZW1iZXJzLnNldCh0aGlzLCBwcml2YXRlcyk7XG4gIH1cblxuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS50aXRsZTtcbiAgfVxuXG4gIGdldCBjb25maXJtTGFiZWwoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5jb25maXJtTGFiZWw7XG4gIH1cblxuICBnZXQgY2FuY2VsTGFiZWwoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5jYW5jZWxMYWJlbDtcbiAgfVxuXG4gIGdldCBpbml0Rm9jdXMoKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG5cbiAgICBpZiAocHJpdmF0ZXMuaW5pdEZvY3VzID09PSAnY29uZmlybS1ib3gnKSB7XG4gICAgICByZXR1cm4gcHJpdmF0ZXMuY29udHJvbHMuY29uZmlybUJveCB8fCAnbm9uZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByaXZhdGVzLmluaXRGb2N1cztcbiAgfVxuXG4gIGFkZENvbnRlbnQocGFyZW50KSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBjb25maXJtQm94IH0gPSBwcml2YXRlcztcblxuICAgIGxldCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsLWlubGluZScpO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgaWYgKGNvbmZpcm1Cb3gpIHtcbiAgICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gJyAnO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBpZDogJ2NvbmZpcm1hdGlvbi1ib3gnLFxuICAgICAgICBuYW1lOiAnY29uZmlybWF0aW9uLWJveCcsXG4gICAgICAgIGNsYXNzTGlzdDogWydmb3JtLWlucHV0JywgJ2NvbmZpcm1hdGlvbi1ib3gnXSxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBjb25maXJtQm94LnZhbHVlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHZhbHVlOiBjb25maXJtQm94LmxhYmVsLFxuICAgICAgICAgIGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWxhYmVsLWlubGluZSddLFxuICAgICAgICB9LFxuICAgICAgICBjb250YWluZXI6IHsgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtY29udGFpbmVyJ10gfSxcbiAgICAgIH0pKTtcblxuICAgICAgcHJpdmF0ZXMuY29udHJvbHMuY29uZmlybUJveCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjY29uZmlybWF0aW9uLWJveCcpO1xuICAgIH1cblxuICAgIGluaXRGb3JtQ29udHJvbHModGhpcyk7XG4gIH1cblxuICBjb25maXJtKCkge1xuICAgIGNvbnN0IHsgY29uZmlybSB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmNhbGxiYWNrcztcbiAgICBpZiAoY29uZmlybSkgY29uZmlybSgpO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IHsgY2FuY2VsIH0gPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcykuY2FsbGJhY2tzO1xuICAgIGlmIChjYW5jZWwpIGNhbmNlbCgpO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG4gICAgY29uc3QgeyBjb250cm9scyB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChjb250cm9scy5jb25maXJtQm94ICYmICFjb250cm9scy5jb25maXJtQm94LnJlcG9ydFZhbGlkaXR5KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlybU1vZGFsO1xuIiwiLyoqXG4gKiBEZWZpbmVzIHRoZSBbRGF0YU1vZGFsXXtAbGluayBtb2R1bGU6ZGF0YU1vZGFsfmRhdGFNb2RhbH0gY2xhc3MuXG4gKiBAbW9kdWxlIGRhdGFNb2RhbFxuICovXG5cbmltcG9ydCBDb25maXJtTW9kYWwgZnJvbSAnLi9jb25maXJtTW9kYWwnO1xuaW1wb3J0IEV4cG9ydE1vZGFsIGZyb20gJy4vZXhwb3J0TW9kYWwnO1xuXG5pbXBvcnQgeyBjcmVhdGVGb3JtQ29udHJvbCB9IGZyb20gJy4uL3V0aWxpdHkvZG9tJztcbmltcG9ydCB7IHJlYWRGaWxlIH0gZnJvbSAnLi4vdXRpbGl0eS9zdG9yYWdlJztcblxuLyoqXG4gKiBPYmplY3QgaG9sZGluZyB0aGUgcHJpdmF0ZSBtZW1iZXJzIGZvciB0aGVcbiAqIFtEYXRhTW9kYWxde0BsaW5rIG1vZHVsZTpkYXRhTW9kYWx+ZGF0YU1vZGFsfSBjbGFzcy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpkYXRhTW9kYWx+RGF0YU1vZGFsfnByaXZhdGVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2FsbGJhY2tzIEFuIG9iamVjdCBob2xkaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmRhdGFNb2RhbH5EYXRhTW9kYWx+aW1wb3J0RGF0YX0gW2NhbGxiYWNrcy5pbXBvcnREYXRhXSBBXG4gKiAgIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIGlmIHRoZSB1c2VyIGNob29zZXMgdG8gaW1wb3J0IGRhdGFcbiAqICAgZnJvbSBhIGZpbGUuXG4gKiBAcHJvcGVydHkge21vZHVsZTpkYXRhTW9kYWx+RGF0YU1vZGFsfmV4cG9ydERhdGF9IFtjYWxsYmFja3MuZXhwb3J0RGF0YV0gQVxuICogICBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCBpZiB0aGUgdXNlciBjaG9vc2VzIHRvIGV4cG9ydCBkYXRhXG4gKiAgIHRvIGEgZmlsZS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuZGVsZXRlQWxsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIGlmIHRoZSB1c2VyIGNob29zZXMgdG8gZGVsZXRlIGFsbCBkYXRhLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5jbG9zZV0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIGNsb3NlcyB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge09iamVjdH0gY29udHJvbHMgQW4gb2JqZWN0IGhvbGRpbmcgdGhlIGZvcm0gY29udHJvbHMgaW4gdGhlIG1vZGFsXG4gKiAgIGNvbnRlbnQuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250cm9scy5maWxlU2VsZWN0b3IgVGhlIGZpbGUgaW5wdXQgY29udHJvbC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLmltcG9ydEJ1dHRvbiBUaGUgaW1wb3J0IGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLmV4cG9ydEJ1dHRvbiBUaGUgZXhwb3J0IGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLmRlbGV0ZUJ1dHRvbiBUaGUgZGVsZXRlIGJ1dHRvbi5cbiAqL1xuXG4vKipcbiAqIEhvbGRzIHByaXZhdGUgZGF0YSBmb3IgdGhlIFtEYXRhTW9kYWxde0BsaW5rIG1vZHVsZTpkYXRhTW9kYWx+ZGF0YU1vZGFsfVxuICogY2xhc3MuXG4gKiBAdHlwZSB7V2Vha01hcH1cbiAqIEBzZWUgbW9kdWxlOmRhdGFNb2RhbH5EYXRhTW9kYWx+cHJpdmF0ZXNcbiAqL1xuY29uc3QgcHJpdmF0ZU1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBkYXRhIGltcG9ydCB0aGF0IHdhcyByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpkYXRhTW9kYWx+RGF0YU1vZGFsfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG9cbiAqICAgYXBwbHkgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbFN0YWNrfSBtb2RhbFN0YWNrIFRoZSBtb2RhbCBzdGFjayBpbiB3aGljaFxuICogICB0aGUgbW9kYWwgaXMgYmVpbmcgaW5zZXJ0ZWQuXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGUgVGhlIGZpbGUgdGhhdCB0aGUgdXNlciBzZWxlY3RlZCBmb3IgaW1wb3J0LlxuICovXG5mdW5jdGlvbiBkb0ltcG9ydChpbnN0YW5jZSwgbW9kYWxTdGFjaywgZmlsZSkge1xuICByZWFkRmlsZShmaWxlLCAoY29udGVudCkgPT4ge1xuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBtb2RhbFN0YWNrLmNsb3NlTW9kYWwoKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKS5jYWxsYmFja3MuaW1wb3J0RGF0YTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IHtcbiAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSB8fCBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBjYWxsYmFjayhjb250ZW50LCBmaWxlSW5mbyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgZGF0YSBleHBvcnQgdGhhdCB3YXMgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLlxuICogQHBhcmFtIHttb2R1bGU6ZGF0YU1vZGFsfkRhdGFNb2RhbH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvXG4gKiAgIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja30gbW9kYWxTdGFjayBUaGUgbW9kYWwgc3RhY2sgaW4gd2hpY2hcbiAqICAgdGhlIG1vZGFsIGlzIGJlaW5nIGluc2VydGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVUeXBlIEEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIGZpbGUgZm9ybWF0IHRvIHVzZSBmb3JcbiAqICAgZXhwb3J0OiAnanNvbicgb3IgJ2NzdicuXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsZU9wdGlvbnMgQW4gb2JqZWN0IHNwZWNpZnlpbmcgYWRkaXRpb25hbCBmaWxlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRvRXhwb3J0KGluc3RhbmNlLCBtb2RhbFN0YWNrLCBmaWxlVHlwZSwgZmlsZU9wdGlvbnMpIHtcbiAgLy8gVXNlIHNldFRpbWVvdXQgdG8gd2FpdCBmb3IgZXhwb3J0IG1vZGFsIHRvIGZpbmlzaFxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBtb2RhbFN0YWNrLmNsb3NlTW9kYWwoKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSkuY2FsbGJhY2tzLmV4cG9ydERhdGE7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhmaWxlVHlwZSwgZmlsZU9wdGlvbnMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgZGF0YSBkZWxldGlvbiBvcGVyYXRpb24gdGhhdCB3YXMgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLlxuICogQHBhcmFtIHttb2R1bGU6ZGF0YU1vZGFsfkRhdGFNb2RhbH0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvXG4gKiAgIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja30gbW9kYWxTdGFjayBUaGUgbW9kYWwgc3RhY2sgaW4gd2hpY2hcbiAqICAgdGhlIG1vZGFsIGlzIGJlaW5nIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBkb0RlbGV0ZShpbnN0YW5jZSwgbW9kYWxTdGFjaykge1xuICBjb25zdCBjYWxsYmFjayA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSkuY2FsbGJhY2tzLmRlbGV0ZUFsbDtcbiAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuXG4gIC8vIENsb3NlIHRoZSBkYXRhIG1vZGFsICh1c2luZyBzZXRUaW1lb3V0IHRvIHdhaXQgZm9yIGNvbmZpcm0gbW9kYWwgdG8gY2xvc2UpXG4gIHNldFRpbWVvdXQoKCkgPT4gbW9kYWxTdGFjay5jbG9zZU1vZGFsKCkpO1xufVxuXG4vKipcbiAqIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBidXR0b25zIGluIHRoZSBtb2RhbC5cbiAqIEBwYXJhbSB7bW9kdWxlOmRhdGFNb2RhbH5EYXRhTW9kYWx9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0b1xuICogICBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTptb2RhbFN0YWNrfk1vZGFsU3RhY2t9IG1vZGFsU3RhY2sgVGhlIG1vZGFsIHN0YWNrIGluIHdoaWNoXG4gKiAgIHRoZSBtb2RhbCBpcyBiZWluZyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGluc3RhbmNlLCBtb2RhbFN0YWNrKSB7XG4gIGNvbnN0IHsgY29udHJvbHMgfSA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG5cbiAgY29udHJvbHMuaW1wb3J0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGNvbnRyb2xzLmZpbGVTZWxlY3Rvci5jbGljaygpO1xuICB9KTtcblxuICBjb250cm9scy5leHBvcnRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3QgbW9kYWwgPSBuZXcgRXhwb3J0TW9kYWwoe1xuICAgICAgY29uZmlybTogKGZpbGVUeXBlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGRvRXhwb3J0KGluc3RhbmNlLCBtb2RhbFN0YWNrLCBmaWxlVHlwZSwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIG1vZGFsU3RhY2suc2hvd01vZGFsKG1vZGFsKTtcbiAgfSk7XG5cbiAgY29udHJvbHMuZGVsZXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IENvbmZpcm1Nb2RhbChcbiAgICAgICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIGFsbCB1c2VyIGRhdGE/IFRoaXMgd2lsbCBlcmFzZSBhbGwgdGFza3MgYW5kIHByb2plY3RzLCBhbmQgd2lsbCBhbHNvIHJlc2V0IGFwcCBzZXR0aW5ncy4nLFxuICAgICAge1xuICAgICAgICBpbml0Rm9jdXM6ICdjb25maXJtLWJveCcsXG4gICAgICAgIGNvbmZpcm1Cb3g6IHtcbiAgICAgICAgICB2YWx1ZTogJ2RlbGV0ZScsXG4gICAgICAgICAgbGFiZWw6ICdUaGlzIGFjdGlvbiBjYW5ub3QgYmUgdW5kb25lLiBQbGVhc2UgY29uZmlybSB5b3VyIGludGVudGlvbiBieSB0eXBpbmcgdGhlIHdvcmQgXFwnZGVsZXRlXFwnICh3aXRob3V0IHF1b3RlcykgaW4gdGhlIGJveDonLFxuICAgICAgICAgIGVycm9yTWVzc2FnZTogJ1BsZWFzZSBlbnRlciB0aGUgd29yZCBcXCdkZWxldGVcXCcuJyxcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlybTogKCkgPT4gZG9EZWxldGUoaW5zdGFuY2UsIG1vZGFsU3RhY2spLFxuICAgICAgfSxcbiAgICApO1xuICAgIG1vZGFsU3RhY2suc2hvd01vZGFsKG1vZGFsKTtcbiAgfSk7XG5cbiAgY29udHJvbHMuZmlsZVNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgY29uc3QgeyBmaWxlcyB9ID0gZS50YXJnZXQ7XG4gICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIGRvSW1wb3J0KGluc3RhbmNlLCBtb2RhbFN0YWNrLCBmaWxlc1swXSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEEgbW9kYWwgZGlhbG9nIGZvciBtYW5hZ2luZyB1c2VyIGRhdGEuXG4gKiBAaW1wbGVtZW50cyB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWx9XG4gKi9cbmNsYXNzIERhdGFNb2RhbCB7XG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIHVzZXIgY2hvb3NlcyB0byBpbXBvcnRcbiAgICogZGF0YSBmcm9tIGEgZmlsZSBhbmQgdGhlIGZpbGUgaXMgcmVhZCBzdWNjZXNzZnVsbHkuXG4gICAqIEBjYWxsYmFjayBtb2R1bGU6ZGF0YU1vZGFsfkRhdGFNb2RhbH5pbXBvcnREYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IFRoZSBjb250ZW50cyBvZiB0aGUgZmlsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtpbmZvXSBBbiBvYmplY3Qgc3BlY2lmeWluZyBhZGRpdGlvbmFsIGZpbGUgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaW5mby5uYW1lXSBUaGUgbmFtZSBvZiB0aGUgZmlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmZvLnNpemVdIFRoZSBzaXplIG9mIHRoZSBmaWxlIGluIGJ5dGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2luZm8udHlwZV0gVGhlIG1lZGlhIHR5cGUgb2YgdGhlIGZpbGUsIG9yIG51bGwgaWYgdGhlXG4gICAqICAgYnJvd3NlciBjb3VsZCBub3QgZGV0ZXJtaW5lIGEgbWVkaWEgdHlwZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgdXNlciBjaG9vc2VzIHRvIGV4cG9ydFxuICAgKiBkYXRhIHRvIGEgZmlsZS5cbiAgICogQGNhbGxiYWNrIG1vZHVsZTpkYXRhTW9kYWx+RGF0YU1vZGFsfmV4cG9ydERhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVUeXBlIEEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIGZpbGUgZm9ybWF0IHRvIHVzZSBmb3JcbiAgICogICBleHBvcnQuIFRoaXMgY2FuIGJlIGVpdGhlciAnanNvbicgb3IgJ2NzdicuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IHNwZWNpZnlpbmcgYWRkaXRpb25hbCBmaWxlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uZXdsaW5lU2VxdWVuY2VdIFRoZSBjaGFyYWN0ZXIgc2VxdWVuY2UgdG8gdXNlXG4gICAqICAgZm9yIG5ld2xpbmVzLlxuICAgKi9cblxuICAvKipcbiAgICogU3BlY2lmaWVzIG9wdGlvbnMgZm9yIHRoZSBtb2RhbC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmRhdGFNb2RhbH5EYXRhTW9kYWx+b3B0aW9uc1xuICAgKiBAcHJvcGVydHkge21vZHVsZTpkYXRhTW9kYWx+RGF0YU1vZGFsfmltcG9ydERhdGF9IFtpbXBvcnREYXRhXSBBIGNhbGxiYWNrXG4gICAqICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgdXNlciBjaG9vc2VzIHRvIGltcG9ydCBkYXRhIGZyb21cbiAgICogICBhIGZpbGUgYW5kIHRoZSBmaWxlIGlzIHJlYWQgc3VjY2Vzc2Z1bGx5LlxuICAgKiBAcHJvcGVydHkge21vZHVsZTpkYXRhTW9kYWx+RGF0YU1vZGFsfmV4cG9ydERhdGF9IFtleHBvcnREYXRhXSBBIGNhbGxiYWNrXG4gICAqICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgdXNlciBjaG9vc2VzIHRvIGV4cG9ydCBkYXRhIHRvIGFcbiAgICogICBmaWxlLlxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZGVsZXRlQWxsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkXG4gICAqICAgd2hlbiB0aGUgdXNlciBjaG9vc2VzIChhbmQgY29uZmlybXMgdGhlIGNob2ljZSkgdG8gZGVsZXRlIGFsbCBkYXRhLlxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY2xvc2VdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlblxuICAgKiAgIHRoZSB1c2VyIGNsb3NlcyB0aGUgbW9kYWwuIFRoaXMgd2lsbCBub3QgYmUgaW52b2tlZCBpZiB0aGUgbW9kYWwgaXNcbiAgICogICBhdXRvbWF0aWNhbGx5IGNsb3NlZCBmb2xsb3dpbmcgYSBkYXRhIG1hbmFnZW1lbnQgb3BlcmF0aW9uLlxuICAgKi9cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7bW9kdWxlOmRhdGFNb2RhbH5EYXRhTW9kYWx+b3B0aW9uc30gW29wdGlvbnM9e31dIEhvbGRzXG4gICAqICAgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgbW9kYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICBpbXBvcnREYXRhOiBvcHRpb25zLmltcG9ydERhdGEgfHwgbnVsbCxcbiAgICAgICAgZXhwb3J0RGF0YTogb3B0aW9ucy5leHBvcnREYXRhIHx8IG51bGwsXG4gICAgICAgIGRlbGV0ZUFsbDogb3B0aW9ucy5kZWxldGVBbGwgfHwgbnVsbCxcbiAgICAgICAgY2xvc2U6IG9wdGlvbnMuY2xvc2UgfHwgbnVsbCxcbiAgICAgIH0sXG4gICAgICBjb250cm9sczoge1xuICAgICAgICBmaWxlU2VsZWN0b3I6IG51bGwsXG4gICAgICAgIGltcG9ydEJ1dHRvbjogbnVsbCxcbiAgICAgICAgZXhwb3J0QnV0dG9uOiBudWxsLFxuICAgICAgICBkZWxldGVCdXR0b246IG51bGwsXG4gICAgICB9LFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgLS1cbiAgICogV2UgbmVlZCB0byBzZXQgdGhlc2UgcHJvcGVydGllcyB0byBjb25mb3JtIHRvIHRoZSBNb2RhbCBpbnRlcmZhY2UsIGJ1dFxuICAgKiBzZXR0aW5nIHRoZW0gZGlyZWN0bHkgaW4gdGhlIGNvbnN0cnVjdG9yIHdvdWxkIGFsbG93IGV4dGVybmFsXG4gICAqIG1vZGlmaWNhdGlvbi5cbiAgICovXG5cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiAnTWFuYWdlIERhdGEnO1xuICB9XG5cbiAgZ2V0IGNvbmZpcm1MYWJlbCgpIHtcbiAgICByZXR1cm4gJ0Nsb3NlJztcbiAgfVxuXG4gIGdldCBub0NhbmNlbEJ1dHRvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldCBpbml0Rm9jdXMoKSB7XG4gICAgcmV0dXJuICdjb25maXJtJztcbiAgfVxuXG4gIC8qIGVzbGludC1lbmFibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG4gIGFkZENvbnRlbnQocGFyZW50LCBtb2RhbFN0YWNrKSB7XG4gICAgY29uc3QgYWRkQ29udGFpbmVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1jb250YWluZXInKTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGFkZEhlYWRpbmcgPSAobGFiZWwsIGNvbnRhaW5lcikgPT4ge1xuICAgICAgY29uc3QgbGFiZWxFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBsYWJlbEVsZW0uY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbCcpO1xuICAgICAgbGFiZWxFbGVtLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWxFbGVtKTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZEJ1dHRvbiA9IChsYWJlbCwgY29udGFpbmVyKSA9PiB7XG4gICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdmb3JtLWJ1dHRvbicpO1xuICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfTtcblxuICAgIGNvbnN0IHsgY29udHJvbHMgfSA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcbiAgICBsZXQgY29udGFpbmVyID0gYWRkQ29udGFpbmVyKCk7XG4gICAgYWRkSGVhZGluZygnSW1wb3J0L0V4cG9ydCcsIGNvbnRhaW5lcik7XG4gICAgY29uc3QgYnV0dG9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYnV0dG9uQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Zvcm0tYnV0dG9uLWNvbnRhaW5lcicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidXR0b25Db250YWluZXIpO1xuICAgIGNvbnRyb2xzLmltcG9ydEJ1dHRvbiA9IGFkZEJ1dHRvbignSW1wb3J0IGZyb20gRmlsZS4uLicsIGJ1dHRvbkNvbnRhaW5lcik7XG4gICAgY29udHJvbHMuZXhwb3J0QnV0dG9uID0gYWRkQnV0dG9uKCdFeHBvcnQgdG8gRmlsZS4uLicsIGJ1dHRvbkNvbnRhaW5lcik7XG5cbiAgICBjb250YWluZXIgPSBhZGRDb250YWluZXIoKTtcbiAgICBhZGRIZWFkaW5nKCdEZWxldGUgRGF0YScsIGNvbnRhaW5lcik7XG4gICAgY29udHJvbHMuZGVsZXRlQnV0dG9uID0gYWRkQnV0dG9uKCdFcmFzZSBBbGwgRGF0YS4uLicsIGNvbnRhaW5lcik7XG5cbiAgICBjb250cm9scy5maWxlU2VsZWN0b3IgPSBjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAnZmlsZScsXG4gICAgICBpZDogJ2RhdGEtaW1wb3J0LWZpbGUtc2VsZWN0JyxcbiAgICAgIG5hbWU6ICdkYXRhLWltcG9ydC1maWxlLXNlbGVjdCcsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1oaWRkZW4nXSxcbiAgICAgIGFjY2VwdDogW1xuICAgICAgICAnLmpzb24nLFxuICAgICAgICAnLmNzdicsXG4gICAgICAgICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ3RleHQvY3N2JyxcbiAgICAgIF0sXG4gICAgfSk7XG5cbiAgICBhZGRMaXN0ZW5lcnModGhpcywgbW9kYWxTdGFjayk7XG4gIH1cblxuICBjb25maXJtKCkge1xuICAgIHRoaXMuY2FuY2VsKCk7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgY29uc3QgeyBjbG9zZSB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmNhbGxiYWNrcztcbiAgICBpZiAoY2xvc2UpIGNsb3NlKCk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAtLVxuICAgKiBOZWNlc3Nhcnkgc2luY2UgbW9kYWwgbXVzdCBoYXZlIHZhbGlkYXRlIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHNhdGlzZnlcbiAgICogTW9kYWwgaW50ZXJmYWNlLlxuICAgKi9cbiAgdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YU1vZGFsO1xuIiwiLyoqXG4gKiBEZWZpbmVzIHRoZSBbRGF0ZVBpY2tlck1vZGFsXXtAbGluayBtb2R1bGU6ZGF0ZVBpY2tlck1vZGFsfkRhdGVQaWNrZXJNb2RhbH1cbiAqIGNsYXNzLlxuICogQG1vZHVsZSBkYXRlUGlja2VyTW9kYWxcbiAqL1xuXG5pbXBvcnQgRGF0ZVBpY2tlciBmcm9tICcuLi9kYXRlUGlja2VyJztcblxuLyoqXG4gKiBPYmplY3QgaG9sZGluZyBwcml2YXRlIG1lbWJlcnMgZm9yIHRoZVxuICogW0RhdGVQaWNrZXJNb2RhbF17QGxpbmsgbW9kdWxlOmRhdGVQaWNrZXJNb2RhbH5EYXRlUGlja2VyTW9kYWx9IGNsYXNzLlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmRhdGVQaWNrZXJNb2RhbH5EYXRlUGlja2VyTW9kYWx+cHJpdmF0ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjYWxsYmFja3MgQW4gb2JqZWN0IGhvbGRpbmcgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5jb25maXJtXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIHdoZW4gdGhlIHVzZXIgc3VjY2Vzc2Z1bGx5IGNvbmZpcm1zIHRoZSBtb2RhbC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuY2FuY2VsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge0RhdGV9IFtzdGF0ZURhdGVdIFRoZSBkZWZhdWx0IGRhdGUgdGhhdCBpcyBzZWxlY3RlZCB3aGVuIHRoZVxuICogICBtb2RhbCBpcyBvcGVuZWQsIGlmIGRpZmZlcmVudCBmcm9tIHRvZGF5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlIFRoZSB0aXRsZSBvZiB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge21vZHVsZTpkYXRlUGlja2VyfkRhdGVQaWNrZXJ9IHBpY2tlciBUaGUgZGF0ZSBwaWNrZXIgaW5zdGFuY2UuXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBwcml2YXRlIGRhdGEgZm9yIHRoZVxuICogW0RhdGVQaWNrZXJNb2RhbF17QGxpbmsgbW9kdWxlOmRhdGVQaWNrZXJNb2RhbH5EYXRlUGlja2VyTW9kYWx9IGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTpkYXRlUGlja2VyTW9kYWx+RGF0ZVBpY2tlck1vZGFsfnByaXZhdGVzXG4gKi9cbmNvbnN0IHByaXZhdGVNZW1iZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBBIG1vZGFsIGRpYWxvZyBmb3IgY2hvb3NpbmcgYSBjYWxlbmRhciBkYXRlLlxuICogQGltcGxlbWVudHMge21vZHVsZTptb2RhbFN0YWNrfk1vZGFsfVxuICovXG5jbGFzcyBEYXRlUGlja2VyTW9kYWwge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gSG9sZHMgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNvbmZpcm1dIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb25maXJtcyB0aGUgbW9kYWwuIFRoZSBzZWxlY3RlZCBkYXRlXG4gICAqICAgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYW5jZWxdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIG1vZGFsLlxuICAgKiBAcGFyYW0ge0RhdGV9IFtvcHRpb25zLnN0YXJ0RGF0ZV0gVGhlIGRhdGUgdGhhdCB3aWxsIGJlIGluaXRpYWxseVxuICAgKiAgIHNlbGVjdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZW4gdGhlIHByZXNlbnQgZGF0ZSBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGl0bGU9U2VsZWN0IERhdGVdIFRoZSB0aXRsZSBvZiB0aGUgbW9kYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICBjb25maXJtOiBvcHRpb25zLmNvbmZpcm0gfHwgbnVsbCxcbiAgICAgICAgY2FuY2VsOiBvcHRpb25zLmNhbmNlbCB8fCBudWxsLFxuICAgICAgfSxcbiAgICAgIHN0YXJ0RGF0ZTogb3B0aW9ucy5zdGFydERhdGUgfHwgbnVsbCxcbiAgICAgIHRpdGxlOiBvcHRpb25zLnRpdGxlID8/ICdTZWxlY3QgRGF0ZScsXG4gICAgICBwaWNrZXI6IG51bGwsXG4gICAgfTtcbiAgICBwcml2YXRlTWVtYmVycy5zZXQodGhpcywgcHJpdmF0ZXMpO1xuICB9XG5cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiBwcml2YXRlTWVtYmVycy5nZXQodGhpcykudGl0bGU7XG4gIH1cblxuICBhZGRDb250ZW50KHBhcmVudCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIHByaXZhdGVzLnBpY2tlciA9IG5ldyBEYXRlUGlja2VyKHBhcmVudCwgcHJpdmF0ZXMuc3RhcnREYXRlKTtcbiAgfVxuXG4gIGNvbmZpcm0oKSB7XG4gICAgY29uc3QgeyBjYWxsYmFja3MsIHBpY2tlciB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChjYWxsYmFja3MuY29uZmlybSkgY2FsbGJhY2tzLmNvbmZpcm0ocGlja2VyLmRhdGUpO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tzIH0gPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgaWYgKGNhbGxiYWNrcy5jYW5jZWwpIGNhbGxiYWNrcy5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzIC0tXG4gICAqIE5lY2Vzc2FyeSBzaW5jZSBtb2RhbCBtdXN0IGhhdmUgdmFsaWRhdGUgZnVuY3Rpb24gaW4gb3JkZXIgdG8gc2F0aXNmeVxuICAgKiBNb2RhbCBpbnRlcmZhY2UuXG4gICAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRlUGlja2VyTW9kYWw7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtFeHBvcnRNb2RhbF17QGxpbmsgbW9kdWxlOmV4cG9ydE1vZGFsfkV4cG9ydE1vZGFsfSBjbGFzcy5cbiAqIEBtb2R1bGUgZXhwb3J0TW9kYWxcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVGb3JtQ29udHJvbCB9IGZyb20gJy4uL3V0aWxpdHkvZG9tJztcblxuLyoqXG4gKiBPYmplY3QgaG9sZGluZyBwcml2YXRlIG1lbWJlcnMgZm9yIHRoZVxuICogW0V4cG9ydE1vZGFsXXtAbGluayBtb2R1bGU6ZXhwb3J0TW9kYWx+RXhwb3J0TW9kYWx9IGNsYXNzLlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmV4cG9ydE1vZGFsfkV4cG9ydE1vZGFsfnByaXZhdGVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2FsbGJhY2tzIEFuIG9iamVjdCBob2xkaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuY29uZmlybV0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb25maXJtcyB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLmNhbmNlbF0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIG1vZGFsLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGNvbnRyb2xzIEFuIG9iamVjdCBob2xkaW5nIHRoZSBmb3JtIGlucHV0IGVsZW1lbnRzIGZvclxuICogICB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250cm9scy5leHBvcnRKc29uIFRoZSByYWRpbyBidXR0b24gZm9yIHNlbGVjdGluZ1xuICogICB0aGUgSlNPTiBmaWxlIGZvcm1hdC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLmV4cG9ydENzdiBUaGUgcmFkaW8gYnV0dG9uIGZvciBzZWxlY3RpbmdcbiAqICAgdGhlIENTViBmaWxlIGZvcm1hdC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLm5ld2xpbmVTZXF1ZW5jZSBUaGUgc2VsZWN0IGJveCBmb3IgY2hvb3NpbmdcbiAqICAgdGhlIG5ld2xpbmUgc3R5bGUuXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBwcml2YXRlIGRhdGEgZm9yIHRoZVxuICogW0V4cG9ydE1vZGFsXXtAbGluayBtb2R1bGU6ZXhwb3J0TW9kYWx+RXhwb3J0TW9kYWx9IGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTpleHBvcnRNb2RhbH5FeHBvcnRNb2RhbH5wcml2YXRlc1xuICovXG5jb25zdCBwcml2YXRlTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQSBtb2RhbCBkaWFsb2cgZm9yIGV4cG9ydGluZyBkYXRhIHRvIGEgZmlsZS5cbiAqIEBpbXBsZW1lbnRzIHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbH1cbiAqL1xuY2xhc3MgRXhwb3J0TW9kYWwge1xuICAvKipcbiAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSB1c2VyIGNob29zZXMgdG8gZXhwb3J0XG4gICAqIGRhdGEgdG8gYSBmaWxlLlxuICAgKiBAY2FsbGJhY2sgbW9kdWxlOmV4cG9ydE1vZGFsfkV4cG9ydE1vZGFsfmV4cG9ydENhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlVHlwZSBBIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBmaWxlIGZvcm1hdCB0byB1c2UgZm9yXG4gICAqICAgZXhwb3J0LiBUaGlzIGNhbiBiZSBlaXRoZXIgJ2pzb24nIG9yICdjc3YnLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBzcGVjaWZ5aW5nIGFkZGl0aW9uYWwgZmlsZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmV3bGluZVNlcXVlbmNlXSBUaGUgY2hhcmFjdGVyIHNlcXVlbmNlIHRvIHVzZVxuICAgKiAgIGZvciBuZXdsaW5lcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBvcHRpb25zIGZvciB0aGUgbW9kYWwuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpleHBvcnRNb2RhbH5FeHBvcnRNb2RhbH5vcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7bW9kdWxlOmV4cG9ydE1vZGFsfkV4cG9ydE1vZGFsfmV4cG9ydENhbGxiYWNrfSBbY29uZmlybV0gQVxuICAgKiAgIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIHVzZXIgc3VjY2Vzc2Z1bGx5XG4gICAqICAgY29uZmlybXMgdGhlIG1vZGFsLlxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY2FuY2VsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkXG4gICAqICAgd2hlbiB0aGUgdXNlciBjYW5jZWxzIHRoZSBtb2RhbC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIG1vZGFsLlxuICAgKiBAcGFyYW0ge21vZHVsZTpleHBvcnRNb2RhbH5FeHBvcnRNb2RhbH5vcHRpb25zfSBbb3B0aW9ucz17fV0gSG9sZHNcbiAgICogICBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBtb2RhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZhdGVzID0ge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIGNvbmZpcm06IG9wdGlvbnMuY29uZmlybSB8fCBudWxsLFxuICAgICAgICBjYW5jZWw6IG9wdGlvbnMuY2FuY2VsIHx8IG51bGwsXG4gICAgICB9LFxuICAgICAgY29udHJvbHM6IHtcbiAgICAgICAgZXhwb3J0SnNvbjogbnVsbCxcbiAgICAgICAgZXhwb3J0Q3N2OiBudWxsLFxuICAgICAgICBuZXdsaW5lU2VxdWVuY2U6IG51bGwsXG4gICAgICB9LFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgLS1cbiAgICogV2UgbmVlZCB0byBzZXQgdGhlc2UgcHJvcGVydGllcyB0byBjb25mb3JtIHRvIHRoZSBNb2RhbCBpbnRlcmZhY2UsIGJ1dFxuICAgKiBzZXR0aW5nIHRoZW0gZGlyZWN0bHkgaW4gdGhlIGNvbnN0cnVjdG9yIHdvdWxkIGFsbG93IGV4dGVybmFsXG4gICAqIG1vZGlmaWNhdGlvbi5cbiAgICovXG5cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiAnRXhwb3J0IERhdGEnO1xuICB9XG5cbiAgZ2V0IGNvbmZpcm1MYWJlbCgpIHtcbiAgICByZXR1cm4gJ0V4cG9ydC4uLic7XG4gIH1cblxuICAvKiBlc2xpbnQtZW5hYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuICBhZGRDb250ZW50KHBhcmVudCkge1xuICAgIGNvbnN0IHJhZGlvTGFiZWwgPSAodmFsdWUpID0+IChcbiAgICAgIHsgdmFsdWUsIGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWxhYmVsLWlubGluZSddIH1cbiAgICApO1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtY29udGFpbmVyJyk7XG5cbiAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwnKTtcbiAgICBsYWJlbC50ZXh0Q29udGVudCA9ICdGaWxlIEZvcm1hdCc7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAncmFkaW8nLFxuICAgICAgaWQ6ICdleHBvcnQtZm9ybWF0LWpzb24nLFxuICAgICAgbmFtZTogJ2V4cG9ydC1mb3JtYXQnLFxuICAgICAgdmFsdWU6ICdqc29uJyxcbiAgICAgIGNoZWNrZWQ6IHRydWUsXG4gICAgICBsYWJlbDogcmFkaW9MYWJlbCgnRXhwb3J0IGFsbCBkYXRhIHRvIEpTT04gZm9ybWF0JyksXG4gICAgICBjb250YWluZXI6IHsgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtaXRlbS1jb250YWluZXInXSB9LFxuICAgIH0pKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ3JhZGlvJyxcbiAgICAgIGlkOiAnZXhwb3J0LWZvcm1hdC1jc3YnLFxuICAgICAgbmFtZTogJ2V4cG9ydC1mb3JtYXQnLFxuICAgICAgdmFsdWU6ICdjc3YnLFxuICAgICAgbGFiZWw6IHJhZGlvTGFiZWwoJ0V4cG9ydCB0YXNrcyB0byBDU1YgZm9ybWF0JyksXG4gICAgICBjb250YWluZXI6IHsgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtaXRlbS1jb250YWluZXInXSB9LFxuICAgIH0pKTtcblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgaWQ6ICdleHBvcnQtbGluZS1lbmRpbmcnLFxuICAgICAgbmFtZTogJ2V4cG9ydC1saW5lLWVuZGluZycsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QnXSxcbiAgICAgIGxhYmVsOiB7IHZhbHVlOiAnTGluZSBFbmRpbmcgU3R5bGUnLCBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1sYWJlbCddIH0sXG4gICAgICBjb250YWluZXI6IHsgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtY29udGFpbmVyJ10gfSxcbiAgICAgIG1lbnVJdGVtczogW1xuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6ICdjcmxmJyxcbiAgICAgICAgICBsYWJlbDogJ1dpbmRvd3MgU3RhbmRhcmQ6IENSTEYnLFxuICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6ICdsZicsXG4gICAgICAgICAgbGFiZWw6ICdVbml4IFN0YW5kYXJkOiBMRicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogJ2NyJyxcbiAgICAgICAgICBsYWJlbDogJ0NsYXNzaWMgTWFjIE9TIFN0YW5kYXJkIChCZWZvcmUgT1MgWCk6IENSJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSkpO1xuXG4gICAgY29uc3QgeyBjb250cm9scyB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGNvbnRyb2xzLmV4cG9ydEpzb24gPSBwYXJlbnQucXVlcnlTZWxlY3RvcignI2V4cG9ydC1mb3JtYXQtanNvbicpO1xuICAgIGNvbnRyb2xzLmV4cG9ydENzdiA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjZXhwb3J0LWZvcm1hdC1jc3YnKTtcbiAgICBjb250cm9scy5uZXdsaW5lU2VxdWVuY2UgPSBwYXJlbnQucXVlcnlTZWxlY3RvcignI2V4cG9ydC1saW5lLWVuZGluZycpO1xuICB9XG5cbiAgY29uZmlybSgpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrcywgY29udHJvbHMgfSA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcblxuICAgIGlmIChjYWxsYmFja3MuY29uZmlybSkge1xuICAgICAgY29uc3QgZmlsZVR5cGUgPSBjb250cm9scy5leHBvcnRKc29uLmNoZWNrZWQgPyAnanNvbicgOiAnY3N2JztcbiAgICAgIGxldCBuZXdsaW5lU2VxdWVuY2U7XG4gICAgICBzd2l0Y2ggKGNvbnRyb2xzLm5ld2xpbmVTZXF1ZW5jZS52YWx1ZSkge1xuICAgICAgICBjYXNlICdsZic6XG4gICAgICAgICAgbmV3bGluZVNlcXVlbmNlID0gJ1xcbic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NyJzpcbiAgICAgICAgICBuZXdsaW5lU2VxdWVuY2UgPSAnXFxyJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY3JsZic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbmV3bGluZVNlcXVlbmNlID0gJ1xcclxcbic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MuY29uZmlybShmaWxlVHlwZSwgeyBuZXdsaW5lU2VxdWVuY2UgfSk7XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmNhbGxiYWNrcy5jYW5jZWw7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgLS1cbiAgICogTmVjZXNzYXJ5IHNpbmNlIG1vZGFsIG11c3QgaGF2ZSB2YWxpZGF0ZSBmdW5jdGlvbiBpbiBvcmRlciB0byBzYXRpc2Z5XG4gICAqIE1vZGFsIGludGVyZmFjZS5cbiAgICovXG4gIHZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4cG9ydE1vZGFsO1xuIiwiLyoqXG4gKiBEZWZpbmVzIHRoZSBbSW5mb01vZGFsXXtAbGluayBtb2R1bGU6aW5mb01vZGFsfkluZm9Nb2RhbH0gY2xhc3MuXG4gKiBAbW9kdWxlIGluZm9Nb2RhbFxuICovXG5cbi8qKlxuICogT2JqZWN0IGhvbGRpbmcgdGhlIHByaXZhdGUgbWVtYmVycyBmb3IgdGhlXG4gKiBbSW5mb01vZGFsXXtAbGluayBtb2R1bGU6aW5mb01vZGFsfkluZm9Nb2RhbH0gY2xhc3MuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6aW5mb01vZGFsfkluZm9Nb2RhbH5wcml2YXRlc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlIFRoZSB0aXRsZSBmb3IgdGhlIG1vZGFsLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbmZpcm1MYWJlbCBUaGUgbGFiZWwgdG8gYmUgdXNlZCBmb3IgdGhlIGNvbmZpcm0gYnV0dG9uLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udGVudCBUaGUgY3VzdG9tIGNvbnRlbnQgdG8gZGlzcGxheSBpbiB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2FsbGJhY2tzIEFuIG9iamVjdCBob2xkaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuY2xvc2VdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gKiAgIGludm9rZWQgd2hlbiB0aGUgdXNlciBjbG9zZXMgdGhlIG1vZGFsLlxuICovXG5cbi8qKlxuICogSG9sZHMgcHJpdmF0ZSBkYXRhIGZvciB0aGUgW0luZm9Nb2RhbF17QGxpbmsgbW9kdWxlOmluZm9Nb2RhbH5JbmZvTW9kYWx9XG4gKiBjbGFzcy5cbiAqIEB0eXBlIHtXZWFrTWFwfVxuICogQHNlZSBtb2R1bGU6aW5mb01vZGFsfkluZm9Nb2RhbH5wcml2YXRlc1xuICovXG5jb25zdCBwcml2YXRlTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQSBtb2RhbCBkaWFsb2cgZGlzcGxheWluZyBjdXN0b20gaW5mb3JtYXRpb25hbCBjb250ZW50LlxuICogQGltcGxlbWVudHMge21vZHVsZTptb2RhbFN0YWNrfk1vZGFsfVxuICovXG5jbGFzcyBJbmZvTW9kYWwge1xuICAvKipcbiAgICogU3BlY2lmaWVzIG9wdGlvbnMgZm9yIHRoZSBtb2RhbC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmluZm9Nb2RhbH5JbmZvTW9kYWx+b3B0aW9uc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlPUFsZXJ0XSBUaGUgdGl0bGUgZm9yIHRoZSBtb2RhbC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb25maXJtTGFiZWw9T2theV0gVGhlIGxhYmVsIHRvIGJlIHVzZWQgZm9yIHRoZVxuICAgKiAgIGNvbmZpcm0gYnV0dG9uLlxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY2xvc2VdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlblxuICAgKiAgIHRoZSB1c2VyIGNsb3NlcyB0aGUgbW9kYWwuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBtb2RhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW118SFRNTEVsZW1lbnR9IGNvbnRlbnQgVGhlIGNvbnRlbnQgdGhhdCB3aWxsIGJlXG4gICAqICAgZGlzcGxheWVkIGluIHRoZSBtb2RhbC4gVGhpcyBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nIHNwZWNpZnlpbmcgYVxuICAgKiAgIG1lc3NhZ2UsIGFuIGFycmF5IG9mIHN0cmluZ3MgZWFjaCBzcGVjaWZ5aW5nIGEgcGFyYWdyYXBoIG9mIHRleHQsIG9yIGFcbiAgICogICBjdXN0b20gZWxlbWVudCB0aGF0IHdpbGwgYmUgaW5zZXJ0ZWQgaW50byB0aGUgbW9kYWwgY29udGVudCBhcmVhLlxuICAgKiBAcGFyYW0ge21vZHVsZTppbmZvTW9kYWx+SW5mb01vZGFsfm9wdGlvbnN9IFtvcHRpb25zPXt9XSBIb2xkc1xuICAgKiAgIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIG1vZGFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSB7XG4gICAgICB0aXRsZTogb3B0aW9ucy50aXRsZSA/PyAnQWxlcnQnLFxuICAgICAgY29uZmlybUxhYmVsOiBvcHRpb25zLmNvbmZpcm1MYWJlbCB8fCAnT2theScsXG4gICAgICBjb250ZW50OiBudWxsLFxuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIGNsb3NlOiBvcHRpb25zLmNsb3NlIHx8IG51bGwsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIHByaXZhdGVzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdpbmZvLW1vZGFsLWNvbnRlbnQtY29udGFpbmVyJyk7XG4gICAgICBjb25zdCBwYXJhZ3JhcGhzID0gQXJyYXkuaXNBcnJheShjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF07XG4gICAgICBwYXJhZ3JhcGhzLmZvckVhY2goKHBhcmFncmFwaCkgPT4ge1xuICAgICAgICBjb25zdCBwRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICAgICAgcEVsZW0uY2xhc3NMaXN0LmFkZCgnaW5mby1tb2RhbC1jb250ZW50LXBhcmFncmFwaCcpO1xuICAgICAgICBwRWxlbS50ZXh0Q29udGVudCA9IHBhcmFncmFwaDtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBFbGVtKTtcbiAgICAgIH0pO1xuICAgICAgcHJpdmF0ZXMuY29udGVudCA9IGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBwcml2YXRlTWVtYmVycy5zZXQodGhpcywgcHJpdmF0ZXMpO1xuICB9XG5cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiBwcml2YXRlTWVtYmVycy5nZXQodGhpcykudGl0bGU7XG4gIH1cblxuICBnZXQgY29uZmlybUxhYmVsKCkge1xuICAgIHJldHVybiBwcml2YXRlTWVtYmVycy5nZXQodGhpcykuY29uZmlybUxhYmVsO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAtLVxuICAgKiBXZSBuZWVkIHRvIHNldCB0aGVzZSBwcm9wZXJ0aWVzIHRvIGNvbmZvcm0gdG8gdGhlIE1vZGFsIGludGVyZmFjZSwgYnV0XG4gICAqIHNldHRpbmcgdGhlbSBkaXJlY3RseSBpbiB0aGUgY29uc3RydWN0b3Igd291bGQgYWxsb3cgZXh0ZXJuYWxcbiAgICogbW9kaWZpY2F0aW9uLlxuICAgKi9cblxuICBnZXQgbm9DYW5jZWxCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXQgaW5pdEZvY3VzKCkge1xuICAgIHJldHVybiAnY29uZmlybSc7XG4gIH1cblxuICAvKiBlc2xpbnQtZW5hYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuICBhZGRDb250ZW50KHBhcmVudCkge1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChwcml2YXRlTWVtYmVycy5nZXQodGhpcykuY29udGVudCk7XG4gIH1cblxuICBjb25maXJtKCkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmNhbGxiYWNrcy5jbG9zZTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5jb25maXJtKCk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAtLVxuICAgKiBOZWNlc3Nhcnkgc2luY2UgbW9kYWwgbXVzdCBoYXZlIHZhbGlkYXRlIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHNhdGlzZnlcbiAgICogTW9kYWwgaW50ZXJmYWNlLlxuICAgKi9cbiAgdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5mb01vZGFsO1xuIiwiLyoqXG4gKiBEZWZpbmVzIHRoZSBbUmVjdXJyZW5jZU1vZGFsXXtAbGluayBtb2R1bGU6cmVjdXJyZW5jZU1vZGFsflJlY3VycmVuY2VNb2RhbH1cbiAqIGNsYXNzLlxuICogQG1vZHVsZSByZWN1cnJlbmNlTW9kYWxcbiAqL1xuXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IG9yZGluYWwgZnJvbSAnb3JkaW5hbCc7XG5cbmltcG9ydCBEYXRlUGlja2VyTW9kYWwgZnJvbSAnLi9kYXRlUGlja2VyTW9kYWwnO1xuaW1wb3J0IFJlY3VycmluZ0RhdGUgZnJvbSAnLi4vcmVjdXJyaW5nRGF0ZSc7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MnO1xuaW1wb3J0IHtcbiAgZm9ybWF0RGF0ZSxcbiAgcGFyc2VEYXRlLFxuICBnZXRXZWVrZGF5TmFtZSxcbiAgZ2V0TW9udGhOYW1lLFxuICBnZXREYXlzSW5Nb250aCxcbn0gZnJvbSAnLi4vdXRpbGl0eS9kYXRlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVEYXRlSW5wdXRGaWVsZCxcbiAgY3JlYXRlRm9ybUNvbnRyb2wsXG4gIGNyZWF0ZVRvZ2dsZUJ1dHRvbixcbn0gZnJvbSAnLi4vdXRpbGl0eS9kb20nO1xuXG5jb25zdCBVTklUUyA9IFtcbiAgeyB2YWx1ZTogJ2RheScsIHNpbmd1bGFyOiAnRGF5JywgcGx1cmFsOiAnRGF5cycgfSxcbiAgeyB2YWx1ZTogJ3dlZWsnLCBzaW5ndWxhcjogJ1dlZWsnLCBwbHVyYWw6ICdXZWVrcycgfSxcbiAgeyB2YWx1ZTogJ21vbnRoJywgc2luZ3VsYXI6ICdNb250aCcsIHBsdXJhbDogJ01vbnRocycgfSxcbiAgeyB2YWx1ZTogJ3llYXInLCBzaW5ndWxhcjogJ1llYXInLCBwbHVyYWw6ICdZZWFycycgfSxcbl07XG5cbi8qKlxuICogT2JqZWN0IGhvbGRpbmcgcHJpdmF0ZSBtZW1iZXJzIGZvciB0aGVcbiAqIFtSZWN1cnJlbmNlTW9kYWxde0BsaW5rIG1vZHVsZTpyZWN1cnJlbmNlTW9kYWx+UmVjdXJyZW5jZU1vZGFsfSBjbGFzcy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpyZWN1cnJlbmNlTW9kYWx+UmVjdXJyZW5jZU1vZGFsfnByaXZhdGVzXG4gKiBAcHJvcGVydHkge21vZHVsZTpyZWN1cnJpbmdEYXRlflJlY3VycmluZ0RhdGV9IFtpbml0aWFsUmVjdXJyZW5jZV0gVGhlXG4gKiAgIHJlY3VycmluZyBkYXRlIHRvIHVzZSBhcyBhIGRlZmF1bHQgd2hlbiBpbml0aWFsaXppbmcgdGhlIGZvcm0gY29udHJvbHMsIGlmXG4gKiAgIGFueS5cbiAqIEBwcm9wZXJ0eSB7RGF0ZX0gYmFzZURhdGUgVGhlIGRhdGUgdG8gdXNlIHdoZW4gaW5pdGlhbGl6aW5nIGNlcnRhaW4gaW5wdXRcbiAqICAgZmllbGRzLlxuICogQHByb3BlcnR5IHttb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+ZGF0ZUZvcm1hdH0gZGF0ZUZvcm1hdCBBbiBvYmplY3QgaG9sZGluZ1xuICogICBkYXRlIGZvcm1hdCBpbmZvcm1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjYWxsYmFja3MgQW4gb2JqZWN0IGhvbGRpbmcgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5jb25maXJtXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIHdoZW4gdGhlIHVzZXIgc3VjY2Vzc2Z1bGx5IGNvbmZpcm1zIHRoZSBtb2RhbC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuY2FuY2VsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICBpbnZva2VkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge09iamVjdH0gY29udGFpbmVycyBBbiBvYmplY3QgaG9sZGluZyB0aGUgdmFyaW91cyBjb250YWluZXJcbiAqICAgZWxlbWVudHMgdXNlZCBpbiB0aGUgbW9kYWwncyBjb250ZW50cy5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMucGFyZW50IFRoZSBwYXJlbnQgY29udGFpbmVyIGVsZW1lbnRcbiAqICAgaG9sZGluZyBhbGwgdGhlIGZvcm0gZWxlbWVudHMuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250YWluZXJzLmNvbnRleHQgVGhlIGNvbnRhaW5lciBlbGVtZW50IGhvbGRpbmdcbiAqICAgY29udGV4dC1zZW5zaXRpdmUgb3B0aW9ucyB0aGF0IGRlcGVuZCBvbiB0aGUgc2VsZWN0ZWQgaW50ZXJ2YWwgdW5pdC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMud2Vla09wdGlvbnMgVGhlIGNvbnRhaW5lciBlbGVtZW50IGhvbGRpbmdcbiAqICAgdGhlIGZvcm0gZWxlbWVudHMgc3BlY2lmaWMgdG8gd2Vla2x5IHJlY3VycmVuY2VzLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udGFpbmVycy5tb250aE9wdGlvbnMgVGhlIGNvbnRhaW5lciBlbGVtZW50XG4gKiAgIGhvbGRpbmcgdGhlIGZvcm0gZWxlbWVudHMgc3BlY2lmaWMgdG8gbW9udGhseSByZWN1cnJlbmNlcy5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMueWVhck9wdGlvbnMgVGhlIGNvbnRhaW5lciBlbGVtZW50IGhvbGRpbmdcbiAqICAgdGhlIGZvcm0gZWxlbWVudHMgc3BlY2lmaWMgdG8geWVhcmx5IHJlY3VycmVuY2VzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlIFRoZSB0aXRsZSBvZiB0aGUgbW9kYWwuXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBwcml2YXRlIGRhdGEgZm9yIHRoZVxuICogW1JlY3VycmVuY2VNb2RhbF17QGxpbmsgbW9kdWxlOnJlY3VycmVuY2VNb2RhbH5SZWN1cnJlbmNlTW9kYWx9IGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTpyZWN1cnJlbmNlTW9kYWx+UmVjdXJyZW5jZU1vZGFsfnByaXZhdGVzXG4gKi9cbmNvbnN0IHByaXZhdGVNZW1iZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGZvcm0gZWxlbWVudHMgZm9yIHRoZSBjb250ZXh0IG9wdGlvbnMgZm9yIHdlZWtseSByZWN1cnJlbmNlcy5cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGNvbnRhaW5lciBlbGVtZW50IGhvbGRpbmcgdGhlIGZvcm0gZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlZWtDb250ZXh0Rm9ybSgpIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWNvbnRhaW5lcicpO1xuXG4gIGxldCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsLWlubGluZScpO1xuICBsYWJlbC50ZXh0Q29udGVudCA9ICdSZXBlYXQgb24nO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgdHlwZTogJ3JhZGlvJyxcbiAgICBpZDogJ3JlY3VycmluZy1kYXRlLXdlZWstdHlwZS1wcmV2aW91cycsXG4gICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLXdlZWstdHlwZScsXG4gICAgdmFsdWU6ICd1c2UtcHJldmlvdXMnLFxuICAgIGNoZWNrZWQ6IHRydWUsXG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbHVlOiAnVGhlIHNhbWUgZGF5IG9mIHRoZSB3ZWVrIGFzIGJlZm9yZScsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnXSxcbiAgICB9LFxuICAgIGNvbnRhaW5lcjogeyBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1pdGVtLWNvbnRhaW5lciddIH0sXG4gIH0pKTtcblxuICBjb25zdCBvcHRpb25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgb3B0aW9uQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtaXRlbS1jb250YWluZXInKTtcblxuICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgIHR5cGU6ICdyYWRpbycsXG4gICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS13ZWVrLXR5cGUtc2VsZWN0LWRheXMnLFxuICAgIG5hbWU6ICdyZWN1cnJpbmctZGF0ZS13ZWVrLXR5cGUnLFxuICAgIHZhbHVlOiAnc2VsZWN0LWRheXMnLFxuICB9KSk7XG5cbiAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsLWlubGluZScpO1xuICBsYWJlbC50ZXh0Q29udGVudCA9ICdUaGVzZSBkYXlzOiAnO1xuICBsYWJlbC5odG1sRm9yID0gJ3JlY3VycmluZy1kYXRlLXdlZWstdHlwZS1zZWxlY3QtZGF5cyc7XG4gIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgXy5yYW5nZSg3KS5tYXAoKGluZGV4KSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGdldFdlZWtkYXlOYW1lKGluZGV4KTtcbiAgICByZXR1cm4geyB2YWx1ZTogbmFtZS50b0xvd2VyQ2FzZSgpLCBsYWJlbDogbmFtZS5zbGljZSgwLCAxKSB9O1xuICB9KS5mb3JFYWNoKChkYXkpID0+IHtcbiAgICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlVG9nZ2xlQnV0dG9uKGRheS5sYWJlbCwge1xuICAgICAgaWQ6IGByZWN1cnJpbmctZGF0ZS13ZWVrZGF5LSR7ZGF5LnZhbHVlfWAsXG4gICAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUtd2Vla2RheScsXG4gICAgICB2YWx1ZTogZGF5LnZhbHVlLFxuICAgICAgY2xhc3NMaXN0OiBbJ3RvZ2dsZS1idXR0b24nLCAnZm9ybS13ZWVrZGF5LWJ1dHRvbiddLFxuICAgIH0pKTtcbiAgfSk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChvcHRpb25Db250YWluZXIpO1xuXG4gIHJldHVybiBjb250YWluZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBmb3JtIGVsZW1lbnRzIGZvciB0aGUgY29udGV4dCBvcHRpb25zIGZvciBtb250aGx5IHJlY3VycmVuY2VzLlxuICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgY29udGFpbmVyIGVsZW1lbnQgaG9sZGluZyB0aGUgZm9ybSBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9udGhDb250ZXh0Rm9ybSgpIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWNvbnRhaW5lcicpO1xuXG4gIGxldCBsYWJlbDtcbiAgbGV0IG9wdGlvbkNvbnRhaW5lcjtcbiAgbGV0IHNlbGVjdEl0ZW1zO1xuXG4gIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwtaW5saW5lJyk7XG4gIGxhYmVsLnRleHRDb250ZW50ID0gJ1JlcGVhdCBvbic7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICB0eXBlOiAncmFkaW8nLFxuICAgIGlkOiAncmVjdXJyaW5nLWRhdGUtbW9udGgtdHlwZS1wcmV2aW91cycsXG4gICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLW1vbnRoLXR5cGUnLFxuICAgIHZhbHVlOiAndXNlLXByZXZpb3VzJyxcbiAgICBjaGVja2VkOiB0cnVlLFxuICAgIGxhYmVsOiB7XG4gICAgICB2YWx1ZTogJ1RoZSBzYW1lIGRheSBvZiB0aGUgbW9udGggYXMgYmVmb3JlJyxcbiAgICAgIGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWxhYmVsLWlubGluZSddLFxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7IGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWl0ZW0tY29udGFpbmVyJ10gfSxcbiAgfSkpO1xuXG4gIG9wdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBvcHRpb25Db250YWluZXIuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1pdGVtLWNvbnRhaW5lcicpO1xuICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgIHR5cGU6ICdyYWRpbycsXG4gICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS1tb250aC10eXBlLWRheScsXG4gICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLW1vbnRoLXR5cGUnLFxuICAgIHZhbHVlOiAnZGF5LW9mLW1vbnRoJyxcbiAgfSkpO1xuXG4gIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgbGFiZWwuaHRtbEZvciA9ICdyZWN1cnJpbmctZGF0ZS1tb250aC10eXBlLWRheSc7XG4gIGxhYmVsLnRleHRDb250ZW50ID0gJ1RoZSAnO1xuICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gIHNlbGVjdEl0ZW1zID0gXy5yYW5nZSgxLCAzMikubWFwKChkYXkpID0+IChcbiAgICB7IHZhbHVlOiBkYXkudG9TdHJpbmcoKSwgbGFiZWw6IG9yZGluYWwoZGF5KSB9XG4gICkpO1xuICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgIGlkOiAncmVjdXJyaW5nLWRhdGUtbW9udGgtZGF5JyxcbiAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUtbW9udGgtZGF5JyxcbiAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QtaW5saW5lJ10sXG4gICAgbWVudUl0ZW1zOiBzZWxlY3RJdGVtcyxcbiAgfSkpO1xuXG4gIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgbGFiZWwuaHRtbEZvciA9ICdyZWN1cnJpbmctZGF0ZS1tb250aC1kYXknO1xuICBsYWJlbC50ZXh0Q29udGVudCA9ICcgZGF5IG9mIHRoZSBtb250aCc7XG4gIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKG9wdGlvbkNvbnRhaW5lcik7XG5cbiAgb3B0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG9wdGlvbkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWl0ZW0tY29udGFpbmVyJyk7XG4gIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgdHlwZTogJ3JhZGlvJyxcbiAgICBpZDogJ3JlY3VycmluZy1kYXRlLW1vbnRoLXR5cGUtd2VlaycsXG4gICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLW1vbnRoLXR5cGUnLFxuICAgIHZhbHVlOiAnd2Vlay1vZi1tb250aCcsXG4gIH0pKTtcblxuICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwtaW5saW5lJyk7XG4gIGxhYmVsLmh0bWxGb3IgPSAncmVjdXJyaW5nLWRhdGUtbW9udGgtdHlwZS13ZWVrJztcbiAgbGFiZWwudGV4dENvbnRlbnQgPSAnVGhlICc7XG4gIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgc2VsZWN0SXRlbXMgPSBfLnJhbmdlKDEsIDYpLm1hcCgod2VlaykgPT4gKFxuICAgIHsgdmFsdWU6IHdlZWsudG9TdHJpbmcoKSwgbGFiZWw6ICh3ZWVrIDwgNSkgPyBvcmRpbmFsKHdlZWspIDogJ2xhc3QnIH1cbiAgKSk7XG4gIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS1tb250aC13ZWVrLW51bWJlcicsXG4gICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLW1vbnRoLXdlZWstbnVtYmVyJyxcbiAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QtaW5saW5lJ10sXG4gICAgbWVudUl0ZW1zOiBzZWxlY3RJdGVtcyxcbiAgfSkpO1xuXG4gIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsLWlubGluZScpO1xuICBsYWJlbC50ZXh0Q29udGVudCA9ICcgJztcbiAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICBzZWxlY3RJdGVtcyA9IF8ucmFuZ2UoNykubWFwKChpbmRleCkgPT4ge1xuICAgIGNvbnN0IGRheSA9IGdldFdlZWtkYXlOYW1lKGluZGV4KTtcbiAgICByZXR1cm4geyB2YWx1ZTogZGF5LnRvTG93ZXJDYXNlKCksIGxhYmVsOiBkYXkgfTtcbiAgfSk7XG4gIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS1tb250aC13ZWVrLWRheScsXG4gICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLW1vbnRoLXdlZWstZGF5JyxcbiAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QtaW5saW5lJ10sXG4gICAgbWVudUl0ZW1zOiBzZWxlY3RJdGVtcyxcbiAgfSkpO1xuXG4gIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgbGFiZWwuaHRtbEZvciA9ICdyZWN1cnJpbmctZGF0ZS1tb250aC13ZWVrLWRheSc7XG4gIGxhYmVsLnRleHRDb250ZW50ID0gJyBvZiB0aGUgbW9udGgnO1xuICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChvcHRpb25Db250YWluZXIpO1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgZm9ybSBlbGVtZW50cyBmb3IgdGhlIGNvbnRleHQgb3B0aW9ucyBmb3IgeWVhcmx5IHJlY3VycmVuY2VzLlxuICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgY29udGFpbmVyIGVsZW1lbnQgaG9sZGluZyB0aGUgZm9ybSBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlWWVhckNvbnRleHRGb3JtKCkge1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtY29udGFpbmVyJyk7XG5cbiAgbGV0IGxhYmVsO1xuICBsZXQgc2VsZWN0SXRlbXM7XG5cbiAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgbGFiZWwudGV4dENvbnRlbnQgPSAnUmVwZWF0IG9uJztcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgIHR5cGU6ICdyYWRpbycsXG4gICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS15ZWFyLXR5cGUtcHJldmlvdXMnLFxuICAgIG5hbWU6ICdyZWN1cnJpbmctZGF0ZS15ZWFyLXR5cGUnLFxuICAgIHZhbHVlOiAndXNlLXByZXZpb3VzJyxcbiAgICBjaGVja2VkOiB0cnVlLFxuICAgIGxhYmVsOiB7XG4gICAgICB2YWx1ZTogJ1RoZSBzYW1lIG1vbnRoIGFuZCBkYXkgYXMgYmVmb3JlJyxcbiAgICAgIGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWxhYmVsLWlubGluZSddLFxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7IGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWl0ZW0tY29udGFpbmVyJ10gfSxcbiAgfSkpO1xuXG4gIGNvbnN0IG9wdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBvcHRpb25Db250YWluZXIuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1pdGVtLWNvbnRhaW5lcicpO1xuICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgIHR5cGU6ICdyYWRpbycsXG4gICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS15ZWFyLXR5cGUtZGF5JyxcbiAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUteWVhci10eXBlJyxcbiAgICB2YWx1ZTogJ21vbnRoLWFuZC1kYXknLFxuICB9KSk7XG5cbiAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsLWlubGluZScpO1xuICBsYWJlbC5odG1sRm9yID0gJ3JlY3VycmluZy1kYXRlLXllYXItdHlwZS1kYXknO1xuICBsYWJlbC50ZXh0Q29udGVudCA9ICdUaGUgJztcbiAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICBzZWxlY3RJdGVtcyA9IF8ucmFuZ2UoMSwgMzIpLm1hcCgoZGF5KSA9PiAoXG4gICAgeyB2YWx1ZTogZGF5LnRvU3RyaW5nKCksIGxhYmVsOiBvcmRpbmFsKGRheSkgfVxuICApKTtcbiAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICBpZDogJ3JlY3VycmluZy1kYXRlLXllYXItZGF5JyxcbiAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUteWVhci1kYXknLFxuICAgIGNsYXNzTGlzdDogWydmb3JtLXNlbGVjdC1pbmxpbmUnXSxcbiAgICBtZW51SXRlbXM6IHNlbGVjdEl0ZW1zLFxuICB9KSk7XG5cbiAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwtaW5saW5lJyk7XG4gIGxhYmVsLnRleHRDb250ZW50ID0gJyBkYXkgb2YgJztcbiAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICBzZWxlY3RJdGVtcyA9IF8ucmFuZ2UoMTIpLm1hcCgoaW5kZXgpID0+IHtcbiAgICBjb25zdCBuYW1lID0gZ2V0TW9udGhOYW1lKGluZGV4KTtcbiAgICByZXR1cm4geyB2YWx1ZTogbmFtZS50b0xvd2VyQ2FzZSgpLCBsYWJlbDogbmFtZSB9O1xuICB9KTtcbiAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICBpZDogJ3JlY3VycmluZy1kYXRlLXllYXItbW9udGgnLFxuICAgIG5hbWU6ICdyZWN1cnJpbmctZGF0ZS15ZWFyLW1vbnRoJyxcbiAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QtaW5saW5lJ10sXG4gICAgbWVudUl0ZW1zOiBzZWxlY3RJdGVtcyxcbiAgfSkpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQob3B0aW9uQ29udGFpbmVyKTtcblxuICByZXR1cm4gY29udGFpbmVyO1xufVxuXG4vKipcbiAqIFNlbGVjdCBhIGZvcm0gY29udHJvbCBpbiB0aGUgbW9kYWwuXG4gKiBAcGFyYW0ge21vZHVsZTpyZWN1cnJlbmNlTW9kYWx+UmVjdXJyZW5jZU1vZGFsfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2VcbiAqICAgb24gd2hpY2ggdG8gYXBwbHkgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkU3VmZml4IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBjb250cm9sIHRvIHJldHJpZXZlLFxuICogICB3aXRob3V0IHRoZSAncmVjdXJyaW5nLWRhdGUtJyBwcmVmaXguXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbnRhaW5lcl0gVGhlIGNvbnRhaW5lciBpbiB3aGljaCB0byBsb29rIGZvciB0aGVcbiAqICAgY29udHJvbC4gSWYgbm90IGdpdmVuLCB0aGVuIHRoZSBtb2RhbCBjb250ZW50IGNvbnRhaW5lciBpcyB1c2VkLlxuICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgcmVxdWVzdGVkIGVsZW1lbnQsIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyb2woaW5zdGFuY2UsIGlkU3VmZml4LCBjb250YWluZXIpIHtcbiAgY29uc3QgcGFyZW50ID0gY29udGFpbmVyIHx8IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSkuY29udGFpbmVycy5wYXJlbnQ7XG4gIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3RvcihgI3JlY3VycmluZy1kYXRlLSR7aWRTdWZmaXh9YCk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgdmFsdWVzIG9mIHRoZSBmb3JtIGVsZW1lbnRzIGJhc2VkIG9uIHRoZSBpbml0aWFsIHJlY3VycmVuY2VcbiAqIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IsIGlmIGFueS5cbiAqIEBwYXJhbSB7bW9kdWxlOnJlY3VycmVuY2VNb2RhbH5SZWN1cnJlbmNlTW9kYWx9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZVxuICogICBvbiB3aGljaCB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGluaXRGb3JtVmFsdWVzKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgeyB3ZWVrT3B0aW9ucywgbW9udGhPcHRpb25zLCB5ZWFyT3B0aW9ucyB9ID0gcHJpdmF0ZXMuY29udGFpbmVycztcbiAgY29uc3QgaW5pdGlhbCA9IHByaXZhdGVzLmluaXRpYWxSZWN1cnJlbmNlO1xuICBpZiAoaW5pdGlhbCkge1xuICAgIGdldENvbnRyb2woaW5zdGFuY2UsICdpbnRlcnZhbC1sZW5ndGgnKS52YWx1ZSA9IGluaXRpYWwuaW50ZXJ2YWxMZW5ndGg7XG4gICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ2ludGVydmFsLXVuaXQnKS52YWx1ZSA9IGluaXRpYWwuaW50ZXJ2YWxVbml0O1xuXG4gICAgbGV0IGNvbnRleHQ7XG4gICAgc3dpdGNoIChpbml0aWFsLmludGVydmFsVW5pdCkge1xuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNvbnRleHQgPSB3ZWVrT3B0aW9ucztcbiAgICAgICAgaWYgKGluaXRpYWwuZGF5c09mV2Vlaykge1xuICAgICAgICAgIGdldENvbnRyb2woaW5zdGFuY2UsICd3ZWVrLXR5cGUtc2VsZWN0LWRheXMnLCBjb250ZXh0KS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICBpbml0aWFsLmRheXNPZldlZWsuZm9yRWFjaCgoZGF5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGB3ZWVrZGF5LSR7Z2V0V2Vla2RheU5hbWUoZGF5KS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgICAgICAgICBjb25zdCBidXR0b24gPSBnZXRDb250cm9sKGluc3RhbmNlLCBpZCwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoYnV0dG9uKSBidXR0b24uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ3dlZWstdHlwZS1wcmV2aW91cycsIGNvbnRleHQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICBjb250ZXh0ID0gbW9udGhPcHRpb25zO1xuICAgICAgICBpZiAoaW5pdGlhbC5kYXlPZk1vbnRoKSB7XG4gICAgICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ21vbnRoLXR5cGUtZGF5JywgY29udGV4dCkuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ21vbnRoLWRheScsIGNvbnRleHQpLnZhbHVlID0gaW5pdGlhbC5kYXlPZk1vbnRoO1xuICAgICAgICB9IGVsc2UgaWYgKGluaXRpYWwud2Vla051bWJlciAmJiBpbml0aWFsLmRheXNPZldlZWtcbiAgICAgICAgICAmJiBpbml0aWFsLmRheXNPZldlZWsubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ21vbnRoLXR5cGUtd2VlaycsIGNvbnRleHQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHdlZWtTZWxlY3QgPSBnZXRDb250cm9sKGluc3RhbmNlLCAnbW9udGgtd2Vlay1udW1iZXInLCBjb250ZXh0KTtcbiAgICAgICAgICBjb25zdCBkYXlTZWxlY3QgPSBnZXRDb250cm9sKGluc3RhbmNlLCAnbW9udGgtd2Vlay1kYXknLCBjb250ZXh0KTtcbiAgICAgICAgICB3ZWVrU2VsZWN0LnZhbHVlID0gaW5pdGlhbC53ZWVrTnVtYmVyO1xuICAgICAgICAgIGRheVNlbGVjdC52YWx1ZSA9IGdldFdlZWtkYXlOYW1lKFxuICAgICAgICAgICAgaW5pdGlhbC5kYXlzT2ZXZWVrWzBdLFxuICAgICAgICAgICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZXRDb250cm9sKGluc3RhbmNlLCAnbW9udGgtdHlwZS1wcmV2aW91cycsIGNvbnRleHQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIGNvbnRleHQgPSB5ZWFyT3B0aW9ucztcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5pdGlhbC5tb250aCkgJiYgaW5pdGlhbC5kYXlPZk1vbnRoKSB7XG4gICAgICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ3llYXItdHlwZS1kYXknLCBjb250ZXh0KS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBtb250aFNlbGVjdCA9IGdldENvbnRyb2woaW5zdGFuY2UsICd5ZWFyLW1vbnRoJywgY29udGV4dCk7XG4gICAgICAgICAgY29uc3QgZGF5U2VsZWN0ID0gZ2V0Q29udHJvbChpbnN0YW5jZSwgJ3llYXItZGF5JywgY29udGV4dCk7XG4gICAgICAgICAgbW9udGhTZWxlY3QudmFsdWUgPSBnZXRNb250aE5hbWUoaW5pdGlhbC5tb250aCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBkYXlTZWxlY3QudmFsdWUgPSBpbml0aWFsLmRheU9mTW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ3llYXItdHlwZS1wcmV2aW91cycsIGNvbnRleHQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWwuZW5kRGF0ZSkge1xuICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ2VuZC10eXBlLWRhdGUnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZ2V0Q29udHJvbChpbnN0YW5jZSwgJ2VuZC1kYXRlJyk7XG4gICAgICBpbnB1dC52YWx1ZSA9IGZvcm1hdERhdGUoXG4gICAgICAgIGluaXRpYWwuZW5kRGF0ZSxcbiAgICAgICAgcHJpdmF0ZXMuZGF0ZUZvcm1hdC5vdXRwdXRQYXR0ZXJuLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGluaXRpYWwubWF4Q291bnQpIHtcbiAgICAgIGdldENvbnRyb2woaW5zdGFuY2UsICdlbmQtdHlwZS1jb3VudCcpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ2VuZC1jb3VudCcpLnZhbHVlID0gaW5pdGlhbC5tYXhDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ2VuZC10eXBlLW5ldmVyJykuY2hlY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWwuc3RhcnREYXRlKSB7XG4gICAgICBnZXRDb250cm9sKGluc3RhbmNlLCAndXNlLXN0YXJ0LWRhdGUnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZ2V0Q29udHJvbChpbnN0YW5jZSwgJ3N0YXJ0LWRhdGUnKTtcbiAgICAgIGlucHV0LnZhbHVlID0gZm9ybWF0RGF0ZShcbiAgICAgICAgaW5pdGlhbC5zdGFydERhdGUsXG4gICAgICAgIHByaXZhdGVzLmRhdGVGb3JtYXQub3V0cHV0UGF0dGVybixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWwuYmFzZU9uQ29tcGxldGlvbikge1xuICAgICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ2Jhc2Utb24tY29tcGxldGlvbicpLmNoZWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsLm9uV2Vla2VuZCAhPT0gJ25vLWNoYW5nZScpIHtcbiAgICAgIGdldENvbnRyb2woaW5zdGFuY2UsICduby13ZWVrZW5kJykuY2hlY2tlZCA9IHRydWU7XG4gICAgICBnZXRDb250cm9sKGluc3RhbmNlLCAnd2Vla2VuZC1zZWxlY3QnKS52YWx1ZSA9IGluaXRpYWwub25XZWVrZW5kO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRhdGUgPSBwcml2YXRlcy5iYXNlRGF0ZTtcbiAgY29uc3QgZGF5T2ZXZWVrID0gZ2V0V2Vla2RheU5hbWUoZGF0ZS5nZXREYXkoKSkudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgZGF5T2ZNb250aCA9IGRhdGUuZ2V0RGF0ZSgpO1xuICBjb25zdCBtb250aCA9IGdldE1vbnRoTmFtZShkYXRlLmdldE1vbnRoKCkpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHdlZWtOdW1iZXIgPSBNYXRoLmZsb29yKChkYXlPZk1vbnRoIC0gMSkgLyA3KSArIDE7XG5cbiAgaWYgKCFpbml0aWFsIHx8IGluaXRpYWwuaW50ZXJ2YWxVbml0ICE9PSAnd2VlaycgfHwgIWluaXRpYWwuZGF5c09mV2Vlaykge1xuICAgIGNvbnN0IGRheUJ1dHRvbiA9IGdldENvbnRyb2woaW5zdGFuY2UsIGB3ZWVrZGF5LSR7ZGF5T2ZXZWVrfWAsIHdlZWtPcHRpb25zKTtcbiAgICBkYXlCdXR0b24uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gIH1cblxuICBpZiAoIWluaXRpYWwgfHwgaW5pdGlhbC5pbnRlcnZhbFVuaXQgIT09ICdtb250aCcgfHwgIWluaXRpYWwuZGF5T2ZNb250aCkge1xuICAgIGNvbnN0IG1vbnRoRGF5U2VsZWN0ID0gZ2V0Q29udHJvbChpbnN0YW5jZSwgJ21vbnRoLWRheScsIG1vbnRoT3B0aW9ucyk7XG4gICAgbW9udGhEYXlTZWxlY3QudmFsdWUgPSBkYXlPZk1vbnRoLnRvU3RyaW5nKCk7XG4gIH1cblxuICBpZiAoIWluaXRpYWwgfHwgaW5pdGlhbC5pbnRlcnZhbFVuaXQgIT09ICdtb250aCcgfHwgIWluaXRpYWwud2Vla051bWJlcikge1xuICAgIGNvbnN0IG1vbnRoV2Vla051bVNlbGVjdCA9IGdldENvbnRyb2woXG4gICAgICBpbnN0YW5jZSxcbiAgICAgICdtb250aC13ZWVrLW51bWJlcicsXG4gICAgICBtb250aE9wdGlvbnMsXG4gICAgKTtcbiAgICBjb25zdCBtb250aFdlZWtEYXlTZWxlY3QgPSBnZXRDb250cm9sKFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAnbW9udGgtd2Vlay1kYXknLFxuICAgICAgbW9udGhPcHRpb25zLFxuICAgICk7XG4gICAgbW9udGhXZWVrTnVtU2VsZWN0LnZhbHVlID0gd2Vla051bWJlci50b1N0cmluZygpO1xuICAgIG1vbnRoV2Vla0RheVNlbGVjdC52YWx1ZSA9IGRheU9mV2VlaztcbiAgfVxuXG4gIGlmICghaW5pdGlhbCB8fCBpbml0aWFsLmludGVydmFsVW5pdCAhPT0gJ3llYXInXG4gICAgfHwgIU51bWJlci5pc0ludGVnZXIoaW5pdGlhbC5tb250aCkpIHtcbiAgICBjb25zdCB5ZWFyTW9udGhTZWxlY3QgPSBnZXRDb250cm9sKGluc3RhbmNlLCAneWVhci1tb250aCcsIHllYXJPcHRpb25zKTtcbiAgICBjb25zdCB5ZWFyRGF5U2VsZWN0ID0gZ2V0Q29udHJvbChpbnN0YW5jZSwgJ3llYXItZGF5JywgeWVhck9wdGlvbnMpO1xuICAgIHllYXJNb250aFNlbGVjdC52YWx1ZSA9IG1vbnRoO1xuICAgIHllYXJEYXlTZWxlY3QudmFsdWUgPSBkYXlPZk1vbnRoLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBPcGVucyBhIGRhdGUgcGlja2VyIGFuZCB1cGRhdGVzIHRoZSBnaXZlbiBpbnB1dCBmaWVsZCB3aXRoIHRoZSBzZWxlY3RlZFxuICogZGF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnJlY3VycmVuY2VNb2RhbH5SZWN1cnJlbmNlTW9kYWx9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZVxuICogICBvbiB3aGljaCB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpbnB1dCBUaGUgdGV4dCBpbnB1dCBmaWVsZCB3aGVyZSB0aGUgZGF0ZSBpcyBiZWluZ1xuICogICBlbnRlcmVkLlxuICogQHBhcmFtIHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbFN0YWNrfSBtb2RhbFN0YWNrIFRoZSBtb2RhbCBzdGFjayBpbiB3aGljaFxuICogICB0aGUgbW9kYWwgaGFzIGJlZW4gaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIHBpY2tEYXRlKGluc3RhbmNlLCBpbnB1dCwgbW9kYWxTdGFjaykge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG5cbiAgbGV0IHN0YXJ0RGF0ZSA9IG51bGw7XG4gIGlmIChpbnB1dC52YWx1ZSkge1xuICAgIHN0YXJ0RGF0ZSA9IHBhcnNlRGF0ZShpbnB1dC52YWx1ZSwgcHJpdmF0ZXMuZGF0ZUZvcm1hdC5pbnB1dFBhdHRlcm5zKTtcbiAgfVxuXG4gIGxldCB0aXRsZSA9IG51bGw7XG4gIHN3aXRjaCAoaW5wdXQuaWQpIHtcbiAgICBjYXNlICdyZWN1cnJpbmctZGF0ZS1zdGFydC1kYXRlJzpcbiAgICAgIHRpdGxlID0gJ1NlbGVjdCBTdGFydCBEYXRlJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3VycmluZy1kYXRlLWVuZC1kYXRlJzpcbiAgICAgIHRpdGxlID0gJ1NlbGVjdCBFbmQgRGF0ZSc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBjb25zdCBmaWVsZCA9IGlucHV0O1xuICBtb2RhbFN0YWNrLnNob3dNb2RhbChuZXcgRGF0ZVBpY2tlck1vZGFsKHtcbiAgICBjb25maXJtOiAoZGF0ZSkgPT4ge1xuICAgICAgZmllbGQudmFsdWUgPSBmb3JtYXREYXRlKGRhdGUsIHByaXZhdGVzLmRhdGVGb3JtYXQub3V0cHV0UGF0dGVybik7XG4gICAgICBmaWVsZC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XG4gICAgfSxcbiAgICBzdGFydERhdGUsXG4gICAgdGl0bGUsXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSBjb250YWluZXIgaG9sZGluZyBjb250ZXh0LXNlbnNpdGl2ZSBvcHRpb25zLFxuICogYmFzZWQgb24gdGhlIHNlbGVjdGVkIGludGVydmFsIHVuaXQuXG4gKiBAcGFyYW0ge21vZHVsZTpyZWN1cnJlbmNlTW9kYWx+UmVjdXJyZW5jZU1vZGFsfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2VcbiAqICAgb24gd2hpY2ggdG8gYXBwbHkgdGhlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29udGFpbmVyKGluc3RhbmNlKSB7XG4gIGNvbnN0IHsgY29udGFpbmVycyB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgY29udGV4dENvbnRhaW5lciA9IGNvbnRhaW5lcnMuY29udGV4dDtcblxuICB3aGlsZSAoY29udGV4dENvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgY29udGV4dENvbnRhaW5lci5yZW1vdmVDaGlsZChjb250ZXh0Q29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgc3dpdGNoIChnZXRDb250cm9sKGluc3RhbmNlLCAnaW50ZXJ2YWwtdW5pdCcpLnZhbHVlKSB7XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICBjb250ZXh0Q29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcnMud2Vla09wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgY29udGV4dENvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXJzLm1vbnRoT3B0aW9ucyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIGNvbnRleHRDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVycy55ZWFyT3B0aW9ucyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgdGhlIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZm9ybSBjb250cm9scyBpbiB0aGUgbW9kYWwuXG4gKiBAcGFyYW0ge21vZHVsZTpyZWN1cnJlbmNlTW9kYWx+UmVjdXJyZW5jZU1vZGFsfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2VcbiAqICAgb24gd2hpY2ggdG8gYXBwbHkgdGhlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCB7IHBhcmVudCB9ID0gcHJpdmF0ZXMuY29udGFpbmVycztcbiAgY29uc3QgZmlyZUV2ZW50ID0gKGlucHV0KSA9PiBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuXG4gIC8vIE1ha2UgdW5pdHMgc2luZ3VsYXIgb3IgcGx1cmFsIGJhc2VkIG9uIGxlbmd0aFxuICBjb25zdCBsZW5ndGhTZWxlY3QgPSBnZXRDb250cm9sKGluc3RhbmNlLCAnaW50ZXJ2YWwtbGVuZ3RoJyk7XG4gIGNvbnN0IHVuaXRTZWxlY3QgPSBnZXRDb250cm9sKGluc3RhbmNlLCAnaW50ZXJ2YWwtdW5pdCcpO1xuICBsZW5ndGhTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBOdW1iZXIoZS50YXJnZXQudmFsdWUpO1xuICAgIGlmIChlLnRhcmdldC52YWx1ZS5sZW5ndGggPiAwICYmIE51bWJlci5pc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBjb25zdCBwbHVyYWwgPSBsZW5ndGggIT09IDE7XG4gICAgICBVTklUUy5mb3JFYWNoKCh1bml0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYG9wdGlvblt2YWx1ZT1cIiR7dW5pdC52YWx1ZX1cIl1gO1xuICAgICAgICBjb25zdCBvcHRpb24gPSB1bml0U2VsZWN0LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHBsdXJhbCA/IHVuaXQucGx1cmFsIDogdW5pdC5zaW5ndWxhcjtcbiAgICAgICAgaWYgKG9wdGlvbi50ZXh0Q29udGVudCAhPT0gbGFiZWwpIG9wdGlvbi50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZmlyZUV2ZW50KGxlbmd0aFNlbGVjdCk7XG5cbiAgdW5pdFNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgdXBkYXRlQ29udGV4dENvbnRhaW5lcihpbnN0YW5jZSk7XG4gIH0pO1xuICBmaXJlRXZlbnQodW5pdFNlbGVjdCk7XG5cbiAgY29uc3QgcmFkaW9TZWxlY3RvciA9ICdpbnB1dFt0eXBlPVwicmFkaW9cIl0nO1xuICBjb25zdCB7IHdlZWtPcHRpb25zLCBtb250aE9wdGlvbnMsIHllYXJPcHRpb25zIH0gPSBwcml2YXRlcy5jb250YWluZXJzO1xuXG4gIC8vIENvbmRpdGlvbmFsbHkgZW5hYmxlL2Rpc2FibGUgY29udHJvbHMgZm9yIHdlZWtseSByZWN1cnJlbmNlc1xuICBjb25zdCB3ZWVrVHlwZUxpc3RlbmVyID0gKGUpID0+IHtcbiAgICBjb25zdCBidXR0b25zID0gd2Vla09wdGlvbnMucXVlcnlTZWxlY3RvckFsbCgnLmZvcm0td2Vla2RheS1idXR0b24nKTtcbiAgICBjb25zdCBlbmFibGUgPSBlLnRhcmdldC52YWx1ZSA9PT0gJ3NlbGVjdC1kYXlzJztcbiAgICBidXR0b25zLmZvckVhY2goKGJ1dHRvbikgPT4ge1xuICAgICAgY29uc3QgZWxlbSA9IGJ1dHRvbjtcbiAgICAgIGVsZW0uZGlzYWJsZWQgPSAhZW5hYmxlO1xuICAgIH0pO1xuICB9O1xuICB3ZWVrT3B0aW9ucy5xdWVyeVNlbGVjdG9yQWxsKHJhZGlvU2VsZWN0b3IpLmZvckVhY2goKHJhZGlvKSA9PiB7XG4gICAgcmFkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgd2Vla1R5cGVMaXN0ZW5lcik7XG4gICAgaWYgKHJhZGlvLmNoZWNrZWQpIGZpcmVFdmVudChyYWRpbyk7XG4gIH0pO1xuXG4gIC8vIENvbmRpdGlvbmFsbHkgZW5hYmxlL2Rpc2FibGUgY29udHJvbHMgZm9yIG1vbnRobHkgcmVjdXJyZW5jZXNcbiAgY29uc3QgbW9udGhUeXBlTGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgIGNvbnN0IGRheVNlbGVjdCA9IGdldENvbnRyb2woaW5zdGFuY2UsICdtb250aC1kYXknLCBtb250aE9wdGlvbnMpO1xuICAgIGNvbnN0IHdlZWtOdW1iZXJTZWxlY3QgPSBnZXRDb250cm9sKFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAnbW9udGgtd2Vlay1udW1iZXInLFxuICAgICAgbW9udGhPcHRpb25zLFxuICAgICk7XG4gICAgY29uc3Qgd2Vla0RheVNlbGVjdCA9IGdldENvbnRyb2woaW5zdGFuY2UsICdtb250aC13ZWVrLWRheScsIG1vbnRoT3B0aW9ucyk7XG5cbiAgICBkYXlTZWxlY3QuZGlzYWJsZWQgPSBlLnRhcmdldC52YWx1ZSAhPT0gJ2RheS1vZi1tb250aCc7XG4gICAgd2Vla051bWJlclNlbGVjdC5kaXNhYmxlZCA9IGUudGFyZ2V0LnZhbHVlICE9PSAnd2Vlay1vZi1tb250aCc7XG4gICAgd2Vla0RheVNlbGVjdC5kaXNhYmxlZCA9IGUudGFyZ2V0LnZhbHVlICE9PSAnd2Vlay1vZi1tb250aCc7XG4gIH07XG4gIG1vbnRoT3B0aW9ucy5xdWVyeVNlbGVjdG9yQWxsKHJhZGlvU2VsZWN0b3IpLmZvckVhY2goKHJhZGlvKSA9PiB7XG4gICAgcmFkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgbW9udGhUeXBlTGlzdGVuZXIpO1xuICAgIGlmIChyYWRpby5jaGVja2VkKSBmaXJlRXZlbnQocmFkaW8pO1xuICB9KTtcblxuICAvLyBDb25kaXRpb25hbGx5IGVuYWJsZS9kaXNhYmxlIGNvbnRyb2xzIGZvciB5ZWFybHkgcmVjdXJyZW5jZXNcbiAgY29uc3QgeWVhclR5cGVMaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0Qm94ZXMgPSB5ZWFyT3B0aW9ucy5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKTtcbiAgICBjb25zdCBlbmFibGUgPSBlLnRhcmdldC52YWx1ZSA9PT0gJ21vbnRoLWFuZC1kYXknO1xuICAgIHNlbGVjdEJveGVzLmZvckVhY2goKHNlbGVjdCkgPT4ge1xuICAgICAgY29uc3QgZWxlbSA9IHNlbGVjdDtcbiAgICAgIGVsZW0uZGlzYWJsZWQgPSAhZW5hYmxlO1xuICAgIH0pO1xuICB9O1xuICB5ZWFyT3B0aW9ucy5xdWVyeVNlbGVjdG9yQWxsKHJhZGlvU2VsZWN0b3IpLmZvckVhY2goKHJhZGlvKSA9PiB7XG4gICAgcmFkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgeWVhclR5cGVMaXN0ZW5lcik7XG4gICAgaWYgKHJhZGlvLmNoZWNrZWQpIGZpcmVFdmVudChyYWRpbyk7XG4gIH0pO1xuXG4gIC8vIFVwZGF0ZSBkYXkgc2VsZWN0IGJveCBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIHNlbGVjdGVkIG1vbnRoXG4gIGNvbnN0IHllYXJNb250aFNlbGVjdCA9IGdldENvbnRyb2woaW5zdGFuY2UsICd5ZWFyLW1vbnRoJywgeWVhck9wdGlvbnMpO1xuICBjb25zdCB5ZWFyRGF5U2VsZWN0ID0gZ2V0Q29udHJvbChpbnN0YW5jZSwgJ3llYXItZGF5JywgeWVhck9wdGlvbnMpO1xuICBjb25zdCB5ZWFyTW9udGhMaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgY29uc3QgbW9udGggPSBfLnJhbmdlKDEyKS5maW5kSW5kZXgoKG1vbnRoSW5kZXgpID0+IChcbiAgICAgIGdldE1vbnRoTmFtZShtb250aEluZGV4KS50b0xvd2VyQ2FzZSgpID09PSBlLnRhcmdldC52YWx1ZVxuICAgICkpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gTnVtYmVyKHllYXJEYXlTZWxlY3QudmFsdWUpO1xuICAgIHllYXJEYXlTZWxlY3QuaW5uZXJIVE1MID0gJyc7XG5cbiAgICBjb25zdCBtYXhEYXlzID0gZ2V0RGF5c0luTW9udGgobW9udGgpO1xuICAgIF8ucmFuZ2UoMSwgbWF4RGF5cyArIDEpLmZvckVhY2goKGRheSkgPT4ge1xuICAgICAgY29uc3Qgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBvcHQudmFsdWUgPSBkYXkudG9TdHJpbmcoKTtcbiAgICAgIG9wdC50ZXh0Q29udGVudCA9IG9yZGluYWwoZGF5KTtcbiAgICAgIHllYXJEYXlTZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICB9KTtcbiAgICBpZiAob2xkVmFsdWUgPD0gbWF4RGF5cykgeWVhckRheVNlbGVjdC52YWx1ZSA9IG9sZFZhbHVlO1xuICAgIGVsc2UgeWVhckRheVNlbGVjdC52YWx1ZSA9IG1heERheXM7XG4gIH07XG4gIHllYXJNb250aFNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB5ZWFyTW9udGhMaXN0ZW5lcik7XG4gIGZpcmVFdmVudCh5ZWFyTW9udGhTZWxlY3QpO1xuXG4gIC8vIE1ha2UgZW5kIGNvdW50IGxhYmVsIHNpbmd1bGFyL3BsdXJhbCBiYXNlZCBvbiB2YWx1ZVxuICBjb25zdCBlbmRDb3VudCA9IGdldENvbnRyb2woaW5zdGFuY2UsICdlbmQtY291bnQnKTtcbiAgZW5kQ291bnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICBjb25zdCBjb3VudCA9IE51bWJlcihlLnRhcmdldC52YWx1ZSk7XG4gICAgaWYgKGUudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDAgJiYgTnVtYmVyLmlzRmluaXRlKGNvdW50KSkge1xuICAgICAgY29uc3QgbGFiZWwgPSBjb3VudCA9PT0gMSA/ICcgb2NjdXJyZW5jZScgOiAnIG9jY3VycmVuY2VzJztcbiAgICAgIGdldENvbnRyb2woaW5zdGFuY2UsICdlbmQtY291bnQtbGFiZWwnKS50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH1cbiAgfSk7XG4gIGZpcmVFdmVudChlbmRDb3VudCk7XG5cbiAgLy8gQ29uZGl0aW9uYWxseSBlbmFibGUvZGlzYWJsZSByZWN1cnJlbmNlIGVuZCBjb250cm9sc1xuICBjb25zdCBlbmRSYWRpb1NlbGVjdG9yID0gJ2lucHV0W25hbWU9XCJyZWN1cnJpbmctZGF0ZS1lbmQtdHlwZVwiXSc7XG4gIGNvbnN0IGVuZFR5cGVMaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgY29uc3QgZGF0ZUlucHV0ID0gZ2V0Q29udHJvbChpbnN0YW5jZSwgJ2VuZC1kYXRlJyk7XG4gICAgY29uc3QgZGF0ZUJ1dHRvbiA9IGdldENvbnRyb2woaW5zdGFuY2UsICdlbmQtZGF0ZS1idXR0b24nKTtcbiAgICBjb25zdCBjb3VudElucHV0ID0gZ2V0Q29udHJvbChpbnN0YW5jZSwgJ2VuZC1jb3VudCcpO1xuXG4gICAgZGF0ZUlucHV0LmRpc2FibGVkID0gZS50YXJnZXQudmFsdWUgIT09ICdkYXRlJztcbiAgICBkYXRlQnV0dG9uLmRpc2FibGVkID0gZS50YXJnZXQudmFsdWUgIT09ICdkYXRlJztcbiAgICBjb3VudElucHV0LmRpc2FibGVkID0gZS50YXJnZXQudmFsdWUgIT09ICdjb3VudCc7XG4gIH07XG4gIHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKGVuZFJhZGlvU2VsZWN0b3IpLmZvckVhY2goKHJhZGlvKSA9PiB7XG4gICAgcmFkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZW5kVHlwZUxpc3RlbmVyKTtcbiAgICBpZiAocmFkaW8uY2hlY2tlZCkgZmlyZUV2ZW50KHJhZGlvKTtcbiAgfSk7XG5cbiAgLy8gQ29uZGl0aW9uYWxseSBlbmFibGUvZGlzYWJsZSBjb250cm9scyBmb3IgY2hlY2tib3ggb3B0aW9uc1xuICBjb25zdCB1c2VEYXRlQ2hlY2tib3ggPSBnZXRDb250cm9sKGluc3RhbmNlLCAndXNlLXN0YXJ0LWRhdGUnKTtcbiAgdXNlRGF0ZUNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgY29uc3QgZW5hYmxlID0gZS50YXJnZXQuY2hlY2tlZDtcbiAgICBnZXRDb250cm9sKGluc3RhbmNlLCAnc3RhcnQtZGF0ZScpLmRpc2FibGVkID0gIWVuYWJsZTtcbiAgICBnZXRDb250cm9sKGluc3RhbmNlLCAnc3RhcnQtZGF0ZS1idXR0b24nKS5kaXNhYmxlZCA9ICFlbmFibGU7XG4gIH0pO1xuICBmaXJlRXZlbnQodXNlRGF0ZUNoZWNrYm94KTtcblxuICBjb25zdCBub1dlZWtlbmRDaGVja2JveCA9IGdldENvbnRyb2woaW5zdGFuY2UsICduby13ZWVrZW5kJyk7XG4gIG5vV2Vla2VuZENoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgZ2V0Q29udHJvbChpbnN0YW5jZSwgJ3dlZWtlbmQtc2VsZWN0JykuZGlzYWJsZWQgPSAhZS50YXJnZXQuY2hlY2tlZDtcbiAgfSk7XG4gIGZpcmVFdmVudChub1dlZWtlbmRDaGVja2JveCk7XG5cbiAgLy8gQ2hlY2sgZGF0ZSB2YWxpZGl0eVxuICBjb25zdCBkYXRlTGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGUudGFyZ2V0O1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgaWYgKCFwYXJzZURhdGUodmFsdWUsIHByaXZhdGVzLmRhdGVGb3JtYXQuaW5wdXRQYXR0ZXJucykpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gcHJpdmF0ZXMuZGF0ZUZvcm1hdC52aXN1YWxQYXR0ZXJuO1xuICAgICAgICBtZXNzYWdlID0gYFBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGUgaW4gJHtmb3JtYXR9IGZvcm1hdC5gO1xuICAgICAgfVxuICAgICAgZS50YXJnZXQuc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgfVxuICB9O1xuICBnZXRDb250cm9sKGluc3RhbmNlLCAnZW5kLWRhdGUnKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBkYXRlTGlzdGVuZXIpO1xuICBnZXRDb250cm9sKGluc3RhbmNlLCAnc3RhcnQtZGF0ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGRhdGVMaXN0ZW5lcik7XG59XG5cbi8qKlxuICogQSBtb2RhbCBkaWFsb2cgZm9yIHNlbGVjdGluZyBhIHJlY3VycmluZyBkYXRlLlxuICogQGltcGxlbWVudHMge21vZHVsZTptb2RhbFN0YWNrfk1vZGFsfVxuICovXG5jbGFzcyBSZWN1cnJlbmNlTW9kYWwge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gSG9sZHMgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNvbmZpcm1dIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb25maXJtcyB0aGUgbW9kYWwuIFRoZSBmdW5jdGlvbiB3aWxsXG4gICAqICAgYmUgcGFzc2VkIHRoZSByZWN1cnJpbmcgZGF0ZSB0aGF0IHdhcyBzZWxlY3RlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FuY2VsXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICAgKiAgIGludm9rZWQgd2hlbiB0aGUgdXNlciBjYW5jZWxzIHRoZSBtb2RhbC5cbiAgICogQHBhcmFtIHttb2R1bGU6cmVjdXJyaW5nRGF0ZX5SZWN1cnJpbmdEYXRlfSBbb3B0aW9ucy5pbml0aWFsXSBBIHJlY3VycmluZ1xuICAgKiAgIGRhdGUgdG8gdXNlIGFzIGEgZGVmYXVsdCB3aGVuIGluaXRpYWxpemluZyB0aGUgZm9ybSBjb250cm9scy5cbiAgICogQHBhcmFtIHtEYXRlfSBbb3B0aW9ucy5iYXNlRGF0ZV0gVGhlIGRhdGUgdG8gdXNlIGFzIGEgZGVmYXVsdCBmb3JcbiAgICogICBpbml0aWFsaXppbmcgY2VydGFpbiBmaWVsZHMuIElmIG5vdCBnaXZlbiwgdGhlbiB0aGUgcHJlc2VudCBkYXRlIGlzXG4gICAqICAgdXNlZC5cbiAgICogQHBhcmFtIHttb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+ZGF0ZUZvcm1hdH0gW29wdGlvbnMuZGF0ZUZvcm1hdF0gQW5cbiAgICogICBvYmplY3QgaG9sZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2FsZW5kYXIgZGF0ZSBmb3JtYXQgdG8gdXNlIGZvclxuICAgKiAgIGRhdGUgZmllbGRzLiBJZiBub3QgZ2l2ZW4sIHRoZW4gdGhlIGJyb3dzZXIgZGVmYXVsdCBpcyB1c2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSB7XG4gICAgICBpbml0aWFsUmVjdXJyZW5jZTogb3B0aW9ucy5pbml0aWFsIHx8IG51bGwsXG4gICAgICBiYXNlRGF0ZTogb3B0aW9ucy5iYXNlRGF0ZSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgZGF0ZUZvcm1hdDogb3B0aW9ucy5kYXRlRm9ybWF0IHx8IFNldHRpbmdzLmxvb2t1cERhdGVGb3JtYXQoKSxcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICBjb25maXJtOiBvcHRpb25zLmNvbmZpcm0gfHwgbnVsbCxcbiAgICAgICAgY2FuY2VsOiBvcHRpb25zLmNhbmNlbCB8fCBudWxsLFxuICAgICAgfSxcbiAgICAgIGNvbnRhaW5lcnM6IHtcbiAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgICB3ZWVrT3B0aW9uczogbnVsbCxcbiAgICAgICAgbW9udGhPcHRpb25zOiBudWxsLFxuICAgICAgICB5ZWFyT3B0aW9uczogbnVsbCxcbiAgICAgIH0sXG4gICAgICB0aXRsZTogJ0VkaXQgUmVjdXJyaW5nIERhdGUnLFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcbiAgfVxuXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLnRpdGxlO1xuICB9XG5cbiAgYWRkQ29udGVudChwYXJlbnQsIG1vZGFsU3RhY2spIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcblxuICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1jb250YWluZXInKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBpZDogJ3JlY3VycmluZy1kYXRlLWludGVydmFsLWxlbmd0aCcsXG4gICAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUtaW50ZXJ2YWwtbGVuZ3RoJyxcbiAgICAgIHZhbHVlOiAnMScsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1pbmxpbmUnLCAnZm9ybS1pbnB1dC1jb3VudCddLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBtaW46IDEsXG4gICAgICBjb250YWluZXI6IHsgaW5saW5lOiB0cnVlIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICB2YWx1ZTogJ1JlcGVhdCBldmVyeSAnLFxuICAgICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnXSxcbiAgICAgIH0sXG4gICAgfSkpO1xuXG4gICAgbGV0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwtaW5saW5lJyk7XG4gICAgbGFiZWwudGV4dENvbnRlbnQgPSAnICc7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgIGlkOiAncmVjdXJyaW5nLWRhdGUtaW50ZXJ2YWwtdW5pdCcsXG4gICAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUtaW50ZXJ2YWwtdW5pdCcsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QtaW5saW5lJ10sXG4gICAgICBtZW51SXRlbXM6IFVOSVRTLm1hcCgodW5pdCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHVuaXQudmFsdWUgPT09ICd3ZWVrJztcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuaXQudmFsdWUsIGxhYmVsOiB1bml0LnNpbmd1bGFyLCBzZWxlY3RlZCB9O1xuICAgICAgfSksXG4gICAgfSkpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgY29uc3QgY29udGV4dENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjb250ZXh0Q29udGFpbmVyKTtcblxuICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWNvbnRhaW5lcicpO1xuXG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsLWlubGluZScpO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gJ1N0b3AgcmVwZWF0aW5nJztcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICBpZDogJ3JlY3VycmluZy1kYXRlLWVuZC10eXBlLW5ldmVyJyxcbiAgICAgIG5hbWU6ICdyZWN1cnJpbmctZGF0ZS1lbmQtdHlwZScsXG4gICAgICB2YWx1ZTogJ25ldmVyJyxcbiAgICAgIGNoZWNrZWQ6IHRydWUsXG4gICAgICBsYWJlbDogeyB2YWx1ZTogJ05ldmVyJywgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtbGFiZWwtaW5saW5lJ10gfSxcbiAgICAgIGNvbnRhaW5lcjogeyBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1pdGVtLWNvbnRhaW5lciddIH0sXG4gICAgfSkpO1xuXG4gICAgbGV0IG9wdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG9wdGlvbkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWl0ZW0tY29udGFpbmVyJyk7XG4gICAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICBpZDogJ3JlY3VycmluZy1kYXRlLWVuZC10eXBlLWRhdGUnLFxuICAgICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLWVuZC10eXBlJyxcbiAgICAgIHZhbHVlOiAnZGF0ZScsXG4gICAgfSkpO1xuXG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwtaW5saW5lJyk7XG4gICAgbGFiZWwuaHRtbEZvciA9ICdyZWN1cnJpbmctZGF0ZS1lbmQtdHlwZS1kYXRlJztcbiAgICBsYWJlbC50ZXh0Q29udGVudCA9ICdPbiBkYXRlICc7XG4gICAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVEYXRlSW5wdXRGaWVsZCh7XG4gICAgICBpZDogJ3JlY3VycmluZy1kYXRlLWVuZC1kYXRlJyxcbiAgICAgIG5hbWU6ICdyZWN1cnJpbmctZGF0ZS1lbmQtZGF0ZScsXG4gICAgICBwbGFjZWhvbGRlcjogcHJpdmF0ZXMuZGF0ZUZvcm1hdC52aXN1YWxQYXR0ZXJuLFxuICAgICAgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtaW5saW5lJ10sXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1kYXRlLWNvbnRhaW5lci1pbmxpbmUnXSxcbiAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIGJ1dHRvbjoge1xuICAgICAgICBpZDogJ3JlY3VycmluZy1kYXRlLWVuZC1kYXRlLWJ1dHRvbicsXG4gICAgICAgIGNsYXNzTGlzdDogWydmb3JtLWJ1dHRvbiddLFxuICAgICAgICBjYWxsYmFjazogKGlucHV0KSA9PiBwaWNrRGF0ZSh0aGlzLCBpbnB1dCwgbW9kYWxTdGFjayksXG4gICAgICB9LFxuICAgIH0pKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQob3B0aW9uQ29udGFpbmVyKTtcblxuICAgIG9wdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG9wdGlvbkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWl0ZW0tY29udGFpbmVyJyk7XG4gICAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICBpZDogJ3JlY3VycmluZy1kYXRlLWVuZC10eXBlLWNvdW50JyxcbiAgICAgIG5hbWU6ICdyZWN1cnJpbmctZGF0ZS1lbmQtdHlwZScsXG4gICAgICB2YWx1ZTogJ2NvdW50JyxcbiAgICB9KSk7XG5cbiAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgICBsYWJlbC5odG1sRm9yID0gJ3JlY3VycmluZy1kYXRlLWVuZC10eXBlLWNvdW50JztcbiAgICBsYWJlbC50ZXh0Q29udGVudCA9ICdBZnRlciAnO1xuICAgIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBpZDogJ3JlY3VycmluZy1kYXRlLWVuZC1jb3VudCcsXG4gICAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUtZW5kLWNvdW50JyxcbiAgICAgIHZhbHVlOiAnMScsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1pbmxpbmUnLCAnZm9ybS1pbnB1dC1jb3VudCddLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBtaW46IDEsXG4gICAgfSkpO1xuXG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGxhYmVsLmlkID0gJ3JlY3VycmluZy1kYXRlLWVuZC1jb3VudC1sYWJlbCc7XG4gICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgICBsYWJlbC5odG1sRm9yID0gJ3JlY3VycmluZy1kYXRlLWVuZC1jb3VudCc7XG4gICAgbGFiZWwudGV4dENvbnRlbnQgPSAnIG9jY3VycmVuY2VzJztcbiAgICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChvcHRpb25Db250YWluZXIpO1xuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1jb250YWluZXInKTtcblxuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgICBsYWJlbC50ZXh0Q29udGVudCA9ICdBZGRpdGlvbmFsIG9wdGlvbnM6JztcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgb3B0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgb3B0aW9uQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtaXRlbS1jb250YWluZXInKTtcblxuICAgIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS11c2Utc3RhcnQtZGF0ZScsXG4gICAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUtYWRkaXRpb25hbC1vcHRpb25zJyxcbiAgICAgIHZhbHVlOiAndXNlLXN0YXJ0LWRhdGUnLFxuICAgIH0pKTtcblxuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsLWlubGluZScpO1xuICAgIGxhYmVsLmh0bWxGb3IgPSAncmVjdXJyaW5nLWRhdGUtdXNlLXN0YXJ0LWRhdGUnO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gJ1N0YXJ0IG9uICc7XG4gICAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVEYXRlSW5wdXRGaWVsZCh7XG4gICAgICBpZDogJ3JlY3VycmluZy1kYXRlLXN0YXJ0LWRhdGUnLFxuICAgICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLXN0YXJ0LWRhdGUnLFxuICAgICAgcGxhY2Vob2xkZXI6IHByaXZhdGVzLmRhdGVGb3JtYXQudmlzdWFsUGF0dGVybixcbiAgICAgIGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWlubGluZSddLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtZGF0ZS1jb250YWluZXItaW5saW5lJ10sXG4gICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBidXR0b246IHtcbiAgICAgICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS1zdGFydC1kYXRlLWJ1dHRvbicsXG4gICAgICAgIGNsYXNzTGlzdDogWydmb3JtLWJ1dHRvbiddLFxuICAgICAgICBjYWxsYmFjazogKGlucHV0KSA9PiBwaWNrRGF0ZSh0aGlzLCBpbnB1dCwgbW9kYWxTdGFjayksXG4gICAgICB9LFxuICAgIH0pKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQob3B0aW9uQ29udGFpbmVyKTtcblxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS1iYXNlLW9uLWNvbXBsZXRpb24nLFxuICAgICAgbmFtZTogJ3JlY3VycmluZy1kYXRlLWFkZGl0aW9uYWwtb3B0aW9ucycsXG4gICAgICB2YWx1ZTogJ2Jhc2Utb24tY29tcGxldGlvbicsXG4gICAgICBsYWJlbDoge1xuICAgICAgICB2YWx1ZTogJ1JlcGVhdCBmcm9tIGNvbXBsZXRpb24gZGF0ZScsXG4gICAgICAgIGNsYXNzTGlzdDogWydmb3JtLWlucHV0LWxhYmVsLWlubGluZSddLFxuICAgICAgfSxcbiAgICAgIGNvbnRhaW5lcjogeyBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1pdGVtLWNvbnRhaW5lciddIH0sXG4gICAgfSkpO1xuXG4gICAgb3B0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgb3B0aW9uQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtaXRlbS1jb250YWluZXInKTtcblxuICAgIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS1uby13ZWVrZW5kJyxcbiAgICAgIG5hbWU6ICdyZWN1cnJpbmctZGF0ZS1hZGRpdGlvbmFsLW9wdGlvbnMnLFxuICAgICAgdmFsdWU6ICduby13ZWVrZW5kJyxcbiAgICB9KSk7XG5cbiAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnKTtcbiAgICBsYWJlbC5odG1sRm9yID0gJ3JlY3VycmluZy1kYXRlLW5vLXdlZWtlbmQnO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gJ09uIHdlZWtlbmRzLCB1c2UgJztcbiAgICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUZvcm1Db250cm9sKHtcbiAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgaWQ6ICdyZWN1cnJpbmctZGF0ZS13ZWVrZW5kLXNlbGVjdCcsXG4gICAgICBuYW1lOiAncmVjdXJyaW5nLWRhdGUtd2Vla2VuZC1zZWxlY3QnLFxuICAgICAgY2xhc3NMaXN0OiBbJ2Zvcm0tc2VsZWN0LWlubGluZSddLFxuICAgICAgbWVudUl0ZW1zOiBbXG4gICAgICAgIHsgdmFsdWU6ICduZWFyZXN0LXdlZWtkYXknLCBsYWJlbDogJ25lYXJlc3QnLCBzZWxlY3RlZDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiAncHJldmlvdXMtd2Vla2RheScsIGxhYmVsOiAncHJldmlvdXMnIH0sXG4gICAgICAgIHsgdmFsdWU6ICduZXh0LXdlZWtkYXknLCBsYWJlbDogJ25leHQnIH0sXG4gICAgICBdLFxuICAgIH0pKTtcblxuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb3JtLWlucHV0LWxhYmVsLWlubGluZScpO1xuICAgIGxhYmVsLmh0bWxGb3IgPSAncmVjdXJyaW5nLWRhdGUtd2Vla2VuZC1zZWxlY3QnO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gJyB3ZWVrZGF5JztcbiAgICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChvcHRpb25Db250YWluZXIpO1xuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBjb25zdCB3ZWVrT3B0aW9ucyA9IGNyZWF0ZVdlZWtDb250ZXh0Rm9ybSgpO1xuICAgIGNvbnN0IG1vbnRoT3B0aW9ucyA9IGNyZWF0ZU1vbnRoQ29udGV4dEZvcm0oKTtcbiAgICBjb25zdCB5ZWFyT3B0aW9ucyA9IGNyZWF0ZVllYXJDb250ZXh0Rm9ybSgpO1xuXG4gICAgcHJpdmF0ZXMuY29udGFpbmVycyA9IHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRDb250YWluZXIsXG4gICAgICB3ZWVrT3B0aW9ucyxcbiAgICAgIG1vbnRoT3B0aW9ucyxcbiAgICAgIHllYXJPcHRpb25zLFxuICAgIH07XG5cbiAgICBpbml0Rm9ybVZhbHVlcyh0aGlzKTtcbiAgICBhZGRMaXN0ZW5lcnModGhpcyk7XG4gIH1cblxuICBjb25maXJtKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChwcml2YXRlcy5jYWxsYmFja3MuY29uZmlybSkge1xuICAgICAgY29uc3QgdW5pdCA9IGdldENvbnRyb2wodGhpcywgJ2ludGVydmFsLXVuaXQnKS52YWx1ZTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcblxuICAgICAgY29uc3QgbGVuZ3RoSW5wdXQgPSBnZXRDb250cm9sKHRoaXMsICdpbnRlcnZhbC1sZW5ndGgnKTtcbiAgICAgIG9wdGlvbnMuaW50ZXJ2YWxMZW5ndGggPSBOdW1iZXIobGVuZ3RoSW5wdXQudmFsdWUpO1xuXG4gICAgICBsZXQgY29udGV4dDtcbiAgICAgIGNvbnN0IGdldERheUluZGV4ID0gKGRheSkgPT4gKFxuICAgICAgICBfLnJhbmdlKDcpLmZpbmRJbmRleCgoZGF5SW5kZXgpID0+IChcbiAgICAgICAgICBkYXkgPT09IGdldFdlZWtkYXlOYW1lKGRheUluZGV4KS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICkpXG4gICAgICApO1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgIGNvbnRleHQgPSBwcml2YXRlcy5jb250YWluZXJzLndlZWtPcHRpb25zO1xuICAgICAgICAgIGlmIChnZXRDb250cm9sKHRoaXMsICd3ZWVrLXR5cGUtc2VsZWN0LWRheXMnLCBjb250ZXh0KS5jaGVja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXlzT2ZXZWVrID0gW107XG4gICAgICAgICAgICBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb3JtLXdlZWtkYXktYnV0dG9uJykuZm9yRWFjaChcbiAgICAgICAgICAgICAgKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChidXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgICAgZGF5c09mV2Vlay5wdXNoKGdldERheUluZGV4KGJ1dHRvbi52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZGF5c09mV2Vlay5sZW5ndGggPiAwKSBvcHRpb25zLmRheXNPZldlZWsgPSBkYXlzT2ZXZWVrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIGNvbnRleHQgPSBwcml2YXRlcy5jb250YWluZXJzLm1vbnRoT3B0aW9ucztcbiAgICAgICAgICBpZiAoZ2V0Q29udHJvbCh0aGlzLCAnbW9udGgtdHlwZS1kYXknLCBjb250ZXh0KS5jaGVja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXlTZWxlY3QgPSBnZXRDb250cm9sKHRoaXMsICdtb250aC1kYXknLCBjb250ZXh0KTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF5T2ZNb250aCA9IE51bWJlcihkYXlTZWxlY3QudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ2V0Q29udHJvbCh0aGlzLCAnbW9udGgtdHlwZS13ZWVrJywgY29udGV4dCkuY2hlY2tlZCkge1xuICAgICAgICAgICAgY29uc3Qgd2Vla1NlbGVjdCA9IGdldENvbnRyb2wodGhpcywgJ21vbnRoLXdlZWstbnVtYmVyJywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBkYXlTZWxlY3QgPSBnZXRDb250cm9sKHRoaXMsICdtb250aC13ZWVrLWRheScsIGNvbnRleHQpO1xuICAgICAgICAgICAgb3B0aW9ucy53ZWVrTnVtYmVyID0gTnVtYmVyKHdlZWtTZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgb3B0aW9ucy5kYXlzT2ZXZWVrID0gW2dldERheUluZGV4KGRheVNlbGVjdC52YWx1ZSldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgY29udGV4dCA9IHByaXZhdGVzLmNvbnRhaW5lcnMueWVhck9wdGlvbnM7XG4gICAgICAgICAgaWYgKGdldENvbnRyb2wodGhpcywgJ3llYXItdHlwZS1kYXknLCBjb250ZXh0KS5jaGVja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBtb250aFNlbGVjdCA9IGdldENvbnRyb2wodGhpcywgJ3llYXItbW9udGgnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGRheVNlbGVjdCA9IGdldENvbnRyb2wodGhpcywgJ3llYXItZGF5JywgY29udGV4dCk7XG4gICAgICAgICAgICBvcHRpb25zLm1vbnRoID0gXy5yYW5nZSgxMikuZmluZEluZGV4KChtb250aEluZGV4KSA9PiAoXG4gICAgICAgICAgICAgIGdldE1vbnRoTmFtZShtb250aEluZGV4KS50b0xvd2VyQ2FzZSgpID09PSBtb250aFNlbGVjdC52YWx1ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBvcHRpb25zLmRheU9mTW9udGggPSBOdW1iZXIoZGF5U2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRDb250cm9sKHRoaXMsICdlbmQtdHlwZS1kYXRlJykuY2hlY2tlZCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGdldENvbnRyb2wodGhpcywgJ2VuZC1kYXRlJyk7XG4gICAgICAgIG9wdGlvbnMuZW5kRGF0ZSA9IHBhcnNlRGF0ZShcbiAgICAgICAgICBpbnB1dC52YWx1ZSxcbiAgICAgICAgICBwcml2YXRlcy5kYXRlRm9ybWF0LmlucHV0UGF0dGVybnMsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGdldENvbnRyb2wodGhpcywgJ2VuZC10eXBlLWNvdW50JykuY2hlY2tlZCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGdldENvbnRyb2wodGhpcywgJ2VuZC1jb3VudCcpO1xuICAgICAgICBvcHRpb25zLm1heENvdW50ID0gTnVtYmVyKGlucHV0LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldENvbnRyb2wodGhpcywgJ3VzZS1zdGFydC1kYXRlJykuY2hlY2tlZCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGdldENvbnRyb2wodGhpcywgJ3N0YXJ0LWRhdGUnKTtcbiAgICAgICAgb3B0aW9ucy5zdGFydERhdGUgPSBwYXJzZURhdGUoXG4gICAgICAgICAgaW5wdXQudmFsdWUsXG4gICAgICAgICAgcHJpdmF0ZXMuZGF0ZUZvcm1hdC5pbnB1dFBhdHRlcm5zLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmJhc2VPbkNvbXBsZXRpb24gPSBnZXRDb250cm9sKFxuICAgICAgICB0aGlzLFxuICAgICAgICAnYmFzZS1vbi1jb21wbGV0aW9uJyxcbiAgICAgICkuY2hlY2tlZDtcblxuICAgICAgaWYgKGdldENvbnRyb2wodGhpcywgJ25vLXdlZWtlbmQnKS5jaGVja2VkKSB7XG4gICAgICAgIG9wdGlvbnMub25XZWVrZW5kID0gZ2V0Q29udHJvbCh0aGlzLCAnd2Vla2VuZC1zZWxlY3QnKS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHJpdmF0ZXMuY2FsbGJhY2tzLmNvbmZpcm0obmV3IFJlY3VycmluZ0RhdGUodW5pdCwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrcyB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChjYWxsYmFja3MuY2FuY2VsKSBjYWxsYmFja3MuY2FuY2VsKCk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBpZiAoIWdldENvbnRyb2wodGhpcywgJ2ludGVydmFsLWxlbmd0aCcpLnJlcG9ydFZhbGlkaXR5KCkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChnZXRDb250cm9sKHRoaXMsICdlbmQtdHlwZS1kYXRlJykuY2hlY2tlZCkge1xuICAgICAgaWYgKCFnZXRDb250cm9sKHRoaXMsICdlbmQtZGF0ZScpLnJlcG9ydFZhbGlkaXR5KCkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0Q29udHJvbCh0aGlzLCAnZW5kLXR5cGUtY291bnQnKS5jaGVja2VkKSB7XG4gICAgICBpZiAoIWdldENvbnRyb2wodGhpcywgJ2VuZC1jb3VudCcpLnJlcG9ydFZhbGlkaXR5KCkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0Q29udHJvbCh0aGlzLCAndXNlLXN0YXJ0LWRhdGUnKS5jaGVja2VkKSB7XG4gICAgICBpZiAoIWdldENvbnRyb2wodGhpcywgJ3N0YXJ0LWRhdGUnKS5yZXBvcnRWYWxpZGl0eSgpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVjdXJyZW5jZU1vZGFsO1xuIiwiLyoqXG4gKiBEZWZpbmVzIHRoZSBbU2V0dGluZ3NNb2RhbF17QGxpbmsgbW9kdWxlOnNldHRpbmdzTW9kYWx+U2V0dGluZ3NNb2RhbH0gY2xhc3MuXG4gKiBAbW9kdWxlIHNldHRpbmdzTW9kYWxcbiAqL1xuXG5pbXBvcnQgQ29uZmlybU1vZGFsIGZyb20gJy4vY29uZmlybU1vZGFsJztcblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL3NldHRpbmdzJztcbmltcG9ydCB7IGNyZWF0ZUZvcm1Db250cm9sIH0gZnJvbSAnLi4vdXRpbGl0eS9kb20nO1xuaW1wb3J0IHsgaXNMb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgfSBmcm9tICcuLi91dGlsaXR5L3N0b3JhZ2UnO1xuXG4vKipcbiAqIE9iamVjdCBob2xkaW5nIHByaXZhdGUgbWVtYmVycyBmb3IgdGhlXG4gKiBbU2V0dGluZ3NNb2RhbF17QGxpbmsgbW9kdWxlOnNldHRpbmdzTW9kYWx+U2V0dGluZ3NNb2RhbH0gY2xhc3MuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6c2V0dGluZ3NNb2RhbH5TZXR0aW5nc01vZGFsfnByaXZhdGVzXG4gKiBAcHJvcGVydHkge21vZHVsZTpzZXR0aW5nc35TZXR0aW5nc30gc2V0dGluZ3MgVGhlIGFwcCBzZXR0aW5ncyBiZWluZ1xuICogICBtb2RpZmllZC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm1vZGFsU3RhY2t+TW9kYWxTdGFja30gbW9kYWxTdGFjayBUaGUgbW9kYWwgc3RhY2sgaW4gd2hpY2hcbiAqICAgdGhlIG1vZGFsIHdhcyBpbnNlcnRlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29uZmlybU5vU3RvcmFnZSBJZiB0cnVlLCB0aGVuIHRoZSB1c2VyIHNob3VsZCBiZSBhc2tlZFxuICogICBmb3IgY29uZmlybWF0aW9uIHdoZW4gZGlzYWJsaW5nIGxvY2FsIHN0b3JhZ2UuXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2FsbGJhY2tzIEFuIG9iamVjdCBob2xkaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjYWxsYmFja3MuY29uZmlybV0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb25maXJtcyB0aGUgbW9kYWwuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLmNhbmNlbF0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgaW52b2tlZCB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIG1vZGFsLlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtjb250cm9sc10gQW4gb2JqZWN0IGhvbGRpbmcgdGhlIGZvcm0gaW5wdXQgZWxlbWVudHMgZm9yXG4gKiAgIHRoZSBtb2RhbC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLnNhdmVMb2NhbCBUaGUgcmFkaW8gYnV0dG9uIGVsZW1lbnQgZm9yXG4gKiAgIGluZGljYXRpbmcgdGhhdCBkYXRhIHNob3VsZCBiZSBzYXZlZCB0byBsb2NhbCBzdG9yYWdlLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udHJvbHMuc2F2ZU5ldmVyIFRoZSByYWRpbyBidXR0b24gZWxlbWVudCBmb3JcbiAqICAgaW5kaWNhdGluZyB0aGF0IGRhdGEgc2hvdWxkIG5vdCBiZSBzYXZlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzLmRhdGVGb3JtYXQgVGhlIHNlbGVjdCBlbGVtZW50IGZvciB0aGUgZGF0ZVxuICogICBmb3JtYXQuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250cm9scy5kZWxldGVPbGQgVGhlIGNoZWNrYm94IGVsZW1lbnQgaW5kaWNhdGluZ1xuICogICB3aGV0aGVyIHRvIGRlbGV0ZSBvbGQgY29tcGxldGVkIHRhc2tzLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udHJvbHMuZGVsZXRlQWZ0ZXIgVGhlIGlucHV0IGVsZW1lbnQgZm9yIGVudGVyaW5nXG4gKiAgIHRoZSBudW1iZXIgb2YgZGF5cyBhZnRlciB3aGljaCB0byBkZWxldGUgY29tcGxldGVkIHRhc2tzLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gY29udHJvbHMuZGVsZXRlQWZ0ZXJMYWJlbCBUaGUgbGFiZWwgZWxlbWVudCBmb3IgdGhlXG4gKiAgIGRlbGV0ZUFmdGVyIGNvbnRyb2wuXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBwcml2YXRlIGRhdGEgZm9yIHRoZVxuICogW1NldHRpbmdzTW9kYWxde0BsaW5rIG1vZHVsZTpzZXR0aW5nc01vZGFsflNldHRpbmdzTW9kYWx9IGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTpzZXR0aW5nc01vZGFsflNldHRpbmdzTW9kYWx+cHJpdmF0ZXNcbiAqL1xuY29uc3QgcHJpdmF0ZU1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIHZhbHVlcyBvZiB0aGUgZm9ybSBlbGVtZW50cyBiYXNlZCBvbiBjdXJyZW50IHNldHRpbmdzLlxuICogQHBhcmFtIHttb2R1bGU6c2V0dGluZ3NNb2RhbH5TZXR0aW5nc01vZGFsfSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb25cbiAqICAgd2hpY2ggdG8gYXBwbHkgdGhlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBpbml0Rm9ybVZhbHVlcyhpbnN0YW5jZSkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGNvbnN0IHsgY29udHJvbHMsIHNldHRpbmdzIH0gPSBwcml2YXRlcztcblxuICBzd2l0Y2ggKHNldHRpbmdzLnN0b3JhZ2VNZXRob2QpIHtcbiAgICBjYXNlICdub25lJzpcbiAgICAgIHByaXZhdGVzLmNvbmZpcm1Ob1N0b3JhZ2UgPSBmYWxzZTtcbiAgICAgIGNvbnRyb2xzLnNhdmVOZXZlci5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xvY2FsJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcHJpdmF0ZXMuY29uZmlybU5vU3RvcmFnZSA9IHRydWU7XG4gICAgICBjb250cm9scy5zYXZlTG9jYWwuY2hlY2tlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGNvbnRyb2xzLmRhdGVGb3JtYXQudmFsdWUgPSBzZXR0aW5ncy5kYXRlRm9ybWF0LnR5cGU7XG5cbiAgY29uc3QgZGVsZXRlT2xkID0gc2V0dGluZ3MuZGVsZXRlQWZ0ZXIgIT09IG51bGw7XG4gIGNvbnRyb2xzLmRlbGV0ZU9sZC5jaGVja2VkID0gZGVsZXRlT2xkO1xuICBpZiAoZGVsZXRlT2xkKSBjb250cm9scy5kZWxldGVBZnRlci52YWx1ZSA9IHNldHRpbmdzLmRlbGV0ZUFmdGVyLnRvU3RyaW5nKCk7XG5cbiAgLy8gRGlzYWJsZSBzdG9yYWdlIG9wdGlvbnMgaWYgbG9jYWwgc3RvcmFnZSBpcyB1bnN1cHBvcnRlZCBvciBkaXNhYmxlZFxuICBpZiAoIWlzTG9jYWxTdG9yYWdlU3VwcG9ydGVkKCkpIHtcbiAgICBjb250cm9scy5zYXZlTmV2ZXIuZGlzYWJsZWQgPSB0cnVlO1xuICAgIGNvbnRyb2xzLnNhdmVMb2NhbC5kaXNhYmxlZCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgdGhlIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZm9ybSBjb250cm9scyBpbiB0aGUgbW9kYWwuXG4gKiBAcGFyYW0ge21vZHVsZTpzZXR0aW5nc01vZGFsflNldHRpbmdzTW9kYWx9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvblxuICogICB3aGljaCB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhpbnN0YW5jZSkge1xuICBjb25zdCB7IGNvbnRyb2xzIH0gPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCBmaXJlRXZlbnQgPSAoaW5wdXQpID0+IGlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnKSk7XG5cbiAgY29udHJvbHMuZGVsZXRlT2xkLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgY29udHJvbHMuZGVsZXRlQWZ0ZXIuZGlzYWJsZWQgPSAhZS50YXJnZXQuY2hlY2tlZDtcbiAgfSk7XG4gIGZpcmVFdmVudChjb250cm9scy5kZWxldGVPbGQpO1xuXG4gIC8vIE1ha2UgZGVsZXRlLWFmdGVyIGxhYmVsIHNpbmd1bGFyL3BsdXJhbCBiYXNlZCBvbiB2YWx1ZVxuICBjb250cm9scy5kZWxldGVBZnRlci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gTnVtYmVyKGUudGFyZ2V0LnZhbHVlKTtcbiAgICBpZiAoZS50YXJnZXQudmFsdWUubGVuZ3RoID4gMCAmJiBOdW1iZXIuaXNGaW5pdGUoY291bnQpKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IGNvdW50ID09PSAxID8gJyBkYXknIDogJyBkYXlzJztcbiAgICAgIGNvbnRyb2xzLmRlbGV0ZUFmdGVyTGFiZWwudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICB9XG4gIH0pO1xuICBmaXJlRXZlbnQoY29udHJvbHMuZGVsZXRlQWZ0ZXIpO1xufVxuXG4vKipcbiAqIEEgbW9kYWwgZGlhbG9nIGZvciBtb2RpZnlpbmcgdXNlciBzZXR0aW5ncy5cbiAqIEBpbXBsZW1lbnRzIHttb2R1bGU6bW9kYWxTdGFja35Nb2RhbH1cbiAqL1xuY2xhc3MgU2V0dGluZ3NNb2RhbCB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgb3B0aW9ucyBmb3IgdGhlIG1vZGFsLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6c2V0dGluZ3NNb2RhbH5TZXR0aW5nc01vZGFsfm9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NvbmZpcm1dIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAgICogICB3aGVuIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb25maXJtcyB0aGUgbW9kYWwuIFRoZSBmdW5jdGlvbiB3aWxsIGJlXG4gICAqICAgcGFzc2VkIGEgcmVmZXJlbmNlIHRvIHRoZSBtb2RpZmllZCBbU2V0dGluZ3Nde21vZHVsZTpzZXR0aW5nc35TZXR0aW5nc31cbiAgICogICBpbnN0YW5jZS5cbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NhbmNlbF0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICAgKiAgIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgbW9kYWwuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBtb2RhbC5cbiAgICogQHBhcmFtIHttb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N9IHNldHRpbmdzIFRoZSBhcHAgc2V0dGluZ3MgYmVpbmdcbiAgICogICBtb2RpZmllZC5cbiAgICogQHBhcmFtIHttb2R1bGU6c2V0dGluZ3NNb2RhbH5TZXR0aW5nc01vZGFsfm9wdGlvbnN9IFtvcHRpb25zPXt9XSBIb2xkc1xuICAgKiAgIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIG1vZGFsLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZhdGVzID0ge1xuICAgICAgc2V0dGluZ3MsXG4gICAgICBtb2RhbFN0YWNrOiBudWxsLFxuICAgICAgY29uZmlybU5vU3RvcmFnZTogdHJ1ZSxcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICBjb25maXJtOiBvcHRpb25zLmNvbmZpcm0gfHwgbnVsbCxcbiAgICAgICAgY2FuY2VsOiBvcHRpb25zLmNhbmNlbCB8fCBudWxsLFxuICAgICAgfSxcbiAgICAgIGNvbnRyb2xzOiB7XG4gICAgICAgIHNhdmVMb2NhbDogbnVsbCxcbiAgICAgICAgc2F2ZU5ldmVyOiBudWxsLFxuICAgICAgICBkYXRlRm9ybWF0OiBudWxsLFxuICAgICAgICBkZWxldGVPbGQ6IG51bGwsXG4gICAgICAgIGRlbGV0ZUFmdGVyOiBudWxsLFxuICAgICAgICBkZWxldGVBZnRlckxhYmVsOiBudWxsLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHByaXZhdGVNZW1iZXJzLnNldCh0aGlzLCBwcml2YXRlcyk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAtLVxuICAgKiBOZWVkIHRvIHNldCB0aXRsZSB0byBjb25mb3JtIHRvIE1vZGFsIGludGVyZmFjZSwgYnV0IHNldHRpbmcgcHJvcGVydHlcbiAgICogZGlyZWN0bHkgaW4gY29uc3RydWN0b3Igd291bGQgYWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uLlxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiAnRWRpdCBTZXR0aW5ncyc7XG4gIH1cblxuICBhZGRDb250ZW50KHBhcmVudCwgbW9kYWxTdGFjaykge1xuICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1jb250YWluZXInKTtcblxuICAgIGxldCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwnKTtcbiAgICBsYWJlbC50ZXh0Q29udGVudCA9ICdEYXRhIFN0b3JhZ2UnO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ3JhZGlvJyxcbiAgICAgIGlkOiAnc2V0dGluZ3Mtc2F2ZS1sb2NhbCcsXG4gICAgICBuYW1lOiAnc2V0dGluZ3Mtc2F2ZS1tZXRob2QnLFxuICAgICAgdmFsdWU6ICdsb2NhbCcsXG4gICAgICBsYWJlbDoge1xuICAgICAgICB2YWx1ZTogJ1NhdmUgZGF0YSBpbiBicm93c2VyXFwncyBsb2NhbCBzdG9yYWdlIGFyZWEnLFxuICAgICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnXSxcbiAgICAgIH0sXG4gICAgICBjb250YWluZXI6IHsgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtaXRlbS1jb250YWluZXInXSB9LFxuICAgIH0pKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ3JhZGlvJyxcbiAgICAgIGlkOiAnc2V0dGluZ3Mtc2F2ZS1uZXZlcicsXG4gICAgICBuYW1lOiAnc2V0dGluZ3Mtc2F2ZS1tZXRob2QnLFxuICAgICAgdmFsdWU6ICduZXZlcicsXG4gICAgICBsYWJlbDoge1xuICAgICAgICB2YWx1ZTogJ0RvIG5vdCBzYXZlIGRhdGEnLFxuICAgICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUnXSxcbiAgICAgIH0sXG4gICAgICBjb250YWluZXI6IHsgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtaXRlbS1jb250YWluZXInXSB9LFxuICAgIH0pKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgIGNvbnN0IGRhdGVGb3JtYXRzID0gW1xuICAgICAgJ2xvY2FsJyxcbiAgICAgICdpc28nLFxuICAgICAgJ21vbnRoLWRheS15ZWFyJyxcbiAgICAgICdkYXktbW9udGgteWVhcicsXG4gICAgICAneWVhci1tb250aC1kYXknLFxuICAgIF0ubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gU2V0dGluZ3MubG9va3VwRGF0ZUZvcm1hdCh2YWx1ZSkudmlzdWFsUGF0dGVybjtcbiAgICAgIGxldCBkZXNjcmlwdGlvbjtcbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbG9jYWwnOlxuICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ0xvY2FsIEZvcm1hdCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lzbyc6XG4gICAgICAgICAgZGVzY3JpcHRpb24gPSAnSVNPJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgtZGF5LXllYXInOlxuICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ01vbnRoL0RheS9ZZWFyJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGF5LW1vbnRoLXllYXInOlxuICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ0RheS9Nb250aC9ZZWFyJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneWVhci1tb250aC1kYXknOlxuICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ1llYXIvTW9udGgvRGF5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgdmFsdWUsIGxhYmVsOiBgJHtkZXNjcmlwdGlvbn06ICR7Zm9ybWF0fWAgfTtcbiAgICB9KTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRm9ybUNvbnRyb2woe1xuICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICBpZDogJ3NldHRpbmdzLWRhdGUtZm9ybWF0JyxcbiAgICAgIG5hbWU6ICdzZXR0aW5ncy1kYXRlLWZvcm1hdCcsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1zZWxlY3QnXSxcbiAgICAgIGxhYmVsOiB7IHZhbHVlOiAnRGF0ZSBGb3JtYXQnLCBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1sYWJlbCddIH0sXG4gICAgICBjb250YWluZXI6IHsgY2xhc3NMaXN0OiBbJ2Zvcm0taW5wdXQtY29udGFpbmVyJ10gfSxcbiAgICAgIG1lbnVJdGVtczogZGF0ZUZvcm1hdHMsXG4gICAgfSkpO1xuXG4gICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtY29udGFpbmVyJyk7XG5cbiAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwnKTtcbiAgICBsYWJlbC50ZXh0Q29udGVudCA9ICdBZGRpdGlvbmFsIE9wdGlvbnMnO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICBjb25zdCBvcHRpb25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBvcHRpb25Db250YWluZXIuY2xhc3NMaXN0LmFkZCgnZm9ybS1pbnB1dC1pdGVtLWNvbnRhaW5lcicpO1xuICAgIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgaWQ6ICdzZXR0aW5ncy1kZWxldGUtb2xkLXRhc2tzJyxcbiAgICAgIG5hbWU6ICdzZXR0aW5ncy1kZWxldGUtdGFza3MnLFxuICAgICAgdmFsdWU6ICdkZWxldGUtb2xkJyxcbiAgICB9KSk7XG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwtaW5saW5lJyk7XG4gICAgbGFiZWwuaHRtbEZvciA9ICdzZXR0aW5ncy1kZWxldGUtb2xkLXRhc2tzJztcbiAgICBsYWJlbC50ZXh0Q29udGVudCA9ICdEZWxldGUgY29tcGxldGVkIHRhc2tzIGFmdGVyICc7XG4gICAgb3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIG9wdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGlkOiAnc2V0dGluZ3MtZGVsZXRlLWFmdGVyJyxcbiAgICAgIG5hbWU6ICdzZXR0aW5ncy1kZWxldGUtYWZ0ZXInLFxuICAgICAgdmFsdWU6ICcxNCcsXG4gICAgICBjbGFzc0xpc3Q6IFsnZm9ybS1pbnB1dC1pbmxpbmUnLCAnZm9ybS1pbnB1dC1jb3VudCddLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgfSkpO1xuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBsYWJlbC5pZCA9ICdzZXR0aW5ncy1kZWxldGUtYWZ0ZXItbGFiZWwnO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Zvcm0taW5wdXQtbGFiZWwtaW5saW5lJyk7XG4gICAgbGFiZWwuaHRtbEZvciA9ICdzZXR0aW5ncy1kZWxldGUtYWZ0ZXInO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gJyBkYXlzJztcbiAgICBvcHRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG9wdGlvbkNvbnRhaW5lcik7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcbiAgICBwcml2YXRlcy5tb2RhbFN0YWNrID0gbW9kYWxTdGFjaztcblxuICAgIGNvbnN0IHsgY29udHJvbHMgfSA9IHByaXZhdGVzO1xuICAgIGNvbnRyb2xzLnNhdmVMb2NhbCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3Mtc2F2ZS1sb2NhbCcpO1xuICAgIGNvbnRyb2xzLnNhdmVOZXZlciA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3Mtc2F2ZS1uZXZlcicpO1xuICAgIGNvbnRyb2xzLmRhdGVGb3JtYXQgPSBwYXJlbnQucXVlcnlTZWxlY3RvcignI3NldHRpbmdzLWRhdGUtZm9ybWF0Jyk7XG4gICAgY29udHJvbHMuZGVsZXRlT2xkID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1kZWxldGUtb2xkLXRhc2tzJyk7XG4gICAgY29udHJvbHMuZGVsZXRlQWZ0ZXIgPSBwYXJlbnQucXVlcnlTZWxlY3RvcignI3NldHRpbmdzLWRlbGV0ZS1hZnRlcicpO1xuICAgIGNvbnRyb2xzLmRlbGV0ZUFmdGVyTGFiZWwgPSBwYXJlbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICcjc2V0dGluZ3MtZGVsZXRlLWFmdGVyLWxhYmVsJyxcbiAgICApO1xuXG4gICAgaW5pdEZvcm1WYWx1ZXModGhpcyk7XG4gICAgYWRkTGlzdGVuZXJzKHRoaXMpO1xuICB9XG5cbiAgY29uZmlybSgpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrcywgY29udHJvbHMsIHNldHRpbmdzIH0gPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG5cbiAgICBpZiAoIWNvbnRyb2xzLnNhdmVMb2NhbC5kaXNhYmxlZCkge1xuICAgICAgc2V0dGluZ3Muc3RvcmFnZU1ldGhvZCA9IGNvbnRyb2xzLnNhdmVMb2NhbC5jaGVja2VkID8gJ2xvY2FsJyA6ICdub25lJztcbiAgICB9XG5cbiAgICBzZXR0aW5ncy5zZXREYXRlRm9ybWF0KGNvbnRyb2xzLmRhdGVGb3JtYXQudmFsdWUpO1xuXG4gICAgaWYgKGNvbnRyb2xzLmRlbGV0ZU9sZC5jaGVja2VkKSB7XG4gICAgICBzZXR0aW5ncy5kZWxldGVBZnRlciA9IE51bWJlcihjb250cm9scy5kZWxldGVBZnRlci52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHRpbmdzLmRlbGV0ZUFmdGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tzLmNvbmZpcm0pIGNhbGxiYWNrcy5jb25maXJtKHNldHRpbmdzKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrcyB9ID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGlmIChjYWxsYmFja3MuY2FuY2VsKSBjYWxsYmFja3MuY2FuY2VsKCk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcbiAgICBjb25zdCB7IGNvbnRyb2xzLCBtb2RhbFN0YWNrIH0gPSBwcml2YXRlcztcblxuICAgIGlmIChjb250cm9scy5kZWxldGVPbGQuY2hlY2tlZCkge1xuICAgICAgaWYgKCFjb250cm9scy5kZWxldGVBZnRlci5yZXBvcnRWYWxpZGl0eSgpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQXNrIGZvciBjb25maXJtYXRpb24gd2hlbiBkaXNhYmxpbmcgbG9jYWwgc3RvcmFnZVxuICAgIGlmIChwcml2YXRlcy5jb25maXJtTm9TdG9yYWdlXG4gICAgICAmJiAhY29udHJvbHMuc2F2ZU5ldmVyLmRpc2FibGVkICYmIGNvbnRyb2xzLnNhdmVOZXZlci5jaGVja2VkKSB7XG4gICAgICBjb25zdCBtb2RhbCA9IG5ldyBDb25maXJtTW9kYWwoXG4gICAgICAgICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGlzYWJsZSBsb2NhbCBzdG9yYWdlPyBZb3VyIGRhdGEgd2lsbCBub3QgYmUgc2F2ZWQgaW4gdGhlIGJyb3dzZXIgYW5kIHdpbGwgYmUgbG9zdCBhZnRlciB5b3UgbGVhdmUgdGhpcyBwYWdlLicsXG4gICAgICAgIHtcbiAgICAgICAgICBjb25maXJtOiAoKSA9PiB7XG4gICAgICAgICAgICBwcml2YXRlcy5jb25maXJtTm9TdG9yYWdlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENsb3NlIHNldHRpbmdzIG1vZGFsXG4gICAgICAgICAgICAvLyBVc2luZyBzZXRUaW1lb3V0IHdpbGwgbGV0IHVzIHdhaXQgZm9yIHRoZSBjb25maXJtIG1vZGFsIHRvIGNsb3NlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG1vZGFsU3RhY2suY29uZmlybU1vZGFsKCkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9scy5zYXZlTG9jYWwuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBtb2RhbFN0YWNrLnNob3dNb2RhbChtb2RhbCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2V0dGluZ3NNb2RhbDtcbiIsIi8qKlxuICogRGVmaW5lcyB0aGUgW1BvcHVwTWVudV17QGxpbmsgbW9kdWxlOnBvcHVwTWVudX5Qb3B1cE1lbnV9IGNsYXNzLlxuICogQG1vZHVsZSBwb3B1cE1lbnVcbiAqL1xuXG4vKipcbiAqIE9iamVjdCBob2xkaW5nIHByaXZhdGUgbWVtYmVycyBmb3IgdGhlXG4gKiBbUG9wdXBNZW51XXtAbGluayBtb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX0gY2xhc3MuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX5wcml2YXRlc1xuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgZWxlbWVudCBpbiB0aGUgRE9NIHVuZGVyIHdoaWNoIHRoZVxuICogICBwb3B1cCBtZW51IHNob3VsZCBiZSBpbnNlcnRlZC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnBvcHVwTWVudX5Qb3B1cE1lbnV+bWVudUl0ZW1bXX0gbWVudUl0ZW1zIEFuIGFycmF5IG9mXG4gKiAgIG9iamVjdHMgc3BlY2lmeWluZyB0aGUgaXRlbXMgaW4gdGhlIG1lbnUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2FjdGl2ZUl0ZW1dIEhvbGRzIHRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIChmb2N1c2VkKSBtZW51XG4gKiAgIGl0ZW0sIGlmIGFueS5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IFtjb250YWluZXJdIFRoZSBjb250YWluZXIgZWxlbWVudCBob2xkaW5nIHRoZSBtZW51LlxuICogICBXaWxsIGJlIG51bGwgd2hlbiB0aGUgbWVudSBpcyBoaWRkZW4uXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbb3ZlcmxheV0gVGhlIGVsZW1lbnQgdGhhdCB3aWxsIG92ZXJsYXkgdGhlXG4gKiAgIGJhY2tncm91bmQgb2YgdGhlIG1lbnUuIFdpbGwgYmUgbnVsbCB3aGVuIHRoZSBtZW51IGlzIGhpZGRlbi5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnBvcHVwTWVudX5Qb3B1cE1lbnV+c2VsZWN0aW9uQ2FsbGJhY2t9IFtjYWxsYmFja10gSG9sZHNcbiAqICAgdGhlIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgbWVudSBpdGVtLiBUaGlzIHdpbGwgYmVcbiAqICAgbnVsbCB3aGVuIHRoZSBtZW51IGlzIGNsb3NlZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGV2ZW50TGlzdGVuZXIgQW4gZXZlbnQgbGlzdGVuZXIgdG8gbW9uaXRvclxuICogICBkb2N1bWVudC13aWRlIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHMuIE5lZWRzIHRvIGJlIHN0b3JlZCBzbyB0aGF0IGl0IGNhblxuICogICBiZSBsYXRlciByZW1vdmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzY3JvbGxUaW1lb3V0XSBBbiBpZGVudGlmaWVyIGZvciBhIHRpbWVvdXQgdXNlZCB0b1xuICogICBkZWJvdW5jZSBzY3JvbGwgZXZlbnRzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbc2Nyb2xsVGFyZ2V0XSBBbiBlbGVtZW50IHRvIG1vbml0b3IgZm9yIHNjcm9sbFxuICogICBldmVudHMuIElmIHRoZSBlbGVtZW50IGlzIHNjcm9sbGVkLCB0aGVuIHRoZSBwb3B1cCBtZW51IHdpbGwgYmUgY2xvc2VkLlxuICovXG5cbi8qKlxuICogSG9sZHMgcHJpdmF0ZSBkYXRhIGZvciB0aGUgW1BvcHVwTWVudV17QGxpbmsgbW9kdWxlOnBvcHVwTWVudX5Qb3B1cE1lbnV9XG4gKiBjbGFzcy5cbiAqIEB0eXBlIHtXZWFrTWFwfVxuICogQHNlZSBtb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX5wcml2YXRlc1xuICovXG5jb25zdCBwcml2YXRlTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogUG9zaXRpb24gdGhlIHBvcHVwIG1lbnUgYXQgYSBwYXJ0aWN1bGFyIGxvY2F0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvXG4gKiAgIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnBvcHVwTWVudX5Qb3B1cE1lbnV+cG9zaXRpb259IFtwb3NpdGlvbj17fV0gQW4gb2JqZWN0XG4gKiAgIHNwZWNpZnlpbmcgdGhlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBhdCB3aGljaCB0byBwbGFjZSB0aGUgbWVudS5cbiAqL1xuZnVuY3Rpb24gcG9zaXRpb25NZW51KGluc3RhbmNlLCBwb3NpdGlvbiA9IHt9KSB7XG4gIGNvbnN0IHsgY29udGFpbmVyIH0gPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICBsZXQgbGVmdCA9IDA7XG4gIGxldCB0b3AgPSAwO1xuICBpZiAocG9zaXRpb24ucmVmZXJlbmNlRWxlbWVudCkge1xuICAgIGNvbnN0IHJlY3QgPSBwb3NpdGlvbi5yZWZlcmVuY2VFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxlZnQgPSByZWN0LmxlZnQ7XG4gICAgdG9wID0gcmVjdC50b3AgKyByZWN0LmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoJ2xlZnQnIGluIHBvc2l0aW9uKSBsZWZ0ID0gcG9zaXRpb24ubGVmdDtcbiAgICBpZiAoJ3RvcCcgaW4gcG9zaXRpb24pIHRvcCA9IHBvc2l0aW9uLnRvcDtcbiAgfVxuXG4gIGNvbnN0IE1BUkdJTiA9IDQ7XG4gIGNvbnN0IGJvZHlXaWR0aCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG4gIGNvbnN0IGJvZHlIZWlnaHQgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICBpZiAobGVmdCArIHdpZHRoICsgTUFSR0lOID4gYm9keVdpZHRoKSBsZWZ0ID0gYm9keVdpZHRoIC0gKHdpZHRoICsgTUFSR0lOKTtcbiAgaWYgKHRvcCArIGhlaWdodCArIE1BUkdJTiA+IGJvZHlIZWlnaHQpIHRvcCA9IGJvZHlIZWlnaHQgLSAoaGVpZ2h0ICsgTUFSR0lOKTtcblxuICBpZiAobGVmdCA8IDApIGxlZnQgPSAwO1xuICBpZiAodG9wIDwgMCkgdG9wID0gMDtcblxuICBjb250YWluZXIuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICBjb250YWluZXIuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcbn1cblxuLyoqXG4gKiBTZWxlY3QgYW4gaXRlbSBpbiB0aGUgbWVudS5cbiAqIEBwYXJhbSB7bW9kdWxlOnBvcHVwTWVudX5Qb3B1cE1lbnV9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaCB0b1xuICogICBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBtZW51IGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdEl0ZW0oaW5zdGFuY2UsIGluZGV4KSB7XG4gIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KGluc3RhbmNlKTtcbiAgcHJpdmF0ZXMuY2FsbGJhY2socHJpdmF0ZXMubWVudUl0ZW1zW2luZGV4XS5pZCwgaW5kZXgpO1xuICBpbnN0YW5jZS5jbG9zZSgpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBpdGVtIEhUTUwgZWxlbWVudCBmb3IgYSBtZW51IGl0ZW0uXG4gKiBAcGFyYW0ge21vZHVsZTpwb3B1cE1lbnV+UG9wdXBNZW51fSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2ggdG9cbiAqICAgYXBwbHkgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbWVudSBpdGVtIHRvIGZpbmQuXG4gKiBAcmV0dXJucyB7P0hUTUxFbGVtZW50fSBUaGUgbGlzdCBpdGVtIGVsZW1lbnQgaWYgaXQgZXhpc3RzLCBvciBudWxsIGlmIGl0XG4gKiAgIGRvZXMgbm90LlxuICovXG5mdW5jdGlvbiBnZXRJdGVtKGluc3RhbmNlLCBpbmRleCkge1xuICBjb25zdCBzZWxlY3RvciA9IGAucG9wdXAtbWVudS1pdGVtW2RhdGEtaW5kZXg9XCIke2luZGV4fVwiXWA7XG4gIHJldHVybiBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuLyoqXG4gKiBGb2N1cyBhbiBpdGVtIGluIHRoZSBtZW51LlxuICogQHBhcmFtIHttb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvXG4gKiAgIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7P251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBtZW51IGl0ZW0gdG8gZm9jdXMuIElmIHNldCB0byBudWxsLFxuICogICB0aGVuIG5vIGZvY3VzIHdpbGwgYmUgc2V0IGFuZCBhbnkgZXhpc3RpbmcgZm9jdXMgaXMgY2xlYXJlZC5cbiAqL1xuZnVuY3Rpb24gZm9jdXNJdGVtKGluc3RhbmNlLCBpbmRleCkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIGlmIChpbmRleCA9PT0gcHJpdmF0ZXMuYWN0aXZlSXRlbSkgcmV0dXJuO1xuXG4gIGlmIChwcml2YXRlcy5hY3RpdmVJdGVtICE9PSBudWxsKSB7XG4gICAgY29uc3QgaXRlbSA9IGdldEl0ZW0oaW5zdGFuY2UsIHByaXZhdGVzLmFjdGl2ZUl0ZW0pO1xuICAgIGlmIChpdGVtKSBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgIHByaXZhdGVzLmFjdGl2ZUl0ZW0gPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICBjb25zdCBpdGVtID0gZ2V0SXRlbShpbnN0YW5jZSwgaW5kZXgpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBwcml2YXRlcy5hY3RpdmVJdGVtID0gaW5kZXg7XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBhIG1vdXNlIG9yIGtleWJvYXJkIGV2ZW50LlxuICogQHBhcmFtIHttb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX0gaW5zdGFuY2UgVGhlIGNsYXNzIGluc3RhbmNlIG9uIHdoaWNoIHRvXG4gKiAgIGFwcGx5IHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBldmVudCB0aGF0IG9jY3VycmVkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVFdmVudChpbnN0YW5jZSwgZXZlbnQpIHtcbiAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQoaW5zdGFuY2UpO1xuICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgLy8gQ2xvc2UgcG9wdXAgaWYgbW91c2Ugd2FzIGNsaWNrZWQgb3V0c2lkZVxuICAgICAgaWYgKCFwcml2YXRlcy5jb250YWluZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkgaW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2tleWRvd24nOiB7XG4gICAgICBsZXQgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgY2FzZSAnRXNjJzpcbiAgICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgICBpbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdTcGFjZWJhcic6XG4gICAgICAgICAgaWYgKHByaXZhdGVzLmFjdGl2ZUl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGVjdEl0ZW0oaW5zdGFuY2UsIHByaXZhdGVzLmFjdGl2ZUl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgIGNhc2UgJ1VwJzoge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHByaXZhdGVzLmFjdGl2ZUl0ZW07XG4gICAgICAgICAgY29uc3QgaXRlbUNvdW50ID0gcHJpdmF0ZXMubWVudUl0ZW1zLmxlbmd0aDtcbiAgICAgICAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgICAgICAgIGlmIChhY3RpdmUgIT09IG51bGwpIGluZGV4ID0gYWN0aXZlID4gMCA/IGFjdGl2ZSAtIDEgOiBpdGVtQ291bnQgLSAxO1xuICAgICAgICAgIGVsc2UgaWYgKGl0ZW1Db3VudCA+IDApIGluZGV4ID0gaXRlbUNvdW50IC0gMTtcbiAgICAgICAgICBmb2N1c0l0ZW0oaW5zdGFuY2UsIGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICBjYXNlICdEb3duJzoge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHByaXZhdGVzLmFjdGl2ZUl0ZW07XG4gICAgICAgICAgY29uc3QgaXRlbUNvdW50ID0gcHJpdmF0ZXMubWVudUl0ZW1zLmxlbmd0aDtcbiAgICAgICAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgICAgICAgIGlmIChhY3RpdmUgIT09IG51bGwpIGluZGV4ID0gYWN0aXZlIDwgaXRlbUNvdW50IC0gMSA/IGFjdGl2ZSArIDEgOiAwO1xuICAgICAgICAgIGVsc2UgaWYgKGl0ZW1Db3VudCA+IDApIGluZGV4ID0gMDtcbiAgICAgICAgICBmb2N1c0l0ZW0oaW5zdGFuY2UsIGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocHJldmVudERlZmF1bHQpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnc2Nyb2xsJzoge1xuICAgICAgaWYgKHByaXZhdGVzLnNjcm9sbFRpbWVvdXQpIGNsZWFyVGltZW91dChwcml2YXRlcy5zY3JvbGxUaW1lb3V0KTtcblxuICAgICAgcHJpdmF0ZXMuc2Nyb2xsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwcml2YXRlcy5zY3JvbGxUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5jb250YWlucyhwcml2YXRlcy5zY3JvbGxUYXJnZXQpKSBpbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgfSwgMTAwKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHBvcHVwIG1lbnUuXG4gKi9cbmNsYXNzIFBvcHVwTWVudSB7XG4gIC8qKlxuICAgKiBBbiBvYmplY3QgaG9sZGluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBwb3B1cCBtZW51LlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX5vcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IFtwYXJlbnQ9ZG9jdW1lbnQuYm9keV0gVGhlIHBhcmVudCBlbGVtZW50IGluIHRoZVxuICAgKiAgIERPTSB1bmRlciB3aGljaCB0aGUgcG9wdXAgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKiBAcHJvcGVydHkge21vZHVsZTpwb3B1cE1lbnV+UG9wdXBNZW51fm1lbnVJdGVtW119IFttZW51SXRlbXNdIEFuIGFycmF5IG9mXG4gICAqICAgb2JqZWN0cyBzcGVjaWZ5aW5nIHRoZSBpdGVtcyBpbiB0aGUgbWVudS5cbiAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gW2Nsb3NlSWZTY3JvbGxlZF0gSWYgcHJvdmlkZWQsIHRoZSBwb3B1cCBtZW51IHdpbGxcbiAgICogICBiZSBjbG9zZWQgd2hlbiB0aGUgZ2l2ZW4gZWxlbWVudCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBpcyBzY3JvbGxlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEEgbWVudSBpdGVtIGluIHRoZSBwb3B1cC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOnBvcHVwTWVudX5Qb3B1cE1lbnV+bWVudUl0ZW1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsIFRoZSB0ZXh0IGxhYmVsIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlXG4gICAqICAgbWVudS5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIEFuIGlkZW50aWZpZXIgZm9yIHRoZSBtZW51IGl0ZW0uIFRoaXMgd2lsbCBiZSBwYXNzZWRcbiAgICogICB0byBjYWxsYmFja3MuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblR5cGVdIFRoZSB0eXBlIG9mIGljb24gdG8gZGlzcGxheS4gVGhpcyBpbmRpY2F0ZXNcbiAgICogICB0aGUgaWNvbiB0byB1c2UgZnJvbSB0aGUgR29vZ2xlIE1hdGVyaWFsIEljb25zIGZvbnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgZGVzY3JpYmluZyBob3cgdGhlIHBvcHVwIHNob3VsZCBiZSBwb3NpdGlvbmVkLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX5wb3NpdGlvblxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2xlZnQ9MF0gVGhlIHBvc2l0aW9uIG9mIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHBvcHVwLCBpblxuICAgKiAgIHBpeGVscywgcmVsYXRpdmUgdG8gdGhlIGxlZnQgZWRnZSBvZiB0aGUgZG9jdW1lbnQuIFRoaXMgcHJvcGVydHkgaXNcbiAgICogICBpZ25vcmVkIGlmIHRoZSByZWZlcmVuY2VFbGVtZW50IHByb3BlcnR5IGlzIHNldC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0b3A9MF0gVGhlIHBvc2l0aW9uIG9mIHRoZSB0b3Agb2YgdGhlIHBvcHVwLCBpblxuICAgKiAgIHBpeGVscywgcmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGUgZG9jdW1lbnQuIFRoaXMgcHJvcGVydHkgaXMgaWdub3JlZCBpZlxuICAgKiAgIHRoZSByZWZlcmVuY2VFbGVtZW50IHByb3BlcnR5IGlzIHNldC5cbiAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gW3JlZmVyZW5jZUVsZW1lbnRdIEFuIGVsZW1lbnQgaW4gdGhlIERPTSB3aG9zZVxuICAgKiAgIHBvc2l0aW9uIGlzIHRvIGJlIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wdXAuIElmXG4gICAqICAgZ2l2ZW4sIHRoZSBwb3B1cCB3aWxsIGJlIHBvc2l0aW9uZWQganVzdCB1bmRlcm5lYXRoIHRoZSBlbGVtZW50LlxuICAgKi9cblxuICAvKipcbiAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBtZW51XG4gICAqIGl0ZW0uXG4gICAqIEBjYWxsYmFjayBtb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX5zZWxlY3Rpb25DYWxsYmFja1xuICAgKiBAcGFyYW0gaXRlbUlkIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBtZW51IGl0ZW0gdGhhdCB3YXMgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG1lbnUgaXRlbSB0aGF0IHdhcyBzZWxlY3RlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBvcHVwIG1lbnUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnBvcHVwTWVudX5Qb3B1cE1lbnV+b3B0aW9uc30gW29wdGlvbnM9e31dIEFuIG9iamVjdCBob2xkaW5nXG4gICAqICAgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcG9wdXAgbWVudS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZhdGVzID0ge1xuICAgICAgcGFyZW50OiBvcHRpb25zLnBhcmVudCB8fCBkb2N1bWVudC5ib2R5LFxuICAgICAgbWVudUl0ZW1zOiBvcHRpb25zLm1lbnVJdGVtcyB8fCBbXSxcbiAgICAgIGFjdGl2ZUl0ZW06IG51bGwsXG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICBldmVudExpc3RlbmVyOiAoZSkgPT4gaGFuZGxlRXZlbnQodGhpcywgZSksXG4gICAgICBzY3JvbGxUaW1lb3V0OiBudWxsLFxuICAgICAgc2Nyb2xsVGFyZ2V0OiBvcHRpb25zLmNsb3NlSWZTY3JvbGxlZCB8fCBudWxsLFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhlIHBvcHVwIG1lbnUgaXMgY3VycmVudGx5IG9wZW4uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwb3B1cCBtZW51IGlzIG9wZW4sIG9yIGZhbHNlIGlmIGl0IGlzXG4gICAqICAgY2xvc2VkLlxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiBwcml2YXRlTWVtYmVycy5nZXQodGhpcykuY29udGFpbmVyICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIHBvcHVwIG1lbnUgYXQgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge21vZHVsZTpwb3B1cE1lbnV+UG9wdXBNZW51fnNlbGVjdGlvbkNhbGxiYWNrfSBjYWxsYmFjayBBIGNhbGxiYWNrXG4gICAqICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgdXNlciBjaG9vc2VzIGEgbWVudSBpdGVtLlxuICAgKiBAcGFyYW0ge21vZHVsZTpwb3B1cE1lbnV+UG9wdXBNZW51fnBvc2l0aW9ufSBbcG9zaXRpb25dIEFuIG9iamVjdFxuICAgKiAgIHNwZWNpZnlpbmcgdGhlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBhdCB3aGljaCB0byBwbGFjZSB0aGUgbWVudS4gSWZcbiAgICogICBub3QgZ2l2ZW4sIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgZG9jdW1lbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgb3BlbihjYWxsYmFjaywgcG9zaXRpb24pIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcbiAgICBpZiAocHJpdmF0ZXMuY29udGFpbmVyKSB0aGlzLmNsb3NlKCk7XG4gICAgaWYgKHByaXZhdGVzLm1lbnVJdGVtcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGNvbnN0IG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ3BvcHVwLW1lbnUtb3ZlcmxheScpO1xuICAgIHByaXZhdGVzLnBhcmVudC5hcHBlbmRDaGlsZChvdmVybGF5KTtcbiAgICBwcml2YXRlcy5vdmVybGF5ID0gb3ZlcmxheTtcblxuICAgIGNvbnN0IG1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBtZW51LmNsYXNzTGlzdC5hZGQoJ3BvcHVwLW1lbnUnKTtcblxuICAgIGNvbnN0IGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgIG1lbnUuYXBwZW5kQ2hpbGQobGlzdCk7XG4gICAgcHJpdmF0ZXMubWVudUl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBsaXN0SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICBsaXN0SXRlbS5jbGFzc0xpc3QuYWRkKCdwb3B1cC1tZW51LWl0ZW0nKTtcbiAgICAgIGxpc3RJdGVtLmRhdGFzZXQuaW5kZXggPSBpbmRleC50b1N0cmluZygpO1xuICAgICAgbGlzdC5hcHBlbmRDaGlsZChsaXN0SXRlbSk7XG5cbiAgICAgIGNvbnN0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGljb24uY2xhc3NMaXN0LmFkZCgnaWNvbicsICdtYXRlcmlhbC1pY29ucycsICdwb3B1cC1tZW51LWl0ZW0taWNvbicpO1xuICAgICAgaWNvbi50ZXh0Q29udGVudCA9IGl0ZW0uaWNvblR5cGU7XG4gICAgICBsaXN0SXRlbS5hcHBlbmRDaGlsZChpY29uKTtcblxuICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ3BvcHVwLW1lbnUtaXRlbS1sYWJlbCcpO1xuICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsO1xuICAgICAgbGlzdEl0ZW0uYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgICBsaXN0SXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHNlbGVjdEl0ZW0odGhpcywgaW5kZXgpKTtcbiAgICAgIGxpc3RJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsICgpID0+IGZvY3VzSXRlbSh0aGlzLCBpbmRleCkpO1xuICAgIH0pO1xuXG4gICAgbWVudS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4gZm9jdXNJdGVtKHRoaXMsIG51bGwpKTtcblxuICAgIHByaXZhdGVzLmNvbnRhaW5lciA9IG1lbnU7XG4gICAgcHJpdmF0ZXMucGFyZW50LmFwcGVuZENoaWxkKG1lbnUpO1xuICAgIHByaXZhdGVzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBwb3NpdGlvbk1lbnUodGhpcywgcG9zaXRpb24pO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgcHJpdmF0ZXMuZXZlbnRMaXN0ZW5lcik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHByaXZhdGVzLmV2ZW50TGlzdGVuZXIpO1xuICAgIGlmIChwcml2YXRlcy5zY3JvbGxUYXJnZXQpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHByaXZhdGVzLmV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgcG9wdXAgbWVudSBpZiBpdCBpcyBvcGVuLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgaWYgKHByaXZhdGVzLmNvbnRhaW5lcikge1xuICAgICAgcHJpdmF0ZXMucGFyZW50LnJlbW92ZUNoaWxkKHByaXZhdGVzLmNvbnRhaW5lcik7XG4gICAgICBwcml2YXRlcy5wYXJlbnQucmVtb3ZlQ2hpbGQocHJpdmF0ZXMub3ZlcmxheSk7XG4gICAgICBwcml2YXRlcy5hY3RpdmVJdGVtID0gbnVsbDtcbiAgICAgIHByaXZhdGVzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICBwcml2YXRlcy5vdmVybGF5ID0gbnVsbDtcbiAgICAgIHByaXZhdGVzLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHByaXZhdGVzLmV2ZW50TGlzdGVuZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHByaXZhdGVzLmV2ZW50TGlzdGVuZXIpO1xuICAgICAgaWYgKHByaXZhdGVzLnNjcm9sbFRhcmdldCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBwcml2YXRlcy5ldmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBzdGF0ZSBvZiB0aGUgcG9wdXA6IGlmIHRoZSBtZW51IGlzIGNsb3NlZCwgaXQgd2lsbCBiZSBvcGVuZWQuXG4gICAqIElmIHRoZSBtZW51IGlzIG9wZW4sIGl0IHdpbGwgYmUgY2xvc2VkLlxuICAgKiBAcGFyYW0ge21vZHVsZTpwb3B1cE1lbnV+UG9wdXBNZW51fnNlbGVjdGlvbkNhbGxiYWNrfSBjYWxsYmFjayBBIGNhbGxiYWNrXG4gICAqICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgdXNlciBjaG9vc2VzIGEgbWVudSBpdGVtLlxuICAgKiBAcGFyYW0ge21vZHVsZTpwb3B1cE1lbnV+UG9wdXBNZW51fnBvc2l0aW9ufSBbcG9zaXRpb25dIEFuIG9iamVjdFxuICAgKiAgIHNwZWNpZnlpbmcgdGhlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBhdCB3aGljaCB0byBwbGFjZSB0aGUgbWVudS4gSWZcbiAgICogICBub3QgZ2l2ZW4sIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgZG9jdW1lbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgdG9nZ2xlKGNhbGxiYWNrLCBwb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB0aGlzLmNsb3NlKCk7XG4gICAgZWxzZSB0aGlzLm9wZW4oY2FsbGJhY2ssIHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1lbnUgaXRlbXMgdGhhdCB3aWxsIGJlIHNob3duIHRoZSBuZXh0IHRpbWUgdGhlIHBvcHVwIG1lbnUgaXNcbiAgICogb3BlbmVkLiBJZiB0aGUgcG9wdXAgbWVudSBpcyBjdXJyZW50bHkgb3BlbiwgdGhlIGRpc3BsYXllZCBpdGVtcyB3aWxsIG5vdFxuICAgKiBiZSBhbHRlcmVkIHVudGlsIHRoZSBtZW51IGlzIHJlb3BlbmVkLlxuICAgKiBAcGFyYW0ge21vZHVsZTpwb3B1cE1lbnV+UG9wdXBNZW51fm1lbnVJdGVtW119IG1lbnVJdGVtcyBUaGUgYXJyYXkgb2YgbWVudVxuICAgKiAgIGl0ZW1zLlxuICAgKi9cbiAgc2V0TWVudUl0ZW1zKG1lbnVJdGVtcykge1xuICAgIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5tZW51SXRlbXMgPSBtZW51SXRlbXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9wdXBNZW51O1xuIiwiLyoqXG4gKiBEZWZpbmVzIHRoZSBbUHJvamVjdF17QGxpbmsgbW9kdWxlOnByb2plY3R+UHJvamVjdH0gY2xhc3MuXG4gKiBAbW9kdWxlIHByb2plY3RcbiAqL1xuXG4vKipcbiAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGEgdXNlciBwcm9qZWN0LlxuICovXG5jbGFzcyBQcm9qZWN0IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHByb2plY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIEFuIG9iamVjdCBob2xkaW5nIGFkZGl0aW9uYWwgcHJvamVjdCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dIEEgZGVzY3JpcHRpb24gZm9yIHRoZSBwcm9qZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogQSBkZXNjcmlwdGlvbiBmb3IgdGhlIHByb2plY3QuXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb24gPz8gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwcm9qZWN0IGZyb20gYSBKU09OIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIEpTT04gb2JqZWN0IGhvbGRpbmcgdGhlIHNlcmlhbGl6ZWQgZGF0YS5cbiAgICogQHJldHVybnMge21vZHVsZTpwcm9qZWN0flByb2plY3R9IEEgbmV3IHByb2plY3QgY29udmVydGVkIGZyb20gdGhlIEpTT05cbiAgICogICBkYXRhLlxuICAgKi9cbiAgc3RhdGljIGZyb21Kc29uKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFByb2plY3QoZGF0YS5uYW1lLCB7IGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3Q7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtQcm9qZWN0TGlzdF17QGxpbmsgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fSBjbGFzcy5cbiAqIEBtb2R1bGUgcHJvamVjdExpc3RcbiAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgdjQgYXMgZ2VuZXJhdGVVdWlkIH0gZnJvbSAndXVpZCc7XG5cbmltcG9ydCBQcm9qZWN0IGZyb20gJy4vcHJvamVjdCc7XG5pbXBvcnQgeyBnZXRKc29uVHlwZSwgaXNVdWlkVmFsaWQsIHZhbGlkYXRlVmFsdWUgfSBmcm9tICcuL3V0aWxpdHkvZGF0YSc7XG5cbi8qKlxuICogT2JqZWN0IGhvbGRpbmcgcHJpdmF0ZSBtZW1iZXJzIGZvciB0aGVcbiAqIFtQcm9qZWN0TGlzdF17QGxpbmsgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fSBjbGFzcy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH5wcml2YXRlc1xuICogQHByb3BlcnR5IHttb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R+cHJvamVjdFdyYXBwZXJbXX0gcHJvamVjdHMgQW5cbiAqICAgYXJyYXkgb2YgcHJvamVjdHMuIEVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgYSB3cmFwcGVyIHRoYXQgaG9sZHMgdGhlXG4gKiAgIHByb2plY3QgYWxvbmcgd2l0aCBpdHMgdW5pcXVlIGlkZW50aWZpZXIuXG4gKiBAcHJvcGVydHkge21vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH5ldmVudEVtaXR0ZXJ9IEhvbGRzIHRoZSBldmVudFxuICogICBlbWl0dGVyIHdoaWNoIGRpc3BhdGNoZXMgZXZlbnRzIHRvIGF0dGFjaGVkIGxpc3RlbmVycy5cbiAqL1xuXG4vKipcbiAqIEhvbGRzIHByaXZhdGUgZGF0YSBmb3IgdGhlXG4gKiBbUHJvamVjdExpc3Rde0BsaW5rIG1vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH0gY2xhc3MuXG4gKiBAdHlwZSB7V2Vha01hcH1cbiAqIEBzZWUgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fnByaXZhdGVzXG4gKi9cbmNvbnN0IHByaXZhdGVNZW1iZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBHZXQgYSBwcm9qZWN0J3MgaW5kZXggaW4gdGhlIHByb2plY3QgbGlzdC5cbiAqIEBwYXJhbSB7bW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fSBpbnN0YW5jZSBUaGUgY2xhc3MgaW5zdGFuY2Ugb24gd2hpY2hcbiAqICAgdG8gYXBwbHkgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgcHJvamVjdCB0byBsb29rIHVwLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBwcm9qZWN0LCBvciAtMSBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChpbnN0YW5jZSwgaWQpIHtcbiAgcmV0dXJuIHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSkucHJvamVjdHMuZmluZEluZGV4KChlbnRyeSkgPT4gKFxuICAgIGVudHJ5LmlkID09PSBpZFxuICApKTtcbn1cblxuLyoqXG4gKiBIb2xkcyBhIGxpc3Qgb2YgcHJvamVjdHMuXG4gKi9cbmNsYXNzIFByb2plY3RMaXN0IHtcbiAgLyoqXG4gICAqIFdyYXBwZXIgb2JqZWN0IGhvbGRpbmcgYSBwcm9qZWN0IGFsb25nIHdpdGggaXRzIFVVSUQuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH5wcm9qZWN0V3JhcHBlclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcHJvamVjdC5cbiAgICogQHByb3BlcnR5IHttb2R1bGU6cHJvamVjdH5Qcm9qZWN0fSBwcm9qZWN0IFRoZSBwcm9qZWN0IGluc3RhbmNlLlxuICAgKi9cblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIGEgcHJvamVjdCBpcyBhZGRlZCB0byB0aGUgcHJvamVjdCBsaXN0LlxuICAgKiBAZXZlbnQgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fmFkZFByb2plY3RcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGU6ICdhZGQtcHJvamVjdCcuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIG5ld2x5LWFkZGVkIHByb2plY3QuXG4gICAqIEBwcm9wZXJ0eSB7bW9kdWxlOnByb2plY3R+UHJvamVjdH0gcHJvamVjdCBBIGNvcHkgb2YgdGhlIG5ld2x5LWFkZGVkXG4gICAqICAgcHJvamVjdC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBhIHByb2plY3QgaW4gdGhlIGxpc3QgaXMgbW9kaWZpZWQuXG4gICAqIEBldmVudCBtb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R+dXBkYXRlUHJvamVjdFxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZTogJ3VwZGF0ZS1wcm9qZWN0Jy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHVwZGF0ZWQgcHJvamVjdC5cbiAgICogQHByb3BlcnR5IHttb2R1bGU6cHJvamVjdH5Qcm9qZWN0fSBwcm9qZWN0IEEgY29weSBvZiB0aGUgdXBkYXRlZCBwcm9qZWN0LlxuICAgKi9cblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIGEgcHJvamVjdCBpbiB0aGUgbGlzdCBpcyBkZWxldGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fmRlbGV0ZVByb2plY3RcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGU6ICdkZWxldGUtcHJvamVjdCcuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBkZWxldGVkIHByb2plY3QuXG4gICAqIEBwcm9wZXJ0eSB7bW9kdWxlOnByb2plY3R+UHJvamVjdH0gcHJvamVjdCBBIGNvcHkgb2YgdGhlIGRlbGV0ZWQgcHJvamVjdC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGF0dXMgb2YgYSBkYXRhIGltcG9ydC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fmltcG9ydFN0YXR1c1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gcHJvamVjdHMgQW4gb2JqZWN0IGhvbGRpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG51bWJlclxuICAgKiAgIG9mIHByb2plY3RzIHRoYXQgd2VyZSBpbXBvcnRlZC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2plY3RzLmFkZGVkIFRoZSBudW1iZXIgb2YgbmV3IHByb2plY3RzIHRoYXQgd2VyZVxuICAgKiAgIGFkZGVkIHRvIHRoZSBwcm9qZWN0IGxpc3QuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9qZWN0cy51cGRhdGVkIFRoZSBudW1iZXIgb2YgZXhpc3RpbmcgcHJvamVjdHMgaW4gdGhlXG4gICAqICAgcHJvamVjdCBsaXN0IHRoYXQgd2VyZSB1cGRhdGVkLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcHJvamVjdHMuZmFpbGVkIFRoZSBudW1iZXIgb2YgcHJvamVjdHMgdGhhdCBmYWlsZWQgdG9cbiAgICogICBpbXBvcnQuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9qZWN0cy50b3RhbCBUaGUgdG90YWwgbnVtYmVyIG9mIHByb2plY3RzIHRoYXQgd2VyZVxuICAgKiAgIHByb2Nlc3NlZC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZXJyb3JzIEFuIGFycmF5IG9mIGVycm9yIG1lc3NhZ2VzIGRlc2NyaWJpbmcgYW55XG4gICAqICAgZXJyb3JzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoZSBpbXBvcnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwcm9qZWN0IGxpc3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHtcbiAgICAgIHByb2plY3RzOiBbXSxcbiAgICAgIGV2ZW50RW1pdHRlcjogbmV3IEV2ZW50RW1pdHRlcigpLFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBwcm9qZWN0IGluIHRoZSBwcm9qZWN0IGxpc3QuIFRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyBhIGNvcHkgb2YgdGhlXG4gICAqIHByb2plY3QsIG5vdCBhbiBhY3R1YWwgcmVmZXJlbmNlIHRvIHRoZSBwcm9qZWN0IGl0c2VsZi4gVG8gbW9kaWZ5IGFcbiAgICogcHJvamVjdCBpbiB0aGUgbGlzdCwgdXNlIHRoZVxuICAgKiBbdXBkYXRlUHJvamVjdF17QGxpbmsgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0I3VwZGF0ZVByb2plY3R9XG4gICAqIG1ldGhvZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcHJvamVjdCB0byByZXRyaWV2ZS5cbiAgICogQHJldHVybnMgez9tb2R1bGU6cHJvamVjdH5Qcm9qZWN0fSBUaGUgcmVxdWVzdGVkIHByb2plY3QsIG9yIHVuZGVmaW5lZCBpZlxuICAgKiAgIGl0IGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAgICovXG4gIGdldFByb2plY3QoaWQpIHtcbiAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleCh0aGlzLCBpZCk7XG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBfLmNsb25lRGVlcChwcml2YXRlTWVtYmVycy5nZXQodGhpcykucHJvamVjdHNbaW5kZXhdLnByb2plY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHByb2plY3QgaW4gdGhlIHByb2plY3QgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcHJvamVjdCB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpwcm9qZWN0flByb2plY3R9IHByb2plY3QgVGhlIG5ldyBwcm9qZWN0IHRvIGFzc29jaWF0ZSB3aXRoXG4gICAqICAgdGhlIGdpdmVuIGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb2plY3Qgd2FzIHJlcGxhY2VkIHN1Y2Nlc3NmdWxseSxcbiAgICogICBvciBmYWxzZSBpZiB0aGUgZ2l2ZW4gaWRlbnRpZmllciBpcyBpbnZhbGlkLlxuICAgKiBAZmlyZXMgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fnVwZGF0ZVByb2plY3RcbiAgICovXG4gIHVwZGF0ZVByb2plY3QoaWQsIHByb2plY3QpIHtcbiAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleCh0aGlzLCBpZCk7XG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgY29uc3Qgd3JhcHBlciA9IHByaXZhdGVzLnByb2plY3RzW2luZGV4XTtcbiAgICBjb25zdCBuZWVkU29ydCA9IHByb2plY3QubmFtZSAhPT0gd3JhcHBlci5wcm9qZWN0Lm5hbWU7XG4gICAgd3JhcHBlci5wcm9qZWN0ID0gXy5jbG9uZURlZXAocHJvamVjdCk7XG5cbiAgICBpZiAobmVlZFNvcnQpIHtcbiAgICAgIHByaXZhdGVzLnByb2plY3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBjb25zdCBpbnNlcnRBdCA9IF8uc29ydGVkSW5kZXhCeShcbiAgICAgICAgcHJpdmF0ZXMucHJvamVjdHMsXG4gICAgICAgIHdyYXBwZXIsXG4gICAgICAgIChlbGVtKSA9PiBlbGVtLnByb2plY3QubmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgKTtcbiAgICAgIHByaXZhdGVzLnByb2plY3RzLnNwbGljZShpbnNlcnRBdCwgMCwgd3JhcHBlcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3VwZGF0ZS1wcm9qZWN0Jywge1xuICAgICAgdHlwZTogJ3VwZGF0ZS1wcm9qZWN0JyxcbiAgICAgIGlkLFxuICAgICAgcHJvamVjdDogXy5jbG9uZURlZXAocHJvamVjdCksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb3IgdXBkYXRlIGEgcHJvamVjdC4gSWYgYSBwcm9qZWN0IHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXIgZXhpc3RzLFxuICAgKiB0aGVuIGl0IGlzIHJlcGxhY2VkIHdpdGggdGhlIGdpdmVuIHByb2plY3QuIE90aGVyd2lzZSwgdGhlIHByb2plY3QgaXNcbiAgICogYWRkZWQgdG8gdGhlIGxpc3QgYXMgYSBuZXcgcHJvamVjdC4gSWYgdGhlIGdpdmVuIGlkZW50aWZpZXIgaXMgbm90IGEgdmFsaWRcbiAgICogVVVJRCwgdGhlbiB0aGUgbWV0aG9kIHJldHVybnMgZmFsc2UgYW5kIG5vdGhpbmcgaGFwcGVucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcHJvamVjdC5cbiAgICogQHBhcmFtIHttb2R1bGU6cHJvamVjdH5Qcm9qZWN0fSBwcm9qZWN0IFRoZSBwcm9qZWN0IHRoYXQgc2hvdWxkIGJlIGFkZGVkXG4gICAqICAgb3Igd2l0aCB3aGljaCBhbiBleGlzdGluZyBwcm9qZWN0IHNob3VsZCBiZSByZXBsYWNlZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb2plY3Qgd2FzIHN1Y2Nlc3NmdWxseSBhZGRlZCBvciB1cGRhdGVkLFxuICAgKiAgIG9yIGZhbHNlIGlmIHRoZSBnaXZlbiBpZGVudGlmaWVyIGlzIG5vdCBhIHZhbGlkIFVVSUQuXG4gICAqIEBmaXJlcyBtb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R+YWRkUHJvamVjdFxuICAgKiBAZmlyZXMgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fnVwZGF0ZVByb2plY3RcbiAgICovXG4gIGFkZE9yVXBkYXRlUHJvamVjdChpZCwgcHJvamVjdCkge1xuICAgIGlmICghaXNVdWlkVmFsaWQoaWQpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMudXBkYXRlUHJvamVjdChpZCwgcHJvamVjdCkpIHtcbiAgICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgICAgY29uc3QgdmFsdWUgPSB7IGlkLCBwcm9qZWN0OiBfLmNsb25lRGVlcChwcm9qZWN0KSB9O1xuXG4gICAgICAvLyBNYWludGFpbiBzb3J0IG9yZGVyIG9uIGluc2VydGlvblxuICAgICAgY29uc3QgaW5kZXggPSBfLnNvcnRlZEluZGV4QnkoXG4gICAgICAgIHByaXZhdGVzLnByb2plY3RzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgKGVsZW0pID0+IGVsZW0ucHJvamVjdC5uYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICApO1xuXG4gICAgICBwcml2YXRlcy5wcm9qZWN0cy5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcblxuICAgICAgcHJpdmF0ZXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2FkZC1wcm9qZWN0Jywge1xuICAgICAgICB0eXBlOiAnYWRkLXByb2plY3QnLFxuICAgICAgICBpZCxcbiAgICAgICAgcHJvamVjdDogXy5jbG9uZURlZXAocHJvamVjdCksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwcm9qZWN0IHRvIHRoZSBsaXN0LiBJbiBvcmRlciB0byBwcmV2ZW50IHVuaW50ZW50aW9uYWwgZXh0ZXJuYWxcbiAgICogbW9kaWZpY2F0aW9uIG9mIHRoZSBwcm9qZWN0LCBhIGRlZXAgY29weSBpcyBtYWRlLCBhbmQgdGhlIG9yaWdpbmFsIG9iamVjdFxuICAgKiBpcyBub3Qga2VwdC5cbiAgICogQHBhcmFtIHttb2R1bGU6cHJvamVjdH5Qcm9qZWN0fSBwcm9qZWN0IFRoZSBwcm9qZWN0IHRvIGFkZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGlkZW50aWZpZXIgb2YgdGhlIG5ld2x5LWFkZGVkIHByb2plY3QuXG4gICAqIEBmaXJlcyBtb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R+YWRkUHJvamVjdFxuICAgKi9cbiAgYWRkUHJvamVjdChwcm9qZWN0KSB7XG4gICAgLy8gR2VuZXJhdGUgVVVJRCAobG9vcCBpbiBjYXNlIG9mIGNvbGxpc2lvbilcbiAgICBsZXQgaWQ7XG4gICAgZG8ge1xuICAgICAgaWQgPSBnZW5lcmF0ZVV1aWQoKTtcbiAgICB9IHdoaWxlICh0aGlzLmhhc1Byb2plY3QoaWQpKTtcblxuICAgIHRoaXMuYWRkT3JVcGRhdGVQcm9qZWN0KGlkLCBwcm9qZWN0KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgcHJvamVjdCBmcm9tIHRoZSBwcm9qZWN0IGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJvamVjdCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb2plY3Qgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLFxuICAgKiAgIG9yIGZhbHNlIGlmIGFuIGludmFsaWQgaWRlbnRpZmllciB3YXMgZ2l2ZW4uXG4gICAqIEBmaXJlcyBtb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R+ZGVsZXRlUHJvamVjdFxuICAgKi9cbiAgZGVsZXRlUHJvamVjdChpZCkge1xuICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHRoaXMsIGlkKTtcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcblxuICAgIGNvbnN0IHsgcHJvamVjdCB9ID0gcHJpdmF0ZXMucHJvamVjdHNbaW5kZXhdO1xuICAgIHByaXZhdGVzLnByb2plY3RzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBwcml2YXRlcy5ldmVudEVtaXR0ZXIuZW1pdCgnZGVsZXRlLXByb2plY3QnLCB7XG4gICAgICB0eXBlOiAnZGVsZXRlLXByb2plY3QnLFxuICAgICAgaWQsXG4gICAgICBwcm9qZWN0LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFsbCBwcm9qZWN0cyBmcm9tIHRoZSBwcm9qZWN0IGxpc3QuXG4gICAqIEBmaXJlcyBtb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R+ZGVsZXRlUHJvamVjdFxuICAgKi9cbiAgZGVsZXRlQWxsKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IHByb2plY3RzID0gWy4uLnByaXZhdGVzLnByb2plY3RzXTtcblxuICAgIHByaXZhdGVzLnByb2plY3RzLmxlbmd0aCA9IDA7XG5cbiAgICBwcm9qZWN0cy5mb3JFYWNoKCh7IGlkLCBwcm9qZWN0IH0pID0+IHtcbiAgICAgIHByaXZhdGVzLmV2ZW50RW1pdHRlci5lbWl0KCdkZWxldGUtcHJvamVjdCcsIHtcbiAgICAgICAgdHlwZTogJ2RlbGV0ZS1wcm9qZWN0JyxcbiAgICAgICAgaWQsXG4gICAgICAgIHByb2plY3QsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBwcm9qZWN0IHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXIgZXhpc3RzIHdpdGhpbiB0aGVcbiAgICogcHJvamVjdCBsaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBwcm9qZWN0IHRvIGxvb2sgZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvamVjdCBleGlzdHMsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBoYXNQcm9qZWN0KGlkKSB7XG4gICAgcmV0dXJuIGZpbmRJbmRleCh0aGlzLCBpZCkgPj0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBvbiBlYWNoIHByb2plY3QgaW4gdGhlIGxpc3QuIE5vdGUgdGhhdCB0aGVcbiAgICogcHJvamVjdCBpbnN0YW5jZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIG9ubHkgYSBjb3B5IG9mIHRoZVxuICAgKiBwcm9qZWN0IGluIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHByb2plY3QuIFRoZVxuICAgKiAgIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFcbiAgICogICBbd3JhcHBlcl17QGxpbmsgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fnByb2plY3RXcmFwcGVyfVxuICAgKiAgIGNvbnRhaW5pbmcgdGhlIHByb2plY3QgYW5kIGl0cyBpZGVudGlmaWVyLiBUaGUgZnVuY3Rpb24gY2FuIGFsc29cbiAgICogICBvcHRpb25hbGx5IGFjY2VwdCB0aGUgaW5kZXggb2YgdGhlIHByb2plY3QgaW4gdGhlIGxpc3QgYXMgaXRzIHNlY29uZFxuICAgKiAgIGFyZ3VtZW50LlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5wcm9qZWN0cy5mb3JFYWNoKChwcm9qZWN0LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY29weSA9IF8uY2xvbmVEZWVwKHByb2plY3QpO1xuICAgICAgY2FsbGJhY2soY29weSwgaW5kZXgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgcHJvamVjdCBsaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGVcbiAgICogICBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmV2ZW50RW1pdHRlci5vbih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBkYXRhIHRvIGFuIG9iamVjdCBzdWl0YWJsZSBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBzZXJpYWxpemFibGUgZGF0YSBmb3IgdGhlIGNsYXNzLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHByb2plY3RzID0gW107XG4gICAgcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLnByb2plY3RzLmZvckVhY2goKHsgaWQsIHByb2plY3QgfSkgPT4ge1xuICAgICAgcHJvamVjdHMucHVzaCh7XG4gICAgICAgIG5hbWU6IHByb2plY3QubmFtZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBwcm9qZWN0LmRlc2NyaXB0aW9uLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2plY3RzO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcG9ydCBwcm9qZWN0cyBmcm9tIGEgSlNPTiBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBzZXJpYWxpemVkIEpTT04gb2JqZWN0IHRvIGltcG9ydC5cbiAgICogQHJldHVybnMge21vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH5pbXBvcnRTdGF0dXN9IEFuIG9iamVjdCBob2xkaW5nXG4gICAqICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXR1cyBvZiB0aGUgaW1wb3J0LlxuICAgKiBAZmlyZXMgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fmFkZFByb2plY3RcbiAgICogQGZpcmVzIG1vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH51cGRhdGVQcm9qZWN0XG4gICAqL1xuICBpbXBvcnRGcm9tSnNvbihkYXRhKSB7XG4gICAgY29uc3QgY291bnRzID0ge1xuICAgICAgYWRkZWQ6IDAsXG4gICAgICB1cGRhdGVkOiAwLFxuICAgICAgZmFpbGVkOiAwLFxuICAgICAgdG90YWw6IDAsXG4gICAgfTtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgZXJyb3JzLnB1c2goJ0Vycm9yOiBFeHBlY3RlZCBcInByb2plY3RzXCIgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkuJyk7XG4gICAgICByZXR1cm4geyBwcm9qZWN0czogY291bnRzLCBlcnJvcnMgfTtcbiAgICB9XG5cbiAgICBkYXRhLmZvckVhY2goKHsgbmFtZSwgaWQsIGRlc2NyaXB0aW9uIH0pID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yVHlwZSwgdmFsdWUsIG9wdHMpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgbXNnUHJlZml4ID0gYFdhcm5pbmc6IFByb2plY3QgXCIke25hbWV9XCJgO1xuICAgICAgICBsZXQgbXNnO1xuICAgICAgICBzd2l0Y2ggKGVycm9yVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2JhZC10eXBlJzpcbiAgICAgICAgICAgIG1zZyA9IGBFeHBlY3RlZCB0eXBlIFwiJHtvcHRzLmV4cGVjdGVkVHlwZX1cIiBmb3IgcHJvcGVydHkgXCIke29wdHMudmFsdWVOYW1lfVwiIChyZWNlaXZlZCBcIiR7Z2V0SnNvblR5cGUodmFsdWUpfVwiKS5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYmFkLWlkJzpcbiAgICAgICAgICAgIG1zZyA9IGBFeHBlY3RlZCBhIHZlcnNpb24gNCBVVUlEIGZvciBwcm9wZXJ0eSBcIiR7b3B0cy52YWx1ZU5hbWV9XCIgKHJlY2VpdmVkIFwiJHt2YWx1ZX1cIikuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtc2cgPSBgRW5jb3VudGVyZWQgdW5yZWNvZ25pemVkIGVycm9yIFwiJHtlcnJvclR5cGV9XCIgZm9yIHByb3BlcnR5IFwiJHtvcHRzLnZhbHVlTmFtZX1cIi5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcnMucHVzaChgJHttc2dQcmVmaXh9OiAke21zZ31gKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goJ0Vycm9yOiBQcm9qZWN0IG11c3QgaGF2ZSBhIG5hbWUuJyk7XG4gICAgICAgIGNvdW50cy5mYWlsZWQgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGBFcnJvcjogRXhwZWN0ZWQgdHlwZSBcInN0cmluZ1wiIGZvciBwcm9qZWN0IG5hbWUgKHJlY2VpdmVkIFwiJHtnZXRKc29uVHlwZShuYW1lKX1cIikuYCk7XG4gICAgICAgIGNvdW50cy5mYWlsZWQgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZXJyb3JzLnB1c2goJ0Vycm9yOiBQcm9qZWN0IG5hbWUgbXVzdCBub3QgYmUgZW1wdHkuJyk7XG4gICAgICAgIGNvdW50cy5mYWlsZWQgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb2plY3RPcHRpb25zID0ge307XG5cbiAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUoZGVzY3JpcHRpb24sIHtcbiAgICAgICAgICB2YWx1ZU5hbWU6ICdkZXNjcmlwdGlvbicsXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgfSkpIHByb2plY3RPcHRpb25zLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG5cbiAgICAgICAgbGV0IG5ld0lkID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZU5hbWU6ICdpZCcsXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICByZXF1aXJlVXVpZDogdHJ1ZSxcbiAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgfSkpIG5ld0lkID0gaWQ7XG5cbiAgICAgICAgaWYgKG5ld0lkICYmIHRoaXMuaGFzUHJvamVjdChuZXdJZCkpIGNvdW50cy51cGRhdGVkICs9IDE7XG4gICAgICAgIGVsc2UgY291bnRzLmFkZGVkICs9IDE7XG5cbiAgICAgICAgY29uc3QgcHJvamVjdCA9IG5ldyBQcm9qZWN0KG5hbWUsIHByb2plY3RPcHRpb25zKTtcbiAgICAgICAgaWYgKG5ld0lkKSB0aGlzLmFkZE9yVXBkYXRlUHJvamVjdChuZXdJZCwgcHJvamVjdCk7XG4gICAgICAgIGVsc2UgdGhpcy5hZGRQcm9qZWN0KHByb2plY3QpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY291bnRzLnRvdGFsID0gY291bnRzLmFkZGVkICsgY291bnRzLnVwZGF0ZWQgKyBjb3VudHMuZmFpbGVkO1xuXG4gICAgcmV0dXJuIHsgcHJvamVjdHM6IGNvdW50cywgZXJyb3JzIH07XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IHByb2plY3RzIGZyb20gcGFyc2VkIENTViBkYXRhLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdW119IGRhdGEgQW4gYXJyYXkgb2Ygc3RyaW5nIGFycmF5cy4gRWFjaCBtZW1iZXIgb2YgdGhlXG4gICAqICAgb3V0ZXIgYXJyYXkgcmVwcmVzZW50cyBhIHNpbmdsZSBwcm9qZWN0LCBhbmQgZWFjaCBtZW1iZXIgb2YgZWFjaCBpbm5lclxuICAgKiAgIGFycmF5IGlzIGEgZGF0YSBmaWVsZCBmb3IgdGhhdCBwYXJ0aWN1bGFyIHByb2plY3QuIFRoZSBmaXJzdCBtZW1iZXIgb2ZcbiAgICogICB0aGUgb3V0ZXIgYXJyYXkgc2hvdWxkIGJlIGEgaGVhZGVyIGhvbGRpbmcgZmllbGQgbmFtZXMuIER1cGxpY2F0ZVxuICAgKiAgIHByb2plY3RzIGFyZSBpZ25vcmVkLCBhcyBhcmUgdW5yZWxhdGVkIGZpZWxkcy5cbiAgICogQHJldHVybnMge21vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH5pbXBvcnRTdGF0dXN9IEFuIG9iamVjdCBob2xkaW5nXG4gICAqICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXR1cyBvZiB0aGUgaW1wb3J0LlxuICAgKiBAZmlyZXMgbW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fmFkZFByb2plY3RcbiAgICogQGZpcmVzIG1vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH51cGRhdGVQcm9qZWN0XG4gICAqL1xuICBpbXBvcnRGcm9tQ3N2KGRhdGEpIHtcbiAgICBjb25zdCBjb2x1bW5zID0gW107XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaGVhZGVyID0gZGF0YVswXTtcbiAgICAgIGhlYWRlci5mb3JFYWNoKChmaWVsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAncHJvamVjdCBuYW1lJzpcbiAgICAgICAgICBjYXNlICdwcm9qZWN0LW5hbWUnOlxuICAgICAgICAgICAgY29sdW1ucy5wdXNoKHsgbmFtZTogJ25hbWUnLCBpbmRleCB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Byb2plY3QgdXVpZCc6XG4gICAgICAgICAgY2FzZSAncHJvamVjdC11dWlkJzpcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7IG5hbWU6ICdpZCcsIGluZGV4IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncHJvamVjdCBkZXNjcmlwdGlvbic6XG4gICAgICAgICAgY2FzZSAncHJvamVjdC1kZXNjcmlwdGlvbic6XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goeyBuYW1lOiAnZGVzY3JpcHRpb24nLCBpbmRleCB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgIGRhdGEuZm9yRWFjaCgoY3N2UmVjb3JkLCBjc3ZJbmRleCkgPT4ge1xuICAgICAgICBpZiAoY3N2SW5kZXggPT09IDApIHJldHVybjtcblxuICAgICAgICBjb25zdCBlbnRyeSA9IHt9O1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goKHsgbmFtZSwgaW5kZXggfSkgPT4ge1xuICAgICAgICAgIGlmIChjc3ZSZWNvcmQubGVuZ3RoID4gaW5kZXggJiYgY3N2UmVjb3JkW2luZGV4XS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbnRyeVtuYW1lXSA9IGNzdlJlY29yZFtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFfLmlzRW1wdHkoZW50cnkpKSBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNFbnRyeUVxdWFsID0gKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBpZiAobGVmdC5pZCAhPSBudWxsIHx8IHJpZ2h0LmlkICE9IG51bGwpIHJldHVybiBsZWZ0LmlkID09PSByaWdodC5pZDtcbiAgICAgIHJldHVybiBsZWZ0Lm5hbWUgPT09IHJpZ2h0Lm5hbWVcbiAgICAgICAgJiYgbGVmdC5kZXNjcmlwdGlvbiA9PT0gcmlnaHQuZGVzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pbXBvcnRGcm9tSnNvbihfLnVuaXFXaXRoKGVudHJpZXMsIGlzRW50cnlFcXVhbCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3RMaXN0O1xuIiwiLyoqXG4gKiBEZWZpbmVzIHRoZSBbUmVjdXJyaW5nRGF0ZV17QGxpbmsgbW9kdWxlOnJlY3VycmluZ0RhdGV+UmVjdXJyaW5nRGF0ZX0gY2xhc3MuXG4gKiBAbW9kdWxlIHJlY3VycmluZ0RhdGVcbiAqL1xuXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IG9yZGluYWwgZnJvbSAnb3JkaW5hbCc7XG5pbXBvcnQge1xuICBhZGQgYXMgYWRkVG9EYXRlLFxuICBnZXREYXlzSW5Nb250aCxcbiAgaXNCZWZvcmUgYXMgaXNEYXRlQmVmb3JlLFxuICBpc1dlZWtlbmQsXG4gIG5leHREYXksXG4gIHByZXZpb3VzRGF5LFxuICBzdGFydE9mRGF5LFxuICBzdGFydE9mTW9udGgsXG59IGZyb20gJ2RhdGUtZm5zJztcblxuaW1wb3J0IHtcbiAgZm9ybWF0RGF0ZSxcbiAgZ2V0V2Vla2RheU5hbWUsXG4gIGdldE1vbnRoTmFtZSxcbiAgcGFyc2VJc29EYXRlVGltZSxcbn0gZnJvbSAnLi91dGlsaXR5L2RhdGVzJztcblxuLyoqXG4gKiBTdGFydGluZyBmcm9tIHRoZSBnaXZlbiBkYXRlLCBmaW5kIHRoZSBuZXh0IGRhdGUgbGFuZGluZyBvbiBvbmUgb2YgdGhlIGdpdmVuXG4gKiBkYXlzIG9mIHRoZSB3ZWVrLlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIFRoZSBpbml0aWFsIGRhdGUgdG8gc3RhcnQgZnJvbS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGRheXNPZldlZWsgQW4gYXJyYXkgb2YgZGVzaXJlZCB3ZWVrZGF5cy4gRWFjaCBkYXkgaXMgYVxuICogICB2YWx1ZSBmcm9tIDAtNiwgd2l0aCBTdW5kYXkgYmVpbmcgMC5cbiAqIEByZXR1cm5zIHtEYXRlfSBUaGUgZmlyc3QgZGF0ZSBvbiBvciBhZnRlciB0aGUgZ2l2ZW4gZGF0ZSB0aGF0IG1hdGNoZXMgb25lXG4gKiAgIG9mIHRoZSBnaXZlbiB3ZWVrZGF5cy5cbiAqL1xuZnVuY3Rpb24gbmV4dERheU9mV2VlayhkYXRlLCBkYXlzT2ZXZWVrKSB7XG4gIGxldCByZXN1bHQgPSBzdGFydE9mRGF5KGRhdGUpO1xuICBpZiAoZGF5c09mV2Vlay5sZW5ndGggPT09IDApIHJldHVybiByZXN1bHQ7XG5cbiAgY29uc3QgY3VycmVudERheSA9IHJlc3VsdC5nZXREYXkoKTtcbiAgY29uc3QgZGF5c1RvQWRkID0gZGF5c09mV2Vlay5tYXAoKGRheSkgPT4gKFxuICAgIGRheSA+PSBjdXJyZW50RGF5ID8gZGF5IC0gY3VycmVudERheSA6IGRheSArIDcgLSBjdXJyZW50RGF5XG4gICkpLnJlZHVjZSgobWluLCBjdXJyZW50KSA9PiAoY3VycmVudCA8IG1pbiA/IGN1cnJlbnQgOiBtaW4pKTtcblxuICBpZiAoZGF5c1RvQWRkID4gMCkgcmVzdWx0ID0gYWRkVG9EYXRlKHJlc3VsdCwgeyBkYXlzOiBkYXlzVG9BZGQgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogU3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gZGF0ZSwgZmluZCB0aGUgbmV4dCBkYXRlIHdpdGggdGhlIGluZGljYXRlZCBkYXkgb2ZcbiAqIHRoZSBtb250aC5cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBUaGUgaW5pdGlhbCBkYXRlIHRvIHN0YXJ0IGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gZGF5T2ZNb250aCBUaGUgZGVzaXJlZCBkYXkgb2YgdGhlIG1vbnRoLCBmcm9tIDEtMzEuXG4gKiBAcmV0dXJucyB7RGF0ZX0gVGhlIGZpcnN0IGRhdGUgb24gb3IgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUgdGhhdCBtYXRjaGVzIHRoZVxuICogICBkYXkgb2YgdGhlIG1vbnRoLlxuICovXG5mdW5jdGlvbiBuZXh0RGF5T2ZNb250aChkYXRlLCBkYXlPZk1vbnRoKSB7XG4gIGNvbnN0IGN1cnJlbnRNb250aCA9IHN0YXJ0T2ZNb250aChkYXRlKTtcbiAgY29uc3QgbmV4dE1vbnRoID0gc3RhcnRPZk1vbnRoKGFkZFRvRGF0ZShjdXJyZW50TW9udGgsIHsgbW9udGhzOiAxIH0pKTtcblxuICBjb25zdCByZXN1bHQgPSAoZGF0ZS5nZXREYXRlKCkgPD0gZGF5T2ZNb250aCkgPyBjdXJyZW50TW9udGggOiBuZXh0TW9udGg7XG4gIGNvbnN0IGRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGgocmVzdWx0KTtcbiAgcmVzdWx0LnNldERhdGUoTWF0aC5taW4oZGF5T2ZNb250aCwgZGF5c0luTW9udGgpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBTdGFydGluZyBmcm9tIHRoZSBnaXZlbiBkYXRlLCBmaW5kIHRoZSBuZXh0IGRhdGUgYmVsb25naW5nIHRvIHRoZSBpbmRpY2F0ZWRcbiAqIHdlZWsgYW5kIHdlZWtkYXkgb2YgdGhlIG1vbnRoLlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIFRoZSBpbml0aWFsIGRhdGUgdG8gc3RhcnQgZnJvbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3ZWVrTnVtYmVyIFRoZSB3ZWVrIG9mIHRoZSBtb250aCwgZnJvbSAxLTUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2Vla0RheSBUaGUgZGF5IG9mIHRoZSB3ZWVrLCBmcm9tIDAtNiB3aXRoIFN1bmRheSBiZWluZyAwLlxuICogQHJldHVybnMge0RhdGV9IFRoZSBmaXJzdCBkYXRlIG9uIG9yIGFmdGVyIHRoZSBnaXZlbiBkYXRlIHRoYXQgbWF0Y2hlcyB0aGVcbiAqICAgd2VlayBhbmQgZGF5IG9mIHRoZSBtb250aC5cbiAqL1xuZnVuY3Rpb24gbmV4dFdlZWtPZk1vbnRoKGRhdGUsIHdlZWtOdW1iZXIsIHdlZWtEYXkpIHtcbiAgY29uc3QgY3VycmVudE1vbnRoID0gc3RhcnRPZk1vbnRoKGRhdGUpO1xuICBjb25zdCBuZXh0TW9udGggPSBzdGFydE9mTW9udGgoYWRkVG9EYXRlKGN1cnJlbnRNb250aCwgeyBtb250aHM6IDEgfSkpO1xuXG4gIGNvbnN0IGZpbmREYXkgPSAobW9udGgpID0+IHtcbiAgICBjb25zdCBkYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoKG1vbnRoKTtcbiAgICBsZXQgcmVzdWx0ID0gbW9udGg7XG4gICAgaWYgKHJlc3VsdC5nZXREYXkoKSAhPT0gd2Vla0RheSkgcmVzdWx0ID0gbmV4dERheShyZXN1bHQsIHdlZWtEYXkpO1xuXG4gICAgbGV0IGRheXNUb0FkZCA9ICh3ZWVrTnVtYmVyIC0gMSkgKiA3O1xuICAgIGlmIChyZXN1bHQuZ2V0RGF0ZSgpICsgZGF5c1RvQWRkID4gZGF5c0luTW9udGgpIHtcbiAgICAgIGRheXNUb0FkZCA9IE1hdGguZmxvb3IoKGRheXNJbk1vbnRoIC0gcmVzdWx0LmdldERhdGUoKSkgLyA3KSAqIDc7XG4gICAgfVxuICAgIGlmICh3ZWVrTnVtYmVyID4gMSkgcmVzdWx0ID0gYWRkVG9EYXRlKHJlc3VsdCwgeyBkYXlzOiBkYXlzVG9BZGQgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBsZXQgcmVzdWx0ID0gZmluZERheShjdXJyZW50TW9udGgpO1xuICBpZiAoaXNEYXRlQmVmb3JlKHJlc3VsdCwgZGF0ZSkpIHJlc3VsdCA9IGZpbmREYXkobmV4dE1vbnRoKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIGRhdGUsIGZpbmQgdGhlIG5leHQgZGF0ZSBiZWxvbmdpbmcgdG8gdGhlIGdpdmVuXG4gKiBtb250aCBhbmQgZGF5IG9mIHRoZSB5ZWFyLlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIFRoZSBpbml0aWFsIGRhdGUgdG8gc3RhcnQgZnJvbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb250aCBUaGUgZGVzaXJlZCBtb250aCwgZnJvbSAwLTExIHdpdGggSmFudWFyeSBiZWluZyAwLlxuICogQHBhcmFtIHtudW1iZXJ9IGRheU9mTW9udGggVGhlIGRlc2lyZWQgZGF5IG9mIHRoZSBtb250aCwgZnJvbSAxLTMxLlxuICogQHJldHVybnMge0RhdGV9IFRoZSBmaXJzdCBkYXRlIG9uIG9yIGFmdGVyIHRoZSBnaXZlbiBkYXRlIHRoYXQgbWF0Y2hlcyB0aGVcbiAqICAgbW9udGggYW5kIGRheSBvZiB0aGUgeWVhci5cbiAqL1xuZnVuY3Rpb24gbmV4dERheU9mWWVhcihkYXRlLCBtb250aCwgZGF5T2ZNb250aCkge1xuICBjb25zdCBkYXRlT2ZDdXJyZW50WWVhciA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgbW9udGgsIDEpO1xuICBkYXRlT2ZDdXJyZW50WWVhci5zZXREYXRlKFxuICAgIE1hdGgubWluKGRheU9mTW9udGgsIGdldERheXNJbk1vbnRoKGRhdGVPZkN1cnJlbnRZZWFyKSksXG4gICk7XG5cbiAgY29uc3QgZGF0ZU9mTmV4dFllYXIgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCkgKyAxLCBtb250aCwgMSk7XG4gIGRhdGVPZk5leHRZZWFyLnNldERhdGUoXG4gICAgTWF0aC5taW4oZGF5T2ZNb250aCwgZ2V0RGF5c0luTW9udGgoZGF0ZU9mTmV4dFllYXIpKSxcbiAgKTtcblxuICBsZXQgcmVzdWx0ID0gZGF0ZU9mQ3VycmVudFllYXI7XG4gIGlmIChpc0RhdGVCZWZvcmUocmVzdWx0LCBkYXRlKSkgcmVzdWx0ID0gZGF0ZU9mTmV4dFllYXI7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlY3VycmluZyBkYXRlLlxuICovXG5jbGFzcyBSZWN1cnJpbmdEYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlY3VycmluZyBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW50ZXJ2YWxVbml0IFRoZSB1bml0IG9mIHRpbWUgKGUuZy4gJ3dlZWsnKSBpbiB3aGljaCB0aGVcbiAgICogICByZXBldGl0aW9uIGludGVydmFsIGlzIG1lYXN1cmVkLiBWYWxpZCBvcHRpb25zIGFyZSAnZGF5JywgJ3dlZWsnLFxuICAgKiAgICdtb250aCcsIGFuZCAneWVhcicuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBob2xkaW5nIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlXG4gICAqICAgcmVjdXJyZW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmludGVydmFsTGVuZ3RoPTFdIFRoZSBsZW5ndGggb2YgdGhlIHJlcGV0aXRpb25cbiAgICogICBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtEYXRlfSBbb3B0aW9ucy5zdGFydERhdGVdIEluZGljYXRlcyB0aGUgZWFybGllc3QgZGF0ZSB0aGF0IHRoZVxuICAgKiAgIG5leHQgb2NjdXJyZW5jZSBjYW4gaGFwcGVuLiBBbnkgb2NjdXJyZW5jZXMgdGhhdCB3b3VsZCBmYWxsIGJlZm9yZSB0aGlzXG4gICAqICAgZGF0ZSBhcmUgc2tpcHBlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlT25Db21wbGV0aW9uPWZhbHNlXSBJZiB0aGlzIGlzIHRydWUsIHRoZW5cbiAgICogICB0aGUgbmV4dCBvY2N1cnJlbmNlIHNob3VsZCBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIHRhc2sncyBjb21wbGV0aW9uXG4gICAqICAgZGF0ZS4gT3RoZXJ3aXNlLCB0aGUgb2NjdXJyZW5jZSBzaG91bGQgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSB0YXNrJ3MgZHVlXG4gICAqICAgZGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndlZWtOdW1iZXJdIFRoZSBudW1iZXIgb2YgdGhlIHdlZWsgd2l0aGluIGEgbW9udGhcbiAgICogICBpbiB3aGljaCB0aGUgcmVjdXJyaW5nIGRhdGUgc2hvdWxkIG9jY3VyLiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAgICogICBkYXlzT2ZXZWVrLiBBIHZhbHVlIG9mIDEgaW5kaWNhdGVzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgZGF5IHdpdGhpblxuICAgKiAgIHRoZSBtb250aCwgMiBpbmRpY2F0ZXMgdGhlIHNlY29uZCBvY2N1cnJlbmNlLCBhbmQgc28gb24uIElmIHRoaXMgaXMgc2V0XG4gICAqICAgdG8gNSwgdGhlbiB0aGUgNHRoIG9yIDV0aCBvY2N1cnJlbmNlIG9mIHRoZSBkYXkgbWF5IGJlIHVzZWQsIGRlcGVuZGluZ1xuICAgKiAgIG9uIGhvdyBtYW55IHN1Y2ggZGF5cyBhcmUgaW4gYSBwYXJ0aWN1bGFyIG1vbnRoLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBbb3B0aW9ucy5kYXlzT2ZXZWVrXSBBbiBhcnJheSBob2xkaW5nIHRoZSBkYXlzIG9mIHRoZVxuICAgKiAgIHdlZWsgb24gd2hpY2ggdGhlIHJlY3VycmluZyBkYXRlIHNob3VsZCBvY2N1ci4gRWFjaCBkYXkgaXMgYW4gaW50ZWdlclxuICAgKiAgIGZyb20gMC02LCB3aGVyZSAwIHJlcHJlc2VudHMgU3VuZGF5LCAxIHJlcHJlc2VudHMgTW9uZGF5LCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tb250aF0gVGhlIG1vbnRoIGluIHRoZSB5ZWFyIG9uIHdoaWNoIHRoZVxuICAgKiAgIHJlY3VycmluZyBkYXRlIHNob3VsZCBvY2N1ciwgcmVwcmVzZW50ZWQgYXMgYSBudW1iZXIgZnJvbSAwIHRvIDExLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGF5T2ZNb250aF0gVGhlIGRheSBvZiB0aGUgbW9udGggb24gd2hpY2ggdGhlXG4gICAqICAgcmVjdXJyaW5nIGRhdGUgc2hvdWxkIG9jY3VyLCByZXByZXNlbnRlZCBhcyBhIG51bWJlciBmcm9tIDEgdG8gMzEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbldlZWtlbmQ9bm8tY2hhbmdlXSBTcGVjaWZpZXMgd2hhdCBoYXBwZW5zIHdoZW5cbiAgICogICB0aGUgbmV4dCByZWN1cnJlbmNlIGZhbGxzIG9uIGEgd2Vla2VuZC4gSWYgc2V0IHRvICduby1jaGFuZ2UnLCB0aGVuIHRoZVxuICAgKiAgIGRhdGUgaXMgdW5hZmZlY3RlZC4gSWYgc2V0IHRvICdwcmV2aW91cy13ZWVrZGF5JyBvciAnbmV4dC13ZWVrZGF5JywgdGhlblxuICAgKiAgIHRoZSBwcmV2aW91cyBvciBuZXh0IHdlZWtkYXkgaXMgdXNlZCBpbnN0ZWFkLiBJZiBzZXQgdG9cbiAgICogICAnbmVhcmVzdC13ZWVrZGF5JywgdGhlbiB0aGUgY2xvc2VzdCB3ZWVrZGF5IGlzIHVzZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtEYXRlfSBbb3B0aW9ucy5lbmREYXRlXSBJbmRpY2F0ZXMgdGhlIGRhdGUgYWZ0ZXIgd2hpY2ggdGhlXG4gICAqICAgcmVwZXRpdGlvbiBzaG91bGQgc3RvcC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heENvdW50XSBJbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICAqICAgcmVwZXRpdGlvbnMgYmVmb3JlIHRoZSByZWN1cnJlbmNlIHNob3VsZCBzdG9wLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaW50ZXJ2YWxVbml0LCBvcHRpb25zID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pdCBvZiB0aW1lIGluIHdoaWNoIHRoZSByZXBldGl0aW9uIGludGVydmFsIGlzIG1lYXN1cmVkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnZhbFVuaXQgPSBpbnRlcnZhbFVuaXQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSByZXBldGl0aW9uIGludGVydmFsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnZhbExlbmd0aCA9IG9wdGlvbnMuaW50ZXJ2YWxMZW5ndGggPz8gMTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgZWFybGllc3QgZGF0ZSB0aGF0IHRoZSBuZXh0IG9jY3VycmVuY2UgY2FuIGhhcHBlbi4gQW55XG4gICAgICogb2NjdXJyZW5jZXMgdGhhdCB3b3VsZCBmYWxsIGJlZm9yZSB0aGlzIGRhdGUgYXJlIHNraXBwZWQuXG4gICAgICogQHR5cGUgez9EYXRlfVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnREYXRlID0gb3B0aW9ucy5zdGFydERhdGUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgdHJ1ZSwgdGhlbiB0aGUgbmV4dCBvY2N1cnJlbmNlIHNob3VsZCBiZSBjYWxjdWxhdGVkIGZyb20gdGhlXG4gICAgICogdGFzaydzIGNvbXBsZXRpb24gZGF0ZS4gT3RoZXJ3aXNlLCB0aGUgb2NjdXJyZW5jZSBzaG91bGQgYmUgY2FsY3VsYXRlZFxuICAgICAqIGZyb20gdGhlIHRhc2sncyBkdWUgZGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VPbkNvbXBsZXRpb24gPSBvcHRpb25zLmJhc2VPbkNvbXBsZXRpb24gPz8gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRoZSB3ZWVrIHdpdGhpbiBhIG1vbnRoIGluIHdoaWNoIHRoZSByZWN1cnJpbmcgZGF0ZSBzaG91bGRcbiAgICAgKiBvY2N1ci4gVXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGRheXNPZldlZWsuIEEgdmFsdWUgb2YgMSBpbmRpY2F0ZXMgdGhlXG4gICAgICogZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIGRheSB3aXRoaW4gdGhlIG1vbnRoLCAyIGluZGljYXRlcyB0aGUgc2Vjb25kXG4gICAgICogb2NjdXJyZW5jZSwgYW5kIHNvIG9uLiBJZiB0aGlzIGlzIHNldCB0byA1LCB0aGVuIHRoZSA0dGggb3IgNXRoXG4gICAgICogb2NjdXJyZW5jZSBvZiB0aGUgZGF5IG1heSBiZSB1c2VkLCBkZXBlbmRpbmcgb24gaG93IG1hbnkgc3VjaCBkYXlzIGFyZVxuICAgICAqIGluIGEgcGFydGljdWxhciBtb250aC5cbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLndlZWtOdW1iZXIgPSBvcHRpb25zLndlZWtOdW1iZXIgPz8gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IGhvbGRpbmcgdGhlIGRheXMgb2YgdGhlIHdlZWsgb24gd2hpY2ggdGhlIHJlY3VycmluZyBkYXRlIHNob3VsZFxuICAgICAqIG9jY3VyLiBFYWNoIGRheSBpcyBhbiBpbnRlZ2VyIGZyb20gMC02LCB3aGVyZSAwIHJlcHJlc2VudHMgU3VuZGF5LCAxXG4gICAgICogcmVwcmVzZW50cyBNb25kYXksIGFuZCBzbyBvbi5cbiAgICAgKiBAdHlwZSB7P251bWJlcltdfVxuICAgICAqL1xuICAgIHRoaXMuZGF5c09mV2VlayA9IG9wdGlvbnMuZGF5c09mV2VlayB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vbnRoIGluIHRoZSB5ZWFyIG9uIHdoaWNoIHRoZSByZWN1cnJpbmcgZGF0ZSBzaG91bGQgb2NjdXIsXG4gICAgICogcmVwcmVzZW50ZWQgYXMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMS5cbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vbnRoID0gb3B0aW9ucy5tb250aCA/PyBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRheSBvZiB0aGUgbW9udGggb24gd2hpY2ggdGhlIHJlY3VycmluZyBkYXRlIHNob3VsZCBvY2N1cixcbiAgICAgKiByZXByZXNlbnRlZCBhcyBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDMxLlxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGF5T2ZNb250aCA9IG9wdGlvbnMuZGF5T2ZNb250aCA/PyBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoYXQgaGFwcGVucyB3aGVuIHRoZSBuZXh0IHJlY3VycmVuY2Ugb2NjdXJzIG9uIGEgd2Vla2VuZC4gSWZcbiAgICAgKiBzZXQgdG8gJ25vLWNoYW5nZScsIHRoZW4gdGhlIGRhdGUgaXMgdW5hZmZlY3RlZC4gSWYgc2V0IHRvXG4gICAgICogJ3ByZXZpb3VzLXdlZWtkYXknIG9yICduZXh0LXdlZWtkYXknLCB0aGVuIHRoZSBwcmV2aW91cyBvciBuZXh0IHdlZWtkYXlcbiAgICAgKiBpcyB1c2VkIGluc3RlYWQuIElmIHNldCB0byAnbmVhcmVzdC13ZWVrZGF5JywgdGhlbiB0aGUgY2xvc2VzdCB3ZWVrZGF5XG4gICAgICogaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5vbldlZWtlbmQgPSBvcHRpb25zLm9uV2Vla2VuZCB8fCAnbm8tY2hhbmdlJztcblxuICAgIC8qKlxuICAgICogSW5kaWNhdGVzIHRoZSBkYXRlIGFmdGVyIHdoaWNoIHRoZSByZXBldGl0aW9uIHNob3VsZCBzdG9wLCBpZiBhbnkuXG4gICAgKiBAdHlwZSB7P0RhdGV9XG4gICAgKi9cbiAgICB0aGlzLmVuZERhdGUgPSBvcHRpb25zLmVuZERhdGUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVwZXRpdGlvbnMgYmVmb3JlIHRoZSByZWN1cnJlbmNlIHNob3VsZFxuICAgICAqIHN0b3AsIGlmIGV2ZXIuXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhDb3VudCA9IG9wdGlvbnMubWF4Q291bnQgPz8gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgb2NjdXJyZW5jZSBvZiB0aGUgcmVjdXJyaW5nIGRhdGUuXG4gICAqIEBwYXJhbSB7RGF0ZX0gW2Jhc2VEYXRlXSBUaGUgYmFzZSBkYXRlIGZyb20gd2hpY2ggdGhlIG5leHQgb2NjdXJyZW5jZVxuICAgKiAgIHNob3VsZCBiZSBjYWxjdWxhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZW4gdGhlIHByZXNlbnQgZGF5IGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHs/RGF0ZX0gVGhlIGRhdGUgb24gd2hpY2ggdGhlIHJlY3VycmVuY2Ugd2lsbCBuZXh0IG9jY3VyLCBvciBudWxsXG4gICAqICAgaWYgdGhlIHJlY3VycmVuY2UgaGFzIGVuZGVkLlxuICAgKi9cbiAgZ2V0TmV4dE9jY3VycmVuY2UoYmFzZURhdGUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubWF4Q291bnQgPT09ICdudW1iZXInICYmIHRoaXMubWF4Q291bnQgPCAxKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHJlZmVyZW5jZSA9IHN0YXJ0T2ZEYXkoYmFzZURhdGUgfHwgbmV3IERhdGUoKSk7XG5cbiAgICBsZXQgc3RhcnREYXRlID0gcmVmZXJlbmNlO1xuICAgIGlmICh0aGlzLnN0YXJ0RGF0ZSAmJiBpc0RhdGVCZWZvcmUocmVmZXJlbmNlLCB0aGlzLnN0YXJ0RGF0ZSkpIHtcbiAgICAgIHN0YXJ0RGF0ZSA9IHN0YXJ0T2ZEYXkodGhpcy5zdGFydERhdGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9uV2Vla2VuZCA9PT0gJ3ByZXZpb3VzLXdlZWtkYXknICYmIGlzV2Vla2VuZChzdGFydERhdGUpKSB7XG4gICAgICAvLyBNb3ZlIHN0YXJ0aW5nIGRhdGUgdG8gZm9sbG93aW5nIE1vbmRheVxuICAgICAgc3RhcnREYXRlID0gbmV4dERheShzdGFydERhdGUsIDEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vbldlZWtlbmQgPT09ICduZWFyZXN0LXdlZWtkYXknXG4gICAgICAmJiBzdGFydERhdGUuZ2V0RGF5KCkgPT09IDYpIHtcbiAgICAgIC8vIE1vdmUgc3RhcnRpbmcgZGF0ZSB0byBTdW5kYXlcbiAgICAgIHN0YXJ0RGF0ZSA9IG5leHREYXkoc3RhcnREYXRlLCAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0JlZm9yZVN0YXJ0ID0gKGRhdGUpID0+IHN0YXJ0RGF0ZSAmJiBpc0RhdGVCZWZvcmUoZGF0ZSwgc3RhcnREYXRlKTtcblxuICAgIGxldCByZXN1bHQgPSByZWZlcmVuY2U7XG4gICAgc3dpdGNoICh0aGlzLmludGVydmFsVW5pdCkge1xuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgcmVzdWx0ID0gYWRkVG9EYXRlKHJlc3VsdCwgeyBkYXlzOiB0aGlzLmludGVydmFsTGVuZ3RoIH0pO1xuICAgICAgICBpZiAoaXNCZWZvcmVTdGFydChyZXN1bHQpKSByZXN1bHQgPSBzdGFydERhdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICBpZiAodGhpcy5kYXlPZk1vbnRoIHx8IHRoaXMud2Vla051bWJlcikge1xuICAgICAgICAgIHJlc3VsdCA9IGFkZFRvRGF0ZShyZXN1bHQsIHtcbiAgICAgICAgICAgIG1vbnRoczogdGhpcy5pbnRlcnZhbExlbmd0aCxcbiAgICAgICAgICAgIGRheXM6IC0xNCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmRheU9mTW9udGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5leHREYXlPZk1vbnRoKHJlc3VsdCwgdGhpcy5kYXlPZk1vbnRoKTtcblxuICAgICAgICAgICAgaWYgKGlzQmVmb3JlU3RhcnQocmVzdWx0KSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBuZXh0RGF5T2ZNb250aChzdGFydERhdGUsIHRoaXMuZGF5T2ZNb250aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLndlZWtOdW1iZXIpIHtcbiAgICAgICAgICAgIGxldCB3ZWVrRGF5ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRheXNPZldlZWsgJiYgdGhpcy5kYXlzT2ZXZWVrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgW3dlZWtEYXldID0gdGhpcy5kYXlzT2ZXZWVrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV4dFdlZWtPZk1vbnRoKHJlc3VsdCwgdGhpcy53ZWVrTnVtYmVyLCB3ZWVrRGF5KTtcblxuICAgICAgICAgICAgaWYgKGlzQmVmb3JlU3RhcnQocmVzdWx0KSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBuZXh0V2Vla09mTW9udGgoc3RhcnREYXRlLCB0aGlzLndlZWtOdW1iZXIsIHdlZWtEYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBhZGRUb0RhdGUocmVzdWx0LCB7IG1vbnRoczogdGhpcy5pbnRlcnZhbExlbmd0aCB9KTtcbiAgICAgICAgICBpZiAoaXNCZWZvcmVTdGFydChyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXh0RGF5T2ZNb250aChzdGFydERhdGUsIHJlZmVyZW5jZS5nZXREYXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubW9udGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYWRkVG9EYXRlKHJlc3VsdCwge1xuICAgICAgICAgICAgeWVhcnM6IHRoaXMuaW50ZXJ2YWxMZW5ndGgsXG4gICAgICAgICAgICBtb250aHM6IC02LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzdWx0ID0gbmV4dERheU9mWWVhcihyZXN1bHQsIHRoaXMubW9udGgsIHRoaXMuZGF5T2ZNb250aCB8fCAxKTtcbiAgICAgICAgICBpZiAoaXNCZWZvcmVTdGFydChyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXh0RGF5T2ZZZWFyKFxuICAgICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICAgIHRoaXMubW9udGgsXG4gICAgICAgICAgICAgIHRoaXMuZGF5T2ZNb250aCB8fCAxLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gYWRkVG9EYXRlKHJlc3VsdCwgeyB5ZWFyczogdGhpcy5pbnRlcnZhbExlbmd0aCB9KTtcbiAgICAgICAgICBpZiAoaXNCZWZvcmVTdGFydChyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXh0RGF5T2ZZZWFyKFxuICAgICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICAgIHJlZmVyZW5jZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgICByZWZlcmVuY2UuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgaWYgKHRoaXMuZGF5c09mV2VlayAmJiB0aGlzLmRheXNPZldlZWsubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIENoZWNrIGZvciBvY2N1cnJlbmNlcyByZW1haW5pbmcgZm9yIHRoZSBjdXJyZW50IHdlZWtcbiAgICAgICAgICBpZiAodGhpcy5kYXlzT2ZXZWVrLmZpbmRJbmRleCgoZGF5KSA9PiAoXG4gICAgICAgICAgICBkYXkgPiByZXN1bHQuZ2V0RGF5KClcbiAgICAgICAgICApKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZFRvRGF0ZShyZXN1bHQsIHsgZGF5czogMSB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5leHREYXlPZldlZWsocmVzdWx0LCB0aGlzLmRheXNPZldlZWspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEb25lIHdpdGggY3VycmVudCB3ZWVrLCBzdGFydCBhdCBmb2xsb3dpbmcgU3VuZGF5XG4gICAgICAgICAgICByZXN1bHQgPSBuZXh0RGF5KHJlc3VsdCwgMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcnZhbExlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gYWRkVG9EYXRlKHJlc3VsdCwgeyB3ZWVrczogdGhpcy5pbnRlcnZhbExlbmd0aCAtIDEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBuZXh0RGF5T2ZXZWVrKHJlc3VsdCwgdGhpcy5kYXlzT2ZXZWVrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNCZWZvcmVTdGFydChyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXh0RGF5T2ZXZWVrKHN0YXJ0RGF0ZSwgdGhpcy5kYXlzT2ZXZWVrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gYWRkVG9EYXRlKHJlc3VsdCwgeyB3ZWVrczogdGhpcy5pbnRlcnZhbExlbmd0aCB9KTtcbiAgICAgICAgICBpZiAoaXNCZWZvcmVTdGFydChyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXh0RGF5T2ZXZWVrKHN0YXJ0RGF0ZSwgW3JlZmVyZW5jZS5nZXREYXkoKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9uV2Vla2VuZCAhPT0gJ25vLWNoYW5nZScgJiYgaXNXZWVrZW5kKHJlc3VsdCkpIHtcbiAgICAgIGxldCBmb3J3YXJkO1xuICAgICAgc3dpdGNoICh0aGlzLm9uV2Vla2VuZCkge1xuICAgICAgICBjYXNlICdwcmV2aW91cy13ZWVrZGF5JzpcbiAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25leHQtd2Vla2RheSc6XG4gICAgICAgICAgZm9yd2FyZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25lYXJlc3Qtd2Vla2RheSc6XG4gICAgICAgICAgZm9yd2FyZCA9IHJlc3VsdC5nZXREYXkoKSA9PT0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3J3YXJkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcndhcmQpIHJlc3VsdCA9IG5leHREYXkocmVzdWx0LCAxKTsgLy8gTmV4dCBNb25kYXlcbiAgICAgIGVsc2UgcmVzdWx0ID0gcHJldmlvdXNEYXkocmVzdWx0LCA1KTsgLy8gUHJldmlvdXMgRnJpZGF5XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kRGF0ZSAmJiBpc0RhdGVCZWZvcmUodGhpcy5lbmREYXRlLCByZXN1bHQpKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQWR2YW5jZSB0aGUgcmVjdXJyZW5jZSB0byB0aGUgbmV4dCBkYXRlLiBUaGlzIHdpbGwgdXBkYXRlIHRoZSByZW1haW5pbmdcbiAgICogcmVwZXRpdGlvbiBjb3VudCBpZiBuZWVkZWQuXG4gICAqL1xuICBhZHZhbmNlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5tYXhDb3VudCA9PT0gJ251bWJlcicgJiYgdGhpcy5tYXhDb3VudCA+IDApIHtcbiAgICAgIHRoaXMubWF4Q291bnQgLT0gMTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZSByZWN1cnJlbmNlIHdhcyBjcmVhdGVkIHdpdGggdGhlIGRlZmF1bHRcbiAgICogb3B0aW9ucy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3VycmluZyBkYXRlIGlzIGEgZGVmYXVsdCByZWN1cnJlbmNlLCBhbmRcbiAgICogICBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0RlZmF1bHQoKSB7XG4gICAgY29uc3QgZGVmID0gbmV3IFJlY3VycmluZ0RhdGUodGhpcy5pbnRlcnZhbFVuaXQpO1xuICAgIGlmICh0aGlzLmludGVydmFsTGVuZ3RoICE9PSBkZWYuaW50ZXJ2YWxMZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5zdGFydERhdGU/LmdldFRpbWUoKSAhPT0gZGVmLnN0YXJ0RGF0ZT8uZ2V0VGltZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuYmFzZU9uQ29tcGxldGlvbiAhPT0gZGVmLmJhc2VPbkNvbXBsZXRpb24pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy53ZWVrTnVtYmVyICE9PSBkZWYud2Vla051bWJlcikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghXy5pc0VxdWFsKHRoaXMuZGF5c09mV2VlaywgZGVmLmRheXNPZldlZWspKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMubW9udGggIT09IGRlZi5tb250aCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmRheU9mTW9udGggIT09IGRlZi5kYXlPZk1vbnRoKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMub25XZWVrZW5kICE9PSBkZWYub25XZWVrZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuZW5kRGF0ZT8uZ2V0VGltZSgpICE9PSBkZWYuZW5kRGF0ZT8uZ2V0VGltZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMubWF4Q291bnQgIT09IGRlZi5tYXhDb3VudCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVjdXJyaW5nIGRhdGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWN1cnJpbmcgZGF0ZS5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuaW50ZXJ2YWxMZW5ndGg7XG5cbiAgICBsZXQgc3RyVmFsdWUgPSAnJztcbiAgICBzd2l0Y2ggKHRoaXMuaW50ZXJ2YWxVbml0KSB7XG4gICAgICBjYXNlICdkYXknOlxuICAgICAgICBzdHJWYWx1ZSA9IGxlbmd0aCA9PT0gMSA/ICdEYWlseScgOiBgRXZlcnkgJHtsZW5ndGh9IGRheXNgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBzdHJWYWx1ZSA9IGxlbmd0aCA9PT0gMSA/ICdXZWVrbHknIDogYEV2ZXJ5ICR7bGVuZ3RofSB3ZWVrc2A7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF5c09mV2VlayAmJiB0aGlzLmRheXNPZldlZWsubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0clZhbHVlICs9ICcgb24gJztcbiAgICAgICAgICBpZiAoXy51bmlxKHRoaXMuZGF5c09mV2VlaykubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICBzdHJWYWx1ZSArPSAnYWxsIGRheXMnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRheXNPZldlZWsuZm9yRWFjaCgoZGF5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPiAwKSBzdHJWYWx1ZSArPSAnLCAnO1xuICAgICAgICAgICAgICBzdHJWYWx1ZSArPSBnZXRXZWVrZGF5TmFtZShkYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICBzdHJWYWx1ZSA9IGxlbmd0aCA9PT0gMSA/ICdNb250aGx5JyA6IGBFdmVyeSAke2xlbmd0aH0gbW9udGhzYDtcblxuICAgICAgICBpZiAodGhpcy5kYXlPZk1vbnRoKSB7XG4gICAgICAgICAgc3RyVmFsdWUgKz0gYCBvbiB0aGUgJHtvcmRpbmFsKHRoaXMuZGF5T2ZNb250aCl9YDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLndlZWtOdW1iZXIgJiYgdGhpcy5kYXlzT2ZXZWVrPy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBsZXQgd2Vla1N0cjtcbiAgICAgICAgICBpZiAodGhpcy53ZWVrTnVtYmVyIDwgNSkgd2Vla1N0ciA9IG9yZGluYWwodGhpcy53ZWVrTnVtYmVyKTtcbiAgICAgICAgICBlbHNlIHdlZWtTdHIgPSAnbGFzdCc7XG4gICAgICAgICAgY29uc3QgZGF5U3RyID0gZ2V0V2Vla2RheU5hbWUodGhpcy5kYXlzT2ZXZWVrWzBdKTtcbiAgICAgICAgICBzdHJWYWx1ZSArPSBgIG9uIHRoZSAke3dlZWtTdHJ9ICR7ZGF5U3RyfWA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgc3RyVmFsdWUgPSBsZW5ndGggPT09IDEgPyAnQW5udWFsbHknIDogYEV2ZXJ5ICR7bGVuZ3RofSB5ZWFyc2A7XG5cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodGhpcy5tb250aCkgJiYgdGhpcy5kYXlPZk1vbnRoKSB7XG4gICAgICAgICAgY29uc3QgbW9udGhTdHIgPSBnZXRNb250aE5hbWUodGhpcy5tb250aCk7XG4gICAgICAgICAgY29uc3QgZGF5U3RyID0gb3JkaW5hbCh0aGlzLmRheU9mTW9udGgpO1xuICAgICAgICAgIHN0clZhbHVlICs9IGAgb24gJHttb250aFN0cn0gJHtkYXlTdHJ9YDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaWtlIFt0b1N0cmluZ117QGxpbmsgbW9kdWxlOnJlY3VycmluZ0RhdGV+UmVjdXJyaW5nRGF0ZSN0b1N0cmluZ30sIGJ1dFxuICAgKiBtb3JlIHZlcmJvc2UsIGluY2x1ZGluZyBhbGwgZGV0YWlscyBvZiB0aGUgcmVjdXJyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVGb3JtYXRTdHIgVGhlIGZvcm1hdCB0byB1c2UgZm9yIGRhdGVzLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVjdXJyaW5nIGRhdGUuXG4gICAqL1xuICB0b1N0cmluZ1ZlcmJvc2UoZGF0ZUZvcm1hdFN0cikge1xuICAgIGxldCBzdHJWYWx1ZSA9IHRoaXMudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnN0YXJ0RGF0ZSkge1xuICAgICAgY29uc3QgZGF0ZVN0ciA9IGZvcm1hdERhdGUodGhpcy5zdGFydERhdGUsIGRhdGVGb3JtYXRTdHIpO1xuICAgICAgc3RyVmFsdWUgKz0gYCwgZnJvbSAke2RhdGVTdHJ9YDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmREYXRlKSB7XG4gICAgICBjb25zdCBkYXRlU3RyID0gZm9ybWF0RGF0ZSh0aGlzLmVuZERhdGUsIGRhdGVGb3JtYXRTdHIpO1xuICAgICAgc3RyVmFsdWUgKz0gYCwgdW50aWwgJHtkYXRlU3RyfWA7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1heENvdW50KSB7XG4gICAgICBpZiAodGhpcy5tYXhDb3VudCA9PT0gMSkgc3RyVmFsdWUgKz0gJywgMSB0aW1lJztcbiAgICAgIGVsc2Ugc3RyVmFsdWUgKz0gYCwgJHt0aGlzLm1heENvdW50fSB0aW1lc2A7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmFzZU9uQ29tcGxldGlvbikge1xuICAgICAgc3RyVmFsdWUgKz0gJywgYmFzZWQgb24gY29tcGxldGlvbiBkYXRlJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vbldlZWtlbmQgIT09ICduby1jaGFuZ2UnKSB7XG4gICAgICBzdHJWYWx1ZSArPSAnLCAnO1xuICAgICAgc3dpdGNoICh0aGlzLm9uV2Vla2VuZCkge1xuICAgICAgICBjYXNlICdwcmV2aW91cy13ZWVrZGF5JzpcbiAgICAgICAgICBzdHJWYWx1ZSArPSAncHJldmlvdXMgd2Vla2RheSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25leHQtd2Vla2RheSc6XG4gICAgICAgICAgc3RyVmFsdWUgKz0gJ25leHQgd2Vla2RheSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25lYXJlc3Qtd2Vla2RheSc6XG4gICAgICAgICAgc3RyVmFsdWUgKz0gJ25lYXJlc3Qgd2Vla2RheSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0clZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlY3VycmluZyBkYXRlIGZyb20gYSBKU09OIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIEpTT04gb2JqZWN0IGhvbGRpbmcgdGhlIHNlcmlhbGl6ZWQgZGF0YS5cbiAgICogQHJldHVybnMge21vZHVsZTpyZWN1cnJpbmdEYXRlflJlY3VycmluZ0RhdGV9IEEgbmV3IHJlY3VycmluZyBkYXRlXG4gICAqICAgY29udmVydGVkIGZyb20gdGhlIEpTT04gZGF0YS5cbiAgICovXG4gIHN0YXRpYyBmcm9tSnNvbihkYXRhKSB7XG4gICAgY29uc3QgY29udmVydERhdGUgPSAoZGF0ZSkgPT4gKGRhdGUgPyBwYXJzZUlzb0RhdGVUaW1lKGRhdGUpIDogbnVsbCk7XG4gICAgcmV0dXJuIG5ldyBSZWN1cnJpbmdEYXRlKGRhdGEuaW50ZXJ2YWxVbml0LCB7XG4gICAgICBpbnRlcnZhbExlbmd0aDogZGF0YS5pbnRlcnZhbExlbmd0aCxcbiAgICAgIHN0YXJ0RGF0ZTogY29udmVydERhdGUoZGF0YS5zdGFydERhdGUpLFxuICAgICAgYmFzZU9uQ29tcGxldGlvbjogZGF0YS5iYXNlT25Db21wbGV0aW9uLFxuICAgICAgd2Vla051bWJlcjogZGF0YS53ZWVrTnVtYmVyLFxuICAgICAgZGF5c09mV2VlazogZGF0YS5kYXlzT2ZXZWVrLFxuICAgICAgbW9udGg6IGRhdGEubW9udGgsXG4gICAgICBkYXlPZk1vbnRoOiBkYXRhLmRheU9mTW9udGgsXG4gICAgICBvbldlZWtlbmQ6IGRhdGEub25XZWVrZW5kLFxuICAgICAgZW5kRGF0ZTogY29udmVydERhdGUoZGF0YS5lbmREYXRlKSxcbiAgICAgIG1heENvdW50OiBkYXRhLm1heENvdW50LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlY3VycmluZ0RhdGU7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtTZXR0aW5nc117QGxpbmsgbW9kdWxlOnNldHRpbmdzflNldHRpbmdzfSBjbGFzcy5cbiAqIEBtb2R1bGUgc2V0dGluZ3NcbiAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBnZXRKc29uVHlwZSwgdmFsaWRhdGVWYWx1ZSB9IGZyb20gJy4vdXRpbGl0eS9kYXRhJztcbmltcG9ydCB7IGdldERhdGVGb3JtYXQgfSBmcm9tICcuL3V0aWxpdHkvZGF0ZXMnO1xuXG4vKipcbiAqIE9iamVjdCBob2xkaW5nIHByaXZhdGUgbWVtYmVycyBmb3IgdGhlXG4gKiBbU2V0dGluZ3Nde0BsaW5rIG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc30gY2xhc3MuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+cHJpdmF0ZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdG9yYWdlTWV0aG9kIFRoZSBtZXRob2QgZm9yIHN0b3JpbmcgZGF0YTogJ25vbmUnIChub1xuICogICBzdG9yYWdlKSBvciAnbG9jYWwnIChsb2NhbCBzdG9yYWdlIGluIHRoZSBicm93c2VyKS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnNldHRpbmdzflNldHRpbmdzfmRhdGVGb3JtYXR9IGRhdGVGb3JtYXQgVGhlIGZvcm1hdCB0byB1c2VcbiAqICAgZm9yIGNhbGVuZGFyIGRhdGVzLlxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBkZWxldGVBZnRlciBEZXRlcm1pbmVzIGhvdyBtYW55IGRheXMgYWZ0ZXIgYSB0YXNrIGlzXG4gKiAgIGNvbXBsZXRlZCBiZWZvcmUgdGhlIHRhc2sgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRlbGV0ZWQuIElmIHNldCB0byBudWxsLFxuICogICBjb21wbGV0ZWQgdGFza3Mgd2lsbCBuZXZlciBiZSBkZWxldGVkIGF1dG9tYXRpY2FsbHkuXG4gKiBAcHJvcGVydHkge01hcH0gZmlsdGVyR3JvdXBzIEEgbWFwIGFzc29jaWF0aW5nIHRoZSBuYW1lIG9mIGEgZmlsdGVyIGdyb3VwIHRvXG4gKiAgIGEgW2ZpbHRlck9wdGlvbnNde0BsaW5rIG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35maWx0ZXJPcHRpb25zfSBvYmplY3QuXG4gKiBAcHJvcGVydHkge0V2ZW50RW1pdHRlcn0gZXZlbnRFbWl0dGVyIEhvbGRzIHRoZSBldmVudCBlbWl0dGVyIHdoaWNoXG4gKiAgIGRpc3BhdGNoZXMgZXZlbnRzIHRvIGF0dGFjaGVkIGV2ZW50IGxpc3RlbmVycy5cbiAqL1xuXG4vKipcbiAqIEhvbGRzIHByaXZhdGUgZGF0YSBmb3IgdGhlIFtTZXR0aW5nc117QGxpbmsgbW9kdWxlOnNldHRpbmdzflNldHRpbmdzfSBjbGFzcy5cbiAqIEB0eXBlIHtXZWFrTWFwfVxuICogQHNlZSBtb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+cHJpdmF0ZXNcbiAqL1xuY29uc3QgcHJpdmF0ZU1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEhvbGRzIHVzZXIgYXBwIHNldHRpbmdzLlxuICovXG5jbGFzcyBTZXR0aW5ncyB7XG4gIC8qKlxuICAgKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGF0dGVybiB0byB1c2UgZm9yIGZvcm1hdHRpbmcgYW5kIHBhcnNpbmdcbiAgICogY2FsZW5kYXIgZGF0ZXMuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35kYXRlRm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvdXRwdXRQYXR0ZXJuIFRoZSBkYXRlIGZvcm1hdCBzdHJpbmcgdXNlZCBmb3JcbiAgICogICBmb3JtYXR0aW5nIGRhdGVzIGZvciBvdXRwdXQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGlucHV0UGF0dGVybnMgQW4gYXJyYXkgb2YgZGF0ZSBmb3JtYXQgc3RyaW5ncyB1c2VkXG4gICAqICAgZm9yIHBhcnNpbmcgZGF0ZXMuIEVhY2ggcGF0dGVybiB3aWxsIGJlIHRyaWVkIGluIHNlcXVlbmNlIHVudGlsIGEgdmFsaWRcbiAgICogICBtYXRjaCBpcyBtYWRlLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdmlzdWFsUGF0dGVybiBBIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0ZVxuICAgKiAgIGZvcm1hdCBzdWl0YWJsZSBmb3IgZGlzcGxheWluZyB0byB0aGUgdXNlci5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZGF0ZSBmb3JtYXQuIFZhbGlkIHZhbHVlcyBhcmUgJ2xvY2FsJyxcbiAgICogICAnaXNvJywgJ21vbnRoLWRheS15ZWFyJywgJ2RheS1tb250aC15ZWFyJywgYW5kICd5ZWFyLW1vbnRoLWRheScuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIb2xkcyBvcHRpb25zIGZvciBkaXNwbGF5aW5nIGEgdGFzayBmaWx0ZXIuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35maWx0ZXJPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBncm91cEJ5IFRoZSBmaWVsZCB0byBncm91cCB0aGUgdGFza3MgYnk6ICdkZWZhdWx0JyxcbiAgICogICAnZHVlLWRhdGUnLCAncHJpb3JpdHknLCAncHJvamVjdCcsIG9yICdub25lJy4gVGhlIGRlZmF1bHQgZGVwZW5kcyBvbiB0aGVcbiAgICogICB0eXBlIG9mIGZpbHRlci5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNvcnRCeSBUaGUgcHJpbWFyeSBmaWVsZCB0byBzb3J0IHRoZSB0YXNrcyBieTogJ25hbWUnLFxuICAgKiAgICdkdWUtZGF0ZScsICdjcmVhdGUtZGF0ZScsICdwcmlvcml0eScsIG9yICdwcm9qZWN0Jy5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBzb3J0RGVzY2VuZGluZyBJbmRpY2F0ZXMgd2hldGhlciB0byBzb3J0IGluIGRlc2NlbmRpbmdcbiAgICogICBvcmRlciByYXRoZXIgdGhhbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd0NvbXBsZXRlZCBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIGNvbXBsZXRlZFxuICAgKiAgIHRhc2tzIGluIHRoZSByZXN1bHRzLlxuICAgKi9cblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIGEgc2V0dGluZyBpcyBtb2RpZmllZC5cbiAgICogQGV2ZW50IG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc351cGRhdGVTZXR0aW5nXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlOiAndXBkYXRlLXNldHRpbmcnLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc2V0dGluZy4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGVcbiAgICogICBuYW1lIG9mIHRoZSBjb3JyZXNwb25kaW5nIGluc3RhbmNlIHByb3BlcnR5LCBleGNlcHQgZm9yIGZpbHRlciBncm91cFxuICAgKiAgIHNldHRpbmdzLCB3aGljaCBoYXZlIHRoZSBmb3JtICdmaWx0ZXJHcm91cHMuZ3JvdXAtbmFtZScsIHdoZXJlXG4gICAqICAgJ2dyb3VwLW5hbWUnIGlzIHRoZSBuYW1lIG9mIHRoZSBmaWx0ZXIgZ3JvdXAuXG4gICAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgc2V0dGluZy5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGF0dXMgb2YgYSBkYXRhIGltcG9ydC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOnNldHRpbmdzflNldHRpbmdzfmltcG9ydFN0YXR1c1xuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBlcnJvcnMgQW4gYXJyYXkgb2YgZXJyb3IgbWVzc2FnZXMgZGVzY3JpYmluZyBhbnlcbiAgICogICBlcnJvcnMgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhlIGltcG9ydC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBvYmplY3QgaG9sZGluZyB0aGUgZGVmYXVsdCBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHByaXZhdGVzID0ge1xuICAgICAgc3RvcmFnZU1ldGhvZDogbnVsbCxcbiAgICAgIGRhdGVGb3JtYXQ6IHt9LFxuICAgICAgZGVsZXRlQWZ0ZXI6IG51bGwsXG4gICAgICBmaWx0ZXJHcm91cHM6IG5ldyBNYXAoKSxcbiAgICAgIGV2ZW50RW1pdHRlcjogbmV3IEV2ZW50RW1pdHRlcigpLFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcblxuICAgIHRoaXMucmVzZXRUb0RlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgc2V0dGluZy4gQWx0aG91Z2ggZWFjaCBzZXR0aW5nIGNhbiBiZSByZXRyaWV2ZWRcbiAgICogZGlyZWN0bHkgdXNpbmcgb3RoZXIgY2xhc3MgbWV0aG9kcyBhbmQgcHJvcGVydGllcywgdGhpcyBtZXRob2QgY2FuIG1ha2VcbiAgICogc3RvcmFnZSBhbmQgc2VyaWFsaXphdGlvbiBlYXNpZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzZXR0aW5nLiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBuYW1lXG4gICAqICAgb2YgdGhlIGNvcnJlc3BvbmRpbmcgaW5zdGFuY2UgcHJvcGVydHksIGV4Y2VwdCBmb3IgZmlsdGVyIGdyb3VwXG4gICAqICAgc2V0dGluZ3MsIHdoaWNoIGhhdmUgdGhlIGZvcm0gJ2ZpbHRlckdyb3Vwcy5ncm91cC1uYW1lJywgd2hlcmVcbiAgICogICAnZ3JvdXAtbmFtZScgaXMgdGhlIG5hbWUgb2YgdGhlIGZpbHRlciBncm91cC5cbiAgICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBvZiB0aGUgc2V0dGluZy4gRm9yIGZpbHRlciBncm91cCBzZXR0aW5ncywgdGhpcyBpc1xuICAgKiAgIGEgW2ZpbHRlck9wdGlvbnNde0BsaW5rIG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35maWx0ZXJPcHRpb25zfSBvYmplY3QuXG4gICAqICAgRm9yIGRhdGUgZm9ybWF0IHNldHRpbmdzLCB0aGlzIGlzIGFcbiAgICogICBbZGF0ZUZvcm1hdF17QGxpbmsgbW9kdWxlOnNldHRpbmdzflNldHRpbmdzfmRhdGVGb3JtYXR9IG9iamVjdC5cbiAgICovXG4gIGdldFNldHRpbmcobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnc3RvcmFnZU1ldGhvZCc6XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VNZXRob2Q7XG4gICAgICBjYXNlICdkYXRlRm9ybWF0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUZvcm1hdDtcbiAgICAgIGNhc2UgJ2RlbGV0ZUFmdGVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlQWZ0ZXI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWx0ZXJHcm91cHMuJykpIHtcbiAgICAgICAgICBjb25zdCBncm91cCA9IG5hbWUuc3Vic3RyaW5nKCdmaWx0ZXJHcm91cHMuJy5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpbHRlck9wdGlvbnMoZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIG9mIGEgc2V0dGluZy4gQWx0aG91Z2ggZWFjaCBzZXR0aW5nIGNhbiBiZSBzZXQgZGlyZWN0bHlcbiAgICogdXNpbmcgb3RoZXIgY2xhc3MgbWV0aG9kcyBhbmQgcHJvcGVydGllcywgdGhpcyBtZXRob2QgY2FuIG1ha2Ugc3RvcmFnZSBhbmRcbiAgICogZGVzZXJpYWxpemF0aW9uIGVhc2llci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNldHRpbmcuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIG5hbWVcbiAgICogICBvZiB0aGUgY29ycmVzcG9uZGluZyBpbnN0YW5jZSBwcm9wZXJ0eSwgZXhjZXB0IGZvciBmaWx0ZXIgZ3JvdXBcbiAgICogICBzZXR0aW5ncywgd2hpY2ggaGF2ZSB0aGUgZm9ybSAnZmlsdGVyR3JvdXBzLmdyb3VwLW5hbWUnLCB3aGVyZVxuICAgKiAgICdncm91cC1uYW1lJyBpcyB0aGUgbmFtZSBvZiB0aGUgZmlsdGVyIGdyb3VwLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgc2V0dGluZy4gRm9yIGZpbHRlciBncm91cCBzZXR0aW5ncywgdGhpc1xuICAgKiAgIHNob3VsZCBiZSBhXG4gICAqICAgW2ZpbHRlck9wdGlvbnNde0BsaW5rIG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35maWx0ZXJPcHRpb25zfSBvYmplY3QuXG4gICAqICAgRm9yIGRhdGUgZm9ybWF0IHNldHRpbmdzLCB0aGlzIGNhbiBiZSBlaXRoZXIgYVxuICAgKiAgIFtkYXRlRm9ybWF0XXtAbGluayBtb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+ZGF0ZUZvcm1hdH0gb2JqZWN0IG9yIGFcbiAgICogICBzdHJpbmcgc3BlY2lmeWluZyB0aGUgbmFtZSBvZiB0aGUgZm9ybWF0IHRvIHVzZS5cbiAgICogQGZpcmVzIG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc351cGRhdGVTZXR0aW5nXG4gICAqL1xuICBzZXRTZXR0aW5nKG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IHZhbGlkU2V0dGluZyA9IHRydWU7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdzdG9yYWdlTWV0aG9kJzpcbiAgICAgICAgdGhpcy5zdG9yYWdlTWV0aG9kID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGF0ZUZvcm1hdCc6XG4gICAgICAgIHRoaXMuc2V0RGF0ZUZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGVsZXRlQWZ0ZXInOlxuICAgICAgICB0aGlzLmRlbGV0ZUFmdGVyID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnZmlsdGVyR3JvdXBzLicpKSB7XG4gICAgICAgICAgY29uc3QgZ3JvdXAgPSBuYW1lLnN1YnN0cmluZygnZmlsdGVyR3JvdXBzLicubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLnNldEZpbHRlck9wdGlvbnMoZ3JvdXAsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZFNldHRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodmFsaWRTZXR0aW5nKSB7XG4gICAgICBwcml2YXRlTWVtYmVycy5nZXQodGhpcykuZXZlbnRFbWl0dGVyLmVtaXQoJ3VwZGF0ZS1zZXR0aW5nJywge1xuICAgICAgICB0eXBlOiAndXBkYXRlLXNldHRpbmcnLFxuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZTogXy5jbG9uZURlZXAodmFsdWUpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGZvciBlYWNoIGF2YWlsYWJsZSBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBzZXR0aW5nLiBUaGVcbiAgICogICBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCB0aGUgbmFtZSBvZiBlYWNoIHNldHRpbmcgYWxvbmcgd2l0aCBpdHMgdmFsdWUuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgY29uc3Qgc2V0dGluZ0xpc3QgPSBbXG4gICAgICAnc3RvcmFnZU1ldGhvZCcsXG4gICAgICAnZGF0ZUZvcm1hdCcsXG4gICAgICAnZGVsZXRlQWZ0ZXInLFxuICAgIF07XG5cbiAgICBjb25zdCBncm91cEtleXMgPSBbLi4ucHJpdmF0ZXMuZmlsdGVyR3JvdXBzLmtleXMoKV0ubWFwKFxuICAgICAgKGtleSkgPT4gYGZpbHRlckdyb3Vwcy4ke2tleX1gLFxuICAgICk7XG4gICAgc2V0dGluZ0xpc3QucHVzaCguLi5ncm91cEtleXMpO1xuXG4gICAgc2V0dGluZ0xpc3QuZm9yRWFjaCgoc2V0dGluZykgPT4ge1xuICAgICAgY2FsbGJhY2soc2V0dGluZywgdGhpcy5nZXRTZXR0aW5nKHNldHRpbmcpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIGZvciBzdG9yaW5nIGRhdGE6ICdub25lJyAobm8gc3RvcmFnZSkgb3IgJ2xvY2FsJyAobG9jYWwgc3RvcmFnZVxuICAgKiBpbiB0aGUgYnJvd3NlcikuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgc3RvcmFnZU1ldGhvZCgpIHtcbiAgICByZXR1cm4gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLnN0b3JhZ2VNZXRob2Q7XG4gIH1cblxuICBzZXQgc3RvcmFnZU1ldGhvZChtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kICE9PSAnbm9uZScgJiYgbWV0aG9kICE9PSAnbG9jYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHN0b3JhZ2UgbWV0aG9kOiBcIiR7bWV0aG9kfVwiYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgcHJpdmF0ZXMuc3RvcmFnZU1ldGhvZCA9IG1ldGhvZDtcblxuICAgIHByaXZhdGVzLmV2ZW50RW1pdHRlci5lbWl0KCd1cGRhdGUtc2V0dGluZycsIHtcbiAgICAgIHR5cGU6ICd1cGRhdGUtc2V0dGluZycsXG4gICAgICBuYW1lOiAnc3RvcmFnZU1ldGhvZCcsXG4gICAgICB2YWx1ZTogbWV0aG9kLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb3JtYXQgdG8gdXNlIGZvciBjYWxlbmRhciBkYXRlcy5cbiAgICogQHR5cGUge21vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35kYXRlRm9ybWF0fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkYXRlRm9ybWF0KCkge1xuICAgIHJldHVybiBfLmNsb25lRGVlcChwcml2YXRlTWVtYmVycy5nZXQodGhpcykuZGF0ZUZvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBob3cgbWFueSBkYXlzIGFmdGVyIGEgdGFzayBpcyBjb21wbGV0ZWQgYmVmb3JlIHRoZSB0YXNrIHdpbGwgYmVcbiAgICogYXV0b21hdGljYWxseSBkZWxldGVkLiBJZiBzZXQgdG8gbnVsbCwgY29tcGxldGVkIHRhc2tzIHdpbGwgbmV2ZXIgYmVcbiAgICogZGVsZXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICovXG4gIGdldCBkZWxldGVBZnRlcigpIHtcbiAgICByZXR1cm4gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmRlbGV0ZUFmdGVyO1xuICB9XG5cbiAgc2V0IGRlbGV0ZUFmdGVyKGRheXMpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcbiAgICBwcml2YXRlcy5kZWxldGVBZnRlciA9IGRheXM7XG5cbiAgICBwcml2YXRlcy5ldmVudEVtaXR0ZXIuZW1pdCgndXBkYXRlLXNldHRpbmcnLCB7XG4gICAgICB0eXBlOiAndXBkYXRlLXNldHRpbmcnLFxuICAgICAgbmFtZTogJ2RlbGV0ZUFmdGVyJyxcbiAgICAgIHZhbHVlOiBkYXlzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3QgaG9sZGluZyBvcHRpb25zIGZvciBkaXNwbGF5aW5nIHRhc2sgZmlsdGVycyBiZWxvbmdpbmcgdG8gYVxuICAgKiBwYXJ0aWN1bGFyIGZpbHRlciBncm91cC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlckdyb3VwIFRoZSBmaWx0ZXIgZ3JvdXAgd2hvc2Ugb3B0aW9ucyBhcmUgdG8gYmVcbiAgICogICByZXRyaWV2ZWQuXG4gICAqIEByZXR1cm5zIHs/bW9kdWxlOnNldHRpbmdzflNldHRpbmdzfmZpbHRlck9wdGlvbnN9IEFuIG9iamVjdCBob2xkaW5nIHRoZVxuICAgKiAgIGZpbHRlciBvcHRpb25zLCBvciBudWxsIGlmIHRoZSBmaWx0ZXIgZ3JvdXAgd2FzIG5vdCBmb3VuZC5cbiAgICovXG4gIGdldEZpbHRlck9wdGlvbnMoZmlsdGVyR3JvdXApIHtcbiAgICBjb25zdCBvcHRzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmZpbHRlckdyb3Vwcy5nZXQoZmlsdGVyR3JvdXApO1xuICAgIHJldHVybiBvcHRzID8gXy5jbG9uZURlZXAob3B0cykgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zIGZvciBkaXNwbGF5aW5nIHRhc2sgZmlsdGVycyBiZWxvbmdpbmcgdG8gYSBwYXJ0aWN1bGFyIGZpbHRlclxuICAgKiBncm91cC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlckdyb3VwIFRoZSBmaWx0ZXIgZ3JvdXAgd2hvc2Ugb3B0aW9ucyBhcmUgdG8gYmVcbiAgICogICBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge21vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35maWx0ZXJPcHRpb25zfSBbb3B0aW9ucz17fV0gQW4gb2JqZWN0XG4gICAqICAgc3BlY2lmeWluZyB0aGUgZmlsdGVyIG9wdGlvbnMgdG8gc2V0LiBBbnkgdW5zcGVjaWZpZWQgb3B0aW9ucyB3aWxsXG4gICAqICAgcmV0YWluIHRoZWlyIHByaW9yIHZhbHVlcywgb3Igd2lsbCBiZSBzZXQgdG8gZGVmYXVsdCB2YWx1ZXMgaWYgdGhleSB3ZXJlXG4gICAqICAgbm90IHByZXZpb3VzbHkgc2V0LlxuICAgKiBAZmlyZXMgbW9kdWxlOnNldHRpbmdzflNldHRpbmdzfnVwZGF0ZVNldHRpbmdcbiAgICovXG4gIHNldEZpbHRlck9wdGlvbnMoZmlsdGVyR3JvdXAsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IHsgZmlsdGVyR3JvdXBzIH0gPSBwcml2YXRlcztcblxuICAgIGNvbnN0IG9sZE9wdGlvbnMgPSBmaWx0ZXJHcm91cHMuZ2V0KGZpbHRlckdyb3VwKTtcblxuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB7XG4gICAgICBncm91cEJ5OiBvcHRpb25zLmdyb3VwQnkgPz8gb2xkT3B0aW9ucz8uZ3JvdXBCeSA/PyAnZGVmYXVsdCcsXG4gICAgICBzb3J0Qnk6IG9wdGlvbnMuc29ydEJ5ID8/IG9sZE9wdGlvbnM/LnNvcnRCeSA/PyAnY3JlYXRlLWRhdGUnLFxuICAgICAgc29ydERlc2NlbmRpbmc6IG9wdGlvbnMuc29ydERlc2NlbmRpbmcgPz8gb2xkT3B0aW9ucz8uc29ydERlc2NlbmRpbmdcbiAgICAgICAgPz8gZmFsc2UsXG4gICAgICBzaG93Q29tcGxldGVkOiBvcHRpb25zLnNob3dDb21wbGV0ZWQgPz8gb2xkT3B0aW9ucz8uc2hvd0NvbXBsZXRlZFxuICAgICAgICA/PyBmYWxzZSxcbiAgICB9O1xuXG4gICAgZmlsdGVyR3JvdXBzLnNldChmaWx0ZXJHcm91cCwgbmV3T3B0aW9ucyk7XG5cbiAgICBwcml2YXRlcy5ldmVudEVtaXR0ZXIuZW1pdCgndXBkYXRlLXNldHRpbmcnLCB7XG4gICAgICB0eXBlOiAndXBkYXRlLXNldHRpbmcnLFxuICAgICAgbmFtZTogYGZpbHRlckdyb3Vwcy4ke2ZpbHRlckdyb3VwfWAsXG4gICAgICB2YWx1ZTogXy5jbG9uZURlZXAobmV3T3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgYWxsIHNldHRpbmdzIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBAZmlyZXMgbW9kdWxlOnNldHRpbmdzflNldHRpbmdzfnVwZGF0ZVNldHRpbmdcbiAgICovXG4gIHJlc2V0VG9EZWZhdWx0KCkge1xuICAgIHRoaXMuc3RvcmFnZU1ldGhvZCA9ICdsb2NhbCc7XG4gICAgdGhpcy5zZXREYXRlRm9ybWF0KCdsb2NhbCcpO1xuICAgIHRoaXMuZGVsZXRlQWZ0ZXIgPSAxNDtcblxuICAgIGNvbnN0IGZpbHRlck9wdGlvbnMgPSB7XG4gICAgICBncm91cEJ5OiAnZGVmYXVsdCcsXG4gICAgICBzb3J0Qnk6ICdjcmVhdGUtZGF0ZScsXG4gICAgICBzb3J0RGVzY2VuZGluZzogZmFsc2UsXG4gICAgICBzaG93Q29tcGxldGVkOiBmYWxzZSxcbiAgICB9O1xuICAgIFsnZGVmYXVsdCcsICdkYXRlcycsICdwcm9qZWN0cycsICdwcmlvcml0aWVzJ10uZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgIHRoaXMuc2V0RmlsdGVyT3B0aW9ucyhncm91cCwgZmlsdGVyT3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwYXR0ZXJuIHVzZWQgZm9yIGZvcm1hdHRpbmcgYW5kIHBhcnNpbmcgZGF0ZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35kYXRlRm9ybWF0fSBbZm9ybWF0PWxvY2FsXSBUaGVcbiAgICogICB0eXBlIG9mIGRhdGUgZm9ybWF0IHRvIHVzZS4gVGhpcyBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlXG4gICAqICAgZm9ybWF0IHR5cGUgKCdsb2NhbCcsICdpc28nLCAnbW9udGgtZGF5LXllYXInLCAnZGF5LW1vbnRoLXllYXInLCBvclxuICAgKiAgICd5ZWFyLW1vbnRoLWRheScpLCBvciBpdCBjYW4gYmUgYSBmdWxsXG4gICAqICAgW2RhdGVGb3JtYXRde0BsaW5rIG1vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35kYXRlRm9ybWF0fSBvYmplY3QuXG4gICAqIEBmaXJlcyBtb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+dXBkYXRlU2V0dGluZ1xuICAgKi9cbiAgc2V0RGF0ZUZvcm1hdChmb3JtYXQgPSAnbG9jYWwnKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByaXZhdGVzLmRhdGVGb3JtYXQgPSBTZXR0aW5ncy5sb29rdXBEYXRlRm9ybWF0KGZvcm1hdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaXZhdGVzLmRhdGVGb3JtYXQgPSBfLmNsb25lRGVlcChmb3JtYXQpO1xuICAgIH1cblxuICAgIHByaXZhdGVzLmV2ZW50RW1pdHRlci5lbWl0KCd1cGRhdGUtc2V0dGluZycsIHtcbiAgICAgIHR5cGU6ICd1cGRhdGUtc2V0dGluZycsXG4gICAgICBuYW1lOiAnZGF0ZUZvcm1hdCcsXG4gICAgICB2YWx1ZTogdGhpcy5kYXRlRm9ybWF0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gZm9yIGEgcGFydGljdWxhciBkYXRlIGZvcm1hdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPWxvY2FsXSBUaGUgdHlwZSBvZiBkYXRlIGZvcm1hdCB0byBsb29rdXA6ICdsb2NhbCcsXG4gICAqICAgJ2lzbycsICdtb250aC1kYXkteWVhcicsICdkYXktbW9udGgteWVhcicsIG9yICd5ZWFyLW1vbnRoLWRheScuXG4gICAqIEByZXR1cm5zIHttb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+ZGF0ZUZvcm1hdH0gQW4gb2JqZWN0IGhvbGRpbmdcbiAgICogICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZGF0ZSBmb3JtYXQuXG4gICAqL1xuICBzdGF0aWMgbG9va3VwRGF0ZUZvcm1hdCh0eXBlID0gJ2xvY2FsJykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaXNvJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvdXRwdXRQYXR0ZXJuOiAneXl5eS1NTS1kZCcsXG4gICAgICAgICAgaW5wdXRQYXR0ZXJuczogWyd5eXl5LU1NLWRkJ10sXG4gICAgICAgICAgdmlzdWFsUGF0dGVybjogJ1lZWVktTU0tREQnLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgIH07XG4gICAgICBjYXNlICdtb250aC1kYXkteWVhcic6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3V0cHV0UGF0dGVybjogJ01NL2RkL3l5eXknLFxuICAgICAgICAgIGlucHV0UGF0dGVybnM6IFsnTU0vZGQveXknLCAnTU0vZGQveXl5eSddLFxuICAgICAgICAgIHZpc3VhbFBhdHRlcm46ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICB9O1xuICAgICAgY2FzZSAnZGF5LW1vbnRoLXllYXInOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG91dHB1dFBhdHRlcm46ICdkZC9NTS95eXl5JyxcbiAgICAgICAgICBpbnB1dFBhdHRlcm5zOiBbJ2RkL01NL3l5JywgJ2RkL01NL3l5eXknXSxcbiAgICAgICAgICB2aXN1YWxQYXR0ZXJuOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3llYXItbW9udGgtZGF5JzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvdXRwdXRQYXR0ZXJuOiAneXl5eS9NTS9kZCcsXG4gICAgICAgICAgaW5wdXRQYXR0ZXJuczogWyd5eS9NTS9kZCcsICd5eXl5L01NL2RkJ10sXG4gICAgICAgICAgdmlzdWFsUGF0dGVybjogJ1lZWVkvTU0vREQnLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgIH07XG4gICAgICBjYXNlICdsb2NhbCc6XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSB7XG4gICAgICAgICAgdG9rZW5TdHlsZTogJ2ludGVybmFsJyxcbiAgICAgICAgICBmdWxsWWVhcjogZmFsc2UsXG4gICAgICAgICAgcGFkTW9udGhzOiB0cnVlLFxuICAgICAgICAgIHBhZERheXM6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlucHV0UGF0dGVybnMgPSBbZ2V0RGF0ZUZvcm1hdChudWxsLCBmb3JtYXRPcHRzKV07XG5cbiAgICAgICAgZm9ybWF0T3B0cy5mdWxsWWVhciA9IHRydWU7XG4gICAgICAgIGNvbnN0IG91dHB1dFBhdHRlcm4gPSBnZXREYXRlRm9ybWF0KG51bGwsIGZvcm1hdE9wdHMpO1xuICAgICAgICBpbnB1dFBhdHRlcm5zLnB1c2gob3V0cHV0UGF0dGVybik7XG5cbiAgICAgICAgZm9ybWF0T3B0cy50b2tlblN0eWxlID0gJ3Zpc3VhbCc7XG4gICAgICAgIGNvbnN0IHZpc3VhbFBhdHRlcm4gPSBnZXREYXRlRm9ybWF0KG51bGwsIGZvcm1hdE9wdHMpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3V0cHV0UGF0dGVybixcbiAgICAgICAgICBpbnB1dFBhdHRlcm5zLFxuICAgICAgICAgIHZpc3VhbFBhdHRlcm4sXG4gICAgICAgICAgdHlwZTogJ2xvY2FsJyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHNldHRpbmdzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGVcbiAgICogICBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmV2ZW50RW1pdHRlci5vbih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBkYXRhIHRvIGFuIG9iamVjdCBzdWl0YWJsZSBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBzZXJpYWxpemFibGUgZGF0YSBmb3IgdGhlIGNsYXNzLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHN0b3JhZ2VNZXRob2Q6IHRoaXMuc3RvcmFnZU1ldGhvZCxcbiAgICAgIGRhdGVGb3JtYXQ6IHRoaXMuZGF0ZUZvcm1hdCxcbiAgICAgIGRlbGV0ZUFmdGVyOiB0aGlzLmRlbGV0ZUFmdGVyLFxuICAgICAgZmlsdGVyR3JvdXBzOiB7fSxcbiAgICB9O1xuXG4gICAgcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLmZpbHRlckdyb3Vwcy5mb3JFYWNoKChvcHRpb25zLCBncm91cCkgPT4ge1xuICAgICAgcmVzdWx0LmZpbHRlckdyb3Vwc1tncm91cF0gPSBfLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IHNldHRpbmdzIGZyb20gYSBKU09OIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIHNlcmlhbGl6ZWQgSlNPTiBvYmplY3QgdG8gaW1wb3J0LlxuICAgKiBAcmV0dXJucyB7bW9kdWxlOnNldHRpbmdzflNldHRpbmdzfmltcG9ydFN0YXR1c30gQW4gb2JqZWN0IGhvbGRpbmdcbiAgICogICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3RhdHVzIG9mIHRoZSBpbXBvcnQuXG4gICAqIEBmaXJlcyBtb2R1bGU6c2V0dGluZ3N+U2V0dGluZ3N+dXBkYXRlU2V0dGluZ1xuICAgKi9cbiAgaW1wb3J0RnJvbUpzb24oZGF0YSkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyb3JUeXBlLCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICAgIHN3aXRjaCAoZXJyb3JUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2JhZC10eXBlJzpcbiAgICAgICAgICBlcnJvcnMucHVzaChgRXJyb3I6IEV4cGVjdGVkIHR5cGUgXCIke29wdGlvbnMuZXhwZWN0ZWRUeXBlfVwiIGZvciBzZXR0aW5nIFwiJHtvcHRpb25zLnZhbHVlTmFtZX1cIiAocmVjZWl2ZWQgXCIke2dldEpzb25UeXBlKHZhbHVlKX1cIikuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Vua25vd24tdmFsdWUnOlxuICAgICAgICAgIGVycm9ycy5wdXNoKGBFcnJvcjogVW5yZWNvZ25pemVkIHZhbHVlIFwiJHt2YWx1ZX1cIiBmb3Igc2V0dGluZyBcIiR7b3B0aW9ucy52YWx1ZU5hbWV9XCIuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25vdC1pbnRlZ2VyJzpcbiAgICAgICAgICBlcnJvcnMucHVzaChgRXJyb3I6IFZhbHVlIGZvciBzZXR0aW5nIFwiJHtvcHRpb25zLnZhbHVlTmFtZX1cIiBtdXN0IGJlIGFuIGludGVnZXIgKHJlY2VpdmVkIFwiJHt2YWx1ZX1cIikuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Rvby1sb3cnOlxuICAgICAgICAgIGVycm9ycy5wdXNoKGBFcnJvcjogVmFsdWUgZm9yIHNldHRpbmcgXCIke29wdGlvbnMudmFsdWVOYW1lfVwiIGNhbm5vdCBiZSBiZWxvdyBcIiR7b3B0aW9ucy5taW59XCIgKHJlY2VpdmVkIFwiJHt2YWx1ZX1cIikuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Rvby1oaWdoJzpcbiAgICAgICAgICBlcnJvcnMucHVzaChgRXJyb3I6IFZhbHVlIGZvciBzZXR0aW5nIFwiJHtvcHRpb25zLnZhbHVlTmFtZX1cIiBjYW5ub3QgYmUgYWJvdmUgXCIke29wdGlvbnMubWF4fVwiIChyZWNlaXZlZCBcIiR7dmFsdWV9XCIpLmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVycm9ycy5wdXNoKGBFcnJvcjogRW5jb3VudGVyZWQgdW5yZWNvZ25pemVkIGVycm9yIFwiJHtlcnJvclR5cGV9XCIgZm9yIHNldHRpbmcgXCIke29wdGlvbnMudmFsdWVOYW1lfVwiLmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodmFsaWRhdGVWYWx1ZShkYXRhLnN0b3JhZ2VNZXRob2QsIHtcbiAgICAgIHZhbHVlTmFtZTogJ3N0b3JhZ2VNZXRob2QnLFxuICAgICAgZXhwZWN0ZWRUeXBlOiAnc3RyaW5nJyxcbiAgICAgIGV4cGVjdGVkVmFsdWVzOiBbJ25vbmUnLCAnbG9jYWwnXSxcbiAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgIH0pKSB0aGlzLnN0b3JhZ2VNZXRob2QgPSBkYXRhLnN0b3JhZ2VNZXRob2Q7XG5cbiAgICBpZiAoZGF0YS5kYXRlRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgIGlmICh2YWxpZGF0ZVZhbHVlKGRhdGEuZGF0ZUZvcm1hdC50eXBlLCB7XG4gICAgICAgIHZhbHVlTmFtZTogJ2RhdGVGb3JtYXQudHlwZScsXG4gICAgICAgIGV4cGVjdGVkVHlwZTogJ3N0cmluZycsXG4gICAgICAgIGV4cGVjdGVkVmFsdWVzOiBbXG4gICAgICAgICAgJ2xvY2FsJyxcbiAgICAgICAgICAnaXNvJyxcbiAgICAgICAgICAnbW9udGgtZGF5LXllYXInLFxuICAgICAgICAgICdkYXktbW9udGgteWVhcicsXG4gICAgICAgICAgJ3llYXItbW9udGgtZGF5JyxcbiAgICAgICAgXSxcbiAgICAgICAgZXJyb3JDYWxsYmFjazogaGFuZGxlRXJyb3IsXG4gICAgICB9KSkgdGhpcy5zZXREYXRlRm9ybWF0KGRhdGEuZGF0ZUZvcm1hdC50eXBlKTtcbiAgICB9XG5cbiAgICBpZiAodmFsaWRhdGVWYWx1ZShkYXRhLmRlbGV0ZUFmdGVyLCB7XG4gICAgICB2YWx1ZU5hbWU6ICdkZWxldGVBZnRlcicsXG4gICAgICBleHBlY3RlZFR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZUludGVnZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICB9KSkgdGhpcy5kZWxldGVBZnRlciA9IGRhdGEuZGVsZXRlQWZ0ZXI7XG5cbiAgICBpZiAoZGF0YS5maWx0ZXJHcm91cHMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcHJvY2Vzc0dyb3VwID0gKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyT3B0aW9ucyA9IGRhdGEuZmlsdGVyR3JvdXBzW25hbWVdO1xuICAgICAgICBpZiAoZmlsdGVyT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUoZmlsdGVyT3B0aW9ucy5ncm91cEJ5LCB7XG4gICAgICAgICAgICB2YWx1ZU5hbWU6IGBmaWx0ZXJHcm91cHMuJHtuYW1lfS5ncm91cEJ5YCxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBleHBlY3RlZFZhbHVlczogW1xuICAgICAgICAgICAgICAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICdkdWUtZGF0ZScsXG4gICAgICAgICAgICAgICdwcmlvcml0eScsXG4gICAgICAgICAgICAgICdwcm9qZWN0JyxcbiAgICAgICAgICAgICAgJ25vbmUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICAgIH0pKSBuZXdPcHRpb25zLmdyb3VwQnkgPSBmaWx0ZXJPcHRpb25zLmdyb3VwQnk7XG5cbiAgICAgICAgICBpZiAodmFsaWRhdGVWYWx1ZShmaWx0ZXJPcHRpb25zLnNvcnRCeSwge1xuICAgICAgICAgICAgdmFsdWVOYW1lOiBgZmlsdGVyR3JvdXBzLiR7bmFtZX0uc29ydEJ5YCxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBleHBlY3RlZFZhbHVlczogW1xuICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICdkdWUtZGF0ZScsXG4gICAgICAgICAgICAgICdjcmVhdGUtZGF0ZScsXG4gICAgICAgICAgICAgICdwcmlvcml0eScsXG4gICAgICAgICAgICAgICdwcm9qZWN0JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgICB9KSkgbmV3T3B0aW9ucy5zb3J0QnkgPSBmaWx0ZXJPcHRpb25zLnNvcnRCeTtcblxuICAgICAgICAgIGlmICh2YWxpZGF0ZVZhbHVlKGZpbHRlck9wdGlvbnMuc29ydERlc2NlbmRpbmcsIHtcbiAgICAgICAgICAgIHZhbHVlTmFtZTogYGZpbHRlckdyb3Vwcy4ke25hbWV9LnNvcnREZXNjZW5kaW5nYCxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZXJyb3JDYWxsYmFjazogaGFuZGxlRXJyb3IsXG4gICAgICAgICAgfSkpIG5ld09wdGlvbnMuc29ydERlc2NlbmRpbmcgPSBmaWx0ZXJPcHRpb25zLnNvcnREZXNjZW5kaW5nO1xuXG4gICAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUoZmlsdGVyT3B0aW9ucy5zaG93Q29tcGxldGVkLCB7XG4gICAgICAgICAgICB2YWx1ZU5hbWU6IGBmaWx0ZXJHcm91cHMuJHtuYW1lfS5zaG93Q29tcGxldGVkYCxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZXJyb3JDYWxsYmFjazogaGFuZGxlRXJyb3IsXG4gICAgICAgICAgfSkpIG5ld09wdGlvbnMuc2hvd0NvbXBsZXRlZCA9IGZpbHRlck9wdGlvbnMuc2hvd0NvbXBsZXRlZDtcblxuICAgICAgICAgIHRoaXMuc2V0RmlsdGVyT3B0aW9ucyhuYW1lLCBuZXdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcHJvY2Vzc0dyb3VwKCdkZWZhdWx0Jyk7XG4gICAgICBwcm9jZXNzR3JvdXAoJ2RhdGVzJyk7XG4gICAgICBwcm9jZXNzR3JvdXAoJ3Byb2plY3RzJyk7XG4gICAgICBwcm9jZXNzR3JvdXAoJ3ByaW9yaXRpZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnMgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZXR0aW5ncztcbiIsIi8qKlxuICogRGVmaW5lcyB0aGUgW1Rhc2tde0BsaW5rIG1vZHVsZTp0YXNrflRhc2t9IGNsYXNzLlxuICogQG1vZHVsZSB0YXNrXG4gKi9cblxuaW1wb3J0IFJlY3VycmluZ0RhdGUgZnJvbSAnLi9yZWN1cnJpbmdEYXRlJztcbmltcG9ydCB7IHBhcnNlSXNvRGF0ZVRpbWUgfSBmcm9tICcuL3V0aWxpdHkvZGF0ZXMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0YXNrLlxuICovXG5jbGFzcyBUYXNrIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRhc2suXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIEFuIG9iamVjdCBzcGVjaWZ5aW5nIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3JcbiAgICogICB0aGUgdGFzay5cbiAgICogQHBhcmFtIHtEYXRlfSBbb3B0aW9ucy5kdWVEYXRlXSBUaGUgZGF0ZSB3aGVuIHRoZSB0YXNrIGlzIGR1ZSwgaWYgYW55LlxuICAgKiBAcGFyYW0ge0RhdGV9IFtvcHRpb25zLmNyZWF0aW9uRGF0ZV0gVGhlIGRhdGUgdGhlIHRhc2sgd2FzIGNyZWF0ZWQuIElmIG5vdFxuICAgKiAgIGdpdmVuLCB0aGVuIHRoZSBwcmVzZW50IGRhdGUgaXMgdXNlZC5cbiAgICogQHBhcmFtIHtEYXRlfSBbb3B0aW9ucy5jb21wbGV0aW9uRGF0ZV0gVGhlIGRhdGUgd2hlbiB0aGUgdGFzayB3YXNcbiAgICogICBjb21wbGV0ZWQsIGlmIGFueS5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy5wcmlvcml0eT0wXSBUaGUgcHJpb3JpdHkgb2YgdGhlIHRhc2suIEZvclxuICAgKiAgIG51bWVyaWMgdmFsdWVzLCBhIGxhcmdlciB2YWx1ZSBpbmRpY2F0ZXMgYSBoaWdoZXIgcHJpb3JpdHksIHdpdGggMFxuICAgKiAgIHJlcHJlc2VudGluZyBtZWRpdW0gcHJpb3JpdHksIHBvc2l0aXZlIHZhbHVlcyByZXByZXNlbnRpbmcgaGlnaGVyLXRoYW4tXG4gICAqICAgbWVkaXVtIHByaW9yaXR5LCBhbmQgbmVnYXRpdmUgdmFsdWVzIHJlcHJlc2VudGluZyBsb3dlci10aGFuLW1lZGl1bVxuICAgKiAgIHByaW9yaXR5LiBGb3Igc3RyaW5nIHZhbHVlcywgcG9zc2libGUgc2V0dGluZ3MgYXJlICd2ZXJ5LWxvdycsICdsb3cnLFxuICAgKiAgICdtZWRpdW0nLCAnaGlnaCcsIGFuZCAndmVyeS1oaWdoJy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXSBBIGRlc2NyaXB0aW9uIGZvciB0aGUgdGFzay5cbiAgICogQHBhcmFtIHttb2R1bGU6cmVjdXJyaW5nRGF0ZX5SZWN1cnJpbmdEYXRlfSBbb3B0aW9ucy5yZWN1cnJpbmdEYXRlXSBBXG4gICAqICAgcmVjdXJyaW5nIGRhdGUgZm9yIHRoZSB0YXNrLCBpZiBhbnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm9qZWN0XSBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJvamVjdCB0byB3aGljaFxuICAgKiAgIHRoZSB0YXNrIGJlbG9uZ3MsIGlmIGFueS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSB0YXNrLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIHRhc2sgaXMgZHVlLCBpZiBhbnkuXG4gICAgICogQHR5cGUgez9EYXRlfVxuICAgICAqL1xuICAgIHRoaXMuZHVlRGF0ZSA9IG9wdGlvbnMuZHVlRGF0ZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgd2hlbiB0aGUgdGFzayB3YXMgY3JlYXRlZC5cbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0aW9uRGF0ZSA9IG9wdGlvbnMuY3JlYXRpb25EYXRlIHx8IG5ldyBEYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSB3aGVuIHRoZSB0YXNrIHdhcyBjb21wbGV0ZWQsIG9yIG51bGwgaWYgaXQgaXMgbm90IGNvbXBsZXRlZC5cbiAgICAgKiBAdHlwZSB7P0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb21wbGV0aW9uRGF0ZSA9IG9wdGlvbnMuY29tcGxldGlvbkRhdGUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmlvcml0eSBvZiB0aGUgdGFzay4gQSBsYXJnZXIgdmFsdWUgaW5kaWNhdGVzIGEgaGlnaGVyIHByaW9yaXR5LFxuICAgICAqIHdpdGggMCByZXByZXNlbnRpbmcgbWVkaXVtIHByaW9yaXR5LiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGhpZ2hlciB0aGFuXG4gICAgICogbWVkaXVtLCBhbmQgbmVnYXRpdmUgdmFsdWVzIGFyZSBsb3dlciB0aGFuIG1lZGl1bS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmlvcml0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucHJpb3JpdHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnByaW9yaXR5U3RyaW5nID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBkZXNjcmlwdGlvbiBvZiB0aGUgdGFzay5cbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbiA/PyBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSByZWN1cnJpbmcgZGF0ZSBmb3IgdGhlIHRhc2ssIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7P21vZHVsZTpyZWN1cnJpbmdEYXRlflJlY3VycmluZ0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5yZWN1cnJpbmdEYXRlID0gb3B0aW9ucy5yZWN1cnJpbmdEYXRlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJvamVjdCB0byB3aGljaCB0aGlzIHRhc2sgYmVsb25ncywgaWYgYW55LlxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdCA9IG9wdGlvbnMucHJvamVjdCB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwcmlvcml0eSBvZiB0aGUgdGFzayByZXByZXNlbnRlZCBhcyBhIHN0cmluZyB2YWx1ZS4gVGhpcyBjb3JyZXNwb25kc1xuICAgKiB0byB0aGUgbnVtZXJpY2FsIFtwcmlvcml0eV17QGxpbmsgbW9kdWxlOnRhc2t+VGFza35wcmlvcml0eX0gcHJvcGVydHksXG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBjb3JyZXNwb25kZW5jZTogJ3ZlcnktbG93JyA9IC0yLCAnbG93JyA9IC0xLCAnbWVkaXVtJyA9XG4gICAqIDAsICdoaWdoJyA9IDEsIGFuZCAndmVyeS1oaWdoJyA9IDIuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgcHJpb3JpdHlTdHJpbmcoKSB7XG4gICAgcmV0dXJuIFRhc2suY29udmVydFByaW9yaXR5VG9TdHJpbmcodGhpcy5wcmlvcml0eSk7XG4gIH1cblxuICBzZXQgcHJpb3JpdHlTdHJpbmcocHJpb3JpdHkpIHtcbiAgICB0aGlzLnByaW9yaXR5ID0gVGFzay5jb252ZXJ0U3RyaW5nVG9Qcmlvcml0eShwcmlvcml0eSk7XG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGUgdGFzayBhcyBjb21wbGV0ZWQuXG4gICAqIEBwYXJhbSB7RGF0ZX0gW2RhdGVdIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNvbXBsZXRpb24uIElmIG5vdCBnaXZlbiwgdGhlblxuICAgKiAgIHRoZSBwcmVzZW50IHRpbWUgaXMgdXNlZC5cbiAgICovXG4gIG1hcmtDb21wbGV0ZShkYXRlKSB7XG4gICAgdGhpcy5jb21wbGV0aW9uRGF0ZSA9IGRhdGUgfHwgbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIHRoZSB0YXNrIGFzIGluY29tcGxldGUuXG4gICAqL1xuICBtYXJrSW5jb21wbGV0ZSgpIHtcbiAgICB0aGlzLmNvbXBsZXRpb25EYXRlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhlIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdGFzayBoYXMgYmVlbiBjb21wbGV0ZWQgYW5kIGZhbHNlXG4gICAqICAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNDb21wbGV0ZSgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmNvbXBsZXRpb25EYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRhc2suXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0YXNrLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZSA/IGBUYXNrOiAke3RoaXMubmFtZX1gIDogJ1Rhc2s6ICh1bnRpdGxlZCknO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRhc2sgZnJvbSBhIEpTT04gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgSlNPTiBvYmplY3QgaG9sZGluZyB0aGUgc2VyaWFsaXplZCBkYXRhLlxuICAgKiBAcmV0dXJucyB7bW9kdWxlOnRhc2t+VGFza30gQSBuZXcgdGFzayBjb252ZXJ0ZWQgZnJvbSB0aGUgSlNPTiBkYXRhLlxuICAgKi9cbiAgc3RhdGljIGZyb21Kc29uKGRhdGEpIHtcbiAgICBjb25zdCBjb252ZXJ0RGF0ZSA9IChkYXRlKSA9PiAoZGF0ZSA/IHBhcnNlSXNvRGF0ZVRpbWUoZGF0ZSkgOiBudWxsKTtcbiAgICBjb25zdCByZWN1cnJpbmdEYXRlID0gZGF0YS5yZWN1cnJpbmdEYXRlXG4gICAgICA/IFJlY3VycmluZ0RhdGUuZnJvbUpzb24oZGF0YS5yZWN1cnJpbmdEYXRlKSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBUYXNrKGRhdGEubmFtZSwge1xuICAgICAgZHVlRGF0ZTogY29udmVydERhdGUoZGF0YS5kdWVEYXRlKSxcbiAgICAgIGNyZWF0aW9uRGF0ZTogY29udmVydERhdGUoZGF0YS5jcmVhdGlvbkRhdGUpLFxuICAgICAgY29tcGxldGlvbkRhdGU6IGNvbnZlcnREYXRlKGRhdGEuY29tcGxldGlvbkRhdGUpLFxuICAgICAgcHJpb3JpdHk6IGRhdGEucHJpb3JpdHksXG4gICAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgIHJlY3VycmluZ0RhdGUsXG4gICAgICBwcm9qZWN0OiBkYXRhLnByb2plY3QsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHRhc2sgcHJpb3JpdHkgbnVtYmVyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHkgVGhlIHByaW9yaXR5IHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaW9yaXR5IHZhbHVlLlxuICAgKi9cbiAgc3RhdGljIGNvbnZlcnRQcmlvcml0eVRvU3RyaW5nKHByaW9yaXR5KSB7XG4gICAgc3dpdGNoIChwcmlvcml0eSkge1xuICAgICAgY2FzZSAtMjogcmV0dXJuICd2ZXJ5LWxvdyc7XG4gICAgICBjYXNlIC0xOiByZXR1cm4gJ2xvdyc7XG4gICAgICBjYXNlIDA6IHJldHVybiAnbWVkaXVtJztcbiAgICAgIGNhc2UgMTogcmV0dXJuICdoaWdoJztcbiAgICAgIGNhc2UgMjogcmV0dXJuICd2ZXJ5LWhpZ2gnO1xuICAgICAgZGVmYXVsdDogcmV0dXJuICd1bmtub3duJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHRhc2sgcHJpb3JpdHkgbnVtYmVyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBVbmxpa2VcbiAgICogW2NvbnZlcnRQcmlvcml0eVRvU3RyaW5nXXtAbGluayBtb2R1bGU6dGFza35UYXNrLmNvbnZlcnRQcmlvcml0eVRvU3RyaW5nfSxcbiAgICogdGhpcyBtZXRob2QgcmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHN1aXRhYmxlIGZvciBkaXNwbGF5IHRvIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHkgVGhlIHByaW9yaXR5IHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaW9yaXR5IHZhbHVlLlxuICAgKi9cbiAgc3RhdGljIGNvbnZlcnRQcmlvcml0eVRvUHJldHR5U3RyaW5nKHByaW9yaXR5KSB7XG4gICAgc3dpdGNoIChwcmlvcml0eSkge1xuICAgICAgY2FzZSAtMjogcmV0dXJuICdWZXJ5IExvdyc7XG4gICAgICBjYXNlIC0xOiByZXR1cm4gJ0xvdyc7XG4gICAgICBjYXNlIDA6IHJldHVybiAnTWVkaXVtJztcbiAgICAgIGNhc2UgMTogcmV0dXJuICdIaWdoJztcbiAgICAgIGNhc2UgMjogcmV0dXJuICdWZXJ5IEhpZ2gnO1xuICAgICAgZGVmYXVsdDogcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRhc2sgcHJpb3JpdHkgdG8gdGhlIHN0YW5kYXJkIG51bWVyaWNcbiAgICogZXF1aXZhbGVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW9yaXR5U3RyIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaW9yaXR5IHRvXG4gICAqICAgY29udmVydC5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIHByaW9yaXR5IHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBjb252ZXJ0U3RyaW5nVG9Qcmlvcml0eShwcmlvcml0eVN0cikge1xuICAgIHN3aXRjaCAocHJpb3JpdHlTdHIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAndmVyeS1sb3cnOlxuICAgICAgY2FzZSAndmVyeSBsb3cnOlxuICAgICAgICByZXR1cm4gLTI7XG4gICAgICBjYXNlICdsb3cnOlxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgJ2hpZ2gnOlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgJ3ZlcnktaGlnaCc6XG4gICAgICBjYXNlICd2ZXJ5IGhpZ2gnOlxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUYXNrO1xuIiwiLyoqXG4gKiBEZWZpbmVzIHRoZSBbVGFza0Rpc3BsYXlde0BsaW5rIG1vZHVsZTp0YXNrRGlzcGxheX5UYXNrRGlzcGxheX0gY2xhc3MuXG4gKiBAbW9kdWxlIHRhc2tEaXNwbGF5XG4gKi9cblxuaW1wb3J0IHsgaXNTYW1lRGF5IH0gZnJvbSAnZGF0ZS1mbnMnO1xuXG5pbXBvcnQgUG9wdXBNZW51IGZyb20gJy4vcG9wdXBNZW51JztcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCBUYXNrIGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBmb3JtYXREYXRlIH0gZnJvbSAnLi91dGlsaXR5L2RhdGVzJztcbmltcG9ydCB7IGNyZWF0ZUljb25CdXR0b24gfSBmcm9tICcuL3V0aWxpdHkvZG9tJztcblxuY29uc3QgQ0hFQ0tFRF9JQ09OID0gJ2NoZWNrX2NpcmNsZV9vdXRsaW5lJztcbmNvbnN0IFVOQ0hFQ0tFRF9JQ09OID0gJ3JhZGlvX2J1dHRvbl91bmNoZWNrZWQnO1xuXG5jb25zdCBTVEFOREFSRF9NRU5VX0lURU1TID0gW1xuICB7IGxhYmVsOiAnRWRpdCBUYXNrLi4uJywgaWQ6ICdlZGl0JywgaWNvblR5cGU6ICdlZGl0JyB9LFxuICB7IGxhYmVsOiAnQ2xvbmUgVGFzaycsIGlkOiAnY2xvbmUnLCBpY29uVHlwZTogJ2NvbnRlbnRfY29weScgfSxcbiAgeyBsYWJlbDogJ0RlbGV0ZSBUYXNrLi4uJywgaWQ6ICdkZWxldGUnLCBpY29uVHlwZTogJ2RlbGV0ZScgfSxcbl07XG5jb25zdCBQUk9KRUNUX01FTlVfSVRFTVMgPSBbXG4gIHsgbGFiZWw6ICdHbyBUbyBQcm9qZWN0JywgaWQ6ICdnby10by1wcm9qZWN0JywgaWNvblR5cGU6ICdhc3NpZ25tZW50JyB9LFxuXTtcblxuLyoqXG4gKiBPYmplY3QgaG9sZGluZyBwcml2YXRlIG1lbWJlcnMgZm9yIHRoZVxuICogW1Rhc2tEaXNwbGF5XXtAbGluayBtb2R1bGU6dGFza0Rpc3BsYXl+VGFza0Rpc3BsYXl9IGNsYXNzLlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOnRhc2tEaXNwbGF5flRhc2tEaXNwbGF5fnByaXZhdGVzXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb250YWluZXIgVGhlIHRvcC1sZXZlbCBjb250YWluZXIgaG9sZGluZyB0aGVcbiAqICAgZGlzcGxheSBwYW5lbC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGNvbnRlbnQgVGhlIGNvbnRhaW5lciBob2xkaW5nIHRoZSBwYW5lbCBjb250ZW50LlxuICogQHByb3BlcnR5IHttb2R1bGU6dGFza0xpc3R+VGFza0xpc3R9IHRhc2tzIFRoZSB0YXNrIGNvbnRhaW5lci5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fSBwcm9qZWN0cyBUaGUgcHJvamVjdCBjb250YWluZXIuXG4gKiBAcHJvcGVydHkge21vZHVsZTp0YXNrRGlzcGxheX5UYXNrRGlzcGxheX50YXNrQ2FsbGJhY2t9IFt0YXNrQ2FsbGJhY2tdIEFcbiAqICAgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYW4gYWN0aW9uIG9uIGFcbiAqICAgdGFzay5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnNldHRpbmdzflNldHRpbmdzfmRhdGVGb3JtYXR9IGRhdGVGb3JtYXQgQW4gb2JqZWN0IGhvbGRpbmdcbiAqICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZvcm1hdCB0byB1c2UgZm9yIGNhbGVuZGFyIGRhdGVzLlxuICogQHByb3BlcnR5IHttb2R1bGU6cG9wdXBNZW51flBvcHVwTWVudX0gdGFza01lbnUgVGhlIHBvcHVwIG1lbnUgdGhhdCBpcyBzaG93blxuICogICB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgJ21vcmUnIGJ1dHRvbiBuZXh0IHRvIGEgdGFzay5cbiAqL1xuXG4vKipcbiAqIEhvbGRzIHByaXZhdGUgZGF0YSBmb3IgdGhlXG4gKiBbVGFza0Rpc3BsYXlde0BsaW5rIG1vZHVsZTp0YXNrRGlzcGxheX5UYXNrRGlzcGxheX0gY2xhc3MuXG4gKiBAdHlwZSB7V2Vha01hcH1cbiAqIEBzZWUgbW9kdWxlOnRhc2tEaXNwbGF5flRhc2tEaXNwbGF5fnByaXZhdGVzXG4gKi9cbmNvbnN0IHByaXZhdGVNZW1iZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byB0YXNrcyBiZWxvbmcgdG8gdGhlIHNhbWUgdGFzayBncm91cC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBncm91cEJ5IFRoZSB0eXBlIG9mIGdyb3VwaW5nIGJlaW5nIGRvbmU6ICdkdWUtZGF0ZScsXG4gKiAgICdwcm9qZWN0JywgJ3ByaW9yaXR5Jywgb3IgJ25vbmUnLlxuICogQHBhcmFtIHttb2R1bGU6dGFza35UYXNrfSB0YXNrMSBUaGUgZmlyc3QgdGFzayB0byBjb21wYXJlLlxuICogQHBhcmFtIHttb2R1bGU6dGFza35UYXNrfSB0YXNrMiBUaGUgc2Vjb25kIHRhc2sgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0YXNrcyBiZWxvbmcgdG8gdGhlIHNhbWUgZ3JvdXAgYW5kIGZhbHNlXG4gKiAgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNTYW1lR3JvdXAoZ3JvdXBCeSwgdGFzazEsIHRhc2syKSB7XG4gIHN3aXRjaCAoZ3JvdXBCeSkge1xuICAgIGNhc2UgJ2R1ZS1kYXRlJzpcbiAgICAgIGlmICghdGFzazEuZHVlRGF0ZSAmJiAhdGFzazIuZHVlRGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoIXRhc2sxLmR1ZURhdGUgJiYgdGFzazIuZHVlRGF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRhc2sxLmR1ZURhdGUgJiYgIXRhc2syLmR1ZURhdGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBpc1NhbWVEYXkodGFzazEuZHVlRGF0ZSwgdGFzazIuZHVlRGF0ZSk7XG4gICAgY2FzZSAncHJpb3JpdHknOlxuICAgICAgcmV0dXJuIHRhc2sxLnByaW9yaXR5ID09PSB0YXNrMi5wcmlvcml0eTtcbiAgICBjYXNlICdwcm9qZWN0JzpcbiAgICAgIGlmICghdGFzazEucHJvamVjdCAmJiAhdGFzazIucHJvamVjdCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoIXRhc2sxLnByb2plY3QgJiYgdGFzazIucHJvamVjdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRhc2sxLnByb2plY3QgJiYgIXRhc2syLnByb2plY3QpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0YXNrMS5wcm9qZWN0ID09PSB0YXNrMi5wcm9qZWN0O1xuICAgIGNhc2UgJ25vbmUnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEVtcHR5IHRoZSBkaXNwbGF5IHBhbmVsLlxuICogQHBhcmFtIHttb2R1bGU6dGFza0Rpc3BsYXl+VGFza0Rpc3BsYXl9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNsZWFyKGluc3RhbmNlKSB7XG4gIHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSkuY29udGVudC5pbm5lckhUTUwgPSAnJztcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0IGVsZW1lbnQgYW5kIG9wdGlvbmFsIGhlYWRpbmcgdG8gdGhlIHBhbmVsIGZvciBob2xkaW5nIHRhc2tzLlxuICogQHBhcmFtIHttb2R1bGU6dGFza0Rpc3BsYXl+VGFza0Rpc3BsYXl9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXSBUaGUgdGV4dCBjb250ZW50IG9mIHRoZSBoZWFkaW5nLCBpZiBhbnkuXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBsaXN0IGVsZW1lbnQgd2hlcmUgdGhlIHRhc2sgaXRlbXMgY2FuIGJlXG4gKiAgIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMaXN0KGluc3RhbmNlLCBsYWJlbCkge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG5cbiAgaWYgKGxhYmVsKSB7XG4gICAgY29uc3QgaGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2g0Jyk7XG4gICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCd0YXNrLWxpc3QtaGVhZGluZycpO1xuICAgIGhlYWRpbmcudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICBwcml2YXRlcy5jb250ZW50LmFwcGVuZENoaWxkKGhlYWRpbmcpO1xuICB9XG5cbiAgY29uc3QgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gIGxpc3QuY2xhc3NMaXN0LmFkZCgndGFzay1saXN0Jyk7XG4gIHByaXZhdGVzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobGlzdCk7XG4gIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIEFkZCBhIHRhc2sgZW50cnkgdG8gYSBncm91cCBsaXN0LlxuICogQHBhcmFtIHttb2R1bGU6dGFza0Rpc3BsYXl+VGFza0Rpc3BsYXl9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBsaXN0IFRoZSBsaXN0IGVsZW1lbnQgaW4gd2hpY2ggdGhlIHRhc2sgaW5mb3JtYXRpb25cbiAqICAgc2hvdWxkIGJlIGluc2VydGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhc2tJZCBUaGUgaWRlbnRpZmllciBmb3IgdGhlIHRhc2suXG4gKiBAcGFyYW0ge21vZHVsZTp0YXNrflRhc2t9IHRhc2sgVGhlIHRhc2sgdG8gYmUgYWRkZWQuXG4gKi9cbmZ1bmN0aW9uIGFkZFRhc2soaW5zdGFuY2UsIGxpc3QsIHRhc2tJZCwgdGFzaykge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG5cbiAgY29uc3QgaXRlbUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBpdGVtRWxlbS5jbGFzc0xpc3QuYWRkKCd0YXNrLWxpc3QtaXRlbScpO1xuICBsaXN0LmFwcGVuZENoaWxkKGl0ZW1FbGVtKTtcblxuICBjb25zdCBpY29uVHlwZSA9IHRhc2suaXNDb21wbGV0ZSgpID8gQ0hFQ0tFRF9JQ09OIDogVU5DSEVDS0VEX0lDT047XG4gIGNvbnN0IGNoZWNrQnV0dG9uID0gY3JlYXRlSWNvbkJ1dHRvbihpY29uVHlwZSwge1xuICAgIGNsYXNzTGlzdDogWyd0YXNrLWxpc3QtaXRlbS1jaGVja2JveCddLFxuICB9KTtcbiAgaXRlbUVsZW0uYXBwZW5kQ2hpbGQoY2hlY2tCdXR0b24pO1xuICBpZiAocHJpdmF0ZXMudGFza0NhbGxiYWNrKSB7XG4gICAgY2hlY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gdGFzay5pc0NvbXBsZXRlKCkgPyAnbWFyay1pbmNvbXBsZXRlJyA6ICdtYXJrLWNvbXBsZXRlJztcbiAgICAgIHByaXZhdGVzLnRhc2tDYWxsYmFjayh0eXBlLCB0YXNrSWQsIHRhc2spO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgaW5mb0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbmZvQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Rhc2stbGlzdC1pdGVtLWluZm8tY29udGFpbmVyJyk7XG4gIGl0ZW1FbGVtLmFwcGVuZENoaWxkKGluZm9Db250YWluZXIpO1xuXG4gIGNvbnN0IG5hbWVFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG5hbWVFbGVtLmNsYXNzTGlzdC5hZGQoJ3Rhc2stbGlzdC1pdGVtLW5hbWUnKTtcbiAgbmFtZUVsZW0udGV4dENvbnRlbnQgPSB0YXNrLm5hbWU7XG4gIGluZm9Db250YWluZXIuYXBwZW5kQ2hpbGQobmFtZUVsZW0pO1xuXG4gIGlmICh0YXNrLmRlc2NyaXB0aW9uKSB7XG4gICAgY29uc3QgZGVzY0VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZXNjRWxlbS5jbGFzc0xpc3QuYWRkKCd0YXNrLWxpc3QtaXRlbS1kZXNjcmlwdGlvbicpO1xuICAgIGRlc2NFbGVtLnRleHRDb250ZW50ID0gdGFzay5kZXNjcmlwdGlvbjtcbiAgICBpbmZvQ29udGFpbmVyLmFwcGVuZENoaWxkKGRlc2NFbGVtKTtcbiAgfVxuXG4gIGNvbnN0IGRldGFpbHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaW5mb0NvbnRhaW5lci5hcHBlbmRDaGlsZChkZXRhaWxzQ29udGFpbmVyKTtcbiAgY29uc3QgYWRkRGV0YWlsID0gKGNvbnRlbnQsIHN0eWxlQ2xhc3MpID0+IHtcbiAgICBpZiAoZGV0YWlsc0NvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIGNvbnN0IGNvbW1hID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgY29tbWEuY2xhc3NMaXN0LmFkZCgndGFzay1saXN0LWl0ZW0tZGV0YWlscycpO1xuICAgICAgY29tbWEudGV4dENvbnRlbnQgPSAnLCAnO1xuICAgICAgZGV0YWlsc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjb21tYSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGV0YWlsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGRldGFpbC5jbGFzc0xpc3QuYWRkKCd0YXNrLWxpc3QtaXRlbS1kZXRhaWxzJywgc3R5bGVDbGFzcyk7XG4gICAgZGV0YWlsLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICBkZXRhaWxzQ29udGFpbmVyLmFwcGVuZENoaWxkKGRldGFpbCk7XG4gIH07XG5cbiAgaWYgKHRhc2suZHVlRGF0ZSkge1xuICAgIGNvbnN0IGRhdGVGb3JtYXQgPSBwcml2YXRlcy5kYXRlRm9ybWF0Lm91dHB1dFBhdHRlcm47XG4gICAgY29uc3QgZGF0ZVN0ciA9IGZvcm1hdERhdGUodGFzay5kdWVEYXRlLCBkYXRlRm9ybWF0KTtcbiAgICBhZGREZXRhaWwoZGF0ZVN0ciwgJ3Rhc2stbGlzdC1pdGVtLWR1ZS1kYXRlJyk7XG4gIH1cblxuICBpZiAodGFzay5yZWN1cnJpbmdEYXRlKSB7XG4gICAgY29uc3QgcmVjdXJyZW5jZVN0ciA9IHRhc2sucmVjdXJyaW5nRGF0ZS50b1N0cmluZygpO1xuICAgIGFkZERldGFpbChyZWN1cnJlbmNlU3RyLCAndGFzay1saXN0LWl0ZW0tcmVjdXJyaW5nLWRhdGUnKTtcbiAgfVxuXG4gIGlmICh0YXNrLnByb2plY3QpIHtcbiAgICBjb25zdCBwcm9qZWN0ID0gcHJpdmF0ZXMucHJvamVjdHMuZ2V0UHJvamVjdCh0YXNrLnByb2plY3QpO1xuICAgIGFkZERldGFpbChwcm9qZWN0Lm5hbWUsICd0YXNrLWxpc3QtaXRlbS1wcm9qZWN0Jyk7XG4gIH1cblxuICBjb25zdCBwcmlvcml0eVN0ciA9IFRhc2suY29udmVydFByaW9yaXR5VG9QcmV0dHlTdHJpbmcodGFzay5wcmlvcml0eSk7XG4gIGFkZERldGFpbChgJHtwcmlvcml0eVN0cn0gUHJpb3JpdHlgLCAndGFzay1saXN0LWl0ZW0tcHJpb3JpdHknKTtcblxuICBjb25zdCBidXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYnV0dG9uQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ljb24tY29udGFpbmVyJyk7XG4gIGl0ZW1FbGVtLmFwcGVuZENoaWxkKGJ1dHRvbkNvbnRhaW5lcik7XG5cbiAgY29uc3QgZWRpdEJ1dHRvbiA9IGNyZWF0ZUljb25CdXR0b24oJ2VkaXQnKTtcbiAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGVkaXRCdXR0b24pO1xuICBlZGl0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGlmIChwcml2YXRlcy50YXNrQ2FsbGJhY2spIHByaXZhdGVzLnRhc2tDYWxsYmFjaygnZWRpdCcsIHRhc2tJZCwgdGFzayk7XG4gIH0pO1xuXG4gIGNvbnN0IG1vcmVCdXR0b24gPSBjcmVhdGVJY29uQnV0dG9uKCdtb3JlX2hvcml6Jyk7XG4gIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChtb3JlQnV0dG9uKTtcbiAgbW9yZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgcHJpdmF0ZXMudGFza01lbnUub3BlbigoaWQpID0+IHtcbiAgICAgIGlmIChwcml2YXRlcy50YXNrQ2FsbGJhY2spIHtcbiAgICAgICAgcHJpdmF0ZXMudGFza0NhbGxiYWNrKGlkLCB0YXNrSWQsIHRhc2spO1xuICAgICAgfVxuICAgIH0sIHsgcmVmZXJlbmNlRWxlbWVudDogZS50YXJnZXQgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaGVhZGluZyBsYWJlbCBmb3IgYSB0YXNrIGdyb3VwLlxuICogQHBhcmFtIHttb2R1bGU6dGFza0Rpc3BsYXl+VGFza0Rpc3BsYXl9IGluc3RhbmNlIFRoZSBjbGFzcyBpbnN0YW5jZSBvbiB3aGljaFxuICogICB0byBhcHBseSB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBCeSBUaGUgdHlwZSBvZiBncm91cGluZyBiZWluZyBkb25lOiAnZHVlLWRhdGUnLFxuICogICAncHJvamVjdCcsICdwcmlvcml0eScsIG9yICdub25lJy5cbiAqIEBwYXJhbSB7bW9kdWxlOnRhc2t+VGFza30gdGFzayBBIHRhc2sgYmVsb25naW5nIHRvIHRoZSBncm91cC5cbiAqIEByZXR1cm5zIHs/c3RyaW5nfSBUaGUgbGFiZWwgZm9yIHRoZSBoZWFkaW5nLCBvciBudWxsIGlmIG5vIGdyb3VwaW5nIGlzXG4gKiAgIGJlaW5nIGRvbmUuXG4gKi9cbmZ1bmN0aW9uIGdldEdyb3VwSGVhZGluZyhpbnN0YW5jZSwgZ3JvdXBCeSwgdGFzaykge1xuICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldChpbnN0YW5jZSk7XG4gIHN3aXRjaCAoZ3JvdXBCeSkge1xuICAgIGNhc2UgJ2R1ZS1kYXRlJzpcbiAgICAgIGlmICh0YXNrLmR1ZURhdGUpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gcHJpdmF0ZXMuZGF0ZUZvcm1hdC5vdXRwdXRQYXR0ZXJuO1xuICAgICAgICByZXR1cm4gZm9ybWF0RGF0ZSh0YXNrLmR1ZURhdGUsIGZvcm1hdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ05vIER1ZSBEYXRlJztcbiAgICBjYXNlICdwcmlvcml0eSc6XG4gICAgICByZXR1cm4gYCR7VGFzay5jb252ZXJ0UHJpb3JpdHlUb1ByZXR0eVN0cmluZyh0YXNrLnByaW9yaXR5KX0gUHJpb3JpdHlgO1xuICAgIGNhc2UgJ3Byb2plY3QnOlxuICAgICAgaWYgKHRhc2sucHJvamVjdCkgcmV0dXJuIHByaXZhdGVzLnByb2plY3RzLmdldFByb2plY3QodGFzay5wcm9qZWN0KS5uYW1lO1xuICAgICAgcmV0dXJuICdVbmNhdGVnb3JpemVkJztcbiAgICBjYXNlICdub25lJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGRpc3BsYXkgcGFuZWwgc2hvd2luZyBhIGxpc3Qgb2YgdGFza3MuXG4gKi9cbmNsYXNzIFRhc2tEaXNwbGF5IHtcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIGNob29zZXMgdG8gcGVyZm9ybSBhblxuICAgKiBhY3Rpb24gb24gYSB0YXNrLlxuICAgKiBAY2FsbGJhY2sgbW9kdWxlOnRhc2tEaXNwbGF5flRhc2tEaXNwbGF5fnRhc2tDYWxsYmFja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBhY3Rpb24gdGhhdCBpcyBiZWluZyBwZXJmb3JtZWQ6XG4gICAqICAgJ21hcmstY29tcGxldGUnLCAnbWFyay1pbmNvbXBsZXRlJywgJ2VkaXQnLCAnY2xvbmUnLCAnZGVsZXRlJywgb3JcbiAgICogICAnZ28tdG8tcHJvamVjdCcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWRlbnRpZmllciBmb3IgdGhlIHRhc2sgb24gd2hpY2ggdGhlIGFjdGlvbiBpc1xuICAgKiAgIGJlaW5nIHBlcmZvcm1lZC5cbiAgICogQHBhcmFtIHttb2R1bGU6dGFza35UYXNrfSB0YXNrIFRoZSB0YXNrIG9uIHdoaWNoIHRoZSBhY3Rpb24gaXMgYmVpbmdcbiAgICogICBwZXJmb3JtZWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgaG9sZGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgdGFzayBkaXNwbGF5IHBhbmVsLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6dGFza0Rpc3BsYXl+VGFza0Rpc3BsYXl+b3B0aW9uc1xuICAgKiBAcHJvcGVydHkge21vZHVsZTp0YXNrRGlzcGxheX5UYXNrRGlzcGxheX50YXNrQ2FsbGJhY2t9IFt0YXNrQ2FsbGJhY2tdIEFcbiAgICogICBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFuIGFjdGlvblxuICAgKiAgIG9uIGEgdGFzay5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBob2xkaW5nIG9wdGlvbnMgZm9yIHVwZGF0aW5nIHRoZSB0YXNrIGRpc3BsYXkgcGFuZWwuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTp0YXNrRGlzcGxheX5UYXNrRGlzcGxheX51cGRhdGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW3N0YXJ0RGF0ZV0gSWYgcHJvdmlkZWQsIHRhc2tzIHdpdGggZHVlIGRhdGVzIGJlZm9yZSB0aGVcbiAgICogICBnaXZlbiBkYXRlIHdpbGwgYmUgZXhjbHVkZWQuXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW2VuZERhdGVdIElmIHByb3ZpZGVkLCB0YXNrcyB3aXRoIGR1ZSBkYXRlcyBhZnRlciB0aGVcbiAgICogICBnaXZlbiBkYXRlIHdpbGwgYmUgZXhjbHVkZWQuXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbXBsZXRlZD1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIHRoZW4gY29tcGxldGVkIHRhc2tzXG4gICAqICAgd2lsbCBiZSBpbmNsdWRlZC5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZUR1ZURhdGU9ZmFsc2VdIElmIHNldCB0byB0cnVlLCB0aGVuIHRhc2tzIHRoYXRcbiAgICogICBkbyBub3QgaGF2ZSBhIGR1ZSBkYXRlIHdpbGwgYmUgZXhjbHVkZWQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvamVjdF0gSWYgcHJvdmlkZWQsIHRoZW4gb25seSB0YXNrcyB3aXRoIHRoZVxuICAgKiAgIHNwZWNpZmllZCBwcm9qZWN0IHdpbGwgYmUgaW5jbHVkZWQuIFRoaXMgY2FuIGVpdGhlciBiZSBhIHByb2plY3RcbiAgICogICBpZGVudGlmaWVyLCBvciB0aGUgc3RyaW5nICdub25lJy5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmlvcml0eV0gSWYgcHJvdmlkZWQsIHRoZW4gb25seSB0YXNrcyB3aXRoIHRoZSBnaXZlblxuICAgKiAgIHByaW9yaXR5IHdpbGwgYmUgaW5jbHVkZWQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ3JvdXBCeT1ub25lXSBUaGUgZmllbGQgdG8gZ3JvdXAgdGhlIHRhc2tzIGJ5OlxuICAgKiAgICdkdWUtZGF0ZScsICdwcmlvcml0eScsICdwcm9qZWN0Jywgb3IgJ25vbmUnLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NvcnRCeT1jcmVhdGUtZGF0ZV0gVGhlIHByaW1hcnkgZmllbGQgdG8gc29ydCB0aGVcbiAgICogICB0YXNrcyBieTogJ25hbWUnLCAnZHVlLWRhdGUnLCAnY3JlYXRlLWRhdGUnLCAncHJpb3JpdHknLCBvciAncHJvamVjdCcuXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NvcnREZXNjZW5kaW5nPWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgdGhlbiByZXN1bHRzXG4gICAqICAgd2lsbCBiZSBzb3J0ZWQgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2FzZVNlbnNpdGl2ZT1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIHRoZW4gc29ydGluZyBmb3JcbiAgICogICB0ZXh0LWJhc2VkIGZpZWxkcyB3aWxsIGJlIGNhc2Utc2Vuc2l0aXZlLlxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttaXNzaW5nTGFzdD1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIHRoZW4gdGFza3MgdGhhdFxuICAgKiAgIGFyZSBtaXNzaW5nIGEgY2VydGFpbiBmaWVsZCB3aWxsIGJlIHNvcnRlZCBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0LCB3aGVuXG4gICAqICAgc29ydGluZyBieSB0aGF0IGZpZWxkLlxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXNldFNjcm9sbD10cnVlXSBJZiBzZXQgdG8gdHJ1ZSAodGhlIGRlZmF1bHQpLCB0aGVcbiAgICogICBwYW5lbCdzIHNjcm9sbCBwb3NpdGlvbiB3aWxsIGJlIHJlc2V0IGJhY2sgdG8gdGhlIHRvcC4gT3RoZXJ3aXNlIHRoZVxuICAgKiAgIHNjcm9sbCBwb3NpdGlvbiB3aWxsIG5vdCBiZSBjaGFuZ2VkLlxuICAgKiBAcHJvcGVydHkge21vZHVsZTpzZXR0aW5nc35TZXR0aW5nc35kYXRlRm9ybWF0fSBbZGF0ZUZvcm1hdF0gQW4gb2JqZWN0XG4gICAqICAgaG9sZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2FsZW5kYXIgZGF0ZSBmb3JtYXQgdG8gdXNlIHdoZW5cbiAgICogICBkaXNwbGF5aW5nIGRhdGVzLlxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGFzayBkaXNwbGF5LlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgVGhlIHBhcmVudCBET00gbm9kZSB0aGF0IHdpbGwgY29udGFpbiB0aGVcbiAgICogICBwYW5lbC5cbiAgICogQHBhcmFtIHttb2R1bGU6dGFza0xpc3R+VGFza0xpc3R9IHRhc2tMaXN0IFRoZVxuICAgKiAgIFtUYXNrTGlzdF17QGxpbmsgbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fSBob2xkaW5nIGFsbCBvZiB0aGUgdGFza3MuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnByb2plY3RMaXN0flByb2plY3RMaXN0fSBwcm9qZWN0TGlzdCBUaGVcbiAgICogICBbUHJvamVjdExpc3Rde0BsaW5rIG1vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH0gaG9sZGluZyBhbGwgb2YgdGhlXG4gICAqICAgcHJvamVjdHMuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnRhc2tEaXNwbGF5flRhc2tEaXNwbGF5fm9wdGlvbnN9IFtvcHRpb25zPXt9XSBBbiBvYmplY3RcbiAgICogICBob2xkaW5nIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGRpc3BsYXkgcGFuZWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIHRhc2tMaXN0LCBwcm9qZWN0TGlzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwYW5lbC5jbGFzc0xpc3QuYWRkKCd0YXNrLXBhbmVsJyk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHBhbmVsKTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3Rhc2stcGFuZWwtY29udGVudCcpO1xuICAgIHBhbmVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuXG4gICAgY29uc3QgcHJpdmF0ZXMgPSB7XG4gICAgICBjb250YWluZXI6IHBhbmVsLFxuICAgICAgY29udGVudCxcbiAgICAgIHRhc2tzOiB0YXNrTGlzdCxcbiAgICAgIHByb2plY3RzOiBwcm9qZWN0TGlzdCxcbiAgICAgIHRhc2tDYWxsYmFjazogb3B0aW9ucy50YXNrQ2FsbGJhY2sgfHwgbnVsbCxcbiAgICAgIGRhdGVGb3JtYXQ6IFNldHRpbmdzLmxvb2t1cERhdGVGb3JtYXQoJ2lzbycpLFxuICAgICAgdGFza01lbnU6IG51bGwsXG4gICAgfTtcbiAgICBwcml2YXRlTWVtYmVycy5zZXQodGhpcywgcHJpdmF0ZXMpO1xuXG4gICAgcHJpdmF0ZXMudGFza01lbnUgPSBuZXcgUG9wdXBNZW51KHsgY2xvc2VJZlNjcm9sbGVkOiBwYW5lbCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBkaXNwbGF5IHBhbmVsIHdpdGggYSBuZXcgbGlzdCBvZiB0YXNrcy5cbiAgICogQHBhcmFtIHttb2R1bGU6dGFza0Rpc3BsYXl+VGFza0Rpc3BsYXl+dXBkYXRlT3B0aW9uc30gW29wdGlvbnM9e31dIEFuXG4gICAqICAgb2JqZWN0IGhvbGRpbmcgb3B0aW9ucyBmb3IgdXBkYXRpbmcgdGhlIHBhbmVsLlxuICAgKi9cbiAgdXBkYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZhdGVzID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpO1xuXG4gICAgcHJpdmF0ZXMuZGF0ZUZvcm1hdCA9IG9wdGlvbnMuZGF0ZUZvcm1hdCA/PyBTZXR0aW5ncy5sb29rdXBEYXRlRm9ybWF0KCk7XG4gICAgY2xlYXIodGhpcyk7XG5cbiAgICBjb25zdCBsaXN0T3B0aW9ucyA9IHtcbiAgICAgIHByb2plY3RMaXN0OiBwcml2YXRlcy5wcm9qZWN0cyxcbiAgICAgIHN0YXJ0RGF0ZTogb3B0aW9ucy5zdGFydERhdGUgfHwgbnVsbCxcbiAgICAgIGVuZERhdGU6IG9wdGlvbnMuZW5kRGF0ZSB8fCBudWxsLFxuICAgICAgY29tcGxldGVkOiBvcHRpb25zLmNvbXBsZXRlZCA/PyBmYWxzZSxcbiAgICAgIHJlcXVpcmVEdWVEYXRlOiBvcHRpb25zLnJlcXVpcmVEdWVEYXRlID8/IGZhbHNlLFxuICAgICAgcHJvamVjdDogb3B0aW9ucy5wcm9qZWN0IHx8IG51bGwsXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmlvcml0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxpc3RPcHRpb25zLnByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgICB9XG5cbiAgICBjb25zdCBncm91cEJ5ID0gb3B0aW9ucy5ncm91cEJ5IHx8ICdub25lJztcbiAgICBjb25zdCBkZXNjZW5kaW5nID0gb3B0aW9ucy5zb3J0RGVzY2VuZGluZyA/PyBmYWxzZTtcbiAgICBjb25zdCBjYXNlU2Vuc2l0aXZlID0gb3B0aW9ucy5jYXNlU2Vuc2l0aXZlID8/IGZhbHNlO1xuICAgIGNvbnN0IG1pc3NpbmdMYXN0ID0gb3B0aW9ucy5taXNzaW5nTGFzdCA/PyBmYWxzZTtcbiAgICBjb25zdCBwdXNoU29ydEZpZWxkID0gKGZpZWxkKSA9PiB7XG4gICAgICBpZiAoIWxpc3RPcHRpb25zLnNvcnRCeSkgbGlzdE9wdGlvbnMuc29ydEJ5ID0gW107XG4gICAgICBsaXN0T3B0aW9ucy5zb3J0QnkucHVzaCh7XG4gICAgICAgIGZpZWxkLFxuICAgICAgICBkZXNjZW5kaW5nLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlLFxuICAgICAgICBtaXNzaW5nTGFzdCxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoZ3JvdXBCeSAhPT0gJ25vbmUnKSBwdXNoU29ydEZpZWxkKGdyb3VwQnkpO1xuICAgIGlmIChvcHRpb25zLnNvcnRCeSkgcHVzaFNvcnRGaWVsZChvcHRpb25zLnNvcnRCeSk7XG4gICAgaWYgKG9wdGlvbnMuc29ydEJ5ICE9PSAnY3JlYXRlLWRhdGUnKSBwdXNoU29ydEZpZWxkKCdjcmVhdGUtZGF0ZScpO1xuXG4gICAgY29uc3QgZW50cmllcyA9IHByaXZhdGVzLnRhc2tzLmVudHJpZXMobGlzdE9wdGlvbnMpO1xuXG4gICAgbGV0IGxpc3QgPSBudWxsO1xuICAgIGxldCBwcmV2VGFzayA9IG51bGw7XG4gICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgaWYgKCFwcmV2VGFzayB8fCAhaXNTYW1lR3JvdXAoZ3JvdXBCeSwgZW50cnkudGFzaywgcHJldlRhc2spKSB7XG4gICAgICAgIGxpc3QgPSBjcmVhdGVMaXN0KHRoaXMsIGdldEdyb3VwSGVhZGluZyh0aGlzLCBncm91cEJ5LCBlbnRyeS50YXNrKSk7XG4gICAgICB9XG5cbiAgICAgIGFkZFRhc2sodGhpcywgbGlzdCwgZW50cnkuaWQsIGVudHJ5LnRhc2spO1xuICAgICAgcHJldlRhc2sgPSBlbnRyeS50YXNrO1xuICAgIH0pO1xuXG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtZXNzYWdlLmNsYXNzTGlzdC5hZGQoJ3Rhc2stbGlzdC1lbXB0eScpO1xuICAgICAgbWVzc2FnZS50ZXh0Q29udGVudCA9ICdObyBUYXNrcyBGb3VuZCc7XG4gICAgICBwcml2YXRlcy5jb250ZW50LmFwcGVuZENoaWxkKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8vIFNldCBtZW51IGl0ZW1zIGZvciB0aGUgJ21vcmUnIGJ1dHRvblxuICAgIGlmIChvcHRpb25zLnByb2plY3QpIHtcbiAgICAgIHByaXZhdGVzLnRhc2tNZW51LnNldE1lbnVJdGVtcyhTVEFOREFSRF9NRU5VX0lURU1TKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWVudUl0ZW1zID0gWy4uLlBST0pFQ1RfTUVOVV9JVEVNUywgLi4uU1RBTkRBUkRfTUVOVV9JVEVNU107XG4gICAgICBwcml2YXRlcy50YXNrTWVudS5zZXRNZW51SXRlbXMobWVudUl0ZW1zKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgaWYgKG9wdGlvbnMucmVzZXRTY3JvbGwgIT09IGZhbHNlKSB7XG4gICAgICBwcml2YXRlcy5jb250YWluZXIuc2Nyb2xsVG9wID0gMDtcbiAgICAgIHByaXZhdGVzLmNvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFza0Rpc3BsYXk7XG4iLCIvKipcbiAqIERlZmluZXMgdGhlIFtUYXNrTGlzdF17QGxpbmsgbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fSBjbGFzcy5cbiAqIEBtb2R1bGUgdGFza0xpc3RcbiAqL1xuXG5pbXBvcnQgeyBpc0JlZm9yZSBhcyBpc0RhdGVCZWZvcmUsIGlzU2FtZURheSB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyB2NCBhcyBnZW5lcmF0ZVV1aWQgfSBmcm9tICd1dWlkJztcblxuaW1wb3J0IFJlY3VycmluZ0RhdGUgZnJvbSAnLi9yZWN1cnJpbmdEYXRlJztcbmltcG9ydCBUYXNrIGZyb20gJy4vdGFzayc7XG5pbXBvcnQge1xuICBhZGRUb01hcEFycmF5LFxuICBmaW5kSW5NYXBBcnJheSxcbiAgZ2V0SnNvblR5cGUsXG4gIGlzVXVpZFZhbGlkLFxuICByZW1vdmVGcm9tTWFwQXJyYXlCeSxcbiAgdmFsaWRhdGVWYWx1ZSxcbn0gZnJvbSAnLi91dGlsaXR5L2RhdGEnO1xuaW1wb3J0IHtcbiAgZm9ybWF0SXNvRGF0ZSxcbiAgZ2V0TW9udGhJbmRleCxcbiAgZ2V0TW9udGhOYW1lLFxuICBnZXRXZWVrZGF5SW5kZXgsXG4gIGdldFdlZWtkYXlOYW1lLFxufSBmcm9tICcuL3V0aWxpdHkvZGF0ZXMnO1xuaW1wb3J0IHsgYXJyYXlUb0NzdlJlY29yZCB9IGZyb20gJy4vdXRpbGl0eS9zdG9yYWdlJztcblxuLyoqXG4gKiBPYmplY3QgaG9sZGluZyBwcml2YXRlIG1lbWJlcnMgZm9yIHRoZVxuICogW1Rhc2tMaXN0XXtAbGluayBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R9IGNsYXNzLlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fnByaXZhdGVzXG4gKiBAcHJvcGVydHkge01hcH0gdGFza3MgSG9sZHMgYSBtYXAgYXNzb2NpYXRpbmcgVVVJRHMgdG8gdGFza3MuXG4gKiBAcHJvcGVydHkge01hcH0gdGFza3NCeUR1ZURhdGUgSG9sZHMgYSBtYXAgYXNzb2NpYXRpbmcgSVNPIGRhdGUgc3RyaW5ncyB0b1xuICogICBhcnJheXMgb2YgW3Rhc2tXcmFwcGVyXXtAbGluayBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R+dGFza1dyYXBwZXJ9XG4gKiAgIG9iamVjdHMgYmFzZWQgb24gdGhlIGR1ZSBkYXRlcyBvZiB0aGUgdGFza3MuIFRhc2tzIHdpdGggbm8gZHVlIGRhdGUgYXJlXG4gKiAgIGFzc2lnbmVkIHRvIHRoZSBhcnJheSBhc3NvY2lhdGVkIHdpdGggdGhlIHN0cmluZyAnbm9uZScuXG4gKiBAcHJvcGVydHkge01hcH0gdGFza3NCeVByb2plY3QgSG9sZHMgYSBtYXAgYXNzb2NpYXRpbmcgcHJvamVjdCBpZGVudGlmaWVyc1xuICogICB0byBhcnJheXMgb2YgW3Rhc2tXcmFwcGVyXXtAbGluayBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R+dGFza1dyYXBwZXJ9XG4gKiAgIG9iamVjdHMgYmFzZWQgb24gdGhlIHByb2plY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGFza3MuIFRhc2tzIG5vdFxuICogICBiZWxvbmdpbmcgdG8gYW55IHByb2plY3QgYXJlIGFzc2lnbmVkIHRvIHRoZSBhcnJheSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gKiAgIHN0cmluZyAnbm9uZScuXG4gKiBAcHJvcGVydHkge01hcH0gdGFza3NCeVByaW9yaXR5IEhvbGRzIGEgbWFwIGFzc29jaWF0aW5nIHByaW9yaXR5IG51bWJlcnMgdG9cbiAqICAgYXJyYXlzIG9mIFt0YXNrV3JhcHBlcl17QGxpbmsgbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fnRhc2tXcmFwcGVyfVxuICogICBvYmplY3RzIGJhc2VkIG9uIHRoZSBwcmlvcml0aWVzIG9mIHRoZSB0YXNrcy5cbiAqIEBwcm9wZXJ0eSB7RXZlbnRFbWl0dGVyfSBldmVudEVtaXR0ZXIgSG9sZHMgdGhlIGV2ZW50IGVtaXR0ZXIgd2hpY2hcbiAqICAgZGlzcGF0Y2hlcyBldmVudHMgdG8gYXR0YWNoZWQgZXZlbnQgbGlzdGVuZXJzLlxuICovXG5cbi8qKlxuICogSG9sZHMgcHJpdmF0ZSBkYXRhIGZvciB0aGUgW1Rhc2tMaXN0XXtAbGluayBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R9IGNsYXNzLlxuICogQHR5cGUge1dlYWtNYXB9XG4gKiBAc2VlIG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH5wcml2YXRlc1xuICovXG5jb25zdCBwcml2YXRlTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQ29udGFpbmVyIGhvbGRpbmcgYSBsaXN0IG9mIHRhc2tzLlxuICovXG5jbGFzcyBUYXNrTGlzdCB7XG4gIC8qKlxuICAgKiBXcmFwcGVyIG9iamVjdCBob2xkaW5nIGEgdGFzayBhbG9uZyB3aXRoIGl0cyBVVUlELlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R+dGFza1dyYXBwZXJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhc2suXG4gICAqIEBwcm9wZXJ0eSB7bW9kdWxlOnRhc2t+VGFza30gdGFzayBUaGUgdGFzayBpbnN0YW5jZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBhIHRhc2sgaXMgYWRkZWQgdG8gdGhlIHRhc2sgbGlzdC5cbiAgICogQGV2ZW50IG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH5hZGRUYXNrXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlOiAnYWRkLXRhc2snLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBuZXdseS1hZGRlZCB0YXNrLlxuICAgKiBAcHJvcGVydHkge21vZHVsZTp0YXNrflRhc2t9IHRhc2sgQSBjb3B5IG9mIHRoZSBuZXdseS1hZGRlZCB0YXNrLlxuICAgKi9cblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIGEgdGFzayBpbiB0aGUgbGlzdCBpcyBtb2RpZmllZC5cbiAgICogQGV2ZW50IG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH51cGRhdGVUYXNrXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlOiAndXBkYXRlLXRhc2snLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB1cGRhdGVkIHRhc2suXG4gICAqIEBwcm9wZXJ0eSB7bW9kdWxlOnRhc2t+VGFza30gdGFzayBBIGNvcHkgb2YgdGhlIG1vZGlmaWVkIHRhc2suXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFdmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gYSB0YXNrIGluIHRoZSBsaXN0IGlzIGRlbGV0ZWQuXG4gICAqIEBldmVudCBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R+ZGVsZXRlVGFza1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZTogJ2RlbGV0ZS10YXNrJy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGRlbGV0ZWQgdGFzay5cbiAgICogQHByb3BlcnR5IHttb2R1bGU6dGFza35UYXNrfSB0YXNrIEEgY29weSBvZiB0aGUgdGFzayB0aGF0IHdhcyBkZWxldGVkLlxuICAgKi9cblxuICAvKipcbiAgICogQW4gb2JqZWN0IHNwZWNpZnlpbmcgb3B0aW9ucyBmb3Igc29ydGluZyB0YXNrcy5cbiAgICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fnNvcnRPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdG8gc29ydCBieS4gQ2FuIGJlIG9uZSBvZiAnbmFtZScsXG4gICAqICAgJ2R1ZS1kYXRlJywgJ2NyZWF0ZS1kYXRlJywgJ3ByaW9yaXR5Jywgb3IgJ3Byb2plY3QnLlxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZXNjZW5kaW5nPWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgdGFza3Mgd2lsbFxuICAgKiAgIGJlIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyLCByYXRoZXIgdGhhbiBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Nhc2VTZW5zaXRpdmU9ZmFsc2VdIElmIHNldCB0byB0cnVlLCB0aGVuIHRoZSBzb3J0aW5nXG4gICAqICAgd2lsbCBiZSBjYXNlLXNlbnNpdGl2ZSAob25seSBhcHBsaWVzIHRvIHRleHQtYmFzZWQgZmllbGRzKS5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbbWlzc2luZ0xhc3Q9ZmFsc2VdIElmIHNldCB0byB0cnVlLCB0aGVuIHRhc2tzIHRoYXQgZG9cbiAgICogICBub3QgaGF2ZSB0aGUgc3BlY2lmaWVkIGZpZWxkIHdpbGwgYmUgc29ydGVkIGF0IHRoZSBlbmQgKG9yIGF0IHRoZVxuICAgKiAgIGJlZ2lubmluZyBpZiBkZXNjZW5kaW5nIGlzIHRydWUpLiBPdGhlcndpc2UsIHRhc2tzIHRoYXQgYXJlIG1pc3NpbmcgdGhlXG4gICAqICAgc3BlY2lmaWVkIGZpZWxkIGFyZSBzb3J0ZWQgYXQgdGhlIGJlZ2lubmluZyAob3IgZW5kIGlmIGRlc2NlbmRpbmcpLlxuICAgKi9cblxuICAvKipcbiAgICogQW4gb2JqZWN0IGhvbGRpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXR1cyBvZiBhIGRhdGEgaW1wb3J0LlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R+aW1wb3J0U3RhdHVzXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0YXNrcyBBbiBvYmplY3QgaG9sZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbnVtYmVyIG9mXG4gICAqICAgdGFza3MgdGhhdCB3ZXJlIGltcG9ydGVkLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdGFza3MuYWRkZWQgVGhlIG51bWJlciBvZiBuZXcgdGFza3MgdGhhdCB3ZXJlIGFkZGVkIHRvXG4gICAqICAgdGhlIHRhc2sgbGlzdC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRhc2tzLnVwZGF0ZWQgVGhlIG51bWJlciBvZiBleGlzdGluZyB0YXNrcyBpbiB0aGUgdGFza1xuICAgKiAgIGxpc3QgdGhhdCB3ZXJlIHVwZGF0ZWQuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0YXNrcy5mYWlsZWQgVGhlIG51bWJlciBvZiB0YXNrcyB0aGF0IGZhaWxlZCB0byBpbXBvcnQuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0YXNrcy50b3RhbCBUaGUgdG90YWwgbnVtYmVyIG9mIHRhc2tzIHRoYXQgd2VyZVxuICAgKiAgIHByb2Nlc3NlZC5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFtwcm9qZWN0c10gQW4gb2JqZWN0IGhvbGRpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gICAqICAgbnVtYmVyIG9mIHByb2plY3RzIHRoYXQgd2VyZSBpbXBvcnRlZC4gVGhpcyBpcyBub3QgdXNlZCBmb3IgSlNPTlxuICAgKiAgIGltcG9ydHMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9qZWN0cy5hZGRlZCBUaGUgbnVtYmVyIG9mIG5ldyBwcm9qZWN0cyB0aGF0IHdlcmVcbiAgICogICBhZGRlZCB0byB0aGUgcHJvamVjdCBsaXN0LlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcHJvamVjdHMudXBkYXRlZCBUaGUgbnVtYmVyIG9mIGV4aXN0aW5nIHByb2plY3RzIGluIHRoZVxuICAgKiAgIHByb2plY3QgbGlzdCB0aGF0IHdlcmUgdXBkYXRlZC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2plY3RzLmZhaWxlZCBUaGUgbnVtYmVyIG9mIHByb2plY3RzIHRoYXQgZmFpbGVkIHRvXG4gICAqICAgaW1wb3J0LlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcHJvamVjdHMudG90YWwgVGhlIHRvdGFsIG51bWJlciBvZiBwcm9qZWN0cyB0aGF0IHdlcmVcbiAgICogICBwcm9jZXNzZWQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGVycm9ycyBBbiBhcnJheSBvZiBlcnJvciBtZXNzYWdlcyBkZXNjcmliaW5nIGFueVxuICAgKiAgIGVycm9ycyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgaW1wb3J0LlxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGFzayBsaXN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSB7XG4gICAgICB0YXNrczogbmV3IE1hcCgpLFxuICAgICAgdGFza3NCeUR1ZURhdGU6IG5ldyBNYXAoKSxcbiAgICAgIHRhc2tzQnlQcm9qZWN0OiBuZXcgTWFwKCksXG4gICAgICB0YXNrc0J5UHJpb3JpdHk6IG5ldyBNYXAoKSxcbiAgICAgIGV2ZW50RW1pdHRlcjogbmV3IEV2ZW50RW1pdHRlcigpLFxuICAgIH07XG4gICAgcHJpdmF0ZU1lbWJlcnMuc2V0KHRoaXMsIHByaXZhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0YXNrIGluIHRoZSB0YXNrIGxpc3QuIFRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyBhIGNvcHkgb2YgdGhlIHRhc2ssXG4gICAqIG5vdCBhbiBhY3R1YWwgcmVmZXJlbmNlIHRvIHRoZSB0YXNrIGl0c2VsZi4gVG8gbW9kaWZ5IGEgdGFzayBpbiB0aGUgbGlzdCxcbiAgICogdXNlIHRoZSBbdXBkYXRlVGFza117QGxpbmsgbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0I3VwZGF0ZVRhc2t9IG1ldGhvZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFzayB0byByZXRyaWV2ZS5cbiAgICogQHJldHVybnMgez9tb2R1bGU6dGFza35UYXNrfSBUaGUgcmVxdWVzdGVkIHRhc2ssIG9yIHVuZGVmaW5lZCBpZiBpdCBjb3VsZFxuICAgKiAgIG5vdCBiZSBmb3VuZC5cbiAgICovXG4gIGdldFRhc2soaWQpIHtcbiAgICBjb25zdCB0YXNrID0gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLnRhc2tzLmdldChpZCk7XG4gICAgaWYgKHRhc2spIHJldHVybiBfLmNsb25lRGVlcCh0YXNrKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHRhc2sgaW4gdGhlIHRhc2sgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFzayB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge21vZHVsZTp0YXNrflRhc2t9IHRhc2sgVGhlIG5ldyB0YXNrIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBnaXZlblxuICAgKiAgIGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHRhc2sgd2FzIHJlcGxhY2VkIHN1Y2Nlc3NmdWxseS4gSWZcbiAgICogICB0aGUgZ2l2ZW4gaWQgaXMgaW52YWxpZCwgcmV0dXJucyBmYWxzZS5cbiAgICogQGZpcmVzIG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH51cGRhdGVUYXNrXG4gICAqL1xuICB1cGRhdGVUYXNrKGlkLCB0YXNrKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgY29uc3Qgb2xkVGFzayA9IHByaXZhdGVzLnRhc2tzLmdldChpZCk7XG4gICAgaWYgKCFvbGRUYXNrKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBjb3B5ID0gXy5jbG9uZURlZXAodGFzayk7XG4gICAgcHJpdmF0ZXMudGFza3Muc2V0KGlkLCBjb3B5KTtcblxuICAgIGNvbnN0IHVwZGF0ZUluZGV4ID0gKG1hcCwgb2xkS2V5LCBuZXdLZXkpID0+IHtcbiAgICAgIGlmIChvbGRLZXkgPT09IG5ld0tleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IGZpbmRJbk1hcEFycmF5KG1hcCwgbmV3S2V5LCAoZWxlbSkgPT4gZWxlbS5pZCA9PT0gaWQpO1xuICAgICAgICBlbnRyeS50YXNrID0gY29weTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21NYXBBcnJheUJ5KG1hcCwgb2xkS2V5LCAoZWxlbSkgPT4gZWxlbS5pZCA9PT0gaWQpO1xuICAgICAgICBhZGRUb01hcEFycmF5KG1hcCwgbmV3S2V5LCB7IGlkLCB0YXNrOiBjb3B5IH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgb2xkS2V5ID0gJ25vbmUnO1xuICAgIGxldCBuZXdLZXkgPSAnbm9uZSc7XG4gICAgaWYgKG9sZFRhc2suZHVlRGF0ZSkgb2xkS2V5ID0gZm9ybWF0SXNvRGF0ZShvbGRUYXNrLmR1ZURhdGUpO1xuICAgIGlmIChjb3B5LmR1ZURhdGUpIG5ld0tleSA9IGZvcm1hdElzb0RhdGUoY29weS5kdWVEYXRlKTtcbiAgICB1cGRhdGVJbmRleChwcml2YXRlcy50YXNrc0J5RHVlRGF0ZSwgb2xkS2V5LCBuZXdLZXkpO1xuXG4gICAgb2xkS2V5ID0gb2xkVGFzay5wcm9qZWN0IHx8ICdub25lJztcbiAgICBuZXdLZXkgPSBjb3B5LnByb2plY3QgfHwgJ25vbmUnO1xuICAgIHVwZGF0ZUluZGV4KHByaXZhdGVzLnRhc2tzQnlQcm9qZWN0LCBvbGRLZXksIG5ld0tleSk7XG5cbiAgICBvbGRLZXkgPSBvbGRUYXNrLnByaW9yaXR5O1xuICAgIG5ld0tleSA9IGNvcHkucHJpb3JpdHk7XG4gICAgdXBkYXRlSW5kZXgocHJpdmF0ZXMudGFza3NCeVByaW9yaXR5LCBvbGRLZXksIG5ld0tleSk7XG5cbiAgICBwcml2YXRlcy5ldmVudEVtaXR0ZXIuZW1pdCgndXBkYXRlLXRhc2snLCB7XG4gICAgICB0eXBlOiAndXBkYXRlLXRhc2snLFxuICAgICAgaWQsXG4gICAgICB0YXNrOiBfLmNsb25lRGVlcCh0YXNrKSxcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvciB1cGRhdGUgYSB0YXNrLiBJZiBhIHRhc2sgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllciBleGlzdHMsIHRoZW4gaXRcbiAgICogaXMgcmVwbGFjZWQgd2l0aCB0aGUgZ2l2ZW4gdGFzay4gT3RoZXJ3aXNlLCB0aGUgdGFzayBpcyBhZGRlZCB0byB0aGUgbGlzdFxuICAgKiBhcyBhIG5ldyB0YXNrLiBJZiB0aGUgZ2l2ZW4gaWRlbnRpZmllciBpcyBub3QgYSB2YWxpZCBVVUlELCB0aGVuIHRoZVxuICAgKiBtZXRob2QgcmV0dXJucyBmYWxzZSBhbmQgbm90aGluZyBoYXBwZW5zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXNrLlxuICAgKiBAcGFyYW0ge21vZHVsZTp0YXNrflRhc2t9IHRhc2sgVGhlIHRhc2sgdGhhdCBzaG91bGQgYmUgYWRkZWQgb3Igd2l0aCB3aGljaFxuICAgKiAgIGFuIGV4aXN0aW5nIHRhc2sgc2hvdWxkIGJlIHJlcGxhY2VkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdGFzayB3YXMgc3VjY2Vzc2Z1bGx5IGFkZGVkIG9yIHVwZGF0ZWQsIG9yXG4gICAqICAgZmFsc2UgaWYgdGhlIGdpdmVuIGlkZW50aWZpZXIgaXMgbm90IGEgdmFsaWQgVVVJRC5cbiAgICogQGZpcmVzIG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH5hZGRUYXNrXG4gICAqIEBmaXJlcyBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R+dXBkYXRlVGFza1xuICAgKi9cbiAgYWRkT3JVcGRhdGVUYXNrKGlkLCB0YXNrKSB7XG4gICAgaWYgKCFpc1V1aWRWYWxpZChpZCkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICghdGhpcy51cGRhdGVUYXNrKGlkLCB0YXNrKSkge1xuICAgICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG5cbiAgICAgIC8vIEFkZCB0YXNrIHRvIHRhc2sgbWFwXG4gICAgICBjb25zdCBjb3B5ID0gXy5jbG9uZURlZXAodGFzayk7XG4gICAgICBwcml2YXRlcy50YXNrcy5zZXQoaWQsIGNvcHkpO1xuXG4gICAgICAvLyBBZGQgdGFzayB0byBsb29rdXAgbWFwc1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHsgaWQsIHRhc2s6IGNvcHkgfTtcbiAgICAgIGxldCBkYXRlU3RyID0gJ25vbmUnO1xuICAgICAgaWYgKHRhc2suZHVlRGF0ZSkgZGF0ZVN0ciA9IGZvcm1hdElzb0RhdGUodGFzay5kdWVEYXRlKTtcbiAgICAgIGNvbnN0IHByb2plY3RTdHIgPSB0YXNrLnByb2plY3QgfHwgJ25vbmUnO1xuICAgICAgY29uc3QgeyBwcmlvcml0eSB9ID0gdGFzaztcbiAgICAgIGFkZFRvTWFwQXJyYXkoXG4gICAgICAgIHByaXZhdGVzLnRhc2tzQnlEdWVEYXRlLFxuICAgICAgICBkYXRlU3RyLFxuICAgICAgICB7IC4uLndyYXBwZXIgfSxcbiAgICAgICk7XG4gICAgICBhZGRUb01hcEFycmF5KFxuICAgICAgICBwcml2YXRlcy50YXNrc0J5UHJvamVjdCxcbiAgICAgICAgcHJvamVjdFN0cixcbiAgICAgICAgeyAuLi53cmFwcGVyIH0sXG4gICAgICApO1xuICAgICAgYWRkVG9NYXBBcnJheShcbiAgICAgICAgcHJpdmF0ZXMudGFza3NCeVByaW9yaXR5LFxuICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgeyAuLi53cmFwcGVyIH0sXG4gICAgICApO1xuXG4gICAgICBwcml2YXRlcy5ldmVudEVtaXR0ZXIuZW1pdCgnYWRkLXRhc2snLCB7XG4gICAgICAgIHR5cGU6ICdhZGQtdGFzaycsXG4gICAgICAgIGlkLFxuICAgICAgICB0YXNrOiBfLmNsb25lRGVlcCh0YXNrKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0YXNrIHRvIHRoZSB0YXNrIGxpc3QgYW5kIHJldHVybnMgaXRzIHVuaXF1ZSBpZGVudGlmaWVyLiBJbiBvcmRlclxuICAgKiB0byBwcmV2ZW50IHVuaW50ZW50aW9uYWwgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uIG9mIHRoZSB0YXNrLCBhIGRlZXAgY29weSBpc1xuICAgKiBtYWRlLCBhbmQgdGhlIG9yaWdpbmFsIG9iamVjdCBpcyBub3Qga2VwdC5cbiAgICogQHBhcmFtIHttb2R1bGU6dGFza35UYXNrfSB0YXNrIFRoZSB0YXNrIHRvIGJlIGFkZGVkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWRlbnRpZmllciBvZiB0aGUgbmV3bHktYWRkZWQgdGFzay5cbiAgICogQGZpcmVzIG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH5hZGRUYXNrXG4gICAqL1xuICBhZGRUYXNrKHRhc2spIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcblxuICAgIC8vIEdlbmVyYXRlIFVVSUQgKGxvb3AganVzdCBpbiBjYXNlIHRoZXJlJ3MgYSBjb2xsaXNpb24pXG4gICAgbGV0IGlkO1xuICAgIGRvIHtcbiAgICAgIGlkID0gZ2VuZXJhdGVVdWlkKCk7XG4gICAgfSB3aGlsZSAocHJpdmF0ZXMudGFza3MuaGFzKGlkKSk7XG5cbiAgICB0aGlzLmFkZE9yVXBkYXRlVGFzayhpZCwgdGFzayk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHRhc2sgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllciBleGlzdHMgd2l0aGluIHRoZSB0YXNrXG4gICAqIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhc2sgdG8gbG9vayBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0YXNrIGV4aXN0cywgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc1Rhc2soaWQpIHtcbiAgICByZXR1cm4gcHJpdmF0ZU1lbWJlcnMuZ2V0KHRoaXMpLnRhc2tzLmhhcyhpZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFzayBmcm9tIHRoZSB0YXNrIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhc2sgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSB0YXNrIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZFxuICAgKiAgIHN1Y2Nlc3NmdWxseS4gT3RoZXJ3aXNlLCBpZiB0aGUgZ2l2ZW4gaWQgd2FzIG5vdCBmb3VuZCwgcmV0dXJucyBmYWxzZS5cbiAgICogQGZpcmVzIG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH5kZWxldGVUYXNrXG4gICAqL1xuICBkZWxldGVUYXNrKGlkKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgY29uc3QgdGFzayA9IHByaXZhdGVzLnRhc2tzLmdldChpZCk7XG4gICAgaWYgKCF0YXNrKSByZXR1cm4gZmFsc2U7XG5cbiAgICBsZXQgZGF0ZVN0ciA9ICdub25lJztcbiAgICBpZiAodGFzay5kdWVEYXRlKSBkYXRlU3RyID0gZm9ybWF0SXNvRGF0ZSh0YXNrLmR1ZURhdGUpO1xuICAgIGNvbnN0IHByb2plY3RTdHIgPSB0YXNrLnByb2plY3QgfHwgJ25vbmUnO1xuICAgIGNvbnN0IHsgcHJpb3JpdHkgfSA9IHRhc2s7XG5cbiAgICBwcml2YXRlcy50YXNrcy5kZWxldGUoaWQpO1xuICAgIHJlbW92ZUZyb21NYXBBcnJheUJ5KHByaXZhdGVzLnRhc2tzQnlEdWVEYXRlLCBkYXRlU3RyLCAoZWxlbSkgPT4gKFxuICAgICAgZWxlbS5pZCA9PT0gaWRcbiAgICApKTtcbiAgICByZW1vdmVGcm9tTWFwQXJyYXlCeShwcml2YXRlcy50YXNrc0J5UHJvamVjdCwgcHJvamVjdFN0ciwgKGVsZW0pID0+IChcbiAgICAgIGVsZW0uaWQgPT09IGlkXG4gICAgKSk7XG4gICAgcmVtb3ZlRnJvbU1hcEFycmF5QnkocHJpdmF0ZXMudGFza3NCeVByaW9yaXR5LCBwcmlvcml0eSwgKGVsZW0pID0+IChcbiAgICAgIGVsZW0uaWQgPT09IGlkXG4gICAgKSk7XG5cbiAgICBwcml2YXRlcy5ldmVudEVtaXR0ZXIuZW1pdCgnZGVsZXRlLXRhc2snLCB7XG4gICAgICB0eXBlOiAnZGVsZXRlLXRhc2snLFxuICAgICAgaWQsXG4gICAgICB0YXNrLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFsbCB0YXNrcyBpbiB0aGUgdGFzayBsaXN0LlxuICAgKiBAZmlyZXMgbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fmRlbGV0ZVRhc2tcbiAgICovXG4gIGRlbGV0ZUFsbCgpIHtcbiAgICBjb25zdCBwcml2YXRlcyA9IHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKTtcblxuICAgIC8vIFNhdmUgdGFzayBpbmZvcm1hdGlvbiBpbiBvcmRlciB0byBlbWl0IGRlbGV0ZSBldmVudHMgbGF0ZXJcbiAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgIHByaXZhdGVzLnRhc2tzLmZvckVhY2goKHRhc2ssIGlkKSA9PiB0YXNrcy5wdXNoKHsgaWQsIHRhc2sgfSkpO1xuXG4gICAgcHJpdmF0ZXMudGFza3MuY2xlYXIoKTtcbiAgICBwcml2YXRlcy50YXNrc0J5RHVlRGF0ZS5jbGVhcigpO1xuICAgIHByaXZhdGVzLnRhc2tzQnlQcm9qZWN0LmNsZWFyKCk7XG4gICAgcHJpdmF0ZXMudGFza3NCeVByaW9yaXR5LmNsZWFyKCk7XG5cbiAgICB0YXNrcy5mb3JFYWNoKCh7IGlkLCB0YXNrIH0pID0+IHtcbiAgICAgIHByaXZhdGVzLmV2ZW50RW1pdHRlci5lbWl0KCdkZWxldGUtdGFzaycsIHtcbiAgICAgICAgdHlwZTogJ2RlbGV0ZS10YXNrJyxcbiAgICAgICAgaWQsXG4gICAgICAgIHRhc2ssXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgZWFjaCB0YXNrIGJlbG9uZ2luZyB0byBhIGdpdmVuIHByb2plY3QsIHJlbW92ZSB0aGUgdGFzayBmcm9tIHRoYXRcbiAgICogcHJvamVjdC4gQWZ0ZXJ3YXJkLCB0aGVyZSB3aWxsIGJlIG5vIHRhc2tzIGFzc2lnbmVkIHRvIHRoZSBwcm9qZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcHJvamVjdCB0byBjbGVhci5cbiAgICogQGZpcmVzIG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH51cGRhdGVUYXNrXG4gICAqL1xuICBjbGVhclByb2plY3QocHJvamVjdElkKSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgY29uc3QgbWFwID0gcHJpdmF0ZXMudGFza3NCeVByb2plY3Q7XG4gICAgY29uc3QgdGFza3MgPSBtYXAuZ2V0KHByb2plY3RJZCk7XG4gICAgaWYgKCF0YXNrcykgcmV0dXJuO1xuXG4gICAgLy8gU2F2ZSBtb2RpZmllZCB0YXNrcyBpbiBvcmRlciB0byBlbWl0IGV2ZW50cyBsYXRlclxuICAgIGNvbnN0IHVwZGF0ZWRUYXNrcyA9IFtdO1xuXG4gICAgdGFza3MuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHsgdGFzayB9ID0gZW50cnk7XG4gICAgICB0YXNrLnByb2plY3QgPSBudWxsO1xuICAgICAgYWRkVG9NYXBBcnJheShtYXAsICdub25lJywgZW50cnkpO1xuICAgICAgdXBkYXRlZFRhc2tzLnB1c2goZW50cnkpO1xuICAgIH0pO1xuICAgIG1hcC5kZWxldGUocHJvamVjdElkKTtcblxuICAgIHVwZGF0ZWRUYXNrcy5mb3JFYWNoKCh7IGlkLCB0YXNrIH0pID0+IHtcbiAgICAgIHByaXZhdGVzLmV2ZW50RW1pdHRlci5lbWl0KCd1cGRhdGUtdGFzaycsIHtcbiAgICAgICAgdHlwZTogJ3VwZGF0ZS10YXNrJyxcbiAgICAgICAgaWQsXG4gICAgICAgIHRhc2s6IF8uY2xvbmVEZWVwKHRhc2spLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb24gZWFjaCB0YXNrIGluIHRoZSBsaXN0LiBOb3RlIHRoYXQgdGhlIHRhc2tcbiAgICogaW5zdGFuY2UgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBvbmx5IGEgY29weSBvZiB0aGUgdGFzayBpbiB0aGVcbiAgICogbGlzdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB0YXNrLiBUaGVcbiAgICogICBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhXG4gICAqICAgW3dyYXBwZXJde0BsaW5rIG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH50YXNrV3JhcHBlcn0gY29udGFpbmluZyB0aGVcbiAgICogICB0YXNrIGFuZCBpdHMgaWRlbnRpZmllci5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBwcml2YXRlTWVtYmVycy5nZXQodGhpcykudGFza3MuZm9yRWFjaCgodGFzaywgaWQpID0+IHtcbiAgICAgIGNvbnN0IGNvcHkgPSBfLmNsb25lRGVlcCh0YXNrKTtcbiAgICAgIGNhbGxiYWNrKHsgaWQsIHRhc2s6IGNvcHkgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIFt0YXNrV3JhcHBlcl17QGxpbmsgbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fnRhc2tXcmFwcGVyfVxuICAgKiBvYmplY3RzIGZpbHRlcmVkIGFuZCBzb3J0ZWQgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIEFuIG9iamVjdCBob2xkaW5nIG9wdGlvbnMgdG8gY29udHJvbCB3aGljaFxuICAgKiAgIHRhc2tzIHRvIGluY2x1ZGUgaW4gdGhlIEl0ZXJhdG9yLlxuICAgKiBAcGFyYW0ge21vZHVsZTpwcm9qZWN0TGlzdH5Qcm9qZWN0TGlzdH0gW29wdGlvbnMucHJvamVjdExpc3RdIFRoZSBwcm9qZWN0XG4gICAqICAgY29udGFpbmVyLiBJZiBub3QgcHJvdmlkZWQsIHRoZW4gc29ydGluZyBieSBwcm9qZWN0IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqIEBwYXJhbSB7RGF0ZX0gW29wdGlvbnMuc3RhcnREYXRlXSBJZiBwcm92aWRlZCwgYWxsIHRhc2tzIHdpdGggZHVlIGRhdGVzXG4gICAqICAgYmVmb3JlIHRoZSBnaXZlbiBkYXRlIHdpbGwgYmUgZXhjbHVkZWQuXG4gICAqIEBwYXJhbSB7RGF0ZX0gW29wdGlvbnMuZW5kRGF0ZV0gSWYgcHJvdmlkZWQsIGFsbCB0YXNrcyB3aXRoIGR1ZSBkYXRlc1xuICAgKiAgIGFmdGVyIHRoZSBnaXZlbiBkYXRlIHdpbGwgYmUgZXhjbHVkZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29tcGxldGVkPWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgdGhlbiB0YXNrcyB0aGF0XG4gICAqICAgaGF2ZSBiZWVuIGNvbXBsZXRlZCB3aWxsIGJlIGluY2x1ZGVkLiBPdGhlcndpc2UgdGhleSBhcmUgZXhjbHVkZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVxdWlyZUR1ZURhdGU9ZmFsc2VdIElmIHNldCB0byB0cnVlLCB0aGVuIHRhc2tzXG4gICAqICAgdGhhdCBkbyBub3QgaGF2ZSBhIGR1ZSBkYXRlIHdpbGwgYmUgZXhjbHVkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm9qZWN0XSBJZiBwcm92aWRlZCwgb25seSB0YXNrcyBiZWxvbmdpbmcgdG8gdGhlXG4gICAqICAgc3BlY2lmaWVkIHByb2plY3Qgd2lsbCBiZSBpbmNsdWRlZC4gSWYgc2V0IHRvICdub25lJywgdGhlbiBvbmx5IHRhc2tzXG4gICAqICAgdGhhdCBkbyBub3QgaGF2ZSBhIHByb2plY3QgYXNzaWduZWQgd2lsbCBiZSBpbmNsdWRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnByaW9yaXR5XSBJZiBwcm92aWRlZCwgb25seSB0YXNrcyB3aXRoIHRoZVxuICAgKiAgIHNwZWNpZmllZCBwcmlvcml0eSB3aWxsIGJlIGluY2x1ZGVkLlxuICAgKiBAcGFyYW0ge21vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH5zb3J0T3B0aW9uc1tdfSBbb3B0aW9ucy5zb3J0QnldIEFuIGFycmF5XG4gICAqICAgb2Ygb2JqZWN0cyBzcGVjaWZ5aW5nIHRoZSBzb3J0IG9yZGVyLiBUaGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICogICBkZXRlcm1pbmVzIHRoZSBwcmltYXJ5IGZpZWxkIG9uIHdoaWNoIHRvIHNvcnQgdGhlIHRhc2tzLCB0aGUgc2Vjb25kXG4gICAqICAgZWxlbWVudCBkZXRlcm1pbmVzIHRoZSBmaWVsZCB1c2VkIHRvIGJyZWFrIHRpZXMsIHRoZSB0aGlyZCBlbGVtZW50XG4gICAqICAgZGV0ZXJtaW5lcyB0aGUgZmllbGQgdXNlZCB0byBicmVhayBmdXJ0aGVyIHRpZXMsIGFuZCBzbyBvbi5cbiAgICogQHJldHVybnMge21vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH50YXNrV3JhcHBlcltdfSBUaGUgYXJyYXkgb2ZcbiAgICogICBbdGFza1dyYXBwZXJde0BsaW5rIG1vZHVsZTp0YXNrTGlzdH5UYXNrTGlzdH50YXNrV3JhcHBlcn0gb2JqZWN0cy5cbiAgICovXG4gIGVudHJpZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdmF0ZXMgPSBwcml2YXRlTWVtYmVycy5nZXQodGhpcyk7XG4gICAgY29uc3Qgc29ydEJ5ID0gb3B0aW9ucy5zb3J0QnkgfHwgW107XG5cbiAgICAvLyBXaGljaCBpbmRleCB0byB1c2U6IGRlZmF1bHQgfCBkdWUtZGF0ZSB8IHByb2plY3QgfCBwcmlvcml0eVxuICAgIGxldCBsb29rdXBUeXBlID0gJ2RlZmF1bHQnO1xuICAgIGlmIChvcHRpb25zLnByb2plY3QpIHtcbiAgICAgIGxvb2t1cFR5cGUgPSAncHJvamVjdCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmlvcml0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxvb2t1cFR5cGUgPSAncHJpb3JpdHknO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdGFydERhdGUgfHwgb3B0aW9ucy5lbmREYXRlKSB7XG4gICAgICBsb29rdXBUeXBlID0gJ2R1ZS1kYXRlJztcbiAgICB9XG5cbiAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgY29uc3QgY29weVRhc2tzID0gKG1hcCwga2V5KSA9PiB7XG4gICAgICBjb25zdCB0YXNrcyA9IG1hcC5nZXQoa2V5KTtcbiAgICAgIGlmICh0YXNrcykgdGFza3MuZm9yRWFjaCgodGFzaykgPT4gb3V0cHV0LnB1c2goXy5jbG9uZURlZXAodGFzaykpKTtcbiAgICB9O1xuICAgIHN3aXRjaCAobG9va3VwVHlwZSkge1xuICAgICAgY2FzZSAnZHVlLWRhdGUnOiB7XG4gICAgICAgIGNvbnN0IGRhdGVzID0gWy4uLnByaXZhdGVzLnRhc2tzQnlEdWVEYXRlLmtleXMoKV07XG4gICAgICAgIGRhdGVzLnNvcnQoKTtcblxuICAgICAgICBsZXQgc3RhcnRLZXkgPSBudWxsO1xuICAgICAgICBsZXQgZW5kS2V5ID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnREYXRlKSB7XG4gICAgICAgICAgc3RhcnRLZXkgPSBmb3JtYXRJc29EYXRlKG9wdGlvbnMuc3RhcnREYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmREYXRlKSB7XG4gICAgICAgICAgZW5kS2V5ID0gZm9ybWF0SXNvRGF0ZShvcHRpb25zLmVuZERhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxvd0luZGV4ID0gMDtcbiAgICAgICAgbGV0IGhpZ2hJbmRleCA9IGRhdGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXJ0S2V5KSB7XG4gICAgICAgICAgbG93SW5kZXggPSBfLnNvcnRlZEluZGV4KGRhdGVzLCBzdGFydEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZEtleSkge1xuICAgICAgICAgIGhpZ2hJbmRleCA9IF8uc29ydGVkTGFzdEluZGV4KGRhdGVzLCBlbmRLZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGVzLmxlbmd0aCA+IDAgJiYgZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0gPT09ICdub25lJykge1xuICAgICAgICAgIGhpZ2hJbmRleCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0ZXMuc2xpY2UobG93SW5kZXgsIGhpZ2hJbmRleCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgY29weVRhc2tzKHByaXZhdGVzLnRhc2tzQnlEdWVEYXRlLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29weVRhc2tzKHByaXZhdGVzLnRhc2tzQnlEdWVEYXRlLCAnbm9uZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3ByaW9yaXR5Jzoge1xuICAgICAgICBjb3B5VGFza3MocHJpdmF0ZXMudGFza3NCeVByaW9yaXR5LCBvcHRpb25zLnByaW9yaXR5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdwcm9qZWN0JzpcbiAgICAgICAgY29weVRhc2tzKHByaXZhdGVzLnRhc2tzQnlQcm9qZWN0LCBvcHRpb25zLnByb2plY3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHJpdmF0ZXMudGFza3MuZm9yRWFjaCgodGFzaywgaWQpID0+IHtcbiAgICAgICAgICBvdXRwdXQucHVzaCh7IGlkLCB0YXNrOiBfLmNsb25lRGVlcCh0YXNrKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG91dHB1dCA9IG91dHB1dC5maWx0ZXIoKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCB7IHRhc2sgfSA9IGVudHJ5O1xuICAgICAgaWYgKHRhc2suZHVlRGF0ZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5zdGFydERhdGVcbiAgICAgICAgICAmJiBpc0RhdGVCZWZvcmUodGFzay5kdWVEYXRlLCBvcHRpb25zLnN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kRGF0ZSAmJiBpc0RhdGVCZWZvcmUob3B0aW9ucy5lbmREYXRlLCB0YXNrLmR1ZURhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuY29tcGxldGVkICYmIHRhc2suaXNDb21wbGV0ZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAob3B0aW9ucy5yZXF1aXJlRHVlRGF0ZSAmJiAhdGFzay5kdWVEYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAob3B0aW9ucy5wcm9qZWN0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnByb2plY3QgPT09ICdub25lJyAmJiB0YXNrLnByb2plY3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJvamVjdCAhPT0gJ25vbmUnICYmIHRhc2sucHJvamVjdCAhPT0gb3B0aW9ucy5wcm9qZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJpb3JpdHkgPT09ICdudW1iZXInXG4gICAgICAgICYmIHRhc2sucHJpb3JpdHkgIT09IG9wdGlvbnMucHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIG91dHB1dCA9IG91dHB1dC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBsZWZ0VGFzayA9IGEudGFzaztcbiAgICAgIGNvbnN0IHJpZ2h0VGFzayA9IGIudGFzaztcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzb3J0QnkubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNhc2VTZW5zaXRpdmUgPSBzb3J0QnlbaW5kZXhdLmNhc2VTZW5zaXRpdmUgPz8gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlc2NlbmRpbmcgPSBzb3J0QnlbaW5kZXhdLmRlc2NlbmRpbmcgPz8gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdMYXN0ID0gc29ydEJ5W2luZGV4XS5taXNzaW5nTGFzdCA/PyBmYWxzZTtcbiAgICAgICAgY29uc3QgTEVTUyA9IGRlc2NlbmRpbmcgPyAxIDogLTE7XG4gICAgICAgIGNvbnN0IE1PUkUgPSBkZXNjZW5kaW5nID8gLTEgOiAxO1xuICAgICAgICBzd2l0Y2ggKHNvcnRCeVtpbmRleF0uZmllbGQpIHtcbiAgICAgICAgICBjYXNlICduYW1lJzoge1xuICAgICAgICAgICAgbGV0IGxlZnROYW1lID0gbGVmdFRhc2submFtZTtcbiAgICAgICAgICAgIGxldCByaWdodE5hbWUgPSByaWdodFRhc2submFtZTtcbiAgICAgICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgICBsZWZ0TmFtZSA9IGxlZnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHJpZ2h0TmFtZSA9IHJpZ2h0TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnROYW1lIDwgcmlnaHROYW1lKSByZXR1cm4gTEVTUztcbiAgICAgICAgICAgIGlmIChsZWZ0TmFtZSA+IHJpZ2h0TmFtZSkgcmV0dXJuIE1PUkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnZHVlLWRhdGUnOiB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0RGF0ZSA9IGxlZnRUYXNrLmR1ZURhdGU7XG4gICAgICAgICAgICBjb25zdCByaWdodERhdGUgPSByaWdodFRhc2suZHVlRGF0ZTtcbiAgICAgICAgICAgIGlmICghbGVmdERhdGUgJiYgcmlnaHREYXRlKSByZXR1cm4gbWlzc2luZ0xhc3QgPyBNT1JFIDogTEVTUztcbiAgICAgICAgICAgIGlmIChsZWZ0RGF0ZSAmJiAhcmlnaHREYXRlKSByZXR1cm4gbWlzc2luZ0xhc3QgPyBMRVNTIDogTU9SRTtcbiAgICAgICAgICAgIGlmIChsZWZ0RGF0ZSAmJiByaWdodERhdGUgJiYgIWlzU2FtZURheShsZWZ0RGF0ZSwgcmlnaHREYXRlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaXNEYXRlQmVmb3JlKGxlZnREYXRlLCByaWdodERhdGUpID8gTEVTUyA6IE1PUkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnY3JlYXRlLWRhdGUnOlxuICAgICAgICAgICAgaWYgKGlzRGF0ZUJlZm9yZShsZWZ0VGFzay5jcmVhdGlvbkRhdGUsIHJpZ2h0VGFzay5jcmVhdGlvbkRhdGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBMRVNTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGF0ZUJlZm9yZShyaWdodFRhc2suY3JlYXRpb25EYXRlLCBsZWZ0VGFzay5jcmVhdGlvbkRhdGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNT1JFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncHJpb3JpdHknOlxuICAgICAgICAgICAgaWYgKGxlZnRUYXNrLnByaW9yaXR5ID4gcmlnaHRUYXNrLnByaW9yaXR5KSByZXR1cm4gTEVTUztcbiAgICAgICAgICAgIGlmIChsZWZ0VGFzay5wcmlvcml0eSA8IHJpZ2h0VGFzay5wcmlvcml0eSkgcmV0dXJuIE1PUkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwcm9qZWN0Jzoge1xuICAgICAgICAgICAgY29uc3QgbGVmdFByb2ogPSBsZWZ0VGFzay5wcm9qZWN0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHRQcm9qID0gcmlnaHRUYXNrLnByb2plY3Q7XG4gICAgICAgICAgICBpZiAoIWxlZnRQcm9qICYmIHJpZ2h0UHJvaikgcmV0dXJuIG1pc3NpbmdMYXN0ID8gTU9SRSA6IExFU1M7XG4gICAgICAgICAgICBpZiAobGVmdFByb2ogJiYgIXJpZ2h0UHJvaikgcmV0dXJuIG1pc3NpbmdMYXN0ID8gTEVTUyA6IE1PUkU7XG4gICAgICAgICAgICBpZiAobGVmdFByb2ogJiYgcmlnaHRQcm9qKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgcHJvamVjdExpc3QgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgIGlmICghcHJvamVjdExpc3QpIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGxldCBsZWZ0TmFtZSA9IHByb2plY3RMaXN0LmdldFByb2plY3QobGVmdFByb2opLm5hbWU7XG4gICAgICAgICAgICAgIGxldCByaWdodE5hbWUgPSBwcm9qZWN0TGlzdC5nZXRQcm9qZWN0KHJpZ2h0UHJvaikubmFtZTtcbiAgICAgICAgICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgbGVmdE5hbWUgPSBsZWZ0TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0TmFtZSA9IHJpZ2h0TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZWZ0TmFtZSA8IHJpZ2h0TmFtZSkgcmV0dXJuIExFU1M7XG4gICAgICAgICAgICAgIGlmIChsZWZ0TmFtZSA+IHJpZ2h0TmFtZSkgcmV0dXJuIE1PUkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHRhc2sgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlXG4gICAqICAgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS5ldmVudEVtaXR0ZXIub24odHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgZGF0YSB0byBhbiBvYmplY3Qgc3VpdGFibGUgZm9yIHNlcmlhbGl6YXRpb24uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCByZXByZXNlbnRpbmcgc2VyaWFsaXphYmxlIGRhdGEgZm9yIHRoZSBjbGFzcy5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS50YXNrcy5mb3JFYWNoKCh0YXNrLCBpZCkgPT4ge1xuICAgICAgY29uc3QgY29weSA9IF8uY2xvbmVEZWVwKHRhc2spO1xuICAgICAgY29weS5pZCA9IGlkO1xuICAgICAgdGFza3MucHVzaChjb3B5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFza3M7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBkYXRhIHRvIGEgc3RyaW5nIGluIENTViAoY29tbWEtc2VwYXJhdGVkIHZhbHVlcykgZm9ybWF0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIEFuIG9iamVjdCBob2xkaW5nIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5ld2xpbmVTZXF1ZW5jZV0gVGhlIGNoYXJhY3RlciBzZXF1ZW5jZSB0byB1c2VcbiAgICogICBmb3IgbmV3bGluZXMuIElmIG5vdCBnaXZlbiwgdGhlbiBhIGNhcnJpYWdlIHJldHVybi9saW5lIGZlZWQgcGFpciAoQ1JMRilcbiAgICogICBpcyB1c2VkLCBhcyBzdWdnZXN0ZWQgYnkgdGhlXG4gICAqICAgW1JGQyA0MTgwXXtAbGluayBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQxODB9XG4gICAqICAgc3BlY2lmaWNhdGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R9IFtvcHRpb25zLnByb2plY3RMaXN0XSBUaGUgcHJvamVjdFxuICAgKiAgIGNvbnRhaW5lci4gSWYgbm90IHByb3ZpZGVkLCB0aGVuIG5vIHByb2plY3QgaW5mb3JtYXRpb24gYmVzaWRlcyB0aGVcbiAgICogICBwcm9qZWN0IGlkZW50aWZpZXIgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgQ1NWIGZpZWxkcy5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRhc2sgZGF0YSBpbiBDU1YgZm9ybWF0LlxuICAgKi9cbiAgdG9Dc3Yob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcHJvamVjdEZpZWxkcyA9IFtdO1xuICAgIGlmIChvcHRpb25zLnByb2plY3RMaXN0KSBwcm9qZWN0RmllbGRzLnB1c2goJ1Byb2plY3QgTmFtZScpO1xuICAgIHByb2plY3RGaWVsZHMucHVzaCgnUHJvamVjdCBVVUlEJyk7XG4gICAgaWYgKG9wdGlvbnMucHJvamVjdExpc3QpIHByb2plY3RGaWVsZHMucHVzaCgnUHJvamVjdCBEZXNjcmlwdGlvbicpO1xuXG4gICAgY29uc3QgaGVhZGVyID0gW1xuICAgICAgJ05hbWUnLFxuICAgICAgJ1VVSUQnLFxuICAgICAgJ0R1ZSBEYXRlJyxcbiAgICAgICdEYXRlIEFkZGVkJyxcbiAgICAgICdEYXRlIENvbXBsZXRlZCcsXG4gICAgICAnUHJpb3JpdHknLFxuICAgICAgJ0Rlc2NyaXB0aW9uJyxcbiAgICAgIC4uLnByb2plY3RGaWVsZHMsXG4gICAgICAnUmVjdXJyZW5jZSBJbnRlcnZhbCBVbml0JyxcbiAgICAgICdSZWN1cnJlbmNlIEludGVydmFsIExlbmd0aCcsXG4gICAgICAnUmVjdXJyZW5jZSBTdGFydCBEYXRlJyxcbiAgICAgICdSZWN1cnJlbmNlIEJhc2VkIG9uIENvbXBsZXRpb24/JyxcbiAgICAgICdSZWN1cnJlbmNlIFdlZWsgTnVtYmVyJyxcbiAgICAgICdSZWN1cnJlbmNlIFdlZWsgRGF5cycsXG4gICAgICAnUmVjdXJyZW5jZSBNb250aCcsXG4gICAgICAnUmVjdXJyZW5jZSBEYXknLFxuICAgICAgJ1JlY3VycmVuY2UgV2Vla2VuZCBCZWhhdmlvcicsXG4gICAgICAnUmVjdXJyZW5jZSBFbmQgRGF0ZScsXG4gICAgICAnUmVjdXJyZW5jZSBNYXggQ291bnQnLFxuICAgIF07XG5cbiAgICBjb25zdCBuZXdsaW5lU2VxdWVuY2UgPSBvcHRpb25zLm5ld2xpbmVTZXF1ZW5jZSA/PyAnXFxyXFxuJztcbiAgICBjb25zdCBjc3ZPcHRpb25zID0geyBuZXdsaW5lU2VxdWVuY2UgfTtcbiAgICBjb25zdCBjb252ZXJ0RGF0ZSA9IChkYXRlKSA9PiBkYXRlPy50b0pTT04oKSA/PyAnJztcbiAgICBjb25zdCBsaW5lcyA9IFthcnJheVRvQ3N2UmVjb3JkKGhlYWRlciwgY3N2T3B0aW9ucyldO1xuICAgIHByaXZhdGVNZW1iZXJzLmdldCh0aGlzKS50YXNrcy5mb3JFYWNoKCh0YXNrLCBpZCkgPT4ge1xuICAgICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICB0YXNrLm5hbWUsXG4gICAgICAgIGlkLFxuICAgICAgICBjb252ZXJ0RGF0ZSh0YXNrLmR1ZURhdGUpLFxuICAgICAgICBjb252ZXJ0RGF0ZSh0YXNrLmNyZWF0aW9uRGF0ZSksXG4gICAgICAgIGNvbnZlcnREYXRlKHRhc2suY29tcGxldGlvbkRhdGUpLFxuICAgICAgICBUYXNrLmNvbnZlcnRQcmlvcml0eVRvUHJldHR5U3RyaW5nKHRhc2sucHJpb3JpdHkpLFxuICAgICAgICB0YXNrLmRlc2NyaXB0aW9uID8/ICcnLFxuICAgICAgXTtcblxuICAgICAgaWYgKG9wdGlvbnMucHJvamVjdExpc3QpIHtcbiAgICAgICAgbGV0IHByb2plY3QgPSBudWxsO1xuICAgICAgICBpZiAodGFzay5wcm9qZWN0KSB7XG4gICAgICAgICAgcHJvamVjdCA9IG9wdGlvbnMucHJvamVjdExpc3QuZ2V0UHJvamVjdCh0YXNrLnByb2plY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcy5wdXNoKFxuICAgICAgICAgIHByb2plY3Q/Lm5hbWUgPz8gJycsXG4gICAgICAgICAgdGFzay5wcm9qZWN0ID8/ICcnLFxuICAgICAgICAgIHByb2plY3Q/LmRlc2NyaXB0aW9uID8/ICcnLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGRzLnB1c2godGFzay5wcm9qZWN0ID8/ICcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyByZWN1cnJpbmdEYXRlIH0gPSB0YXNrO1xuICAgICAgbGV0IGludGVydmFsVW5pdCA9ICcnO1xuICAgICAgc3dpdGNoIChyZWN1cnJpbmdEYXRlPy5pbnRlcnZhbFVuaXQpIHtcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICBpbnRlcnZhbFVuaXQgPSAnRGF5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgaW50ZXJ2YWxVbml0ID0gJ1dlZWsnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgaW50ZXJ2YWxVbml0ID0gJ01vbnRoJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgaW50ZXJ2YWxVbml0ID0gJ1llYXInO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IGRheXNPZldlZWsgPSAnJztcbiAgICAgIGlmIChyZWN1cnJpbmdEYXRlPy5kYXlzT2ZXZWVrKSB7XG4gICAgICAgIGRheXNPZldlZWsgPSByZWN1cnJpbmdEYXRlLmRheXNPZldlZWsubWFwKGdldFdlZWtkYXlOYW1lKS5qb2luKCcsICcpO1xuICAgICAgfVxuICAgICAgbGV0IG1vbnRoID0gJyc7XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihyZWN1cnJpbmdEYXRlPy5tb250aCkpIHtcbiAgICAgICAgbW9udGggPSBnZXRNb250aE5hbWUocmVjdXJyaW5nRGF0ZS5tb250aCk7XG4gICAgICB9XG4gICAgICBsZXQgb25XZWVrZW5kID0gJyc7XG4gICAgICBzd2l0Y2ggKHJlY3VycmluZ0RhdGU/Lm9uV2Vla2VuZCkge1xuICAgICAgICBjYXNlICduby1jaGFuZ2UnOlxuICAgICAgICAgIG9uV2Vla2VuZCA9ICdObyBDaGFuZ2UnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcmV2aW91cy13ZWVrZGF5JzpcbiAgICAgICAgICBvbldlZWtlbmQgPSAnVXNlIFByZXZpb3VzIFdlZWtkYXknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICduZXh0LXdlZWtkYXknOlxuICAgICAgICAgIG9uV2Vla2VuZCA9ICdVc2UgTmV4dCBXZWVrZGF5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbmVhcmVzdC13ZWVrZGF5JzpcbiAgICAgICAgICBvbldlZWtlbmQgPSAnVXNlIE5lYXJlc3QgV2Vla2RheSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaWVsZHMucHVzaChcbiAgICAgICAgaW50ZXJ2YWxVbml0LFxuICAgICAgICByZWN1cnJpbmdEYXRlPy5pbnRlcnZhbExlbmd0aC50b1N0cmluZygpID8/ICcnLFxuICAgICAgICBjb252ZXJ0RGF0ZShyZWN1cnJpbmdEYXRlPy5zdGFydERhdGUpLFxuICAgICAgICByZWN1cnJpbmdEYXRlPy5iYXNlT25Db21wbGV0aW9uLnRvU3RyaW5nKCkgPz8gJycsXG4gICAgICAgIHJlY3VycmluZ0RhdGU/LndlZWtOdW1iZXI/LnRvU3RyaW5nKCkgPz8gJycsXG4gICAgICAgIGRheXNPZldlZWssXG4gICAgICAgIG1vbnRoLFxuICAgICAgICByZWN1cnJpbmdEYXRlPy5kYXlPZk1vbnRoPy50b1N0cmluZygpID8/ICcnLFxuICAgICAgICBvbldlZWtlbmQsXG4gICAgICAgIGNvbnZlcnREYXRlKHJlY3VycmluZ0RhdGU/LmVuZERhdGUpLFxuICAgICAgICByZWN1cnJpbmdEYXRlPy5tYXhDb3VudD8udG9TdHJpbmcoKSA/PyAnJyxcbiAgICAgICk7XG4gICAgICBsaW5lcy5wdXNoKGFycmF5VG9Dc3ZSZWNvcmQoZmllbGRzLCBjc3ZPcHRpb25zKSk7XG4gICAgfSk7XG4gICAgbGluZXMucHVzaCgnJyk7XG5cbiAgICByZXR1cm4gbGluZXMuam9pbihuZXdsaW5lU2VxdWVuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcG9ydCB0YXNrcyBmcm9tIGEgSlNPTiBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBzZXJpYWxpemVkIEpTT04gb2JqZWN0IHRvIGltcG9ydC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3QgaG9sZGluZyBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZVxuICAgKiAgIGltcG9ydC5cbiAgICogQHBhcmFtIHttb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R9IFtvcHRpb25zLnByb2plY3RMaXN0XSBUaGUgcHJvamVjdFxuICAgKiAgIGNvbnRhaW5lci4gSWYgbm90IHByb3ZpZGVkLCB0aGVuIGZ1bGwgdmFsaWRhdGlvbiB3aWxsIG5vdCBiZSBwZXJmb3JtZWRcbiAgICogICBvbiBwcm9qZWN0IGlkZW50aWZpZXJzLlxuICAgKiBAcmV0dXJucyB7bW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fmltcG9ydFN0YXR1c30gQW4gb2JqZWN0IGhvbGRpbmdcbiAgICogICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3RhdHVzIG9mIHRoZSBpbXBvcnQuXG4gICAqIEBmaXJlcyBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R+YWRkVGFza1xuICAgKiBAZmlyZXMgbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fnVwZGF0ZVRhc2tcbiAgICovXG4gIGltcG9ydEZyb21Kc29uKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvdW50cyA9IHtcbiAgICAgIGFkZGVkOiAwLFxuICAgICAgdXBkYXRlZDogMCxcbiAgICAgIGZhaWxlZDogMCxcbiAgICAgIHRvdGFsOiAwLFxuICAgIH07XG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdFcnJvcjogRXhwZWN0ZWQgXCJ0YXNrc1wiIHByb3BlcnR5IHRvIGJlIGFuIGFycmF5LicpO1xuICAgICAgcmV0dXJuIHsgdGFza3M6IGNvdW50cywgZXJyb3JzIH07XG4gICAgfVxuXG4gICAgZGF0YS5mb3JFYWNoKCh0YXNrKSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVFcnJvciA9IChlcnJvclR5cGUsIHZhbHVlLCBvcHRzKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG1zZ1ByZWZpeCA9IGBXYXJuaW5nOiBUYXNrIFwiJHt0YXNrLm5hbWV9XCJgO1xuICAgICAgICBsZXQgbXNnO1xuICAgICAgICBzd2l0Y2ggKGVycm9yVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2JhZC10eXBlJzpcbiAgICAgICAgICAgIGlmIChvcHRzLmFsbG93Q29udmVyc2lvbiAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIG1zZyA9IGBFeHBlY3RlZCB0eXBlIFwiJHtvcHRzLmV4cGVjdGVkVHlwZX1cIiBmb3IgcHJvcGVydHkgXCIke29wdHMudmFsdWVOYW1lfVwiIChjb252ZXJzaW9uIGZyb20gdHlwZSBcInN0cmluZ1wiIGZhaWxlZCkuYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1zZyA9IGBFeHBlY3RlZCB0eXBlIFwiJHtvcHRzLmV4cGVjdGVkVHlwZX1cIiBmb3IgcHJvcGVydHkgXCIke29wdHMudmFsdWVOYW1lfVwiIChyZWNlaXZlZCBcIiR7Z2V0SnNvblR5cGUodmFsdWUpfVwiKS5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndW5rbm93bi12YWx1ZSc6XG4gICAgICAgICAgICBtc2cgPSBgVW5yZWNvZ25pemVkIHZhbHVlIFwiJHt2YWx1ZX1cIiBmb3IgcHJvcGVydHkgXCIke29wdHMudmFsdWVOYW1lfVwiLmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdub3QtaW50ZWdlcic6XG4gICAgICAgICAgICBtc2cgPSBgVmFsdWUgZm9yIHByb3BlcnR5IFwiJHtvcHRzLnZhbHVlTmFtZX1cIiBtdXN0IGJlIGFuIGludGVnZXIgKHJlY2VpdmVkIFwiJHt2YWx1ZX1cIikuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rvby1sb3cnOlxuICAgICAgICAgICAgbXNnID0gYFZhbHVlIGZvciBwcm9wZXJ0eSBcIiR7b3B0cy52YWx1ZU5hbWV9XCIgY2Fubm90IGJlIGJlbG93IFwiJHtvcHRzLm1pbn1cIiAocmVjZWl2ZWQgXCIke3ZhbHVlfVwiKS5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndG9vLWhpZ2gnOlxuICAgICAgICAgICAgbXNnID0gYFZhbHVlIGZvciBwcm9wZXJ0eSBcIiR7b3B0cy52YWx1ZU5hbWV9XCIgY2Fubm90IGJlIGFib3ZlIFwiJHtvcHRzLm1heH1cIiAocmVjZWl2ZWQgXCIke3ZhbHVlfVwiKS5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYmFkLWRhdGUnOlxuICAgICAgICAgICAgbXNnID0gYEV4cGVjdGVkIGEgZGF0ZSBpbiBJU08gZm9ybWF0IGZvciBwcm9wZXJ0eSBcIiR7b3B0cy52YWx1ZU5hbWV9XCIgKHJlY2VpdmVkIFwiJHt2YWx1ZX1cIikuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JhZC1pZCc6XG4gICAgICAgICAgICBtc2cgPSBgRXhwZWN0ZWQgYSB2ZXJzaW9uIDQgVVVJRCBmb3IgcHJvcGVydHkgXCIke29wdHMudmFsdWVOYW1lfVwiIChyZWNlaXZlZCBcIiR7dmFsdWV9XCIpLmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdmYWlsZWQtcHJlZGljYXRlJzpcbiAgICAgICAgICAgIGlmIChvcHRzLnZhbHVlTmFtZSA9PT0gJ3Byb2plY3QnKSB7XG4gICAgICAgICAgICAgIG1zZyA9IGBVbnJlY29nbml6ZWQgcHJvamVjdCBpZGVudGlmaWVyIFwiJHt2YWx1ZX1cIiBmb3IgcHJvcGVydHkgXCIke29wdHMudmFsdWVOYW1lfVwiLmA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtc2cgPSBgRmFpbGVkIGN1c3RvbSB2YWxpZGF0aW9uIGZvciBwcm9wZXJ0eSBcIiR7b3B0cy52YWx1ZU5hbWV9LmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbXNnID0gYEVuY291bnRlcmVkIHVucmVjb2duaXplZCBlcnJvciBcIiR7ZXJyb3JUeXBlfVwiIGZvciBwcm9wZXJ0eSBcIiR7b3B0cy52YWx1ZU5hbWV9XCIuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3JzLnB1c2goYCR7bXNnUHJlZml4fTogJHttc2d9YCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGFzay5uYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goJ0Vycm9yOiBUYXNrIG11c3QgaGF2ZSBhIG5hbWUuJyk7XG4gICAgICAgIGNvdW50cy5mYWlsZWQgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhc2submFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYEVycm9yOiBFeHBlY3RlZCB0eXBlIFwic3RyaW5nXCIgZm9yIHRhc2sgbmFtZSAocmVjZWl2ZWQgXCIke2dldEpzb25UeXBlKHRhc2submFtZSl9XCIpLmApO1xuICAgICAgICBjb3VudHMuZmFpbGVkICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKHRhc2submFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZXJyb3JzLnB1c2goJ0Vycm9yOiBUYXNrIG5hbWUgbXVzdCBub3QgYmUgZW1wdHkuJyk7XG4gICAgICAgIGNvdW50cy5mYWlsZWQgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhc2tPcHRpb25zID0ge307XG5cbiAgICAgICAgbGV0IG5ld0lkID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUodGFzay5pZCwge1xuICAgICAgICAgIHZhbHVlTmFtZTogJ2lkJyxcbiAgICAgICAgICBleHBlY3RlZFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlcXVpcmVVdWlkOiB0cnVlLFxuICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICB9KSkgbmV3SWQgPSB0YXNrLmlkO1xuXG4gICAgICAgIHZhbGlkYXRlVmFsdWUodGFzay5kdWVEYXRlLCB7XG4gICAgICAgICAgdmFsdWVOYW1lOiAnZHVlRGF0ZScsXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnZGF0ZScsXG4gICAgICAgICAgYWxsb3dDb252ZXJzaW9uOiB0cnVlLFxuICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0YXNrT3B0aW9ucy5kdWVEYXRlID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFsaWRhdGVWYWx1ZSh0YXNrLmNyZWF0aW9uRGF0ZSwge1xuICAgICAgICAgIHZhbHVlTmFtZTogJ2NyZWF0aW9uRGF0ZScsXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnZGF0ZScsXG4gICAgICAgICAgYWxsb3dDb252ZXJzaW9uOiB0cnVlLFxuICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0YXNrT3B0aW9ucy5jcmVhdGlvbkRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICB9KTtcblxuICAgICAgICB2YWxpZGF0ZVZhbHVlKHRhc2suY29tcGxldGlvbkRhdGUsIHtcbiAgICAgICAgICB2YWx1ZU5hbWU6ICdjb21wbGV0aW9uRGF0ZScsXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnZGF0ZScsXG4gICAgICAgICAgYWxsb3dDb252ZXJzaW9uOiB0cnVlLFxuICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0YXNrT3B0aW9ucy5jb21wbGV0aW9uRGF0ZSA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3JDYWxsYmFjazogaGFuZGxlRXJyb3IsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0YXNrLnByaW9yaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBzZXRQcmlvcml0eSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGFza09wdGlvbnMucHJpb3JpdHkgPSB2YWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh0eXBlb2YgdGFzay5wcmlvcml0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVmFsdWUodGFzay5wcmlvcml0eSwge1xuICAgICAgICAgICAgICB2YWx1ZU5hbWU6ICdwcmlvcml0eScsXG4gICAgICAgICAgICAgIGV4cGVjdGVkVmFsdWVzOiBbXG4gICAgICAgICAgICAgICAgJ3ZlcnktbG93JyxcbiAgICAgICAgICAgICAgICAnbG93JyxcbiAgICAgICAgICAgICAgICAnbWVkaXVtJyxcbiAgICAgICAgICAgICAgICAnaGlnaCcsXG4gICAgICAgICAgICAgICAgJ3ZlcnktaGlnaCcsXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogc2V0UHJpb3JpdHksXG4gICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVmFsdWUodGFzay5wcmlvcml0eSwge1xuICAgICAgICAgICAgICB2YWx1ZU5hbWU6ICdwcmlvcml0eScsXG4gICAgICAgICAgICAgIGV4cGVjdGVkVHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgIHJlcXVpcmVJbnRlZ2VyOiB0cnVlLFxuICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IHNldFByaW9yaXR5LFxuICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0ZVZhbHVlKHRhc2suZGVzY3JpcHRpb24sIHtcbiAgICAgICAgICB2YWx1ZU5hbWU6ICdkZXNjcmlwdGlvbicsXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgfSkpIHRhc2tPcHRpb25zLmRlc2NyaXB0aW9uID0gdGFzay5kZXNjcmlwdGlvbjtcblxuICAgICAgICBpZiAodmFsaWRhdGVWYWx1ZSh0YXNrLnJlY3VycmluZ0RhdGUsIHtcbiAgICAgICAgICB2YWx1ZU5hbWU6ICdyZWN1cnJpbmdEYXRlJyxcbiAgICAgICAgICBleHBlY3RlZFR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICB9KSAmJiB2YWxpZGF0ZVZhbHVlKHRhc2sucmVjdXJyaW5nRGF0ZS5pbnRlcnZhbFVuaXQsIHtcbiAgICAgICAgICB2YWx1ZU5hbWU6ICdyZWN1cnJpbmdEYXRlLmludGVydmFsVW5pdCcsXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBleHBlY3RlZFZhbHVlczogW1xuICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAnd2VlaycsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXJyb3JDYWxsYmFjazogaGFuZGxlRXJyb3IsXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgY29uc3QgeyByZWN1cnJpbmdEYXRlIH0gPSB0YXNrO1xuICAgICAgICAgIGNvbnN0IHJlY09wdGlvbnMgPSB7fTtcblxuICAgICAgICAgIGlmICh2YWxpZGF0ZVZhbHVlKHJlY3VycmluZ0RhdGUuaW50ZXJ2YWxMZW5ndGgsIHtcbiAgICAgICAgICAgIHZhbHVlTmFtZTogJ3JlY3VycmluZ0RhdGUuaW50ZXJ2YWxMZW5ndGgnLFxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIHJlcXVpcmVJbnRlZ2VyOiB0cnVlLFxuICAgICAgICAgICAgbWluOiAxLFxuICAgICAgICAgICAgZXJyb3JDYWxsYmFjazogaGFuZGxlRXJyb3IsXG4gICAgICAgICAgfSkpIHJlY09wdGlvbnMuaW50ZXJ2YWxMZW5ndGggPSByZWN1cnJpbmdEYXRlLmludGVydmFsTGVuZ3RoO1xuXG4gICAgICAgICAgdmFsaWRhdGVWYWx1ZShyZWN1cnJpbmdEYXRlLnN0YXJ0RGF0ZSwge1xuICAgICAgICAgICAgdmFsdWVOYW1lOiAncmVjdXJyaW5nRGF0ZS5zdGFydERhdGUnLFxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnZGF0ZScsXG4gICAgICAgICAgICBhbGxvd0NvbnZlcnNpb246IHRydWUsXG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICByZWNPcHRpb25zLnN0YXJ0RGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUocmVjdXJyaW5nRGF0ZS5iYXNlT25Db21wbGV0aW9uLCB7XG4gICAgICAgICAgICB2YWx1ZU5hbWU6ICdyZWN1cnJpbmdEYXRlLmJhc2VPbkNvbXBsZXRpb24nLFxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgICB9KSkgcmVjT3B0aW9ucy5iYXNlT25Db21wbGV0aW9uID0gcmVjdXJyaW5nRGF0ZS5iYXNlT25Db21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUocmVjdXJyaW5nRGF0ZS53ZWVrTnVtYmVyLCB7XG4gICAgICAgICAgICB2YWx1ZU5hbWU6ICdyZWN1cnJpbmdEYXRlLndlZWtOdW1iZXInLFxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIHJlcXVpcmVJbnRlZ2VyOiB0cnVlLFxuICAgICAgICAgICAgbWluOiAxLFxuICAgICAgICAgICAgbWF4OiA1LFxuICAgICAgICAgICAgZXJyb3JDYWxsYmFjazogaGFuZGxlRXJyb3IsXG4gICAgICAgICAgfSkpIHJlY09wdGlvbnMud2Vla051bWJlciA9IHJlY3VycmluZ0RhdGUud2Vla051bWJlcjtcblxuICAgICAgICAgIGlmICh2YWxpZGF0ZVZhbHVlKHJlY3VycmluZ0RhdGUuZGF5c09mV2Vlaywge1xuICAgICAgICAgICAgdmFsdWVOYW1lOiAncmVjdXJyaW5nRGF0ZS5kYXlzT2ZXZWVrJyxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zdCBkYXlzT2ZXZWVrID0gW107XG4gICAgICAgICAgICByZWN1cnJpbmdEYXRlLmRheXNPZldlZWsuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0ZVZhbHVlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVOYW1lOiBgcmVjdXJyaW5nRGF0ZS5kYXlzT2ZXZWVrWyR7aW5kZXh9XWAsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICByZXF1aXJlSW50ZWdlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgbWF4OiA2LFxuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICAgICAgICB9KSkgZGF5c09mV2Vlay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVjT3B0aW9ucy5kYXlzT2ZXZWVrID0gZGF5c09mV2VlaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsaWRhdGVWYWx1ZShyZWN1cnJpbmdEYXRlLm1vbnRoLCB7XG4gICAgICAgICAgICB2YWx1ZU5hbWU6ICdyZWN1cnJpbmdEYXRlLm1vbnRoJyxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICByZXF1aXJlSW50ZWdlcjogdHJ1ZSxcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMTEsXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgICB9KSkgcmVjT3B0aW9ucy5tb250aCA9IHJlY3VycmluZ0RhdGUubW9udGg7XG5cbiAgICAgICAgICBpZiAodmFsaWRhdGVWYWx1ZShyZWN1cnJpbmdEYXRlLmRheU9mTW9udGgsIHtcbiAgICAgICAgICAgIHZhbHVlTmFtZTogJ3JlY3VycmluZ0RhdGUuZGF5T2ZNb250aCcsXG4gICAgICAgICAgICBleHBlY3RlZFR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgcmVxdWlyZUludGVnZXI6IHRydWUsXG4gICAgICAgICAgICBtaW46IDEsXG4gICAgICAgICAgICBtYXg6IDMxLFxuICAgICAgICAgICAgZXJyb3JDYWxsYmFjazogaGFuZGxlRXJyb3IsXG4gICAgICAgICAgfSkpIHJlY09wdGlvbnMuZGF5T2ZNb250aCA9IHJlY3VycmluZ0RhdGUuZGF5T2ZNb250aDtcblxuICAgICAgICAgIGlmICh2YWxpZGF0ZVZhbHVlKHJlY3VycmluZ0RhdGUub25XZWVrZW5kLCB7XG4gICAgICAgICAgICB2YWx1ZU5hbWU6ICdyZWN1cnJpbmdEYXRlLm9uV2Vla2VuZCcsXG4gICAgICAgICAgICBleHBlY3RlZFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZXhwZWN0ZWRWYWx1ZXM6IFtcbiAgICAgICAgICAgICAgJ25vLWNoYW5nZScsXG4gICAgICAgICAgICAgICdwcmV2aW91cy13ZWVrZGF5JyxcbiAgICAgICAgICAgICAgJ25leHQtd2Vla2RheScsXG4gICAgICAgICAgICAgICduZWFyZXN0LXdlZWtkYXknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICAgIH0pKSByZWNPcHRpb25zLm9uV2Vla2VuZCA9IHJlY3VycmluZ0RhdGUub25XZWVrZW5kO1xuXG4gICAgICAgICAgdmFsaWRhdGVWYWx1ZShyZWN1cnJpbmdEYXRlLmVuZERhdGUsIHtcbiAgICAgICAgICAgIHZhbHVlTmFtZTogJ3JlY3VycmluZ0RhdGUuZW5kRGF0ZScsXG4gICAgICAgICAgICBleHBlY3RlZFR5cGU6ICdkYXRlJyxcbiAgICAgICAgICAgIGFsbG93Q29udmVyc2lvbjogdHJ1ZSxcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHJlY09wdGlvbnMuZW5kRGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGhhbmRsZUVycm9yLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUocmVjdXJyaW5nRGF0ZS5tYXhDb3VudCwge1xuICAgICAgICAgICAgdmFsdWVOYW1lOiAncmVjdXJyaW5nRGF0ZS5tYXhDb3VudCcsXG4gICAgICAgICAgICBleHBlY3RlZFR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgcmVxdWlyZUludGVnZXI6IHRydWUsXG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgICB9KSkgcmVjT3B0aW9ucy5tYXhDb3VudCA9IHJlY3VycmluZ0RhdGUubWF4Q291bnQ7XG5cbiAgICAgICAgICBjb25zdCByZWN1cnJlbmNlID0gbmV3IFJlY3VycmluZ0RhdGUoXG4gICAgICAgICAgICB0YXNrLnJlY3VycmluZ0RhdGUuaW50ZXJ2YWxVbml0LFxuICAgICAgICAgICAgcmVjT3B0aW9ucyxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhc2tPcHRpb25zLnJlY3VycmluZ0RhdGUgPSByZWN1cnJlbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkYXRlVmFsdWUodGFzay5wcm9qZWN0LCB7XG4gICAgICAgICAgdmFsdWVOYW1lOiAncHJvamVjdCcsXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICByZXF1aXJlVXVpZDogdHJ1ZSxcbiAgICAgICAgICBjdXN0b21QcmVkaWNhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9qZWN0TGlzdCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiAhcHJvamVjdExpc3QgfHwgcHJvamVjdExpc3QuaGFzUHJvamVjdCh2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvckNhbGxiYWNrOiBoYW5kbGVFcnJvcixcbiAgICAgICAgfSkpIHRhc2tPcHRpb25zLnByb2plY3QgPSB0YXNrLnByb2plY3Q7XG5cbiAgICAgICAgaWYgKG5ld0lkICYmIHRoaXMuaGFzVGFzayhuZXdJZCkpIGNvdW50cy51cGRhdGVkICs9IDE7XG4gICAgICAgIGVsc2UgY291bnRzLmFkZGVkICs9IDE7XG5cbiAgICAgICAgY29uc3QgbmV3VGFzayA9IG5ldyBUYXNrKHRhc2submFtZSwgdGFza09wdGlvbnMpO1xuICAgICAgICBpZiAobmV3SWQpIHRoaXMuYWRkT3JVcGRhdGVUYXNrKG5ld0lkLCBuZXdUYXNrKTtcbiAgICAgICAgZWxzZSB0aGlzLmFkZFRhc2sobmV3VGFzayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb3VudHMudG90YWwgPSBjb3VudHMuYWRkZWQgKyBjb3VudHMudXBkYXRlZCArIGNvdW50cy5mYWlsZWQ7XG5cbiAgICByZXR1cm4geyB0YXNrczogY291bnRzLCBlcnJvcnMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBvcnQgdGFza3MgZnJvbSBwYXJzZWQgQ1NWIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nW11bXX0gZGF0YSBBbiBhcnJheSBvZiBzdHJpbmcgYXJyYXlzLiBFYWNoIG1lbWJlciBvZiB0aGVcbiAgICogICBvdXRlciBhcnJheSByZXByZXNlbnRzIGEgc2luZ2xlIHRhc2ssIGFuZCBlYWNoIG1lbWJlciBvZiBlYWNoIGlubmVyXG4gICAqICAgYXJyYXkgaXMgYSBkYXRhIGZpZWxkIGZvciB0aGF0IHBhcnRpY3VsYXIgdGFzay4gVGhlIGZpcnN0IG1lbWJlciBvZiB0aGVcbiAgICogICBvdXRlciBhcnJheSBzaG91bGQgYmUgYSBoZWFkZXIgaG9sZGluZyBmaWVsZCBuYW1lcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3QgaG9sZGluZyBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZVxuICAgKiAgIGltcG9ydC5cbiAgICogQHBhcmFtIHttb2R1bGU6cHJvamVjdExpc3R+UHJvamVjdExpc3R9IFtvcHRpb25zLnByb2plY3RMaXN0XSBUaGUgcHJvamVjdFxuICAgKiAgIGNvbnRhaW5lci4gSWYgbm90IHByb3ZpZGVkLCB0aGVuIGZ1bGwgdmFsaWRhdGlvbiB3aWxsIG5vdCBiZSBwZXJmb3JtZWRcbiAgICogICBvbiBwcm9qZWN0IGlkZW50aWZpZXJzLlxuICAgKiBAcmV0dXJucyB7bW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fmltcG9ydFN0YXR1c30gQW4gb2JqZWN0IGhvbGRpbmdcbiAgICogICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3RhdHVzIG9mIHRoZSBpbXBvcnQuXG4gICAqIEBmaXJlcyBtb2R1bGU6dGFza0xpc3R+VGFza0xpc3R+YWRkVGFza1xuICAgKiBAZmlyZXMgbW9kdWxlOnRhc2tMaXN0flRhc2tMaXN0fnVwZGF0ZVRhc2tcbiAgICovXG4gIGltcG9ydEZyb21Dc3YoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaGVhZGVyID0gKGRhdGEubGVuZ3RoID4gMCkgPyBkYXRhWzBdIDogW107XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuXG4gICAgZGF0YS5mb3JFYWNoKChjc3ZSZWNvcmQsIGNzdkluZGV4KSA9PiB7XG4gICAgICBpZiAoY3N2SW5kZXggPT09IDApIHJldHVybjtcblxuICAgICAgY29uc3QgZW50cnkgPSB7fTtcbiAgICAgIGNvbnN0IHJlY3VycmluZ0RhdGUgPSB7fTtcbiAgICAgIGNzdlJlY29yZC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ID49IGhlYWRlci5sZW5ndGggfHwgdmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgc3dpdGNoIChoZWFkZXJbaW5kZXhdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgIGVudHJ5Lm5hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3V1aWQnOlxuICAgICAgICAgICAgZW50cnkuaWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2R1ZSBkYXRlJzpcbiAgICAgICAgICBjYXNlICdkdWUtZGF0ZSc6XG4gICAgICAgICAgICBlbnRyeS5kdWVEYXRlID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXRlIGFkZGVkJzpcbiAgICAgICAgICBjYXNlICdkYXRlLWFkZGVkJzpcbiAgICAgICAgICAgIGVudHJ5LmNyZWF0aW9uRGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGF0ZSBjb21wbGV0ZWQnOlxuICAgICAgICAgIGNhc2UgJ2RhdGUtY29tcGxldGVkJzpcbiAgICAgICAgICAgIGVudHJ5LmNvbXBsZXRpb25EYXRlID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwcmlvcml0eSc6XG4gICAgICAgICAgICBlbnRyeS5wcmlvcml0eSA9IFRhc2suY29udmVydFN0cmluZ1RvUHJpb3JpdHkodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVzY3JpcHRpb24nOlxuICAgICAgICAgICAgZW50cnkuZGVzY3JpcHRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Byb2plY3QgdXVpZCc6XG4gICAgICAgICAgY2FzZSAncHJvamVjdC11dWlkJzpcbiAgICAgICAgICAgIGVudHJ5LnByb2plY3QgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2UgaW50ZXJ2YWwgdW5pdCc6XG4gICAgICAgICAgY2FzZSAncmVjdXJyZW5jZS1pbnRlcnZhbC11bml0JzpcbiAgICAgICAgICAgIHJlY3VycmluZ0RhdGUuaW50ZXJ2YWxVbml0ID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2UgaW50ZXJ2YWwgbGVuZ3RoJzpcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlLWludGVydmFsLWxlbmd0aCc6XG4gICAgICAgICAgICByZWN1cnJpbmdEYXRlLmludGVydmFsTGVuZ3RoID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2Ugc3RhcnQgZGF0ZSc6XG4gICAgICAgICAgY2FzZSAncmVjdXJyZW5jZS1zdGFydC1kYXRlJzpcbiAgICAgICAgICAgIHJlY3VycmluZ0RhdGUuc3RhcnREYXRlID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlIGJhc2VkIG9uIGNvbXBsZXRpb24/JzpcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlIGJhc2VkIG9uIGNvbXBsZXRpb24nOlxuICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2UtYmFzZWQtb24tY29tcGxldGlvbic6XG4gICAgICAgICAgICByZWN1cnJpbmdEYXRlLmJhc2VPbkNvbXBsZXRpb24gPSB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlIHdlZWsgbnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlLXdlZWstbnVtYmVyJzpcbiAgICAgICAgICAgIHJlY3VycmluZ0RhdGUud2Vla051bWJlciA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlIHdlZWsgZGF5cyc6XG4gICAgICAgICAgY2FzZSAncmVjdXJyZW5jZS13ZWVrLWRheXMnOlxuICAgICAgICAgICAgcmVjdXJyaW5nRGF0ZS5kYXlzT2ZXZWVrID0gdmFsdWUuc3BsaXQoJywnKS5tYXAoKGRheSkgPT4gKFxuICAgICAgICAgICAgICBnZXRXZWVrZGF5SW5kZXgoZGF5LnRyaW0oKSlcbiAgICAgICAgICAgICkpLmZpbHRlcigoZGF5KSA9PiBkYXkgIT0gbnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlIG1vbnRoJzpcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlLW1vbnRoJzpcbiAgICAgICAgICAgIHJlY3VycmluZ0RhdGUubW9udGggPSBnZXRNb250aEluZGV4KHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2UgZGF5JzpcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlLWRheSc6XG4gICAgICAgICAgICByZWN1cnJpbmdEYXRlLmRheU9mTW9udGggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmVjdXJyZW5jZSB3ZWVrZW5kIGJlaGF2aW9yJzpcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlLXdlZWtlbmQtYmVoYXZpb3InOiB7XG4gICAgICAgICAgICBsZXQgYmVoYXZpb3IgPSBudWxsO1xuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ25vIGNoYW5nZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ25vLWNoYW5nZSc6XG4gICAgICAgICAgICAgICAgYmVoYXZpb3IgPSAnbm8tY2hhbmdlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAndXNlIHByZXZpb3VzIHdlZWtkYXknOlxuICAgICAgICAgICAgICBjYXNlICdwcmV2aW91cyB3ZWVrZGF5JzpcbiAgICAgICAgICAgICAgY2FzZSAncHJldmlvdXMtd2Vla2RheSc6XG4gICAgICAgICAgICAgICAgYmVoYXZpb3IgPSAncHJldmlvdXMtd2Vla2RheSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3VzZSBuZXh0IHdlZWtkYXknOlxuICAgICAgICAgICAgICBjYXNlICduZXh0IHdlZWtkYXknOlxuICAgICAgICAgICAgICBjYXNlICduZXh0LXdlZWtkYXknOlxuICAgICAgICAgICAgICAgIGJlaGF2aW9yID0gJ25leHQtd2Vla2RheSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3VzZSBuZWFyZXN0IHdlZWtkYXknOlxuICAgICAgICAgICAgICBjYXNlICduZWFyZXN0IHdlZWtkYXknOlxuICAgICAgICAgICAgICBjYXNlICduZWFyZXN0LXdlZWtkYXknOlxuICAgICAgICAgICAgICAgIGJlaGF2aW9yID0gJ25lYXJlc3Qtd2Vla2RheSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWN1cnJpbmdEYXRlLm9uV2Vla2VuZCA9IGJlaGF2aW9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2UgZW5kIGRhdGUnOlxuICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2UtZW5kLWRhdGUnOlxuICAgICAgICAgICAgcmVjdXJyaW5nRGF0ZS5lbmREYXRlID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlIG1heCBjb3VudCc6XG4gICAgICAgICAgY2FzZSAncmVjdXJyZW5jZS1tYXgtY291bnQnOlxuICAgICAgICAgICAgcmVjdXJyaW5nRGF0ZS5tYXhDb3VudCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFfLmlzRW1wdHkocmVjdXJyaW5nRGF0ZSkpIGVudHJ5LnJlY3VycmluZ0RhdGUgPSByZWN1cnJpbmdEYXRlO1xuICAgICAgaWYgKCFfLmlzRW1wdHkoZW50cnkpKSBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuaW1wb3J0RnJvbUpzb24oZW50cmllcywgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFza0xpc3Q7XG4iLCIvKipcbiAqIERlZmluZXMgZnVuY3Rpb25zIGZvciBtYW5pcHVsYXRpbmcgZGF0YS5cbiAqIEBtb2R1bGUgZGF0YVxuICovXG5cbmltcG9ydCB7XG4gIHZhbGlkYXRlIGFzIHZhbGlkYXRlVXVpZCxcbiAgdmVyc2lvbiBhcyB1dWlkVmVyc2lvbixcbn0gZnJvbSAndXVpZCc7XG5cbmltcG9ydCB7IGlzRGF0ZVZhbGlkLCBwYXJzZUlzb0RhdGVUaW1lIH0gZnJvbSAnLi9kYXRlcyc7XG5cbi8qKlxuICogQWRkIGEgdmFsdWUgdG8gYW4gYXJyYXkgYmVsb25naW5nIHRvIGEgTWFwIGhhdmluZyBhcnJheSB2YWx1ZXMuIElmIHRoZSBnaXZlblxuICoga2V5IGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAsIHRoZW4gYSBuZXcgYXJyYXkgd2lsbCBiZSBpbnNlcnRlZCBhdCB0aGF0XG4gKiBrZXkuXG4gKiBAcGFyYW0ge01hcH0gbWFwIFRoZSBtYXAgb2YgYXJyYXlzLlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgaXMgdG9cbiAqICAgYmUgaW5zZXJ0ZWQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNlcnQgaW50byB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFkZFRvTWFwQXJyYXkobWFwLCBrZXksIHZhbHVlKSB7XG4gIGxldCBhcnIgPSBtYXAuZ2V0KGtleSk7XG4gIGlmICghYXJyKSB7XG4gICAgYXJyID0gW107XG4gICAgbWFwLnNldChrZXksIGFycik7XG4gIH1cbiAgYXJyLnB1c2godmFsdWUpO1xufVxuXG4vKipcbiAqIEZpbmQgYSB2YWx1ZSBpbiBhbiBhcnJheSBiZWxvbmdpbmcgdG8gYSBNYXAgaGF2aW5nIGFycmF5IHZhbHVlcy4gVGhlIGZpcnN0XG4gKiB2YWx1ZSBpbiB0aGUgYXBwcm9wcmlhdGUgYXJyYXkgZm9yIHdoaWNoIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGlzXG4gKiByZXR1cm5lZC5cbiAqIEBwYXJhbSB7TWFwfSBtYXAgVGhlIG1hcCBvZiBhcnJheXMuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGFycmF5IGluIHdoaWNoIHRoZSBlbGVtZW50IGlzIHRvXG4gKiAgIGJlIGZvdW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZmluZFxuICogICB0aGUgYXJyYXkgZWxlbWVudC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZVxuICogICBhcnJheSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS4gV2hlbiBpbnZva2VkLCB0aGUgZnVuY3Rpb24gd2lsbCBiZVxuICogICBwYXNzZWQgdGhlIGFycmF5IGVsZW1lbnQsIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgYXJyYXksIGFuZCB0aGVcbiAqICAgYXJyYXkgaXRzZWxmLCBpbiB0aGF0IG9yZGVyLCBhcyBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHsqfSBUaGUgbWF0Y2hpbmcgdmFsdWUsIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbk1hcEFycmF5KG1hcCwga2V5LCBwcmVkaWNhdGUpIHtcbiAgY29uc3QgYXJyID0gbWFwLmdldChrZXkpO1xuICBpZiAoIWFycikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIGFyci5maW5kKHByZWRpY2F0ZSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgdmFsdWUgZnJvbSBhbiBhcnJheSBiZWxvbmdpbmcgdG8gYSBNYXAgaGF2aW5nIGFycmF5IHZhbHVlcy4gVGhpc1xuICogZnVuY3Rpb24gaXMgc2ltaWxhciB0b1xuICogW3JlbW92ZUZyb21NYXBBcnJheV17QGxpbmsgbW9kdWxlOmRhdGF+cmVtb3ZlRnJvbU1hcEFycmF5fSwgZXhjZXB0IHRoYXQgaXRcbiAqIHRha2VzIGEgcHJlZGljYXRlIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSB2YWx1ZS4gVGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheVxuICogZm9yIHdoaWNoIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGlzIHJlbW92ZWQuXG4gKiBAcGFyYW0ge01hcH0gbWFwIFRoZSBtYXAgb2YgYXJyYXlzLlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBhcnJheSBmcm9tIHdoaWNoIHRoZSB2YWx1ZSBpcyB0b1xuICogICBiZSByZW1vdmVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZmluZFxuICogICBhIG1hdGNoaW5nIGFycmF5IGVsZW1lbnQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpblxuICogICB0aGUgYXJyYXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuIFdoZW4gaW52b2tlZCwgdGhlIGZ1bmN0aW9uIHdpbGxcbiAqICAgYmUgcGFzc2VkIHRoZSBhcnJheSBlbGVtZW50LCB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGFycmF5LCBhbmRcbiAqICAgdGhlIGFycmF5IGl0c2VsZiwgaW4gdGhhdCBvcmRlciwgYXMgYXJndW1lbnRzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhIHZhbHVlIHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZCwgb3JcbiAqICAgZmFsc2UgaWYgYSBtYXRjaGluZyBhcnJheSBlbGVtZW50IGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRnJvbU1hcEFycmF5QnkobWFwLCBrZXksIHByZWRpY2F0ZSkge1xuICBjb25zdCBhcnIgPSBtYXAuZ2V0KGtleSk7XG4gIGlmICghYXJyKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3QgaW5kZXggPSBhcnIuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIGlmIChpbmRleCA8IDApIHJldHVybiBmYWxzZTtcblxuICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIG1hcC5kZWxldGUoa2V5KTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgdmFsdWUgZnJvbSBhbiBhcnJheSBiZWxvbmdpbmcgdG8gYSBNYXAgaGF2aW5nIGFycmF5IHZhbHVlcy5cbiAqIEBwYXJhbSB7TWFwfSBtYXAgVGhlIG1hcCBvZiBhcnJheXMuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGFycmF5IGZyb20gd2hpY2ggdGhlIHZhbHVlIGlzIHRvXG4gKiAgIGJlIHJlbW92ZWQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZW1vdmUgZnJvbSB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQsIG9yXG4gKiAgIGZhbHNlIGlmIGEgbWF0Y2hpbmcgYXJyYXkgZWxlbWVudCBjb3VsZCBub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUZyb21NYXBBcnJheShtYXAsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHJlbW92ZUZyb21NYXBBcnJheUJ5KG1hcCwga2V5LCAoZWxlbSkgPT4gZWxlbSA9PT0gdmFsdWUpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiBhIEpTT04gdmFsdWU6ICdvYmplY3QnLCAnYXJyYXknLCAnc3RyaW5nJywgJ251bWJlcicsXG4gKiAnYm9vbGVhbicsIG9yICdudWxsJy4gVHlwZXMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBpbiBKU09OLCBzdWNoIGFzXG4gKiBmdW5jdGlvbnMgb3IgdW5kZWZpbmVkLCB3aWxsIHJldHVybiAnbnVsbCcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB3aG9zZSB0eXBlIGlzIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUncyB0eXBlLlxuICovXG5mdW5jdGlvbiBnZXRKc29uVHlwZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gJ2FycmF5JyA6ICdvYmplY3QnO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnbnVsbCc7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIHN0cmluZyBpcyBhIHZhbGlkIHZlcnNpb24gNCBVVUlELlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBVVUlEIGlzIHZhbGlkLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1V1aWRWYWxpZChpZCkge1xuICByZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiB2YWxpZGF0ZVV1aWQoaWQpICYmIHV1aWRWZXJzaW9uKGlkKSA9PT0gNDtcbn1cblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqIEBjYWxsYmFjayBtb2R1bGU6ZGF0YX52YWxpZGF0aW9uU3VjY2Vzc1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCBwYXNzZWQgdmFsaWRhdGlvbi4gSWYgdGhlIGFsbG93Q29udmVyc2lvblxuICogICBvcHRpb24gd2FzIHNldCwgdGhlbiB0aGlzIHdpbGwgYmUgdGhlIGNvbnZlcnRlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBzcGVjaWZ5aW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFsdWVOYW1lXSBUaGUgbmFtZSBmb3IgdGhlIGRhdGEgZmllbGQgdGhhdCB0aGVcbiAqICAgdmFsdWUgY29ycmVzcG9uZHMgdG8uXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSB2YWx1ZSBmYWlscyB2YWxpZGF0aW9uLlxuICogQGNhbGxiYWNrIG1vZHVsZTpkYXRhfnZhbGlkYXRpb25FcnJvclxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yVHlwZSBBIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSB0eXBlIG9mIGVycm9yIHRoYXRcbiAqICAgb2NjdXJyZWQ6ICdiYWQtdHlwZScgaW5kaWNhdGVzIGEgdHlwZSBlcnJvciwgJ3Vua25vd24tdmFsdWUnIGluZGljYXRlcyBhblxuICogICB1bnJlY29nbml6ZWQgdmFsdWUsICdub3QtaW50ZWdlcicgaW5kaWNhdGVzIGEgdmFsdWUgdGhhdCBpcyBub3QgYW5cbiAqICAgaW50ZWdlciwgJ3Rvby1sb3cnIGluZGljYXRlcyBhIHZhbHVlIGJlbG93IHRoZSBtaW5pbXVtLCAndG9vLWhpZ2gnXG4gKiAgIGluZGljYXRlcyBhIHZhbHVlIGFib3ZlIHRoZSBtYXhpbXVtLCAnYmFkLWRhdGUnIGluZGljYXRlcyBhbiBpbnZhbGlkIGRhdGUsXG4gKiAgICdiYWQtaWQnIGluZGljYXRlcyBhbiBpbnZhbGlkIFVVSUQsIGFuZCAnZmFpbGVkLXByZWRpY2F0ZScgaW5kaWNhdGVzIHRoYXRcbiAqICAgdGhlIHZhbHVlIHdhcyByZWplY3RlZCBieSB0aGUgY3VzdG9tIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgY3JpdGVyaWEgdGhhdCB3ZXJlIHVzZWQgdG9cbiAqICAgdmFsaWRhdGUgdGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhbHVlTmFtZV0gVGhlIG5hbWUgZm9yIHRoZSBkYXRhIGZpZWxkIHRoYXQgdGhlXG4gKiAgIHZhbHVlIGNvcnJlc3BvbmRzIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmV4cGVjdGVkVHlwZV0gVGhlIGV4cGVjdGVkIHR5cGUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd0NvbnZlcnNpb25dIEluZGljYXRlcyB3aGV0aGVyIGNvbnZlcnNpb24gZnJvbVxuICogICBzdHJpbmcgd2FzIGFsbG93ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5leHBlY3RlZFZhbHVlc10gQW4gYXJyYXkgb2YgYWNjZXB0YWJsZSBzdHJpbmdzXG4gKiAgIHRoYXQgdGhlIHZhbHVlIHNob3VsZCBoYXZlIG1hdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlcXVpcmVVdWlkXSBJbmRpY2F0ZXMgd2hldGhlciBhIFVVSUQgd2FzXG4gKiAgIHJlcXVpcmVkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXF1aXJlSW50ZWdlcl0gSW5kaWNhdGVzIHdoZXRoZXIgYW4gaW50ZWdlciB3YXNcbiAqICAgcmVxdWlyZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluXSBUaGUgbWluaW11bSBhY2NlcHRhYmxlIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heF0gVGhlIG1heGltdW0gYWNjZXB0YWJsZSB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmN1c3RvbVByZWRpY2F0ZV0gVGhlIGN1c3RvbSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAqICAgdGhhdCB3YXMgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCBzcGVjaWZ5aW5nIG9wdGlvbnMgZm9yIHZhbGlkYXRpbmcgYSB2YWx1ZS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpkYXRhfnZhbGlkYXRpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3ZhbHVlTmFtZV0gQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIGRhdGEgZmllbGQgdGhhdCB0aGVcbiAqICAgdmFsdWUgaXMgcmVhZCBmcm9tIG9yIGJlaW5nIGFzc2lnbmVkIHRvLiBUaGlzIGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAqICAgZnVuY3Rpb25zIGJ1dCBpcyBvdGhlcndpc2UgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXhwZWN0ZWRUeXBlXSBUaGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBzaG91bGQgaGF2ZS4gVGhpc1xuICogICBjYW4gYmUgb25lIG9mICdvYmplY3QnLCAnYXJyYXknLCAnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJywgJ251bGwnLCBvclxuICogICAnZGF0ZScuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbGxvd0NvbnZlcnNpb249ZmFsc2VdIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBpblxuICogICBjb25qdW5jdGlvbiB3aXRoIGV4cGVjdGVkVHlwZS4gSWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgdmFsdWUgaXNcbiAqICAgYWxsb3dlZCB0byBoYXZlIHN0cmluZyB0eXBlIGFzIGxvbmcgYXMgaXQgY2FuIGJlIGNvbnZlcnRlZCB0byB0aGUgZXhwZWN0ZWRcbiAqICAgdHlwZS4gT2JqZWN0cyBhbmQgYXJyYXlzIGNhbm5vdCBiZSBjb252ZXJ0ZWQgZnJvbSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbZXhwZWN0ZWRWYWx1ZXNdIEZvciBzdHJpbmcgdmFsdWVzLCB0aGlzIHByb3BlcnR5XG4gKiAgIHNwZWNpZmllcyBhbiBvcHRpb25hbCBsaXN0IG9mIGFjY2VwdGFibGUgdmFsdWVzLiBWYWx1ZXMgdGhhdCBkbyBtYXRjaCBhblxuICogICBpdGVtIGluIHRoZSBnaXZlbiBhcnJheSB3aWxsIGZhaWwgdmFsaWRhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVVdWlkPWZhbHNlXSBGb3Igc3RyaW5nIHZhbHVlcywgaWYgdGhpcyBwcm9wZXJ0eVxuICogICBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgc3RyaW5nIG11c3QgY29udGFpbiBhIFVVSUQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlSW50ZWdlcj1mYWxzZV0gRm9yIHZhbHVlcyBvZiBudW1iZXIgdHlwZSwgaWZcbiAqICAgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgbnVtYmVyIG11c3QgYmUgYW4gaW50ZWdlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluXSBGb3IgbnVtZXJpYyB2YWx1ZXMsIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIHRoZVxuICogICBtaW5pbXVtIGFjY2VwdGFibGUgdmFsdWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heF0gRm9yIG51bWVyaWMgdmFsdWVzLCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyB0aGVcbiAqICAgbWF4aW11bSBhY2NlcHRhYmxlIHZhbHVlLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2N1c3RvbVByZWRpY2F0ZV0gQSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBjYW4gcGVyZm9ybVxuICogICBjdXN0b20gdmFsaWRhdGlvbi4gSWYgdGhlIHZhbHVlIHBhc3NlcyBhbGwgb3RoZXIgY29uc3RyYWludHMsIHRoZW4gaXQgaXNcbiAqICAgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRydWUgb3IgZmFsc2UgdG9cbiAqICAgaW5kaWNhdGUgd2hldGhlciB0aGUgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKiBAcHJvcGVydHkge21vZHVsZTpkYXRhfnZhbGlkYXRpb25TdWNjZXNzfSBbc3VjY2Vzc0NhbGxiYWNrXSBBIGNhbGxiYWNrXG4gKiAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIGlmIHRoZSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmRhdGF+dmFsaWRhdGlvbkVycm9yfSBbZXJyb3JDYWxsYmFja10gQSBjYWxsYmFja1xuICogICBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCBpZiB0aGUgdmFsdWUgZmFpbHMgdmFsaWRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWNjb3JkaW5nIHRvIGEgc2V0IG9mIGNyaXRlcmlhLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge21vZHVsZTpkYXRhfnZhbGlkYXRpb25PcHRpb25zfSBbb3B0aW9ucz17fV0gQW4gb2JqZWN0IHNwZWNpZnlpbmdcbiAqICAgdmFsaWRhdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZmFpbCA9IChlcnJvclR5cGUpID0+IHtcbiAgICBvcHRpb25zLmVycm9yQ2FsbGJhY2s/LihlcnJvclR5cGUsIHZhbHVlLCB7XG4gICAgICB2YWx1ZU5hbWU6IG9wdGlvbnMudmFsdWVOYW1lID8/IG51bGwsXG4gICAgICBleHBlY3RlZFR5cGU6IG9wdGlvbnMuZXhwZWN0ZWRUeXBlID8/IG51bGwsXG4gICAgICBhbGxvd0NvbnZlcnNpb246IG9wdGlvbnMuYWxsb3dDb252ZXJzaW9uIHx8IGZhbHNlLFxuICAgICAgZXhwZWN0ZWRWYWx1ZXM6IG9wdGlvbnMuZXhwZWN0ZWRWYWx1ZXMgfHwgbnVsbCxcbiAgICAgIHJlcXVpcmVVdWlkOiBvcHRpb25zLnJlcXVpcmVVdWlkIHx8IGZhbHNlLFxuICAgICAgcmVxdWlyZUludGVnZXI6IG9wdGlvbnMucmVxdWlyZUludGVnZXIgfHwgZmFsc2UsXG4gICAgICBtaW46IG9wdGlvbnMubWluID8/IG51bGwsXG4gICAgICBtYXg6IG9wdGlvbnMubWF4ID8/IG51bGwsXG4gICAgICBjdXN0b21QcmVkaWNhdGU6IG9wdGlvbnMuY3VzdG9tUHJlZGljYXRlIHx8IG51bGwsXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgYWxsb3dDb252ZXJzaW9uID0gb3B0aW9ucy5hbGxvd0NvbnZlcnNpb24gfHwgZmFsc2U7XG4gIGxldCBjb252ZXJ0ZWRWYWx1ZSA9IHZhbHVlO1xuICBpZiAob3B0aW9ucy5leHBlY3RlZFR5cGUpIHtcbiAgICBpZiAob3B0aW9ucy5leHBlY3RlZFR5cGUgIT09ICdudWxsJyAmJiB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBmYWlsKCdiYWQtdHlwZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3B0aW9ucy5leHBlY3RlZFR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZmFpbCgnYmFkLXR5cGUnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGlmICghYWxsb3dDb252ZXJzaW9uIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZhaWwoJ2JhZC10eXBlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnZlcnRlZFZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGNvbnZlcnRlZFZhbHVlKSkge1xuICAgICAgICAgIGZhaWwoJ2JhZC10eXBlJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIGlmICghYWxsb3dDb252ZXJzaW9uIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZhaWwoJ2JhZC10eXBlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoICh2YWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBmYWlsKCdiYWQtdHlwZScpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgZmFpbCgnYmFkLXR5cGUnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgIGlmICghYWxsb3dDb252ZXJzaW9uIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZhaWwoJ2JhZC10eXBlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnZlcnRlZFZhbHVlID0gcGFyc2VJc29EYXRlVGltZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRGF0ZVZhbGlkKGNvbnZlcnRlZFZhbHVlKSkge1xuICAgICAgICAgIGZhaWwoJ2JhZC1kYXRlJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGdldEpzb25UeXBlKHZhbHVlKSAhPT0gb3B0aW9ucy5leHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICBmYWlsKCdiYWQtdHlwZScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnZlcnRlZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChvcHRpb25zLmV4cGVjdGVkVmFsdWVzXG4gICAgICAmJiAhb3B0aW9ucy5leHBlY3RlZFZhbHVlcy5pbmNsdWRlcyhjb252ZXJ0ZWRWYWx1ZSkpIHtcbiAgICAgIGZhaWwoJ3Vua25vd24tdmFsdWUnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlVXVpZCAmJiAhaXNVdWlkVmFsaWQoY29udmVydGVkVmFsdWUpKSB7XG4gICAgICBmYWlsKCdiYWQtaWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnZlcnRlZFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmIChvcHRpb25zLnJlcXVpcmVJbnRlZ2VyICYmICFOdW1iZXIuaXNJbnRlZ2VyKGNvbnZlcnRlZFZhbHVlKSkge1xuICAgICAgZmFpbCgnbm90LWludGVnZXInKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5taW4gIT0gbnVsbCAmJiBjb252ZXJ0ZWRWYWx1ZSA8IG9wdGlvbnMubWluKSB7XG4gICAgICBmYWlsKCd0b28tbG93Jyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWF4ICE9IG51bGwgJiYgY29udmVydGVkVmFsdWUgPiBvcHRpb25zLm1heCkge1xuICAgICAgZmFpbCgndG9vLWhpZ2gnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jdXN0b21QcmVkaWNhdGUpIHtcbiAgICBpZiAoIW9wdGlvbnMuY3VzdG9tUHJlZGljYXRlKGNvbnZlcnRlZFZhbHVlKSkge1xuICAgICAgZmFpbCgnZmFpbGVkLXByZWRpY2F0ZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMuc3VjY2Vzc0NhbGxiYWNrPy4oY29udmVydGVkVmFsdWUsIHtcbiAgICB2YWx1ZU5hbWU6IG9wdGlvbnMudmFsdWVOYW1lID8/IG51bGwsXG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHtcbiAgYWRkVG9NYXBBcnJheSxcbiAgZmluZEluTWFwQXJyYXksXG4gIGdldEpzb25UeXBlLFxuICBpc1V1aWRWYWxpZCxcbiAgcmVtb3ZlRnJvbU1hcEFycmF5LFxuICByZW1vdmVGcm9tTWFwQXJyYXlCeSxcbiAgdmFsaWRhdGVWYWx1ZSxcbn07XG4iLCIvKipcbiAqIERlZmluZXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGRhdGVzIGFuZCB0aW1lcy5cbiAqIEBtb2R1bGUgZGF0ZXNcbiAqL1xuXG5pbXBvcnQge1xuICBmb3JtYXQgYXMgZGZGb3JtYXQsXG4gIGZvcm1hdElTTyxcbiAgaXNWYWxpZCxcbiAgcGFyc2UgYXMgZGZQYXJzZSxcbiAgcGFyc2VJU08sXG59IGZyb20gJ2RhdGUtZm5zJztcblxuY29uc3QgV0VFS0RBWVMgPSBbXG4gICdTdW5kYXknLFxuICAnTW9uZGF5JyxcbiAgJ1R1ZXNkYXknLFxuICAnV2VkbmVzZGF5JyxcbiAgJ1RodXJzZGF5JyxcbiAgJ0ZyaWRheScsXG4gICdTYXR1cmRheScsXG5dO1xuY29uc3QgTU9OVEhTID0gW1xuICB7IG5hbWU6ICdKYW51YXJ5JywgbWF4RGF5czogMzEgfSxcbiAgeyBuYW1lOiAnRmVicnVhcnknLCBtYXhEYXlzOiAyOSB9LFxuICB7IG5hbWU6ICdNYXJjaCcsIG1heERheXM6IDMxIH0sXG4gIHsgbmFtZTogJ0FwcmlsJywgbWF4RGF5czogMzAgfSxcbiAgeyBuYW1lOiAnTWF5JywgbWF4RGF5czogMzEgfSxcbiAgeyBuYW1lOiAnSnVuZScsIG1heERheXM6IDMwIH0sXG4gIHsgbmFtZTogJ0p1bHknLCBtYXhEYXlzOiAzMSB9LFxuICB7IG5hbWU6ICdBdWd1c3QnLCBtYXhEYXlzOiAzMSB9LFxuICB7IG5hbWU6ICdTZXB0ZW1iZXInLCBtYXhEYXlzOiAzMCB9LFxuICB7IG5hbWU6ICdPY3RvYmVyJywgbWF4RGF5czogMzEgfSxcbiAgeyBuYW1lOiAnTm92ZW1iZXInLCBtYXhEYXlzOiAzMCB9LFxuICB7IG5hbWU6ICdEZWNlbWJlcicsIG1heERheXM6IDMxIH0sXG5dO1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBkYXRlIGZvcm1hdCBmb3IgYSBnaXZlbiBsb2NhbGUsIG9yIGZvciB0aGUgZGVmYXVsdCBsb2NhbGUuXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGZvcm1hdCBzdHJpbmcgZm9yIGVuLVVTIHNob3VsZCBsb29rIGxpa2UgTS9kL3l5LlxuICogQHBhcmFtIHtzdHJpbmd9IFtsb2NhbGVdIFRoZSBsb2NhbGUgd2hvc2UgZGF0ZSBmb3JtYXQgaXMgdG8gYmUgcmV0cmlldmVkLlxuICogICBJZiBub3QgZ2l2ZW4sIHRoZW4gdGhlIGJyb3dzZXIncyBkZWZhdWx0IGxvY2FsZSBpcyB1c2VkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3Qgd2l0aCBmb3JtYXR0aW5nIG9wdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGF0ZVN0eWxlPXNob3J0XSBUaGUgZGF0ZSBmb3JtYXR0aW5nIHN0eWxlOlxuICogICAnc2hvcnQnLCAnbWVkaXVtJywgJ2xvbmcnLCAnZnVsbCcsIG9yICdub25lJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aW1lU3R5bGU9bm9uZV0gVGhlIHRpbWUgZm9ybWF0dGluZyBzdHlsZTogJ3Nob3J0JyxcbiAqICAgJ21lZGl1bScsICdsb25nJywgJ2Z1bGwnLCBvciAnbm9uZScuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9rZW5TdHlsZT1pbnRlcm5hbF0gVGhlIHR5cGUgb2YgZm9ybWF0IHRva2VucyB0b1xuICogICB1c2UuIFZhbGlkIHZhbHVlcyBhcmUgJ2ludGVybmFsJyBhbmQgJ3Zpc3VhbCcuIElmIHNldCB0byAnaW50ZXJuYWwnICh0aGVcbiAqICAgZGVmYXVsdCksIHRoZW4gdGhlIGZ1bmN0aW9uIHVzZXMgdGhlIHNhbWUgZm9ybWF0IHRva2VucyB0aGF0IHRoZVxuICogICBbZGF0ZS1mbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL30gbGlicmFyeSB1c2VzLiBJZiBzZXQgdG8gJ3Zpc3VhbCcsXG4gKiAgIHRoZW4gbW9yZSBodW1hbi1yZWFkYWJsZSB0b2tlbnMgYXJlIHVzZWQ6IGZvciBleGFtcGxlLCBhIGh1bWFuLXJlYWRhYmxlXG4gKiAgIGZvcm1hdCBzdHJpbmcgbWlnaHQgbG9vayBsaWtlICdZWVlZLU1NLUREIGhoOm1tOnNzJyBvclxuICogICAnTU0vREQvWVlZWSBoaDptbSBhJy5cbiAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtvcHRpb25zLmZ1bGxZZWFyPWF1dG9dIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0b1xuICogICB1c2UgYSBmdWxsIGZvdXItZGlnaXQgeWVhciBpbnN0ZWFkIG9mIGEgdHdvLWRpZ2l0IGFiYnJldmlhdGlvbi4gSWYgc2V0IHRvXG4gKiAgICdhdXRvJywgdGhlbiB0aGUgbG9jYWwgZGVmYXVsdCBpcyB1c2VkLlxuICogQHBhcmFtIHtib29sZWFufHN0cmluZ30gW29wdGlvbnMucGFkTW9udGhzPWF1dG9dIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0b1xuICogICBwYWQgc2luZ2xlLWRpZ2l0IG1vbnRocyB3aXRoIGEgbGVhZGluZyB6ZXJvLiBJZiBzZXQgdG8gJ2F1dG8nLCB0aGVuIHRoZVxuICogICBsb2NhbCBkZWZhdWx0IGlzIHVzZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbb3B0aW9ucy5wYWREYXlzPWF1dG9dIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0b1xuICogICBwYWQgc2luZ2xlLWRpZ2l0IGRheXMgd2l0aCBhIGxlYWRpbmcgemVyby4gSWYgc2V0IHRvICdhdXRvJywgdGhlbiB0aGVcbiAqICAgbG9jYWwgZGVmYXVsdCBpcyB1c2VkLlxuICogQHBhcmFtIHtib29sZWFufHN0cmluZ30gW29wdGlvbnMucGFkSG91cnM9YXV0b10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvXG4gKiAgIHBhZCBzaW5nbGUtZGlnaXQgaG91cnMgd2l0aCBhIGxlYWRpbmcgemVyby4gSWYgc2V0IHRvICdhdXRvJywgdGhlbiB0aGVcbiAqICAgbG9jYWwgZGVmYXVsdCBpcyB1c2VkLlxuICogQHBhcmFtIHtib29sZWFufHN0cmluZ30gW29wdGlvbnMucGFkTWludXRlcz1hdXRvXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3RcbiAqICAgdG8gcGFkIHNpbmdsZS1kaWdpdCBtaW51dGVzIHdpdGggYSBsZWFkaW5nIHplcm8uIElmIHNldCB0byAnYXV0bycsIHRoZW5cbiAqICAgdGhlIGxvY2FsIGRlZmF1bHQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtvcHRpb25zLnBhZFNlY29uZHM9YXV0b10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90XG4gKiAgIHRvIHBhZCBzaW5nbGUtZGlnaXQgc2Vjb25kcyB3aXRoIGEgbGVhZGluZyB6ZXJvLiBJZiBzZXQgdG8gJ2F1dG8nLCB0aGVuXG4gKiAgIHRoZSBsb2NhbCBkZWZhdWx0IGlzIHVzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLmhvdXJTeXN0ZW09YXV0b10gSW5kaWNhdGVzIHdoZXRoZXIgdG8gdXNlIGFcbiAqICAgMTItIG9yIDI0LWhvdXIgY2xvY2suIFZhbGlkIHZhbHVlcyBhcmUgMTIgZm9yIGEgMTItaG91ciBjbG9jaywgMjQgZm9yIGFcbiAqICAgMjQtaG91ciBjbG9jaywgb3IgdGhlIHN0cmluZyAnYXV0bycgdG8gdXNlIHRoZSBsb2NhbCBkZWZhdWx0LlxuICogQHJldHVybnMgVGhlIGRhdGUgZm9ybWF0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0ZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBSRUZFUkVOQ0VfREFURSA9IG5ldyBEYXRlKDIwMjAsIDAsIDEsIDE0LCA1LCA1KTtcblxuICBjb25zdCBmb3JtYXR0ZXJPcHRpb25zID0ge307XG4gIGNvbnN0IGRhdGVTdHlsZSA9IG9wdGlvbnMuZGF0ZVN0eWxlIHx8ICdzaG9ydCc7XG4gIGNvbnN0IHRpbWVTdHlsZSA9IG9wdGlvbnMudGltZVN0eWxlIHx8ICdub25lJztcbiAgaWYgKGRhdGVTdHlsZSAhPT0gJ25vbmUnKSB7XG4gICAgZm9ybWF0dGVyT3B0aW9ucy5kYXRlU3R5bGUgPSBkYXRlU3R5bGU7XG4gIH1cbiAgaWYgKHRpbWVTdHlsZSAhPT0gJ25vbmUnKSB7XG4gICAgZm9ybWF0dGVyT3B0aW9ucy50aW1lU3R5bGUgPSB0aW1lU3R5bGU7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaG91clN5c3RlbSAmJiBvcHRpb25zLmhvdXJTeXN0ZW0gIT09ICdhdXRvJykge1xuICAgIGZvcm1hdHRlck9wdGlvbnMuaG91cjEyID0gb3B0aW9ucy5ob3VyU3lzdGVtID09PSAxMjtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSB8fCBbXSwgZm9ybWF0dGVyT3B0aW9ucyk7XG5cbiAgbGV0IHBhcnRzO1xuXG4gIC8vIEZhbGxiYWNrIGlmIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGZvcm1hdFRvUGFydHMgLSB1c2UgZW4tVVNcbiAgaWYgKCEoJ2Zvcm1hdFRvUGFydHMnIGluIGZvcm1hdHRlcikpIHtcbiAgICBjb25zdCBkYXRlUGFydHMgPSBbXG4gICAgICB7IHR5cGU6ICdtb250aCcsIHZhbHVlOiAnMScgfSxcbiAgICAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAgICB7IHR5cGU6ICdkYXknLCB2YWx1ZTogJzEnIH0sXG4gICAgICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgICAgeyB0eXBlOiAneWVhcicsIHZhbHVlOiAnMjAnIH0sXG4gICAgXTtcblxuICAgIGxldCB0aW1lUGFydHMgPSBbXG4gICAgICB7IHR5cGU6ICdob3VyJywgdmFsdWU6ICcyJyB9LFxuICAgICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnOicgfSxcbiAgICAgIHsgdHlwZTogJ21pbnV0ZScsIHZhbHVlOiAnMDUnIH0sXG4gICAgXTtcblxuICAgIGlmIChmb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCkuaG91cjEyKSB7XG4gICAgICB0aW1lUGFydHMgPSB0aW1lUGFydHMuY29uY2F0KFtcbiAgICAgICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnICcgfSxcbiAgICAgICAgeyB0eXBlOiAnZGF5UGVyaW9kJywgdmFsdWU6ICdhbScgfSxcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc0RhdGUgPSBkYXRlU3R5bGUgIT09ICdub25lJztcbiAgICBjb25zdCBoYXNUaW1lID0gdGltZVN0eWxlICE9PSAnbm9uZSc7XG4gICAgaWYgKGhhc0RhdGUgJiYgaGFzVGltZSkge1xuICAgICAgcGFydHMgPSBbXG4gICAgICAgIC4uLmRhdGVQYXJ0cyxcbiAgICAgICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnICcgfSxcbiAgICAgICAgLi4udGltZVBhcnRzLFxuICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKGhhc1RpbWUpIHtcbiAgICAgIHBhcnRzID0gdGltZVBhcnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cyA9IGRhdGVQYXJ0cztcbiAgICB9XG4gIH0gZWxzZSB7IC8vIEJyb3dzZXIgc3VwcG9ydHMgZm9ybWF0VG9QYXJ0c1xuICAgIHBhcnRzID0gZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoUkVGRVJFTkNFX0RBVEUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzLm1hcCgoeyB0eXBlLCB2YWx1ZSB9KSA9PiB7XG4gICAgbGV0IHRva2VuID0gJyc7XG4gICAgbGV0IGNvdW50ID0gMTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICBpZiAob3B0aW9ucy50b2tlblN0eWxlICE9PSAndmlzdWFsJyAmJiAvW0EtWmEtel0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgdG9rZW4gPSBgJyR7dmFsdWUucmVwbGFjZSgvJy9nLCBcIicnXCIpfSdgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2VuID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXknOlxuICAgICAgICB0b2tlbiA9IG9wdGlvbnMudG9rZW5TdHlsZSA9PT0gJ3Zpc3VhbCcgPyAnRCcgOiAnZCc7XG4gICAgICAgIGlmIChvcHRpb25zLnBhZERheXMgPT09IHRydWUpIHtcbiAgICAgICAgICBjb3VudCA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYWREYXlzID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VyYSc6XG4gICAgICAgIHRva2VuID0gJ0cnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgdG9rZW4gPSAnTSc7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgY291bnQgPSA0O1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgIGNvdW50ID0gMztcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnBhZE1vbnRocyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvdW50ID0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnBhZE1vbnRocyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZWxhdGVkWWVhcic6XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgdG9rZW4gPSBvcHRpb25zLnRva2VuU3R5bGUgPT09ICd2aXN1YWwnID8gJ1knIDogJ3knO1xuICAgICAgICBpZiAob3B0aW9ucy5mdWxsWWVhciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvdW50ID0gNDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZ1bGxZZWFyID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvdW50ID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RheVBlcmlvZCc6XG4gICAgICAgIHRva2VuID0gJ2EnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZyYWN0aW9uYWxTZWNvbmQnOlxuICAgICAgICB0b2tlbiA9ICdTJztcbiAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIGlmIChvcHRpb25zLnRva2VuU3R5bGUgPT09ICd2aXN1YWwnKSB7XG4gICAgICAgICAgdG9rZW4gPSAnaCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4gPSBmb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCkuaG91cjEyID8gJ2gnIDogJ0gnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGFkSG91cnMgPT09IHRydWUpIHtcbiAgICAgICAgICBjb3VudCA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYWRIb3VycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICB0b2tlbiA9ICdtJztcbiAgICAgICAgaWYgKG9wdGlvbnMucGFkTWludXRlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvdW50ID0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnBhZE1pbnV0ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgdG9rZW4gPSAncyc7XG4gICAgICAgIGlmIChvcHRpb25zLnBhZFNlY29uZHMgPT09IHRydWUpIHtcbiAgICAgICAgICBjb3VudCA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYWRTZWNvbmRzID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICB0b2tlbiA9ICdlJztcbiAgICAgICAgY291bnQgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW4ucmVwZWF0KGNvdW50KTtcbiAgfSkuam9pbignJyk7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgZGF0ZSBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBhdHRlcm4uXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgVGhlIGRhdGUgdG8gYmUgZm9ybWF0dGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtmb3JtYXRdIFRoZSBmb3JtYXQgc3RyaW5nIHRvIHVzZSBhcyBhIHBhdHRlcm4uIElmIG5vdFxuICogICBnaXZlbiwgdGhlbiB0aGUgZm9ybWF0IGZyb20gdGhlIGJyb3dzZXIncyBkZWZhdWx0IGxvY2FsZSBpcyB1c2VkLiBUaGVcbiAqICAgZm9ybWF0IHRva2VucyBhcmUgdGhlIHNhbWUgYXMgdXNlZCBieSB0aGVcbiAqICAgW2RhdGUtZm5zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy99IGxpYnJhcnksIGFzIHNwZWNpZmllZCBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBmb3IgdGhlXG4gKiAgIFtmb3JtYXQgZnVuY3Rpb25de0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL3YyLjI4LjAvZG9jcy9mb3JtYXR9LlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQpIHtcbiAgcmV0dXJuIGRmRm9ybWF0KGRhdGUsIGZvcm1hdCA/PyBnZXREYXRlRm9ybWF0KCkpO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGRhdGUgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBJU08gODYwMSBmb3JtYXQuIFRoZSByZXR1cm5lZFxuICogZGF0ZSBzdHJpbmcgd2lsbCBub3QgaW5jbHVkZSBhIHRpbWUgY29tcG9uZW50LiBUbyBpbmNsdWRlIHRoZSB0aW1lIGFuZCB0aW1lXG4gKiB6b25lLCB1c2UgW2Zvcm1hdElzb0RhdGVUaW1lXXtAbGluayBtb2R1bGU6ZGF0ZXN+Zm9ybWF0SXNvRGF0ZVRpbWV9XG4gKiBpbnN0ZWFkLlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIFRoZSBkYXRlIHRvIGJlIGZvcm1hdHRlZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElzb0RhdGUoZGF0ZSkge1xuICByZXR1cm4gZm9ybWF0SVNPKGRhdGUsIHsgcmVwcmVzZW50YXRpb246ICdkYXRlJyB9KTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBkYXRlIGFuZCB0aW1lIGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW4gSVNPIDg2MDEgZm9ybWF0LiBUaGVcbiAqIHJldHVybmVkIGRhdGUgc3RyaW5nIHdpbGwgaW5jbHVkZSB0aGUgdGltZSBhbmQgdGltZSB6b25lLlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIFRoZSBkYXRlIHRvIGJlIGZvcm1hdHRlZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElzb0RhdGVUaW1lKGRhdGUpIHtcbiAgcmV0dXJuIGZvcm1hdElTTyhkYXRlKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGRhdGUgZnJvbSBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBwYXR0ZXJuIG9yIHNlcXVlbmNlIG9mIHBhdHRlcm5zLlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGVTdHJpbmcgVGhlIHN0cmluZyB0byBwYXJzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbZm9ybWF0XSBUaGUgZm9ybWF0IHN0cmluZyBvciBzZXF1ZW5jZSBvZiBmb3JtYXRcbiAqICAgc3RyaW5ncyB0byB1c2UgYXMgcGF0dGVybnMuIElmIGFuIGFycmF5IGlzIGdpdmVuLCB0aGVuIGVhY2ggc3RyaW5nIGluIHRoZVxuICogICBhcnJheSBpcyBhdHRlbXB0ZWQgdG8gYmUgdXNlZCBhcyBhIHBhdHRlcm4gdW50aWwgYSBtYXRjaCBpcyBmb3VuZC4gSWYgbm9cbiAqICAgcGF0dGVybiBpcyBnaXZlbiwgdGhlbiB0aGUgZm9ybWF0IGZyb20gdGhlIGJyb3dzZXIncyBkZWZhdWx0IGxvY2FsZSBpc1xuICogICB1c2VkLiBUaGUgZm9ybWF0IHRva2VucyBhcmUgdGhlIHNhbWUgYXMgdXNlZCBieSB0aGVcbiAqICAgW2RhdGUtZm5zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy99IGxpYnJhcnksIGFzIHNwZWNpZmllZCBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBmb3IgdGhlXG4gKiAgIFtmb3JtYXQgZnVuY3Rpb25de0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL3YyLjI4LjAvZG9jcy9mb3JtYXR9LlxuICogQHJldHVybnMge0RhdGV9IFRoZSBwYXJzZWQgZGF0ZSwgb3IgbnVsbCBpZiB0aGUgc3RyaW5nIGRvZXMgbm90IG1hdGNoIHRoZVxuICogICBwYXR0ZXJuLlxuICovXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cmluZywgZm9ybWF0KSB7XG4gIGxldCBwYXR0ZXJucztcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSBwYXR0ZXJucyA9IFtmb3JtYXRdO1xuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZvcm1hdCkgJiYgZm9ybWF0Lmxlbmd0aCA+IDApIHBhdHRlcm5zID0gZm9ybWF0O1xuICBlbHNlIHBhdHRlcm5zID0gW2dldERhdGVGb3JtYXQoKV07XG5cbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZGZQYXJzZShkYXRlU3RyaW5nLCBwYXR0ZXJuc1tpXSwgdG9kYXkpO1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGRhdGUgZnJvbSBhbiBJU08gODYwMSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZVN0cmluZyBUaGUgc3RyaW5nIHRvIHBhcnNlLlxuICogQHJldHVybnMge0RhdGV9IFRoZSBwYXJzZWQgZGF0ZSwgb3IgbnVsbCBpZiB0aGUgc3RyaW5nIGRvZXMgbm90IG1hdGNoIHRoZVxuICogICBwYXR0ZXJuLlxuICovXG5mdW5jdGlvbiBwYXJzZUlzb0RhdGVUaW1lKGRhdGVTdHJpbmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2VJU08oZGF0ZVN0cmluZyk7XG5cbiAgcmV0dXJuIGlzVmFsaWQocmVzdWx0KSA/IHJlc3VsdCA6IG51bGw7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBEYXRlIG9iamVjdCBob2xkcyBhIHZhbGlkIGRhdGUuXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgVGhlIGRhdGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZGF0ZSBpcyB2YWxpZCAoaXQgaXMgYSBEYXRlIG9iamVjdCBob2xkaW5nIGFcbiAqICAgdmFsaWQgZGF0ZSksIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZVZhbGlkKGRhdGUpIHtcbiAgcmV0dXJuIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkgJiYgaXNWYWxpZChkYXRlKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgYSBkYXkgb2YgdGhlIHdlZWsuXG4gKiBAcGFyYW0ge251bWJlcn0gZGF5SW5kZXggVGhlIGluZGV4IG9mIHRoZSB3ZWVrZGF5IGFzIGFuIGludGVnZXIgZnJvbSAwIHRvIDYsXG4gKiAgIHdpdGggMCByZXByZXNlbnRpbmcgU3VuZGF5LCAxIHJlcHJlc2VudGluZyBNb25kYXksIGFuZCBzbyBvbi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBFbmdsaXNoIG5hbWUgb2YgdGhlIHdlZWtkYXkuXG4gKi9cbmZ1bmN0aW9uIGdldFdlZWtkYXlOYW1lKGRheUluZGV4KSB7XG4gIHJldHVybiBXRUVLREFZU1tkYXlJbmRleF0gfHwgJ1Vua25vd24nO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgdGhlIGRheSBvZiBhIHdlZWssIHdpdGggU3VuZGF5IGNvcnJlc3BvbmRpbmcgdG8gMC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXkgVGhlIG5hbWUgb2YgdGhlIHdlZWtkYXkuXG4gKiBAcmV0dXJucyB7P251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSB3ZWVrZGF5IGFzIGFuIGludGVnZXIgZnJvbSAwIHRvIDYsIHdpdGhcbiAqICAgMCByZXByZXNlbnRpbmcgU3VuZGF5LCAxIHJlcHJlc2VudGluZyBNb25kYXksIGFuZCBzbyBvbi4gSWYgdGhlIHdlZWtkYXkgaXNcbiAqICAgbm90IHJlY29nbml6ZWQsIG51bGwgaXMgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFdlZWtkYXlJbmRleChkYXkpIHtcbiAgY29uc3QgZGF5TG93ZXIgPSBkYXkudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgaW5kZXggPSBXRUVLREFZUy5maW5kSW5kZXgoKGVsZW0pID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gZGF5TG93ZXIpO1xuICBpZiAoaW5kZXggPCAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiBhIG1vbnRoLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vbnRoSW5kZXggVGhlIGluZGV4IG9mIHRoZSBtb250aCBhcyBhbiBpbnRlZ2VyIGZyb20gMCB0b1xuICogICAxMSwgd2l0aCAwIHJlcHJlc2VudGluZyBKYW51YXJ5LCAxIHJlcHJlc2VudGluZyBGZWJydWFyeSwgYW5kIHNvIG9uLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIEVuZ2xpc2ggbmFtZSBvZiB0aGUgbW9udGguXG4gKi9cbmZ1bmN0aW9uIGdldE1vbnRoTmFtZShtb250aEluZGV4KSB7XG4gIHJldHVybiBNT05USFNbbW9udGhJbmRleF0/Lm5hbWUgfHwgJ1Vua25vd24nO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgYSBtb250aCBvZiB0aGUgeWVhciwgd2l0aCBKYW51YXJ5IGNvcnJlc3BvbmRpbmcgdG8gMC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtb250aCBUaGUgbmFtZSBvZiB0aGUgbW9udGguXG4gKiBAcmV0dXJucyB7P251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBtb250aCBhcyBhbiBpbnRlZ2VyIGZyb20gMCB0byAxMSwgd2l0aCAwXG4gKiAgIHJlcHJlc2VudGluZyBKYW51YXJ5LCAxIHJlcHJlc2VudGluZyBGZWJydWFyeSwgYW5kIHNvIG9uLiBJZiB0aGUgbW9udGggaXNcbiAqICAgbm90IHJlY29nbml6ZWQsIG51bGwgaXMgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGdldE1vbnRoSW5kZXgobW9udGgpIHtcbiAgY29uc3QgbW9udGhMb3dlciA9IG1vbnRoLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGluZGV4ID0gTU9OVEhTLmZpbmRJbmRleCgoZWxlbSkgPT4gKFxuICAgIGVsZW0ubmFtZS50b0xvd2VyQ2FzZSgpID09PSBtb250aExvd2VyXG4gICkpO1xuICBpZiAoaW5kZXggPCAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIEdldCB0aGUgKG1heGltdW0pIG51bWJlciBvZiBkYXlzIGluIGEgcGFydGljdWxhciBtb250aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb250aEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbW9udGggYXMgYW4gaW50ZWdlciBmcm9tIDAgdG9cbiAqICAgMTEsIHdpdGggMCByZXByZXNlbnRpbmcgSmFudWFyeSwgMSByZXByZXNlbnRpbmcgRmVicnVhcnksIGFuZCBzbyBvbi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBtYXhpbXVtIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aC4gRm9yIGV4YW1wbGUsIHRoZVxuICogICB2YWx1ZSByZXR1cm5lZCBmb3IgRmVicnVhcnkgd2lsbCBiZSAyOSwgbm90IDI4LiBSZXR1cm5zIGEgdmFsdWUgb2YgMCBpZlxuICogICBhbiBpbnZhbGlkIGluZGV4IGlzIGdpdmVuLlxuICovXG5mdW5jdGlvbiBnZXREYXlzSW5Nb250aChtb250aEluZGV4KSB7XG4gIHJldHVybiBNT05USFNbbW9udGhJbmRleF0/Lm1heERheXMgPz8gMDtcbn1cblxuZXhwb3J0IHtcbiAgZm9ybWF0RGF0ZSxcbiAgZm9ybWF0SXNvRGF0ZSxcbiAgZm9ybWF0SXNvRGF0ZVRpbWUsXG4gIGdldERhdGVGb3JtYXQsXG4gIGdldERheXNJbk1vbnRoLFxuICBnZXRNb250aEluZGV4LFxuICBnZXRNb250aE5hbWUsXG4gIGdldFdlZWtkYXlJbmRleCxcbiAgZ2V0V2Vla2RheU5hbWUsXG4gIGlzRGF0ZVZhbGlkLFxuICBwYXJzZURhdGUsXG4gIHBhcnNlSXNvRGF0ZVRpbWUsXG59O1xuIiwiLyoqXG4gKiBEZWZpbmVzIGZ1bmN0aW9ucyBmb3IgbWFuaXB1bGF0aW5nIHRoZSBET00uXG4gKiBAbW9kdWxlIGRvbVxuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGlucHV0IGNvbnRyb2xzIGluIGEgZm9ybS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTpkb21+Zm9ybUNvbnRyb2xPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGU9dGV4dF0gVGhlIHR5cGUgb2YgaW5wdXQuIEZvciBtb3N0IHRleHQgb3IgbnVtZXJpY1xuICogICBmb3JtcyBvZiBpbnB1dCwgdGhpcyB2YWx1ZSBpcyB1c2VkIGFzIHRoZSAndHlwZScgYXR0cmlidXRlIG9uIGFuICdpbnB1dCdcbiAqICAgZWxlbWVudC4gU2V0dGluZyB0aGlzIHRvICdzZWxlY3QnIGluZGljYXRlcyB0aGF0IGEgJ3NlbGVjdCcgZWxlbWVudCBzaG91bGRcbiAqICAgYmUgY3JlYXRlZC4gU2V0dGluZyB0aGlzIHRvICd0ZXh0YXJlYScgaW5kaWNhdGVzIHRoYXQgYSAndGV4dGFyZWEnIGVsZW1lbnRcbiAqICAgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGlucHV0IGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBlbGVtZW50LCB1c2VkIGluIGZvcm1cbiAqICAgc3VibWlzc2lvbiBhbmQgZm9yIGdyb3VwaW5nIHJhZGlvIGJ1dHRvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXSBUaGUgdGl0bGUgb2YgdGhlIGlucHV0IGVsZW1lbnQsIHVzdWFsbHkgZGlzcGxheWVkXG4gKiAgIGJ5IHRoZSBicm93c2VyIGFzIGEgdG9vbHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmFsdWVdIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBpbnB1dCBlbGVtZW50LCBvciBhXG4gKiAgIHZhbHVlIGlkZW50aWZ5aW5nIGEgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uIG9wdGlvbi4gVGhpcyBwcm9wZXJ0eSBpc1xuICogICBpZ25vcmVkIGZvciB0aGUgJ3NlbGVjdCcgaW5wdXQgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXJdIEEgaGludCBzdHJpbmcgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvclxuICogICB0ZXh0LWJhc2VkIGlucHV0IGVsZW1lbnRzLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW2NsYXNzTGlzdD1bXV0gQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gYXBwbHkgdG8gdGhlXG4gKiAgIGlucHV0IGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjaGVja2VkPWZhbHNlXSBJZiB0cnVlLCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29udHJvbFxuICogICBzaG91bGQgYmUgY2hlY2tlZCBieSBkZWZhdWx0LiBUaGlzIGFwcGxpZXMgb25seSB0byB0aGUgJ2NoZWNrYm94JyBhbmRcbiAqICAgJ3JhZGlvJyBpbnB1dCB0eXBlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkPWZhbHNlXSBJZiB0cnVlLCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29udHJvbFxuICogICBpcyBhIHJlcXVpcmVkIGZpZWxkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYXR0ZXJuXSBTcGVjaWZpZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB0aGUgaW5wdXRcbiAqICAgY29udHJvbCdzIHZhbHVlIHNob3VsZCBtYXRjaCBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICogQHByb3BlcnR5IHtudW1iZXJ8c3RyaW5nfSBbbWluXSBTZXRzIHRoZSBtaW5pbXVtIGFjY2VwdGFibGUgdmFsdWUgZm9yIGFcbiAqICAgbnVtZXJpYyBpbnB1dCBmaWVsZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfHN0cmluZ30gW21heF0gU2V0cyB0aGUgbWF4aW11bSBhY2NlcHRhYmxlIHZhbHVlIGZvciBhXG4gKiAgIG51bWVyaWMgaW5wdXQgZmllbGQuXG4gKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IFtzdGVwXSBTZXRzIHRoZSBhY2NlcHRhYmxlIGluY3JlbWVudHMgZm9yIHZhbHVlc1xuICogICBpbiBhIG51bWVyaWMgaW5wdXQgZmllbGQuIFRoaXMgY2FuIGJlIGEgbnVtYmVyIG9yIHRoZSBzdHJpbmcgJ2FueScuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbkxlbmd0aF0gU2V0cyB0aGUgbWluaW11bSBhY2NlcHRhYmxlIGxlbmd0aCBmb3IgYW5cbiAqICAgaW5wdXQgZmllbGQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heExlbmd0aF0gU2V0cyB0aGUgbWF4aW11bSBhY2NlcHRhYmxlIGxlbmd0aCBmb3IgYW5cbiAqICAgaW5wdXQgZmllbGQuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xzdHJpbmdbXX0gW2FjY2VwdF0gU2V0cyB0aGUgYWNjZXB0YWJsZSBmaWxlIHR5cGVzIGZvciBhXG4gKiAgIGZpbGUgaW5wdXQgZmllbGQuIENhbiBiZSBhIHN0cmluZyBjb250YWluaW5nIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2ZcbiAqICAgZmlsZSBleHRlbnNpb25zIGFuZC9vciBtZWRpYSB0eXBlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBlYWNoIHNwZWNpZnlpbmdcbiAqICAgb25lIGZpbGUgZXh0ZW5zaW9uIG9yIG1lZGlhIHR5cGUuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2xhYmVsXSBBbiBvYmplY3Qgc3BlY2lmeWluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGFiZWxcbiAqICAgZm9yIHRoZSBpbnB1dCBlbGVtZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbC52YWx1ZV0gVGhlIHRleHQgY29udGVudCBvZiB0aGUgbGFiZWwgdGhhdCBzaG91bGRcbiAqICAgYmUgZGlzcGxheWVkIG9uIHRoZSBwYWdlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbC5wbGFjZW1lbnQ9YXV0b10gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBsYWJlbFxuICogICBzaG91bGQgYmUgcGxhY2VkIGJlZm9yZSBvciBhZnRlciB0aGUgaW5wdXQgY29udHJvbC4gVmFsaWQgdmFsdWVzIGFyZVxuICogICAnYmVmb3JlJywgJ2FmdGVyJywgYW5kICdhdXRvJyAodGhlIGRlZmF1bHQpLiBJZiBzZXQgdG8gJ2F1dG8nLCB0aGVuIHRoZVxuICogICBsYWJlbCBpcyBwbGFjZWQgYWZ0ZXIgdGhlIGVsZW1lbnQgaWYgdGhlIGlucHV0IHR5cGUgaXMgJ3JhZGlvJyBvclxuICogICAnY2hlY2tib3gnLCBhbmQgYmVmb3JlIHRoZSBlbGVtZW50IGluIGFsbCBvdGhlciBjYXNlcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtsYWJlbC5jbGFzc0xpc3Q9W11dIEFuIGFycmF5IG9mIGNsYXNzIG5hbWVzIHRvIGFwcGx5XG4gKiAgIHRvIHRoZSBsYWJlbCBlbGVtZW50LlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtzaXplXSBBbiBvYmplY3QgY29udGFpbmluZyBzaXplIGluZm9ybWF0aW9uIGZvciB0aGVcbiAqICAgaW5wdXQgZWxlbWVudC4gVGhpcyBpcyBvbmx5IHVzZWQgZm9yIHRoZSAndGV4dGFyZWEnIGlucHV0IHR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NpemUucm93c10gVGhlIG51bWJlciBvZiByb3dzIHRoYXQgYSB0ZXh0YXJlYSBzaG91bGRcbiAqICAgaGF2ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZS5jb2xzXSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdGhhdCBhIHRleHRhcmVhIHNob3VsZFxuICogICBoYXZlLlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtjb250YWluZXJdIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogICBjb250YWluZXIgaG9sZGluZyB0aGUgaW5wdXQgZWxlbWVudCBhbmQgaXRzIGxhYmVsLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb250YWluZXIuaWRdIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgY29udGFpbmVyLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW2NvbnRhaW5lci5jbGFzc0xpc3Q9W11dIEFuIGFycmF5IG9mIGNsYXNzIG5hbWVzIHRvXG4gKiAgIGFwcGx5IHRvIHRoZSBjb250YWluZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb250YWluZXIuaW5saW5lPWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgaW5kaWNhdGVzIHRoYXRcbiAqICAgdGhlIGNvbnRhaW5lciBzaG91bGQgYmUgYW4gaW5saW5lIGVsZW1lbnQgcmF0aGVyIHRoYW4gYSBibG9jayBlbGVtZW50LlxuICogQHByb3BlcnR5IHtPYmplY3RbXX0gW21lbnVJdGVtc10gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGluZm9ybWF0aW9uXG4gKiAgIGFib3V0IG9wdGlvbnMgZm9yIGEgc2VsZWN0IGNvbnRyb2wuIFRoaXMgcHJvcGVydHkgaXMgaWdub3JlZCB1bmxlc3MgdGhlXG4gKiAgIGlucHV0IHR5cGUgaXMgJ3NlbGVjdCcuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21lbnVJdGVtcy52YWx1ZV0gVGhlIGZvcm0gdmFsdWUgaWRlbnRpZnlpbmcgdGhlIGl0ZW0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVudUl0ZW1zLmxhYmVsIFRoZSBsYWJlbCB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIGZvclxuICogICB0aGUgaXRlbS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21lbnVJdGVtcy5zZWxlY3RlZD1mYWxzZV0gSWYgdHJ1ZSwgaW5kaWNhdGVzIHRoYXQgdGhlXG4gKiAgIGl0ZW0gc2hvdWxkIGJlIHNlbGVjdGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5wdXQgY29udHJvbCBpbiBhIGZvcm0sIG9wdGlvbmFsbHkgaW5jbHVkaW5nIGEgbGFiZWwuXG4gKiBAcGFyYW0ge21vZHVsZTpkb21+Zm9ybUNvbnRyb2xPcHRpb25zfSBbb3B0aW9ucz17fV0gQW4gb2JqZWN0IHNwZWNpZnlpbmdcbiAqICAgb3B0aW9ucyBmb3IgdGhlIGlucHV0IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBjb250YWluZXIgaG9sZGluZyB0aGUgaW5wdXQgZWxlbWVudCBhbmQgaXRzXG4gKiAgIGxhYmVsLiBJZiBubyBsYWJlbCBhbmQgbm8gY29udGFpbmVyIGlkIHdlcmUgc3BlY2lmaWVkLCB0aGVuIHRoZSBmb3JtXG4gKiAgIGVsZW1lbnQgaXMgbm90IHBsYWNlZCBpbiBhIGNvbnRhaW5lciBhbmQgaXMgaW5zdGVhZCByZXR1cm5lZCBkaXJlY3RseS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm9ybUNvbnRyb2wob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGU/LnRvTG93ZXJDYXNlKCkgfHwgJ3RleHQnO1xuICBsZXQgY29udGFpbmVyID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb250YWluZXIpIHtcbiAgICBjb25zdCBjb250YWluZXJUYWcgPSBvcHRpb25zLmNvbnRhaW5lcj8uaW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjb250YWluZXJUYWcpO1xuICAgIGlmIChvcHRpb25zLmNvbnRhaW5lcj8uaWQpIGNvbnRhaW5lci5pZCA9IG9wdGlvbnMuY29udGFpbmVyLmlkO1xuICAgIGlmIChvcHRpb25zLmNvbnRhaW5lcj8uY2xhc3NMaXN0KSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi5vcHRpb25zLmNvbnRhaW5lci5jbGFzc0xpc3QpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBsYWJlbCA9IG51bGw7XG4gIGlmIChvcHRpb25zLmxhYmVsKSB7XG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gb3B0aW9ucy5sYWJlbC52YWx1ZSB8fCAnJztcbiAgICBpZiAob3B0aW9ucy5sYWJlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoLi4ub3B0aW9ucy5sYWJlbC5jbGFzc0xpc3QpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pZCkgbGFiZWwuaHRtbEZvciA9IG9wdGlvbnMuaWQ7XG4gIH1cblxuICBsZXQgaW5wdXQgPSBudWxsO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgIGlmIChvcHRpb25zLm1lbnVJdGVtcykge1xuICAgICAgICBvcHRpb25zLm1lbnVJdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgaWYgKGl0ZW0udmFsdWUpIG9wdC52YWx1ZSA9IGl0ZW0udmFsdWU7XG4gICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIG9wdC5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgb3B0LnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0LnRleHRDb250ZW50ID0gaXRlbS5sYWJlbDtcbiAgICAgICAgICBpbnB1dC5hcHBlbmRDaGlsZChvcHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgIGlucHV0LnRleHRDb250ZW50ID0gb3B0aW9ucy52YWx1ZSB8fCAnJztcbiAgICAgIGlmIChvcHRpb25zLnNpemUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZS5yb3dzKSBpbnB1dC5yb3dzID0gb3B0aW9ucy5zaXplLnJvd3M7XG4gICAgICAgIGlmIChvcHRpb25zLnNpemUuY29scykgaW5wdXQuY29scyA9IG9wdGlvbnMuc2l6ZS5jb2xzO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgICAgaWYgKG9wdGlvbnMudmFsdWUpIHtcbiAgICAgICAgaW5wdXQuZGVmYXVsdFZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5wYXR0ZXJuKSBpbnB1dC5wYXR0ZXJuID0gb3B0aW9ucy5wYXR0ZXJuO1xuICAgICAgaWYgKG9wdGlvbnMubWluICE9IG51bGwpIGlucHV0Lm1pbiA9IG9wdGlvbnMubWluO1xuICAgICAgaWYgKG9wdGlvbnMubWF4ICE9IG51bGwpIGlucHV0Lm1heCA9IG9wdGlvbnMubWF4O1xuICAgICAgaWYgKG9wdGlvbnMuc3RlcCAhPSBudWxsKSBpbnB1dC5zdGVwID0gb3B0aW9ucy5zdGVwO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAob3B0aW9ucy5pZCkgaW5wdXQuaWQgPSBvcHRpb25zLmlkO1xuICBpZiAob3B0aW9ucy5uYW1lKSBpbnB1dC5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICBpZiAob3B0aW9ucy50aXRsZSkgaW5wdXQudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICBpZiAob3B0aW9ucy5jbGFzc0xpc3QpIGlucHV0LmNsYXNzTGlzdC5hZGQoLi4ub3B0aW9ucy5jbGFzc0xpc3QpO1xuICBpZiAob3B0aW9ucy5yZXF1aXJlZCkgaW5wdXQucmVxdWlyZWQgPSB0cnVlO1xuICBpZiAodHlwZSAhPT0gJ3NlbGVjdCcgJiYgb3B0aW9ucy5taW5MZW5ndGggIT0gbnVsbCkge1xuICAgIGlucHV0Lm1pbkxlbmd0aCA9IG9wdGlvbnMubWluTGVuZ3RoO1xuICB9XG4gIGlmICh0eXBlICE9PSAnc2VsZWN0JyAmJiBvcHRpb25zLm1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgaW5wdXQubWF4TGVuZ3RoID0gb3B0aW9ucy5tYXhMZW5ndGg7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdmaWxlJyAmJiBvcHRpb25zLmFjY2VwdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYWNjZXB0KSkgaW5wdXQuYWNjZXB0ID0gb3B0aW9ucy5hY2NlcHQuam9pbignLCcpO1xuICAgIGVsc2UgaW5wdXQuYWNjZXB0ID0gb3B0aW9ucy5hY2NlcHQ7XG4gIH1cblxuICBjb25zdCBjaGVja2FibGUgPSB0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbyc7XG4gIGlmIChjaGVja2FibGUgJiYgb3B0aW9ucy5jaGVja2VkKSB7XG4gICAgaW5wdXQuZGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIgJiYgIWNoZWNrYWJsZSAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIGlucHV0LnBsYWNlaG9sZGVyID0gb3B0aW9ucy5wbGFjZWhvbGRlcjtcbiAgfVxuXG4gIGlmIChsYWJlbCkge1xuICAgIGxldCBwbGFjZW1lbnQgPSBvcHRpb25zLmxhYmVsLnBsYWNlbWVudCB8fCAnYXV0byc7XG4gICAgaWYgKHBsYWNlbWVudCA9PT0gJ2F1dG8nKSBwbGFjZW1lbnQgPSBjaGVja2FibGUgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSAnYWZ0ZXInKSB7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgZGF0ZSBpbnB1dCBmaWVsZCBpbiBhIGZvcm0uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZG9tfmRhdGVJbnB1dE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgdGV4dCBpbnB1dCBlbGVtZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBUaGUgbmFtZSBvZiB0aGUgdGV4dCBpbnB1dCBlbGVtZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV0gVGhlIHRpdGxlIG9mIHRoZSB0ZXh0IGlucHV0IGVsZW1lbnQsIHVzdWFsbHlcbiAqICAgZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIGFzIGEgdG9vbHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmFsdWVdIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSB0ZXh0IGlucHV0IGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXSBBIGhpbnQgc3RyaW5nIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgdGhlXG4gKiAgIHRleHQgaW5wdXQgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtjbGFzc0xpc3Q9W11dIEFuIGFycmF5IG9mIGNsYXNzIG5hbWVzIHRvIGFwcGx5IHRvIHRoZVxuICogICB0ZXh0IGlucHV0IGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZD1mYWxzZV0gSWYgdHJ1ZSwgaW5kaWNhdGVzIHRoYXQgdGhlIGlucHV0XG4gKiAgIGNvbnRyb2wgaXMgYSByZXF1aXJlZCBmaWVsZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGF0dGVybl0gU3BlY2lmaWVzIGEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgdGhlIGlucHV0XG4gKiAgIGNvbnRyb2wncyB2YWx1ZSBzaG91bGQgbWF0Y2ggaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluTGVuZ3RoXSBTZXRzIHRoZSBtaW5pbXVtIGFjY2VwdGFibGUgbGVuZ3RoIGZvciB0aGVcbiAqICAgdGV4dCBpbnB1dCBmaWVsZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4TGVuZ3RoXSBTZXRzIHRoZSBtYXhpbXVtIGFjY2VwdGFibGUgbGVuZ3RoIGZvciB0aGVcbiAqICAgdGV4dCBpbnB1dCBmaWVsZC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbGFiZWxdIEFuIG9iamVjdCBzcGVjaWZ5aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsYWJlbFxuICogICBmb3IgdGhlIGlucHV0IGZpZWxkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbC52YWx1ZV0gVGhlIHRleHQgY29udGVudCBvZiB0aGUgbGFiZWwgdGhhdCBzaG91bGRcbiAqICAgYmUgZGlzcGxheWVkIG9uIHRoZSBwYWdlLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW2xhYmVsLmNsYXNzTGlzdD1bXV0gQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gYXBwbHlcbiAqICAgdG8gdGhlIGxhYmVsIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2NvbnRhaW5lcl0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiAgIGNvbnRhaW5lciBob2xkaW5nIHRoZSBpbnB1dCBmaWVsZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29udGFpbmVyLmlkXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGNvbnRhaW5lci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtjb250YWluZXIuY2xhc3NMaXN0PVtdXSBBbiBhcnJheSBvZiBjbGFzcyBuYW1lcyB0b1xuICogICBhcHBseSB0byB0aGUgY29udGFpbmVyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29udGFpbmVyLmlubGluZT1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIGluZGljYXRlcyB0aGF0XG4gKiAgIHRoZSBjb250YWluZXIgc2hvdWxkIGJlIGFuIGlubGluZSBlbGVtZW50IHJhdGhlciB0aGFuIGEgYmxvY2sgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYnV0dG9uXSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAqICAgYnV0dG9uIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2J1dHRvbi5pZF0gVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBidXR0b24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2J1dHRvbi5uYW1lXSBUaGUgZm9ybSBuYW1lIGZvciB0aGUgYnV0dG9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtidXR0b24udGl0bGVdIFRoZSB0aXRsZSBmb3IgdGhlIGJ1dHRvbiwgdXN1YWxseVxuICogICBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgYXMgYSB0b29sdGlwLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtidXR0b24ubGFiZWw9Q2hvb3NlLi4uXSBUaGUgbGFiZWwgdG8gYmUgZGlzcGxheWVkIGluIHRoZVxuICogICBidXR0b24uXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbYnV0dG9uLmNsYXNzTGlzdF0gQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gYXBwbHkgdG9cbiAqICAgdGhlIGJ1dHRvbiBlbGVtZW50LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2J1dHRvbi5jYWxsYmFja10gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIG9yIGFjdGl2YXRlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFcbiAqICAgcmVmZXJlbmNlIHRvIHRoZSB0ZXh0IGlucHV0IGVsZW1lbnQgYXMgYW4gYXJndW1lbnQuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5wdXQgZmllbGQgZm9yIGVudGVyaW5nIGRhdGVzLiBUaGlzIHdpbGwgY3JlYXRlIGEgdGV4dCBpbnB1dFxuICogY29udHJvbCB0b2dldGhlciB3aXRoIGEgYnV0dG9uIHRoYXQgY2FuIGludm9rZSBhIGNhbGxiYWNrIGFsbG93aW5nIGZvciB0aGVcbiAqIGNhbGxlciB0byBvcGVuIGEgZGF0ZSBwaWNrZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpkb21+ZGF0ZUlucHV0T3B0aW9uc30gW29wdGlvbnM9e31dIEFuIG9iamVjdCBzcGVjaWZ5aW5nXG4gKiAgIG9wdGlvbnMgZm9yIHRoZSBpbnB1dCBmaWVsZC5cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGNvbnRhaW5lciBob2xkaW5nIHRoZSBpbnB1dCBlbGVtZW50cyBhbmQgbGFiZWwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhdGVJbnB1dEZpZWxkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBjb250YWluZXJUYWcgPSBvcHRpb25zLmNvbnRhaW5lcj8uaW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY29udGFpbmVyVGFnKTtcbiAgaWYgKG9wdGlvbnMuY29udGFpbmVyPy5pZCkgY29udGFpbmVyLmlkID0gb3B0aW9ucy5jb250YWluZXIuaWQ7XG4gIGlmIChvcHRpb25zLmNvbnRhaW5lcj8uY2xhc3NMaXN0KSB7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4ub3B0aW9ucy5jb250YWluZXIuY2xhc3NMaXN0KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmxhYmVsKSB7XG4gICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGlmIChvcHRpb25zLmlkKSBsYWJlbC5odG1sRm9yID0gb3B0aW9ucy5pZDtcbiAgICBpZiAob3B0aW9ucy5sYWJlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoLi4ub3B0aW9ucy5sYWJlbC5jbGFzc0xpc3QpO1xuICAgIH1cbiAgICBsYWJlbC50ZXh0Q29udGVudCA9IG9wdGlvbnMubGFiZWwudmFsdWUgfHwgJyc7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgfVxuXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVGb3JtQ29udHJvbCh7XG4gICAgdHlwZTogJ3RleHQnLFxuICAgIGlkOiBvcHRpb25zLmlkID8/IG51bGwsXG4gICAgbmFtZTogb3B0aW9ucy5uYW1lID8/IG51bGwsXG4gICAgdGl0bGU6IG9wdGlvbnMudGl0bGUgPz8gbnVsbCxcbiAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSA/PyBudWxsLFxuICAgIHBsYWNlaG9sZGVyOiBvcHRpb25zLnBsYWNlaG9sZGVyID8/IG51bGwsXG4gICAgY2xhc3NMaXN0OiBvcHRpb25zLmNsYXNzTGlzdCB8fCBudWxsLFxuICAgIHJlcXVpcmVkOiBvcHRpb25zLnJlcXVpcmVkID8/IGZhbHNlLFxuICAgIHBhdHRlcm46IG9wdGlvbnMucGF0dGVybiA/PyBudWxsLFxuICAgIG1pbkxlbmd0aDogb3B0aW9ucy5taW5MZW5ndGggPz8gbnVsbCxcbiAgICBtYXhMZW5ndGg6IG9wdGlvbnMubWF4TGVuZ3RoID8/IG51bGwsXG4gIH0pKTtcblxuICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgaWYgKG9wdGlvbnMuYnV0dG9uPy5pZCkgYnV0dG9uLmlkID0gb3B0aW9ucy5idXR0b24uaWQ7XG4gIGlmIChvcHRpb25zLmJ1dHRvbj8ubmFtZSkgYnV0dG9uLm5hbWUgPSBvcHRpb25zLmJ1dHRvbi5uYW1lO1xuICBpZiAob3B0aW9ucy5idXR0b24/LnRpdGxlKSBidXR0b24udGl0bGUgPSBvcHRpb25zLmJ1dHRvbi50aXRsZTtcbiAgaWYgKG9wdGlvbnMuYnV0dG9uPy5jbGFzc0xpc3QpIHtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZCguLi5vcHRpb25zLmJ1dHRvbi5jbGFzc0xpc3QpO1xuICB9XG4gIGJ1dHRvbi50ZXh0Q29udGVudCA9IG9wdGlvbnMuYnV0dG9uPy5sYWJlbCB8fCAnQ2hvb3NlLi4uJztcbiAgaWYgKG9wdGlvbnMuYnV0dG9uPy5jYWxsYmFjaykge1xuICAgIGNvbnN0IGlucHV0ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gb3B0aW9ucy5idXR0b24uY2FsbGJhY2soaW5wdXQpKTtcbiAgfVxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICByZXR1cm4gY29udGFpbmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBpY29uIGJ1dHRvbiBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGljb25UeXBlIFRoZSB0eXBlIG9mIGljb24gdG8gZGlzcGxheS4gVGhpcyBpcyBzdG9yZWQgaW4gdGhlXG4gKiAgIGRhdGEtaWNvbi10eXBlIGF0dHJpYnV0ZSBvZiB0aGUgYnV0dG9uIGFuZCBhbHNvIGluZGljYXRlcyB0aGUgaWNvbiB0byB1c2VcbiAqICAgZnJvbSB0aGUgR29vZ2xlIE1hdGVyaWFsIEljb25zIGZvbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIEFuIG9iamVjdCBob2xkaW5nIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICBjb250cm9sbGluZyB0aGUgYnV0dG9uIGNyZWF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkXSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGJ1dHRvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aXRsZV0gVGhlIHRpdGxlIG9mIHRoZSBidXR0b24sIHVzdWFsbHkgZGlzcGxheWVkXG4gKiAgIGJ5IHRoZSBicm93c2VyIGFzIGEgdG9vbHRpcC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmNsYXNzTGlzdF0gQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gYXBwbHkgdG9cbiAqICAgdGhlIGJ1dHRvbi5cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIG5ld2x5LWNyZWF0ZWQgYnV0dG9uIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUljb25CdXR0b24oaWNvblR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2ljb24nLCAnbWF0ZXJpYWwtaWNvbnMnKTtcbiAgYnV0dG9uLmRhdGFzZXQuaWNvblR5cGUgPSBpY29uVHlwZTtcbiAgYnV0dG9uLnRleHRDb250ZW50ID0gaWNvblR5cGU7XG4gIGlmIChvcHRpb25zLmlkKSBidXR0b24uaWQgPSBvcHRpb25zLmlkO1xuICBpZiAob3B0aW9ucy50aXRsZSkgYnV0dG9uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgaWYgKG9wdGlvbnMuY2xhc3NMaXN0KSBidXR0b24uY2xhc3NMaXN0LmFkZCguLi5vcHRpb25zLmNsYXNzTGlzdCk7XG4gIHJldHVybiBidXR0b247XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYnV0dG9uIHRoYXQgY2FuIGJlIHRvZ2dsZWQgb24gYW5kIG9mZi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBUaGUgYnV0dG9uIGxhYmVsLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3QgaG9sZGluZyBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgY29udHJvbGxpbmcgdGhlIGJ1dHRvbiBjcmVhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF0gVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBidXR0b24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gVGhlIGZvcm0gbmFtZSBmb3IgdGhlIGJ1dHRvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aXRsZV0gVGhlIHRpdGxlIG9mIHRoZSBidXR0b24sIHVzdWFsbHkgZGlzcGxheWVkXG4gKiAgIGJ5IHRoZSBicm93c2VyIGFzIGEgdG9vbHRpcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YWx1ZV0gVGhlIGZvcm0gdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBidXR0b24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRBY3RpdmU9ZmFsc2VdIFNldHMgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlXG4gKiAgIGJ1dHRvbi4gSWYgc2V0IHRvIHRydWUsIHRoZW4gdGhlIGJ1dHRvbiB3aWxsIGJlIGFjdGl2ZSAob24pIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5jbGFzc0xpc3RdIEFuIGFycmF5IG9mIGNsYXNzIG5hbWVzIHRvIGFwcGx5IHRvXG4gKiAgIHRoZSBidXR0b24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBidXR0b24gd2lsbCByZWNlaXZlIHRoZSAndG9nZ2xlLWJ1dHRvbidcbiAqICAgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWN0aXZlQ2xhc3M9YWN0aXZlXSBUaGUgQ1NTIGNsYXNzIHRvIGFwcGx5IHdoZW5cbiAqICAgdGhlIGJ1dHRvbiBpcyBhY3RpdmUgKG9uKS5cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIG5ld2x5LWNyZWF0ZWQgYnV0dG9uIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvZ2dsZUJ1dHRvbihsYWJlbCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICBpZiAob3B0aW9ucy5pZCkgYnV0dG9uLmlkID0gb3B0aW9ucy5pZDtcbiAgaWYgKG9wdGlvbnMubmFtZSkgYnV0dG9uLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gIGlmIChvcHRpb25zLnRpdGxlKSBidXR0b24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICBpZiAob3B0aW9ucy52YWx1ZSkgYnV0dG9uLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgaWYgKG9wdGlvbnMuY2xhc3NMaXN0KSBidXR0b24uY2xhc3NMaXN0LmFkZCguLi5vcHRpb25zLmNsYXNzTGlzdCk7XG4gIGVsc2UgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3RvZ2dsZS1idXR0b24nKTtcbiAgYnV0dG9uLnRleHRDb250ZW50ID0gbGFiZWw7XG5cbiAgY29uc3QgYWN0aXZlQ2xhc3MgPSBvcHRpb25zLmFjdGl2ZUNsYXNzIHx8ICdhY3RpdmUnO1xuICBpZiAob3B0aW9ucy5kZWZhdWx0QWN0aXZlKSBidXR0b24uY2xhc3NMaXN0LmFkZChhY3RpdmVDbGFzcyk7XG5cbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoYWN0aXZlQ2xhc3MpKTtcbiAgcmV0dXJuIGJ1dHRvbjtcbn1cblxuZXhwb3J0IHtcbiAgY3JlYXRlRGF0ZUlucHV0RmllbGQsXG4gIGNyZWF0ZUZvcm1Db250cm9sLFxuICBjcmVhdGVJY29uQnV0dG9uLFxuICBjcmVhdGVUb2dnbGVCdXR0b24sXG59O1xuIiwiLyoqXG4gKiBEZWZpbmVzIHN0b3JhZ2UtcmVsYXRlZCB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBtb2R1bGUgc3RvcmFnZVxuICovXG5cbmxldCBzdG9yYWdlU3VwcG9ydGVkID0gbnVsbDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgbG9jYWwgc3RvcmFnZSBpcyBzdXBwb3J0ZWQgYW5kIGVuYWJsZWQgaW4gdGhlXG4gKiBicm93c2VyLiBUaGUgY2hlY2sgaXMgb25seSBwZXJmb3JtZWQgb25jZTogc3Vic2VxdWVudCBjYWxscyB3aWxsIGltbWVkaWF0ZWx5XG4gKiByZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBsb2NhbCBzdG9yYWdlIGlzIHN1cHBvcnRlZCBhbmQgZW5hYmxlZCwgYW5kIGZhbHNlXG4gKiAgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VTdXBwb3J0ZWQoKSB7XG4gIGlmIChzdG9yYWdlU3VwcG9ydGVkICE9PSBudWxsKSByZXR1cm4gc3RvcmFnZVN1cHBvcnRlZDtcblxuICBsZXQgc3RvcmFnZTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICBjb25zdCB0ZXN0SXRlbSA9ICdfX3N0b3JhZ2UtdGVzdCc7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHRlc3RJdGVtLCB0ZXN0SXRlbSk7XG4gICAgc3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RJdGVtKTtcbiAgICBzdG9yYWdlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHN0b3JhZ2VTdXBwb3J0ZWQgPSBlIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIChcbiAgICAgIGUuY29kZSA9PT0gMjIgfHwgZS5jb2RlID09PSAxMDE0IHx8IGUubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcidcbiAgICAgIHx8IGUubmFtZSA9PT0gJ05TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEJ1xuICAgICkgJiYgKHN0b3JhZ2UgJiYgc3RvcmFnZS5sZW5ndGggIT09IDApO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JhZ2VTdXBwb3J0ZWQ7XG59XG5cbi8qKlxuICogU3RvcmUgZGF0YSBpbiB0aGUgYnJvd3NlcidzIGxvY2FsIHN0b3JhZ2UsIGlmIGF2YWlsYWJsZS4gVGhpcyBmdW5jdGlvbiB3aWxsXG4gKiBhc3NvY2lhdGUgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBpbiBzdG9yYWdlLiBUaGUgdmFsdWUgaXMgZmlyc3RcbiAqIGNvbnZlcnRlZCB0byBKU09OIGZvcm1hdCBiZWZvcmUgYmVpbmcgc3RvcmVkLlxuICogQHBhcmFtIHs/c3RyaW5nfSBwcmVmaXggQSBwcmVmaXggdG8gdXNlIGZvciB0aGUga2V5IG5hbWUgdG8gYXZvaWQgY2xhc2hlc1xuICogICB3aXRoIG90aGVyIHdlYiBhcHBzIGhvc3RlZCBvbiB0aGUgc2FtZSBvcmlnaW4uIElmIGdpdmVuLCB0aGUgYWN0dWFsIGtleVxuICogICB1c2VkIHdpbGwgaGF2ZSB0aGUgZm9ybSAncHJlZml4LmtleScuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gY3JlYXRlIG9yIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGRhdGEgd2FzIHN1Y2Nlc3NmdWxseSBzdG9yZWQsIGFuZCBmYWxzZVxuICogICBvdGhlcndpc2UuIFBvc3NpYmxlIHJlYXNvbnMgZm9yIHJldHVybmluZyBmYWxzZSBpbmNsdWRlIGxvY2FsIHN0b3JhZ2VcbiAqICAgYmVpbmcgdW5zdXBwb3J0ZWQgb3IgZGlzYWJsZWQsIG9yIHN0b3JhZ2UgbGltaXRzIGJlaW5nIGV4Y2VlZGVkLlxuICovXG5mdW5jdGlvbiBzdG9yZURhdGEocHJlZml4LCBrZXksIHZhbHVlKSB7XG4gIGlmICghaXNMb2NhbFN0b3JhZ2VTdXBwb3J0ZWQoKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGZ1bGxLZXkgPSBwcmVmaXggPyBgJHtwcmVmaXh9LiR7a2V5fWAgOiBrZXk7XG5cbiAgdHJ5IHtcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oZnVsbEtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmUgZGF0YSBmcm9tIHRoZSBicm93c2VyJ3MgbG9jYWwgc3RvcmFnZSwgaWYgYXZhaWxhYmxlLiBUaGlzIGZ1bmN0aW9uXG4gKiB3aWxsIHJldHVybiB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS4gVGhlIGRhdGEgaXMgY29udmVydGVkXG4gKiBmcm9tIEpTT04gZm9ybWF0IGFuZCB0aGUgcmVzdWx0aW5nIHZhbHVlIG9yIG9iamVjdCBpcyB1c2VkIGFzIHRoZSByZXR1cm5cbiAqIHZhbHVlLiBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0IG9yIGlmIGxvY2FsIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSwgbnVsbFxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0gez9zdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IGZvciB0aGUga2V5IG5hbWUgd2hvc2UgdmFsdWUgaXMgdG8gYmVcbiAqICAgcmV0cmlldmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHdob3NlIHZhbHVlIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAqIEByZXR1cm5zIHsqfSBUaGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJldHJpZXZlRGF0YShwcmVmaXgsIGtleSkge1xuICBpZiAoIWlzTG9jYWxTdG9yYWdlU3VwcG9ydGVkKCkpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGZ1bGxLZXkgPSBwcmVmaXggPyBgJHtwcmVmaXh9LiR7a2V5fWAgOiBrZXk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oZnVsbEtleSkpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBkYXRhIGZyb20gdGhlIGJyb3dzZXIncyBsb2NhbCBzdG9yYWdlLiBJZiBpdCBleGlzdHMsIHRoZSBnaXZlbiBrZXlcbiAqIGFuZCBpdHMgYXNzb2NpYXRlZCBkYXRhIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHN0b3JhZ2UuXG4gKiBAcGFyYW0gez9zdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IGZvciB0aGUga2V5IHRvIGJlIHJlbW92ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gYmUgcmVtb3ZlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBrZXkgd2FzIGZvdW5kIGFuZCByZW1vdmVkLiBJZiB0aGUga2V5IHdhcyBub3RcbiAqICAgZm91bmQgb3IgaWYgbG9jYWwgc3RvcmFnZSBpcyB1bmF2YWlsYWJsZSwgcmV0dXJucyBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRGF0YShwcmVmaXgsIGtleSkge1xuICBpZiAoIWlzTG9jYWxTdG9yYWdlU3VwcG9ydGVkKCkpIHJldHVybiBmYWxzZTtcblxuICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocHJlZml4ID8gYCR7cHJlZml4fS4ke2tleX1gIDoga2V5KTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtIGluIHRoZSBicm93c2VyJ3MgbG9jYWwgc3RvcmFnZVxuICogYXJlYSwgb3Igb24gZWFjaCBpdGVtIGhhdmluZyBhIGdpdmVuIHByZWZpeC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggZm9yIHRoZSBrZXlzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgbm90XG4gKiAgIGdpdmVuLCB0aGVuIGFsbCBpdGVtcyB3aWxsIGJlIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqICAgbWF0Y2hpbmcgc3RvcmFnZSBpdGVtLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgdGhlIGtleSAoYnkgZGVmYXVsdFxuICogICB3aXRob3V0IHRoZSBwcmVmaXgpLCB0aGUgdmFsdWUgKHVubGVzcyB1c2luZyB0aGUgbm9WYWx1ZSBvcHRpb24pLCBhbmQgdGhlXG4gKiAgIGluZGV4LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvYmplY3QgaG9sZGluZyBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZVxuICogICBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZVByZWZpeF0gSWYgc2V0IHRvIHRydWUsIHRoZW4gdGhlIGNhbGxiYWNrXG4gKiAgIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgZnVsbCBrZXksIHdpdGggdGhlIHByZWZpeCBpbmNsdWRlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9WYWx1ZV0gSWYgc2V0IHRvIHRydWUsIHRoZW4gb25seSB0aGUga2V5IGFuZFxuICogICBpbmRleCBmb3IgdGhlIGRhdGEgaXRlbSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uIEJ5IG5vdFxuICogICByZXRyaWV2aW5nIGFuZCBkZXNlcmlhbGl6aW5nIGV2ZXJ5IHZhbHVlLCB0aGlzIGNhbiBzYXZlIHRpbWUgaWYgdGhlIGNhbGxlclxuICogICBkb2VzIG5vdCBuZWVkIGV2ZXJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRGF0YUl0ZW0ocHJlZml4LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChpc0xvY2FsU3RvcmFnZVN1cHBvcnRlZCgpKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JhZ2UubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGtleSA9IHN0b3JhZ2Uua2V5KGkpO1xuICAgICAgaWYgKCFwcmVmaXggfHwga2V5LnN0YXJ0c1dpdGgoYCR7cHJlZml4fS5gKSkge1xuICAgICAgICBjb25zdCBsb2NhbEtleSA9IChwcmVmaXggJiYgIW9wdGlvbnMuaW5jbHVkZVByZWZpeClcbiAgICAgICAgICA/IGtleS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCArIDEpIDoga2V5O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMubm9WYWx1ZSA/IG51bGwgOiByZXRyaWV2ZURhdGEobnVsbCwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUpIGNhbGxiYWNrKGxvY2FsS2V5LCB2YWx1ZSwgaSk7XG4gICAgICAgIGVsc2UgY2FsbGJhY2sobG9jYWxLZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENsZWFyIGFsbCBkYXRhIGZyb20gdGhlIGJyb3dzZXIncyBsb2NhbCBzdG9yYWdlLiBJZiBsb2NhbCBzdG9yYWdlIGlzXG4gKiB1bnN1cHBvcnRlZCBvciBkaXNhYmxlZCwgbm90aGluZyBoYXBwZW5zLlxuICogQHBhcmFtIHs/c3RyaW5nfSBwcmVmaXggVGhlIHByZWZpeCBmb3IgdGhlIGtleXMgdG8gYmUgcmVtb3ZlZC4gSWYgbm90IGdpdmVuLFxuICogICB0aGVuIGV2ZXJ5dGhpbmcgc3RvcmVkIGluIGxvY2FsIHN0b3JhZ2Ugd2lsbCBiZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBjbGVhckRhdGEocHJlZml4KSB7XG4gIGlmIChpc0xvY2FsU3RvcmFnZVN1cHBvcnRlZCgpKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgZm9yRWFjaERhdGFJdGVtKFxuICAgICAgICBwcmVmaXgsXG4gICAgICAgIChrZXkpID0+IGtleXMucHVzaChrZXkpLFxuICAgICAgICB7IGluY2x1ZGVQcmVmaXg6IHRydWUsIG5vVmFsdWU6IHRydWUgfSxcbiAgICAgICk7XG4gICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4gcmVtb3ZlRGF0YShudWxsLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmFnZS5jbGVhcigpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdGV4dCBmaWxlLCBhbmQgcHJlc2VudCBpdCB0byB0aGUgdXNlciBhcyBhIGRvd25sb2FkLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgVGhlIHRleHQgZGF0YSB0byBzdG9yZSBpbiB0aGUgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSBUaGUgZGVmYXVsdCBmaWxlIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9dGV4dC9wbGFpbl0gVGhlIEludGVybmV0IG1lZGlhIHR5cGUgZm9yIHRoZSBmaWxlLiBGb3JcbiAqICAgZXhhbXBsZSwgJ2FwcGxpY2F0aW9uL2pzb24nIHdvdWxkIGluZGljYXRlIGEgSlNPTiBmaWxlLCBhbmQgJ3RleHQvY3N2J1xuICogICB3b3VsZCBpbmRpY2F0ZSBhIGZpbGUgY29udGFpbmluZyBjb21tYS1zZXBhcmF0ZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUZpbGUoY29udGVudCwgZmlsZW5hbWUsIHR5cGUgPSAndGV4dC9wbGFpbicpIHtcbiAgY29uc3QgZGF0YSA9IG5ldyBCbG9iKFtjb250ZW50XSwgeyB0eXBlIH0pO1xuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGEpO1xuXG4gIGNvbnN0IGxpbmtFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBsaW5rRWxlbS5ocmVmID0gdXJsO1xuICBsaW5rRWxlbS5kb3dubG9hZCA9IGZpbGVuYW1lO1xuICBsaW5rRWxlbS5jbGljaygpO1xuICBzZXRUaW1lb3V0KCgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwodXJsKSwgMCk7XG59XG5cbi8qKlxuICogUmVhZCB0aGUgY29udGVudHMgb2YgYSB0ZXh0IGZpbGUuIFRoZSBmaWxlIGNvbnRlbnRzIGFyZSBwYXNzZWQgdG8gdGhlXG4gKiBzcGVjaWZpZWQgY2FsbGJhY2sgZnVuY3Rpb24gb25jZSB0aGUgcmVhZCBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGUgVGhlIGZpbGUgdG8gYmUgcmVhZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgZmlsZVxuICogICBjb250ZW50cy4gSWYgYW4gZXJyb3Igb2NjdXJzLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYVxuICogICBudWxsIGFyZ3VtZW50IGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRGaWxlKGZpbGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4gY2FsbGJhY2socmVhZGVyLnJlc3VsdCkpO1xuICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiBjYWxsYmFjayhudWxsKSk7XG4gIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGNhbGxiYWNrKG51bGwpKTtcbiAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBzdHJpbmdzIHRvIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXMgKENTViBmb3JtYXQsIGFzXG4gKiBkZXNjcmliZWQgYnkgdGhlXG4gKiBbUkZDIDQxODBde0BsaW5rIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDE4MH1cbiAqIHNwZWNpZmljYXRpb24pLiBUaGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIG9uZSBDU1YgcmVjb3JkLCB3aGljaCBjYW4gdGhlbiBiZVxuICogY29tYmluZWQgd2l0aCBvdGhlciByZWNvcmRzIHRvIGZvcm0gYSBjb21wbGV0ZSBDU1YgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGRhdGEgQW4gYXJyYXkgb2Ygc3RyaW5ncyBzcGVjaWZ5aW5nIHRoZSB2YWx1ZXMgZm9yIHRoZVxuICogICBmaWVsZHMgaW4gdGhlIHJlY29yZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gQW4gb2JqZWN0IHNwZWNpZnlpbmcgb3B0aW9ucyBmb3IgdGhlXG4gKiAgIGNvbnZlcnNpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmV3bGluZVNlcXVlbmNlXSBUaGUgY2hhcmFjdGVyIHNlcXVlbmNlIHRvIHVzZSBmb3JcbiAqICAgbmV3bGluZXMuIElmIG5vdCBwcm92aWRlZCwgYSBjYXJyaWFnZSByZXR1cm4vbGluZSBmZWVkIHBhaXIgKENSTEYpIGlzXG4gKiAgIHVzZWQuIEFsbCBuZXdsaW5lIGNoYXJhY3RlcnMgd2l0aGluIGVhY2ggZmllbGQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGlzXG4gKiAgIHNlcXVlbmNlLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlY29yZCBpbiBDU1YgZm9ybWF0LiBUaGUgcmV0dXJuZWQgc3RyaW5nIGlzIG5vdFxuICogICB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSwgYnV0IG1heSBjb250YWluIHF1b3RlZCBuZXdsaW5lcyB3aXRoaW4gdGhlIGZpZWxkXG4gKiAgIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9Dc3ZSZWNvcmQoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZSA9IG9wdGlvbnMubmV3bGluZVNlcXVlbmNlID8/ICdcXHJcXG4nO1xuXG4gIGNvbnN0IGZpZWxkcyA9IFtdO1xuICBkYXRhLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgbGV0IG5lZWRRdW90ZXMgPSBmYWxzZTtcbiAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKC8sfFwifFxcclxcbnxcXG58XFxyL2csIChtYXRjaCkgPT4ge1xuICAgICAgbmVlZFF1b3RlcyA9IHRydWU7XG4gICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICByZXR1cm4gJ1wiXCInO1xuICAgICAgICBjYXNlICdcXHJcXG4nOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgIHJldHVybiBuZXdsaW5lU2VxdWVuY2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZmllbGRzLnB1c2gobmVlZFF1b3RlcyA/IGBcIiR7cmVzdWx0fVwiYCA6IHJlc3VsdCk7XG4gIH0pO1xuXG4gIHJldHVybiBmaWVsZHMuam9pbignLCcpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZGF0YSBpbiBjb21tYS1zZXBhcmF0ZWQgdmFsdWUgKENTVikgZm9ybWF0IGludG8gYW4gYXJyYXkgb2YgYXJyYXlzXG4gKiBvZiBzdHJpbmdzLiBFYWNoIGRhdGEgcmVjb3JkIGlzIHN0b3JlZCBhcyBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGhpbiB0aGVcbiAqIG91dGVyIGFycmF5LCB3aXRoIGVhY2ggc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gYSBmaWVsZCBpbiB0aGUgcmVjb3JkLiBBbnlcbiAqIG5ld2xpbmUgc2VxdWVuY2VzIChDUkxGLCBMRiwgb3IgQ1IpIGFyZSBjb252ZXJ0ZWQgdG8gbGluZWZlZWQgKExGKVxuICogY2hhcmFjdGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBkYXRhIGluIENTViBmb3JtYXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nW11bXX0gQW4gYXJyYXkgb2Ygc3RyaW5nIGFycmF5cy4gRWFjaCBpbm5lciBhcnJheSBjb250YWluc1xuICogICB0aGUgZmllbGRzIGZvciBvbmUgcmVjb3JkLlxuICovXG5mdW5jdGlvbiBwYXJzZUNzdihkYXRhKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIGxldCBjdXJyZW50Um93ID0gW107XG4gIGxldCBjdXJyZW50RmllbGQgPSAnJztcblxuICBjb25zdCBjb21taXRGaWVsZCA9ICgpID0+IHtcbiAgICBjdXJyZW50Um93LnB1c2goY3VycmVudEZpZWxkKTtcbiAgICBjdXJyZW50RmllbGQgPSAnJztcbiAgfTtcbiAgY29uc3QgY29tbWl0Um93ID0gKCkgPT4ge1xuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRSb3cpO1xuICAgIGN1cnJlbnRSb3cgPSBbXTtcbiAgfTtcblxuICBsZXQgcXVvdGVkID0gZmFsc2U7XG4gIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGRhdGEubGVuZ3RoOyBwb3MgKz0gMSkge1xuICAgIHN3aXRjaCAoZGF0YVtwb3NdKSB7XG4gICAgICBjYXNlICdcIic6XG4gICAgICAgIGlmICghcXVvdGVkKSB7XG4gICAgICAgICAgcXVvdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgKyAxIDwgZGF0YS5sZW5ndGggJiYgZGF0YVtwb3MgKyAxXSA9PT0gJ1wiJykge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBkb3VibGUgZG91YmxlIHF1b3RlLCBzbyBjb252ZXJ0IGl0IGFuZCBtb3ZlIHRvIG5leHQgY2hhclxuICAgICAgICAgIGN1cnJlbnRGaWVsZCArPSAnXCInO1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdCBhIGRvdWJsZSBkb3VibGUgcXVvdGUsIHNvIHRoZSBxdW90aW5nIGVuZHMgaGVyZVxuICAgICAgICAgIHF1b3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnXFxyJzpcbiAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIC8vIEhhbmRsZSBDUkxGIHNlcXVlbmNlXG4gICAgICAgIGlmIChkYXRhW3Bvc10gPT09ICdcXHInXG4gICAgICAgICAgJiYgcG9zICsgMSA8IGRhdGEubGVuZ3RoICYmIGRhdGFbcG9zICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXVvdGVkKSB7XG4gICAgICAgICAgY3VycmVudEZpZWxkICs9ICdcXG4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEZpZWxkKCk7XG4gICAgICAgICAgY29tbWl0Um93KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcsJzpcbiAgICAgICAgaWYgKHF1b3RlZCkgY3VycmVudEZpZWxkICs9ICcsJztcbiAgICAgICAgZWxzZSBjb21taXRGaWVsZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGN1cnJlbnRGaWVsZCArPSBkYXRhW3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbW1pdCBsYXN0IGVudHJ5IGlmIGxhc3QgY2hhcmFjdGVyIHdhcyBub3QgYSBuZXdsaW5lXG4gIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBsYXN0Q2hhciA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoYXIgIT09ICdcXHInICYmIGxhc3RDaGFyICE9PSAnXFxuJykge1xuICAgICAgY29tbWl0RmllbGQoKTtcbiAgICAgIGNvbW1pdFJvdygpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgZXh0ZW5zaW9uIGZyb20gYSBmaWxlIG5hbWUuIFRoZSBleHRlbnNpb24sIGZvciB0aGUgcHVycG9zZXMgb2ZcbiAqIHRoaXMgZnVuY3Rpb24sIGlzIGNvbnNpZGVyZWQgdG8gYmUgdGhlIHBvcnRpb24gb2YgdGhlIGZpbGVuYW1lIHN0YXJ0aW5nIGZyb21cbiAqIChhbmQgaW5jbHVkaW5nKSB0aGUgbGFzdCBwZXJpb2QgaW4gdGhlIG5hbWUgYW5kIGV4dGVuZGluZyB0byB0aGUgZW5kIG9mIHRoZVxuICogbmFtZS4gSWYgdGhlcmUgaXMgbm8gcGVyaW9kIGluIHRoZSBuYW1lLCBvciBpZiB0aGUgb25seSBwZXJpb2QgaXMgbG9jYXRlZCBhdFxuICogdGhlIHZlcnkgc3RhcnQgb2YgdGhlIG5hbWUgKGFzIHNlZW4gd2l0aCBkb3RmaWxlcyBvbiBVbml4IHN5c3RlbXMsIGZvclxuICogZXhhbXBsZSksIHRoZW4gdGhlIGZpbGUgaXMgY29uc2lkZXJlZCB0byBoYXZlIG5vIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmaWxlJ3MgZXh0ZW5zaW9uLCBpbmNsdWRpbmcgdGhlIHBlcmlvZC4gSWYgdGhlIGZpbGVcbiAqICAgaGFzIG5vIGV4dGVuc2lvbiwgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBnZXRGaWxlRXh0ZW5zaW9uKGZpbGVuYW1lKSB7XG4gIGNvbnN0IGluZGV4ID0gZmlsZW5hbWUubGFzdEluZGV4T2YoJy4nKTtcbiAgcmV0dXJuIChpbmRleCA+IDApID8gZmlsZW5hbWUuc3Vic3RyaW5nKGluZGV4KSA6ICcnO1xufVxuXG5leHBvcnQge1xuICBhcnJheVRvQ3N2UmVjb3JkLFxuICBjbGVhckRhdGEsXG4gIGZvckVhY2hEYXRhSXRlbSxcbiAgZ2VuZXJhdGVGaWxlLFxuICBnZXRGaWxlRXh0ZW5zaW9uLFxuICBpc0xvY2FsU3RvcmFnZVN1cHBvcnRlZCxcbiAgcGFyc2VDc3YsXG4gIHJlYWRGaWxlLFxuICByZW1vdmVEYXRhLFxuICByZXRyaWV2ZURhdGEsXG4gIHN0b3JlRGF0YSxcbn07XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi92YXJpYWJsZXMuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZGF0ZVBpY2tlci5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzJfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9maWx0ZXJNZW51LmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfM19fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2Zvcm0uY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF80X19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbW9kYWwuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF81X19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vcG9wdXBNZW51LmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNl9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3Rhc2tQYW5lbC5jc3NcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJAaW1wb3J0IHVybChodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PUNhcnRlcitPbmUmZGlzcGxheT1zd2FwKTtcIl0pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9TWF0ZXJpYWwrSWNvbnMpO1wiXSk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMF9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMV9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMl9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfM19fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNF9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNV9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNl9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiBVc2UgYWx0ZXJuYXRpdmUgYm94IG1vZGVsICovXFxuaHRtbCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4qLCAqOjpiZWZvcmUsICo6OmFmdGVyIHtcXG4gIGJveC1zaXppbmc6IGluaGVyaXQ7XFxufVxcblxcbmJvZHkge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWNvbnRlbnQtZm9udCk7XFxufVxcblxcbmEsIGE6dmlzaXRlZCB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcblxcbmE6aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcblxcbiNhcHAge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG5cXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxufVxcblxcbiNoZWFkZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBoZWlnaHQ6IHZhcigtLWhlYWRlci1oZWlnaHQpO1xcblxcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwMDBiYjtcXG4gIHBhZGRpbmc6IDEycHg7XFxufVxcblxcbiNoZWFkZXIgLmljb24ge1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbn1cXG5cXG4jbWlkZGxlLWNvbnRhaW5lciB7XFxuICBmbGV4OiAxIDEgYXV0bztcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IGNhbGMoMTAwJSAtIHZhcigtLWhlYWRlci1oZWlnaHQpIC0gdmFyKC0tZm9vdGVyLWhlaWdodCkpO1xcbn1cXG5cXG4jc2lkZS1wYW5lbCB7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zaWRlLXBhbmVsLWJnLWNvbG9yKTtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgd2lkdGg6IDM1MHB4O1xcbiAgbWluLXdpZHRoOiAyNTBweDtcXG4gIG1heC13aWR0aDogbWluKDEwMHZ3LCA1MDBweCk7XFxufVxcblxcbiNtYWluLXBhbmVsIHtcXG4gIGZsZXg6IDEgMSBhdXRvO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuXFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbiNtYWluLXBhbmVsLWhlYWRlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1heC13aWR0aDogdmFyKC0tbWFpbi1jb250ZW50LXdpZHRoKTtcXG4gIG1hcmdpbjogYXV0bztcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBwYWRkaW5nOiAyNHB4IDEycHg7XFxufVxcblxcbiNtYWluLXBhbmVsLWhlYWRpbmctY29udGFpbmVyIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZsZXg6IDE7XFxufVxcblxcbiNtYWluLXBhbmVsLWhlYWRpbmcge1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbiNtYWluLXBhbmVsLXN1YmhlYWRpbmcge1xcbiAgbWFyZ2luLXRvcDogOHB4O1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgY29sb3I6ICM1MDUwNTA7XFxuXFxuICBtYXgtaGVpZ2h0OiA2NHB4O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBsaW5lLWhlaWdodDogbm9ybWFsO1xcbn1cXG5cXG4jbWFpbi1wYW5lbC1oZWFkZXIgLmljb24tY29udGFpbmVyIHtcXG4gIG1hcmdpbi1sZWZ0OiAxMnB4O1xcbn1cXG5cXG4jZm9vdGVyIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyYzJjMzI7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBwYWRkaW5nOiAxMnB4O1xcbiAgaGVpZ2h0OiB2YXIoLS1mb290ZXItaGVpZ2h0KTtcXG5cXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbiNmb290ZXIgYSB7XFxuICBjb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuI2Zvb3RlciBhOmhvdmVyIHtcXG4gIGNvbG9yOiAjYzNjMmZkO1xcbn1cXG5cXG4uY2xvc2VkIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5yZXNpemVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXNpZGUtcGFuZWwtYmctY29sb3IpO1xcbiAgd2lkdGg6IDhweDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGN1cnNvcjogY29sLXJlc2l6ZTtcXG59XFxuXFxuLnJlc2l6ZXIuZHJhZ2dpbmcsIC5yZXNpemVyOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5YjliOWI7XFxufVxcblxcbi5pY29uIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4uaWNvbi1jb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLmljb24tY29udGFpbmVyIC5pY29uIHtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG59XFxuXFxuLmljb24tY29udGFpbmVyID4gKiArICoge1xcbiAgbWFyZ2luLWxlZnQ6IDRweDtcXG59XFxuXFxuLmNvbGxhcHNpYmxlIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0cmFuc2l0aW9uOiBoZWlnaHQgMjUwbXMgZWFzZS1vdXQ7XFxufVxcblxcbi50aXRsZS1jb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi50aXRsZS1jb250YWluZXIgPiAqICsgKiB7XFxuICBtYXJnaW4tbGVmdDogMTJweDtcXG59XFxuXFxuLnRpdGxlIHtcXG4gIGZvbnQtZmFtaWx5OiAnQ2FydGVyIE9uZScsIHNhbnMtc2VyaWY7XFxuICBmb250LXNpemU6IDI0cHg7XFxufVxcblxcbi5kYXRhLWltcG9ydC1yZXN1bHRzIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxufVxcblxcbi5kYXRhLWltcG9ydC1lcnJvci1saXN0IHtcXG4gIGxpc3Qtc3R5bGU6IGRpc2MgaW5zaWRlO1xcbn1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNDAwcHgpIHtcXG4gIC50aXRsZS1jb250YWluZXIgLnRpdGxlIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtYXgtaGVpZ2h0OiA1MDBweCkge1xcbiAgI21haW4tcGFuZWwtc3ViaGVhZGluZyB7XFxuICAgIG1heC1oZWlnaHQ6IDI0cHg7XFxuICB9XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvbWFpbi5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBV0EsOEJBQThCO0FBQzlCO0VBQ0Usc0JBQXNCO0FBQ3hCO0FBQ0E7RUFDRSxtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxnQ0FBZ0M7QUFDbEM7O0FBRUE7RUFDRSxxQkFBcUI7QUFDdkI7O0FBRUE7RUFDRSwwQkFBMEI7QUFDNUI7O0FBRUE7RUFDRSxhQUFhO0VBQ2Isc0JBQXNCO0VBQ3RCLHVCQUF1Qjs7RUFFdkIsWUFBWTtFQUNaLGFBQWE7QUFDZjs7QUFFQTtFQUNFLGFBQWE7RUFDYiw4QkFBOEI7RUFDOUIsbUJBQW1CO0VBQ25CLDRCQUE0Qjs7RUFFNUIsWUFBWTtFQUNaLHlCQUF5QjtFQUN6QixhQUFhO0FBQ2Y7O0FBRUE7RUFDRSxlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsY0FBYztFQUNkLGFBQWE7RUFDYixnRUFBZ0U7QUFDbEU7O0FBRUE7RUFDRSxZQUFZO0VBQ1osNENBQTRDO0VBQzVDLGNBQWM7RUFDZCxZQUFZO0VBQ1osZ0JBQWdCO0VBQ2hCLDRCQUE0QjtBQUM5Qjs7QUFFQTtFQUNFLGNBQWM7RUFDZCxZQUFZO0VBQ1osY0FBYzs7RUFFZCxhQUFhO0VBQ2Isc0JBQXNCO0VBQ3RCLDJCQUEyQjtFQUMzQixtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsb0NBQW9DO0VBQ3BDLFlBQVk7RUFDWixhQUFhO0VBQ2IsOEJBQThCO0VBQzlCLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLDhCQUE4QjtFQUM5QixPQUFPO0FBQ1Q7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsZUFBZTtFQUNmLGVBQWU7RUFDZixxQkFBcUI7RUFDckIsY0FBYzs7RUFFZCxnQkFBZ0I7RUFDaEIsY0FBYztFQUNkLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLFlBQVk7RUFDWix5QkFBeUI7RUFDekIsZUFBZTtFQUNmLGFBQWE7RUFDYiw0QkFBNEI7O0VBRTVCLGFBQWE7RUFDYix1QkFBdUI7RUFDdkIsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxhQUFhO0FBQ2Y7O0FBRUE7RUFDRSw0Q0FBNEM7RUFDNUMsVUFBVTtFQUNWLFlBQVk7RUFDWixrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSx5QkFBeUI7QUFDM0I7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsYUFBYTtBQUNmOztBQUVBO0VBQ0UsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLGdCQUFnQjtFQUNoQixpQ0FBaUM7QUFDbkM7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UscUNBQXFDO0VBQ3JDLGVBQWU7QUFDakI7O0FBRUE7RUFDRSw4QkFBOEI7RUFDOUIsZUFBZTtFQUNmLHFCQUFxQjtFQUNyQixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSx1QkFBdUI7QUFDekI7O0FBRUE7RUFDRTtJQUNFLGFBQWE7RUFDZjtBQUNGOztBQUVBO0VBQ0U7SUFDRSxnQkFBZ0I7RUFDbEI7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0IHVybCgnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1DYXJ0ZXIrT25lJmRpc3BsYXk9c3dhcCcpO1xcbkBpbXBvcnQgdXJsKCdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PU1hdGVyaWFsK0ljb25zJyk7XFxuXFxuQGltcG9ydCAnLi92YXJpYWJsZXMuY3NzJztcXG5AaW1wb3J0ICcuL2RhdGVQaWNrZXIuY3NzJztcXG5AaW1wb3J0ICcuL2ZpbHRlck1lbnUuY3NzJztcXG5AaW1wb3J0ICcuL2Zvcm0uY3NzJztcXG5AaW1wb3J0ICcuL21vZGFsLmNzcyc7XFxuQGltcG9ydCAnLi9wb3B1cE1lbnUuY3NzJztcXG5AaW1wb3J0ICcuL3Rhc2tQYW5lbC5jc3MnO1xcblxcbi8qIFVzZSBhbHRlcm5hdGl2ZSBib3ggbW9kZWwgKi9cXG5odG1sIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbiosICo6OmJlZm9yZSwgKjo6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogaW5oZXJpdDtcXG59XFxuXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogdmFyKC0tY29udGVudC1mb250KTtcXG59XFxuXFxuYSwgYTp2aXNpdGVkIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuYTpob3ZlciB7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuXFxuI2FwcCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcblxcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG59XFxuXFxuI2hlYWRlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGhlaWdodDogdmFyKC0taGVhZGVyLWhlaWdodCk7XFxuXFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwMGJiO1xcbiAgcGFkZGluZzogMTJweDtcXG59XFxuXFxuI2hlYWRlciAuaWNvbiB7XFxuICBmb250LXNpemU6IDI0cHg7XFxufVxcblxcbiNtaWRkbGUtY29udGFpbmVyIHtcXG4gIGZsZXg6IDEgMSBhdXRvO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0taGVhZGVyLWhlaWdodCkgLSB2YXIoLS1mb290ZXItaGVpZ2h0KSk7XFxufVxcblxcbiNzaWRlLXBhbmVsIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXNpZGUtcGFuZWwtYmctY29sb3IpO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICB3aWR0aDogMzUwcHg7XFxuICBtaW4td2lkdGg6IDI1MHB4O1xcbiAgbWF4LXdpZHRoOiBtaW4oMTAwdncsIDUwMHB4KTtcXG59XFxuXFxuI21haW4tcGFuZWwge1xcbiAgZmxleDogMSAxIGF1dG87XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdzogYXV0bztcXG5cXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuI21haW4tcGFuZWwtaGVhZGVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiB2YXIoLS1tYWluLWNvbnRlbnQtd2lkdGgpO1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIHBhZGRpbmc6IDI0cHggMTJweDtcXG59XFxuXFxuI21haW4tcGFuZWwtaGVhZGluZy1jb250YWluZXIge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZmxleDogMTtcXG59XFxuXFxuI21haW4tcGFuZWwtaGVhZGluZyB7XFxuICBmb250LXNpemU6IDI0cHg7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuI21haW4tcGFuZWwtc3ViaGVhZGluZyB7XFxuICBtYXJnaW4tdG9wOiA4cHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICBjb2xvcjogIzUwNTA1MDtcXG5cXG4gIG1heC1oZWlnaHQ6IDY0cHg7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGxpbmUtaGVpZ2h0OiBub3JtYWw7XFxufVxcblxcbiNtYWluLXBhbmVsLWhlYWRlciAuaWNvbi1jb250YWluZXIge1xcbiAgbWFyZ2luLWxlZnQ6IDEycHg7XFxufVxcblxcbiNmb290ZXIge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJjMmMzMjtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIHBhZGRpbmc6IDEycHg7XFxuICBoZWlnaHQ6IHZhcigtLWZvb3Rlci1oZWlnaHQpO1xcblxcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuI2Zvb3RlciBhIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4jZm9vdGVyIGE6aG92ZXIge1xcbiAgY29sb3I6ICNjM2MyZmQ7XFxufVxcblxcbi5jbG9zZWQge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLnJlc2l6ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2lkZS1wYW5lbC1iZy1jb2xvcik7XFxuICB3aWR0aDogOHB4O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgY3Vyc29yOiBjb2wtcmVzaXplO1xcbn1cXG5cXG4ucmVzaXplci5kcmFnZ2luZywgLnJlc2l6ZXI6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzliOWI5YjtcXG59XFxuXFxuLmljb24ge1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbi5pY29uLWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG5cXG4uaWNvbi1jb250YWluZXIgLmljb24ge1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbn1cXG5cXG4uaWNvbi1jb250YWluZXIgPiAqICsgKiB7XFxuICBtYXJnaW4tbGVmdDogNHB4O1xcbn1cXG5cXG4uY29sbGFwc2libGUge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHRyYW5zaXRpb246IGhlaWdodCAyNTBtcyBlYXNlLW91dDtcXG59XFxuXFxuLnRpdGxlLWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLnRpdGxlLWNvbnRhaW5lciA+ICogKyAqIHtcXG4gIG1hcmdpbi1sZWZ0OiAxMnB4O1xcbn1cXG5cXG4udGl0bGUge1xcbiAgZm9udC1mYW1pbHk6ICdDYXJ0ZXIgT25lJywgc2Fucy1zZXJpZjtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG59XFxuXFxuLmRhdGEtaW1wb3J0LXJlc3VsdHMge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG59XFxuXFxuLmRhdGEtaW1wb3J0LWVycm9yLWxpc3Qge1xcbiAgbGlzdC1zdHlsZTogZGlzYyBpbnNpZGU7XFxufVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA0MDBweCkge1xcbiAgLnRpdGxlLWNvbnRhaW5lciAudGl0bGUge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcbn1cXG5cXG5AbWVkaWEgKG1heC1oZWlnaHQ6IDUwMHB4KSB7XFxuICAjbWFpbi1wYW5lbC1zdWJoZWFkaW5nIHtcXG4gICAgbWF4LWhlaWdodDogMjRweDtcXG4gIH1cXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLypcXG4gKiBBZGFwdGVkIGZyb206XFxuICogaHR0cDovL21leWVyd2ViLmNvbS9lcmljL3Rvb2xzL2Nzcy9yZXNldC9cXG4gKiB2Mi4wIC0gMjAxMS0wMS0yNlxcbiAqL1xcblxcbmh0bWwsIGJvZHksIGRpdiwgc3BhbiwgYXBwbGV0LCBvYmplY3QsIGlmcmFtZSxcXG5oMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwLCBibG9ja3F1b3RlLCBwcmUsXFxuYSwgYWJiciwgYWNyb255bSwgYWRkcmVzcywgYmlnLCBjaXRlLCBjb2RlLFxcbmRlbCwgZGZuLCBlbSwgaW1nLCBpbnMsIGtiZCwgcSwgcywgc2FtcCxcXG5zbWFsbCwgc3RyaWtlLCBzdHJvbmcsIHN1Yiwgc3VwLCB0dCwgdmFyLFxcbmIsIHUsIGksIGNlbnRlcixcXG5kbCwgZHQsIGRkLCBvbCwgdWwsIGxpLFxcbmZpZWxkc2V0LCBmb3JtLCBsYWJlbCwgbGVnZW5kLFxcbnRhYmxlLCBjYXB0aW9uLCB0Ym9keSwgdGZvb3QsIHRoZWFkLCB0ciwgdGgsIHRkLFxcbmFydGljbGUsIGFzaWRlLCBjYW52YXMsIGRldGFpbHMsIGVtYmVkLFxcbmZpZ3VyZSwgZmlnY2FwdGlvbiwgZm9vdGVyLCBoZWFkZXIsIGhncm91cCxcXG5tZW51LCBuYXYsIG91dHB1dCwgcnVieSwgc2VjdGlvbiwgc3VtbWFyeSxcXG50aW1lLCBtYXJrLCBhdWRpbywgdmlkZW8sXFxuaW5wdXQsIGJ1dHRvbiwgc2VsZWN0LCB0ZXh0YXJlYSB7XFxuXFx0bWFyZ2luOiAwO1xcblxcdHBhZGRpbmc6IDA7XFxuXFx0Ym9yZGVyOiAwO1xcblxcdGZvbnQtc2l6ZTogMTAwJTtcXG5cXHRmb250OiBpbmhlcml0O1xcblxcdHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuLyogSFRNTDUgZGlzcGxheS1yb2xlIHJlc2V0IGZvciBvbGRlciBicm93c2VycyAqL1xcbmFydGljbGUsIGFzaWRlLCBkZXRhaWxzLCBmaWdjYXB0aW9uLCBmaWd1cmUsXFxuZm9vdGVyLCBoZWFkZXIsIGhncm91cCwgbWVudSwgbmF2LCBzZWN0aW9uIHtcXG5cXHRkaXNwbGF5OiBibG9jaztcXG59XFxuYm9keSB7XFxuXFx0bGluZS1oZWlnaHQ6IDE7XFxufVxcbm9sLCB1bCB7XFxuXFx0bGlzdC1zdHlsZTogbm9uZTtcXG59XFxuYmxvY2txdW90ZSwgcSB7XFxuXFx0cXVvdGVzOiBub25lO1xcbn1cXG5ibG9ja3F1b3RlOmJlZm9yZSwgYmxvY2txdW90ZTphZnRlcixcXG5xOmJlZm9yZSwgcTphZnRlciB7XFxuXFx0Y29udGVudDogJyc7XFxuXFx0Y29udGVudDogbm9uZTtcXG59XFxudGFibGUge1xcblxcdGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuXFx0Ym9yZGVyLXNwYWNpbmc6IDA7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvcmVzZXQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOzs7O0VBSUU7O0FBRUY7Ozs7Ozs7Ozs7Ozs7O0NBY0MsU0FBUztDQUNULFVBQVU7Q0FDVixTQUFTO0NBQ1QsZUFBZTtDQUNmLGFBQWE7Q0FDYix3QkFBd0I7QUFDekI7QUFDQSxnREFBZ0Q7QUFDaEQ7O0NBRUMsY0FBYztBQUNmO0FBQ0E7Q0FDQyxjQUFjO0FBQ2Y7QUFDQTtDQUNDLGdCQUFnQjtBQUNqQjtBQUNBO0NBQ0MsWUFBWTtBQUNiO0FBQ0E7O0NBRUMsV0FBVztDQUNYLGFBQWE7QUFDZDtBQUNBO0NBQ0MseUJBQXlCO0NBQ3pCLGlCQUFpQjtBQUNsQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKlxcbiAqIEFkYXB0ZWQgZnJvbTpcXG4gKiBodHRwOi8vbWV5ZXJ3ZWIuY29tL2VyaWMvdG9vbHMvY3NzL3Jlc2V0L1xcbiAqIHYyLjAgLSAyMDExLTAxLTI2XFxuICovXFxuXFxuaHRtbCwgYm9keSwgZGl2LCBzcGFuLCBhcHBsZXQsIG9iamVjdCwgaWZyYW1lLFxcbmgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHAsIGJsb2NrcXVvdGUsIHByZSxcXG5hLCBhYmJyLCBhY3JvbnltLCBhZGRyZXNzLCBiaWcsIGNpdGUsIGNvZGUsXFxuZGVsLCBkZm4sIGVtLCBpbWcsIGlucywga2JkLCBxLCBzLCBzYW1wLFxcbnNtYWxsLCBzdHJpa2UsIHN0cm9uZywgc3ViLCBzdXAsIHR0LCB2YXIsXFxuYiwgdSwgaSwgY2VudGVyLFxcbmRsLCBkdCwgZGQsIG9sLCB1bCwgbGksXFxuZmllbGRzZXQsIGZvcm0sIGxhYmVsLCBsZWdlbmQsXFxudGFibGUsIGNhcHRpb24sIHRib2R5LCB0Zm9vdCwgdGhlYWQsIHRyLCB0aCwgdGQsXFxuYXJ0aWNsZSwgYXNpZGUsIGNhbnZhcywgZGV0YWlscywgZW1iZWQsXFxuZmlndXJlLCBmaWdjYXB0aW9uLCBmb290ZXIsIGhlYWRlciwgaGdyb3VwLFxcbm1lbnUsIG5hdiwgb3V0cHV0LCBydWJ5LCBzZWN0aW9uLCBzdW1tYXJ5LFxcbnRpbWUsIG1hcmssIGF1ZGlvLCB2aWRlbyxcXG5pbnB1dCwgYnV0dG9uLCBzZWxlY3QsIHRleHRhcmVhIHtcXG5cXHRtYXJnaW46IDA7XFxuXFx0cGFkZGluZzogMDtcXG5cXHRib3JkZXI6IDA7XFxuXFx0Zm9udC1zaXplOiAxMDAlO1xcblxcdGZvbnQ6IGluaGVyaXQ7XFxuXFx0dmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG4vKiBIVE1MNSBkaXNwbGF5LXJvbGUgcmVzZXQgZm9yIG9sZGVyIGJyb3dzZXJzICovXFxuYXJ0aWNsZSwgYXNpZGUsIGRldGFpbHMsIGZpZ2NhcHRpb24sIGZpZ3VyZSxcXG5mb290ZXIsIGhlYWRlciwgaGdyb3VwLCBtZW51LCBuYXYsIHNlY3Rpb24ge1xcblxcdGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5ib2R5IHtcXG5cXHRsaW5lLWhlaWdodDogMTtcXG59XFxub2wsIHVsIHtcXG5cXHRsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5ibG9ja3F1b3RlLCBxIHtcXG5cXHRxdW90ZXM6IG5vbmU7XFxufVxcbmJsb2NrcXVvdGU6YmVmb3JlLCBibG9ja3F1b3RlOmFmdGVyLFxcbnE6YmVmb3JlLCBxOmFmdGVyIHtcXG5cXHRjb250ZW50OiAnJztcXG5cXHRjb250ZW50OiBub25lO1xcbn1cXG50YWJsZSB7XFxuXFx0Ym9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG5cXHRib3JkZXItc3BhY2luZzogMDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLmRhdGUtcGlja2VyLWhlYWRpbmcge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5kYXRlLXBpY2tlci1oZWFkaW5nIHNlbGVjdCwgLmRhdGUtcGlja2VyLWhlYWRpbmcgaW5wdXQge1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbn1cXG5cXG4uZGF0ZS1waWNrZXItZ3JpZCB7XFxuICBtYXJnaW46IDEycHggMDtcXG4gIGRpc3BsYXk6IGdyaWQ7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg3LCAxZnIpO1xcbiAgZ2FwOiA2cHg7XFxufVxcblxcbi5kYXRlLXBpY2tlci1kYXktaGVhZGVyLCAuZGF0ZS1waWNrZXItZGF5IHtcXG4gIHdpZHRoOiA0MHB4O1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgbGluZS1oZWlnaHQ6IDMycHg7XFxuICBwYWRkaW5nOiA0cHg7XFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuXFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbn1cXG5cXG4uZGF0ZS1waWNrZXItZGF5LWhlYWRlciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLmRhdGUtcGlja2VyLWRheS5zZWxlY3RlZCB7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMzUsIDM1LCAyMTEpO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbi5kYXRlLXBpY2tlci1kYXkudG9kYXkge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG59XFxuXFxuLmRhdGUtcGlja2VyLWRheS5kaWZmZXJlbnQtbW9udGgge1xcbiAgY29sb3I6ICM3MDcwNzA7XFxufVxcblxcbi5kYXRlLXBpY2tlci1kYXkuc2VsZWN0ZWQuZGlmZmVyZW50LW1vbnRoIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMzUsIDM1LCAyMTEsIDAuNSk7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvZGF0ZVBpY2tlci5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxhQUFhO0VBQ2IsOEJBQThCO0VBQzlCLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxjQUFjO0VBQ2QsYUFBYTtFQUNiLHFDQUFxQztFQUNyQyxRQUFRO0FBQ1Y7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsWUFBWTtFQUNaLGlCQUFpQjtFQUNqQixZQUFZO0VBQ1osOEJBQThCO0VBQzlCLGVBQWU7RUFDZixrQkFBa0I7O0VBRWxCLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLFlBQVk7RUFDWixrQ0FBa0M7RUFDbEMsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsaUJBQWlCO0VBQ2pCLHVCQUF1QjtBQUN6Qjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxZQUFZO0VBQ1osd0NBQXdDO0FBQzFDXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5kYXRlLXBpY2tlci1oZWFkaW5nIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uZGF0ZS1waWNrZXItaGVhZGluZyBzZWxlY3QsIC5kYXRlLXBpY2tlci1oZWFkaW5nIGlucHV0IHtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG59XFxuXFxuLmRhdGUtcGlja2VyLWdyaWQge1xcbiAgbWFyZ2luOiAxMnB4IDA7XFxuICBkaXNwbGF5OiBncmlkO1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNywgMWZyKTtcXG4gIGdhcDogNnB4O1xcbn1cXG5cXG4uZGF0ZS1waWNrZXItZGF5LWhlYWRlciwgLmRhdGUtcGlja2VyLWRheSB7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG4gIGxpbmUtaGVpZ2h0OiAzMnB4O1xcbiAgcGFkZGluZzogNHB4O1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcblxcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXG59XFxuXFxuLmRhdGUtcGlja2VyLWRheS1oZWFkZXIge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbi5kYXRlLXBpY2tlci1kYXkuc2VsZWN0ZWQge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDM1LCAzNSwgMjExKTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG4uZGF0ZS1waWNrZXItZGF5LnRvZGF5IHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxufVxcblxcbi5kYXRlLXBpY2tlci1kYXkuZGlmZmVyZW50LW1vbnRoIHtcXG4gIGNvbG9yOiAjNzA3MDcwO1xcbn1cXG5cXG4uZGF0ZS1waWNrZXItZGF5LnNlbGVjdGVkLmRpZmZlcmVudC1tb250aCB7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDM1LCAzNSwgMjExLCAwLjUpO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuZmlsdGVyLW1lbnUge1xcbiAgbWFyZ2luOiAyNHB4O1xcbn1cXG5cXG4uZmlsdGVyLWdyb3VwIHtcXG4gIG1hcmdpbi1ib3R0b206IDEycHg7XFxufVxcblxcbi5maWx0ZXItZ3JvdXAtaGVhZGluZyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgbWFyZ2luLXJpZ2h0OiAycHg7XFxufVxcblxcbi5maWx0ZXItZ3JvdXAtaGVhZGluZyA+IC5pY29uLWNvbnRhaW5lciA+IC5pY29uIHtcXG4gIG1hcmdpbi1sZWZ0OiA0cHg7XFxufVxcblxcbi5maWx0ZXItZ3JvdXAtdG9nZ2xlIHtcXG4gIGZsZXg6IDE7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgcGFkZGluZzogOHB4O1xcbn1cXG5cXG4uZmlsdGVyLWdyb3VwLWV4cGFuZC1pY29uIHtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbi5maWx0ZXItZ3JvdXAtbGFiZWwge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG5cXG4uZmlsdGVyLWxpc3Qge1xcbiAgcGFkZGluZzogMnB4O1xcbn1cXG5cXG4uZmlsdGVyLWl0ZW0ge1xcbiAgbWFyZ2luOiA0cHggMCA2cHggMzJweDtcXG59XFxuXFxuLmZpbHRlci1pdGVtLXNlbGVjdG9yIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgd2lkdGg6IDEwMCU7XFxuXFxuICBwYWRkaW5nOiA4cHg7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBvdXRsaW5lLW9mZnNldDogMDtcXG59XFxuXFxuLmZpbHRlci1pdGVtLXNlbGVjdG9yOmhvdmVyLCAuZmlsdGVyLWl0ZW0uc2VsZWN0ZWQgLmZpbHRlci1pdGVtLXNlbGVjdG9yIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNkYWRhZGE7XFxufVxcblxcbi5maWx0ZXItaXRlbS1sYWJlbCB7XFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGVzL2ZpbHRlck1lbnUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsWUFBWTtBQUNkOztBQUVBO0VBQ0UsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsYUFBYTtFQUNiLDhCQUE4QjtFQUM5QixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxPQUFPO0VBQ1AsZ0JBQWdCO0VBQ2hCLFlBQVk7QUFDZDs7QUFFQTtFQUNFLGVBQWU7RUFDZixzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSw4QkFBOEI7RUFDOUIsZUFBZTtFQUNmLGlCQUFpQjtFQUNqQixzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsOEJBQThCO0VBQzlCLG1CQUFtQjtFQUNuQixXQUFXOztFQUVYLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UseUJBQXlCO0FBQzNCOztBQUVBO0VBQ0UsOEJBQThCO0VBQzlCLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtBQUNyQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZmlsdGVyLW1lbnUge1xcbiAgbWFyZ2luOiAyNHB4O1xcbn1cXG5cXG4uZmlsdGVyLWdyb3VwIHtcXG4gIG1hcmdpbi1ib3R0b206IDEycHg7XFxufVxcblxcbi5maWx0ZXItZ3JvdXAtaGVhZGluZyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgbWFyZ2luLXJpZ2h0OiAycHg7XFxufVxcblxcbi5maWx0ZXItZ3JvdXAtaGVhZGluZyA+IC5pY29uLWNvbnRhaW5lciA+IC5pY29uIHtcXG4gIG1hcmdpbi1sZWZ0OiA0cHg7XFxufVxcblxcbi5maWx0ZXItZ3JvdXAtdG9nZ2xlIHtcXG4gIGZsZXg6IDE7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgcGFkZGluZzogOHB4O1xcbn1cXG5cXG4uZmlsdGVyLWdyb3VwLWV4cGFuZC1pY29uIHtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbi5maWx0ZXItZ3JvdXAtbGFiZWwge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG5cXG4uZmlsdGVyLWxpc3Qge1xcbiAgcGFkZGluZzogMnB4O1xcbn1cXG5cXG4uZmlsdGVyLWl0ZW0ge1xcbiAgbWFyZ2luOiA0cHggMCA2cHggMzJweDtcXG59XFxuXFxuLmZpbHRlci1pdGVtLXNlbGVjdG9yIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgd2lkdGg6IDEwMCU7XFxuXFxuICBwYWRkaW5nOiA4cHg7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBvdXRsaW5lLW9mZnNldDogMDtcXG59XFxuXFxuLmZpbHRlci1pdGVtLXNlbGVjdG9yOmhvdmVyLCAuZmlsdGVyLWl0ZW0uc2VsZWN0ZWQgLmZpbHRlci1pdGVtLXNlbGVjdG9yIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNkYWRhZGE7XFxufVxcblxcbi5maWx0ZXItaXRlbS1sYWJlbCB7XFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJpbnB1dDpmb2N1cywgc2VsZWN0OmZvY3VzLCB0ZXh0YXJlYTpmb2N1cywgYnV0dG9uOmZvY3VzIHtcXG4gIG91dGxpbmU6IDFweCBzb2xpZCBibHVlO1xcbn1cXG5cXG4vKiBVc2UgOmZvY3VzLXZpc2libGUgaWYgYnJvd3NlciBzdXBwb3J0cyBpdCAqL1xcbjppcyhpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYnV0dG9uKTpmb2N1czpub3QoOmZvY3VzLXZpc2libGUpIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbmlucHV0OmludmFsaWQsIHNlbGVjdDppbnZhbGlkLCB0ZXh0YXJlYTppbnZhbGlkIHtcXG4gIG91dGxpbmU6IDFweCBzb2xpZCByZWQ7XFxufVxcblxcbmJ1dHRvbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuaW5wdXRbdHlwZT1cXFwicmFkaW9cXFwiXSwgaW5wdXRbdHlwZT1cXFwiY2hlY2tib3hcXFwiXSB7XFxuICBtYXJnaW46IDAgNnB4O1xcbn1cXG5cXG4udG9nZ2xlLWJ1dHRvbiB7XFxuICBwYWRkaW5nOiA2cHg7XFxuXFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDE0cHg7XFxuXFxuICBjb2xvcjogYmxhY2s7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcblxcbiAgdHJhbnNpdGlvbjogY29sb3IgMTAwbXMsIGJhY2tncm91bmQtY29sb3IgMTAwbXM7XFxufVxcblxcbi50b2dnbGUtYnV0dG9uLmFjdGl2ZSB7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjMyM2QzO1xcbn1cXG5cXG4udG9nZ2xlLWJ1dHRvbi5hY3RpdmU6ZGlzYWJsZWQge1xcbiAgY29sb3I6IHZhcigtLWlucHV0LWRpc2FibGVkLWNvbG9yKTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjOGM4ZjQ7XFxufVxcblxcbi5mb3JtLWlucHV0LWNvbnRhaW5lciB7XFxuICBtYXJnaW46IDEycHggMCAyNHB4O1xcbn1cXG5cXG4uZm9ybS1pbnB1dC1kYXRlLWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5mb3JtLWlucHV0LWRhdGUtY29udGFpbmVyIGlucHV0IHtcXG4gIGZsZXg6IGF1dG87XFxuICBtYXJnaW4tcmlnaHQ6IDZweDtcXG59XFxuXFxuLmZvcm0taW5wdXQtZGF0ZS1jb250YWluZXItaW5saW5lIGlucHV0IHtcXG4gIHdpZHRoOiAxNTBweDtcXG4gIG1hcmdpbi1yaWdodDogNnB4O1xcbn1cXG5cXG4uZm9ybS1pbnB1dC1sYWJlbCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG5cXG4uZm9ybS1pbnB1dC1sYWJlbC1pbmxpbmUge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG5cXG4uZm9ybS1pbnB1dCwgLmZvcm0tc2VsZWN0LCAuZm9ybS10ZXh0YXJlYSB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLmZvcm0taW5wdXQsXFxuLmZvcm0taW5wdXQtaW5saW5lLFxcbi5mb3JtLXNlbGVjdCxcXG4uZm9ybS1zZWxlY3QtaW5saW5lLFxcbi5mb3JtLXRleHRhcmVhLFxcbi5mb3JtLWJ1dHRvbiB7XFxuICBwYWRkaW5nOiA4cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXG5cXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuXFxuLmZvcm0tc2VsZWN0IHtcXG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbn1cXG5cXG4uZm9ybS10ZXh0YXJlYSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIHJlc2l6ZTogdmVydGljYWw7XFxufVxcblxcbi5mb3JtLWJ1dHRvbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLmZvcm0tYnV0dG9uOmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBmMGYwO1xcbn1cXG5cXG4uZm9ybS1idXR0b24tY29udGFpbmVyID4gLmZvcm0tYnV0dG9uICsgLmZvcm0tYnV0dG9uIHtcXG4gIG1hcmdpbi1sZWZ0OiA4cHg7XFxufVxcblxcbi5mb3JtLWlucHV0LWl0ZW0tY29udGFpbmVyIHtcXG4gIHBhZGRpbmc6IDhweCAwO1xcbn1cXG5cXG4uZm9ybS1pbnB1dC1pdGVtLWxhYmVsIHtcXG4gIHBhZGRpbmctbGVmdDogOHB4O1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG5cXG4uZm9ybS1pbnB1dC1pbmxpbmUuZm9ybS1pbnB1dC1jb3VudCB7XFxuICB3aWR0aDogOTBweDtcXG59XFxuXFxuLmZvcm0taW5wdXQtaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5mb3JtLXdlZWtkYXktYnV0dG9uIHtcXG4gIG1hcmdpbjogOHB4IDZweCA4cHggMDtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxufVxcblxcbi5mb3JtLWlucHV0OmRpc2FibGVkLFxcbi5mb3JtLWlucHV0LWlubGluZTpkaXNhYmxlZCxcXG4uZm9ybS1zZWxlY3Q6ZGlzYWJsZWQsXFxuLmZvcm0tc2VsZWN0LWlubGluZTpkaXNhYmxlZCxcXG4uZm9ybS10ZXh0YXJlYTpkaXNhYmxlZCxcXG4uZm9ybS1idXR0b246ZGlzYWJsZWQsXFxuLnRvZ2dsZS1idXR0b246ZGlzYWJsZWQge1xcbiAgY29sb3I6IHZhcigtLWlucHV0LWRpc2FibGVkLWNvbG9yKTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWlucHV0LWRpc2FibGVkLWJnLWNvbG9yKTtcXG4gIGJvcmRlci1jb2xvcjogdmFyKC0taW5wdXQtZGlzYWJsZWQtYmctY29sb3IpO1xcbn1cXG5cXG4uY29uZmlybWF0aW9uLWJveCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi10b3A6IDhweDtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlcy9mb3JtLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLHVCQUF1QjtBQUN6Qjs7QUFFQSw4Q0FBOEM7QUFDOUM7RUFDRSxhQUFhO0FBQ2Y7O0FBRUE7RUFDRSxzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSw2QkFBNkI7RUFDN0Isa0JBQWtCO0VBQ2xCLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxhQUFhO0FBQ2Y7O0FBRUE7RUFDRSxZQUFZOztFQUVaLDhCQUE4QjtFQUM5QixlQUFlOztFQUVmLFlBQVk7RUFDWix1QkFBdUI7RUFDdkIsdUJBQXVCO0VBQ3ZCLGtCQUFrQjs7RUFFbEIsK0NBQStDO0FBQ2pEOztBQUVBO0VBQ0UsWUFBWTtFQUNaLHlCQUF5QjtBQUMzQjs7QUFFQTtFQUNFLGtDQUFrQztFQUNsQyx5QkFBeUI7QUFDM0I7O0FBRUE7RUFDRSxtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsV0FBVztBQUNiOztBQUVBO0VBQ0UsVUFBVTtFQUNWLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLFlBQVk7RUFDWixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxjQUFjO0VBQ2QsOEJBQThCO0VBQzlCLGVBQWU7RUFDZixpQkFBaUI7RUFDakIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsOEJBQThCO0VBQzlCLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxXQUFXO0FBQ2I7O0FBRUE7Ozs7OztFQU1FLFlBQVk7RUFDWix1QkFBdUI7RUFDdkIsa0JBQWtCOztFQUVsQiw4QkFBOEI7RUFDOUIsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLHVCQUF1QjtBQUN6Qjs7QUFFQTtFQUNFLFdBQVc7RUFDWCxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSx1QkFBdUI7QUFDekI7O0FBRUE7RUFDRSx5QkFBeUI7QUFDM0I7O0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsaUJBQWlCO0VBQ2pCLDhCQUE4QjtFQUM5QixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsV0FBVztBQUNiOztBQUVBO0VBQ0UsYUFBYTtBQUNmOztBQUVBO0VBQ0UscUJBQXFCO0VBQ3JCLG1CQUFtQjtBQUNyQjs7QUFFQTs7Ozs7OztFQU9FLGtDQUFrQztFQUNsQyxnREFBZ0Q7RUFDaEQsNENBQTRDO0FBQzlDOztBQUVBO0VBQ0UsY0FBYztFQUNkLGVBQWU7QUFDakJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiaW5wdXQ6Zm9jdXMsIHNlbGVjdDpmb2N1cywgdGV4dGFyZWE6Zm9jdXMsIGJ1dHRvbjpmb2N1cyB7XFxuICBvdXRsaW5lOiAxcHggc29saWQgYmx1ZTtcXG59XFxuXFxuLyogVXNlIDpmb2N1cy12aXNpYmxlIGlmIGJyb3dzZXIgc3VwcG9ydHMgaXQgKi9cXG46aXMoaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbik6Zm9jdXM6bm90KDpmb2N1cy12aXNpYmxlKSB7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG5cXG5pbnB1dDppbnZhbGlkLCBzZWxlY3Q6aW52YWxpZCwgdGV4dGFyZWE6aW52YWxpZCB7XFxuICBvdXRsaW5lOiAxcHggc29saWQgcmVkO1xcbn1cXG5cXG5idXR0b24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbmlucHV0W3R5cGU9XFxcInJhZGlvXFxcIl0sIGlucHV0W3R5cGU9XFxcImNoZWNrYm94XFxcIl0ge1xcbiAgbWFyZ2luOiAwIDZweDtcXG59XFxuXFxuLnRvZ2dsZS1idXR0b24ge1xcbiAgcGFkZGluZzogNnB4O1xcblxcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcblxcbiAgY29sb3I6IGJsYWNrO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXG5cXG4gIHRyYW5zaXRpb246IGNvbG9yIDEwMG1zLCBiYWNrZ3JvdW5kLWNvbG9yIDEwMG1zO1xcbn1cXG5cXG4udG9nZ2xlLWJ1dHRvbi5hY3RpdmUge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIzMjNkMztcXG59XFxuXFxuLnRvZ2dsZS1idXR0b24uYWN0aXZlOmRpc2FibGVkIHtcXG4gIGNvbG9yOiB2YXIoLS1pbnB1dC1kaXNhYmxlZC1jb2xvcik7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzhjOGY0O1xcbn1cXG5cXG4uZm9ybS1pbnB1dC1jb250YWluZXIge1xcbiAgbWFyZ2luOiAxMnB4IDAgMjRweDtcXG59XFxuXFxuLmZvcm0taW5wdXQtZGF0ZS1jb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4uZm9ybS1pbnB1dC1kYXRlLWNvbnRhaW5lciBpbnB1dCB7XFxuICBmbGV4OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiA2cHg7XFxufVxcblxcbi5mb3JtLWlucHV0LWRhdGUtY29udGFpbmVyLWlubGluZSBpbnB1dCB7XFxuICB3aWR0aDogMTUwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDZweDtcXG59XFxuXFxuLmZvcm0taW5wdXQtbGFiZWwge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIG1hcmdpbi1ib3R0b206IDhweDtcXG59XFxuXFxuLmZvcm0taW5wdXQtbGFiZWwtaW5saW5lIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuXFxuLmZvcm0taW5wdXQsIC5mb3JtLXNlbGVjdCwgLmZvcm0tdGV4dGFyZWEge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5mb3JtLWlucHV0LFxcbi5mb3JtLWlucHV0LWlubGluZSxcXG4uZm9ybS1zZWxlY3QsXFxuLmZvcm0tc2VsZWN0LWlubGluZSxcXG4uZm9ybS10ZXh0YXJlYSxcXG4uZm9ybS1idXR0b24ge1xcbiAgcGFkZGluZzogOHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItcmFkaXVzOiA4cHg7XFxuXFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcblxcbi5mb3JtLXNlbGVjdCB7XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG59XFxuXFxuLmZvcm0tdGV4dGFyZWEge1xcbiAgd2lkdGg6IDEwMCU7XFxuICByZXNpemU6IHZlcnRpY2FsO1xcbn1cXG5cXG4uZm9ybS1idXR0b24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcblxcbi5mb3JtLWJ1dHRvbjphY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcXG59XFxuXFxuLmZvcm0tYnV0dG9uLWNvbnRhaW5lciA+IC5mb3JtLWJ1dHRvbiArIC5mb3JtLWJ1dHRvbiB7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbn1cXG5cXG4uZm9ybS1pbnB1dC1pdGVtLWNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiA4cHggMDtcXG59XFxuXFxuLmZvcm0taW5wdXQtaXRlbS1sYWJlbCB7XFxuICBwYWRkaW5nLWxlZnQ6IDhweDtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuXFxuLmZvcm0taW5wdXQtaW5saW5lLmZvcm0taW5wdXQtY291bnQge1xcbiAgd2lkdGg6IDkwcHg7XFxufVxcblxcbi5mb3JtLWlucHV0LWhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4uZm9ybS13ZWVrZGF5LWJ1dHRvbiB7XFxuICBtYXJnaW46IDhweCA2cHggOHB4IDA7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbn1cXG5cXG4uZm9ybS1pbnB1dDpkaXNhYmxlZCxcXG4uZm9ybS1pbnB1dC1pbmxpbmU6ZGlzYWJsZWQsXFxuLmZvcm0tc2VsZWN0OmRpc2FibGVkLFxcbi5mb3JtLXNlbGVjdC1pbmxpbmU6ZGlzYWJsZWQsXFxuLmZvcm0tdGV4dGFyZWE6ZGlzYWJsZWQsXFxuLmZvcm0tYnV0dG9uOmRpc2FibGVkLFxcbi50b2dnbGUtYnV0dG9uOmRpc2FibGVkIHtcXG4gIGNvbG9yOiB2YXIoLS1pbnB1dC1kaXNhYmxlZC1jb2xvcik7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1pbnB1dC1kaXNhYmxlZC1iZy1jb2xvcik7XFxuICBib3JkZXItY29sb3I6IHZhcigtLWlucHV0LWRpc2FibGVkLWJnLWNvbG9yKTtcXG59XFxuXFxuLmNvbmZpcm1hdGlvbi1ib3gge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tdG9wOiA4cHg7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5tb2RhbC1vdmVybGF5IHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwdnc7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgei1pbmRleDogMTAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xcbn1cXG5cXG4ubW9kYWwtd3JhcHBlciB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIHotaW5kZXg6IDIwMDtcXG5cXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5tb2RhbCB7XFxuICB3aWR0aDogNDAwcHg7XFxuICBtYXgtd2lkdGg6IDEwMHZ3O1xcbiAgbWF4LWhlaWdodDogbWluKDYwMHB4LCAxMDB2aCk7XFxuICBvdmVyZmxvdzogYXV0bztcXG5cXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG5cXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItcmFkaXVzOiA4cHg7XFxufVxcblxcbi5tb2RhbC10aXRsZS1iYXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbW9kYWwtYWNjZW50LWNvbG9yKTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogMTJweDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcXG4gIGZsZXg6IG5vbmU7XFxuXFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLm1vZGFsLXRpdGxlLWJhciAuaWNvbiB7XFxuICBmb250LXNpemU6IDI0cHg7XFxufVxcblxcbi5tb2RhbC10aXRsZSB7XFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLm1vZGFsLWNvbnRlbnQge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIHBhZGRpbmc6IDEycHg7XFxufVxcblxcbi5tb2RhbC1idXR0b24tY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcblxcbiAgd2lkdGg6IDEwMCU7XFxuICBwYWRkaW5nOiAxMnB4O1xcblxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbW9kYWwtYWNjZW50LWNvbG9yKTtcXG59XFxuXFxuLm1vZGFsLWJ1dHRvbi1jb250YWluZXIgPiAqICsgKiB7XFxuICBtYXJnaW4tbGVmdDogMTJweDtcXG59XFxuXFxuLm1vZGFsLWJ1dHRvbiB7XFxuICB3aWR0aDogMTAwcHg7XFxuICBwYWRkaW5nOiA2cHg7XFxuXFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDE2cHg7XFxuXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcbn1cXG5cXG4ubW9kYWwtYnV0dG9uOmZvY3VzIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG4ubW9kYWwtYnV0dG9uLm1vZGFsLW9rYXkge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIzMjNkMztcXG59XFxuXFxuLmluZm8tbW9kYWwtY29udGVudC1wYXJhZ3JhcGgge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG59XFxuXFxuLmluZm8tbW9kYWwtY29udGVudC1wYXJhZ3JhcGggKyAuaW5mby1tb2RhbC1jb250ZW50LXBhcmFncmFwaCB7XFxuICBtYXJnaW4tdG9wOiAxMnB4O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGVzL21vZGFsLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGVBQWU7RUFDZixNQUFNO0VBQ04sT0FBTztFQUNQLFlBQVk7RUFDWixhQUFhO0VBQ2IsWUFBWTtFQUNaLG9DQUFvQztBQUN0Qzs7QUFFQTtFQUNFLGVBQWU7RUFDZixNQUFNO0VBQ04sT0FBTztFQUNQLFlBQVk7RUFDWixhQUFhO0VBQ2IsWUFBWTs7RUFFWixhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLFlBQVk7RUFDWixnQkFBZ0I7RUFDaEIsNkJBQTZCO0VBQzdCLGNBQWM7O0VBRWQsYUFBYTtFQUNiLHNCQUFzQjtFQUN0QixtQkFBbUI7O0VBRW5CLHVCQUF1QjtFQUN2Qix1QkFBdUI7RUFDdkIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsMkNBQTJDO0VBQzNDLFdBQVc7RUFDWCxhQUFhO0VBQ2IsOEJBQThCO0VBQzlCLFVBQVU7O0VBRVYsYUFBYTtFQUNiLDhCQUE4QjtFQUM5QixtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsOEJBQThCO0VBQzlCLGVBQWU7RUFDZixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsY0FBYztFQUNkLGFBQWE7QUFDZjs7QUFFQTtFQUNFLGFBQWE7RUFDYix5QkFBeUI7O0VBRXpCLFdBQVc7RUFDWCxhQUFhOztFQUViLDJCQUEyQjtFQUMzQiwyQ0FBMkM7QUFDN0M7O0FBRUE7RUFDRSxpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxZQUFZO0VBQ1osWUFBWTs7RUFFWiw4QkFBOEI7RUFDOUIsZUFBZTs7RUFFZix1QkFBdUI7RUFDdkIsdUJBQXVCO0VBQ3ZCLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLFlBQVk7RUFDWix5QkFBeUI7QUFDM0I7O0FBRUE7RUFDRSw4QkFBOEI7RUFDOUIsZUFBZTtFQUNmLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLGdCQUFnQjtBQUNsQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIubW9kYWwtb3ZlcmxheSB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIHotaW5kZXg6IDEwMDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcXG59XFxuXFxuLm1vZGFsLXdyYXBwZXIge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxuICB6LWluZGV4OiAyMDA7XFxuXFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4ubW9kYWwge1xcbiAgd2lkdGg6IDQwMHB4O1xcbiAgbWF4LXdpZHRoOiAxMDB2dztcXG4gIG1heC1oZWlnaHQ6IG1pbig2MDBweCwgMTAwdmgpO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuXFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcbn1cXG5cXG4ubW9kYWwtdGl0bGUtYmFyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW1vZGFsLWFjY2VudC1jb2xvcik7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBhZGRpbmc6IDEycHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgYmxhY2s7XFxuICBmbGV4OiBub25lO1xcblxcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5tb2RhbC10aXRsZS1iYXIgLmljb24ge1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbn1cXG5cXG4ubW9kYWwtdGl0bGUge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbi5tb2RhbC1jb250ZW50IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBwYWRkaW5nOiAxMnB4O1xcbn1cXG5cXG4ubW9kYWwtYnV0dG9uLWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG5cXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogMTJweDtcXG5cXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW1vZGFsLWFjY2VudC1jb2xvcik7XFxufVxcblxcbi5tb2RhbC1idXR0b24tY29udGFpbmVyID4gKiArICoge1xcbiAgbWFyZ2luLWxlZnQ6IDEycHg7XFxufVxcblxcbi5tb2RhbC1idXR0b24ge1xcbiAgd2lkdGg6IDEwMHB4O1xcbiAgcGFkZGluZzogNnB4O1xcblxcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcblxcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXG59XFxuXFxuLm1vZGFsLWJ1dHRvbjpmb2N1cyB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLm1vZGFsLWJ1dHRvbi5tb2RhbC1va2F5IHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyMzIzZDM7XFxufVxcblxcbi5pbmZvLW1vZGFsLWNvbnRlbnQtcGFyYWdyYXBoIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxufVxcblxcbi5pbmZvLW1vZGFsLWNvbnRlbnQtcGFyYWdyYXBoICsgLmluZm8tbW9kYWwtY29udGVudC1wYXJhZ3JhcGgge1xcbiAgbWFyZ2luLXRvcDogMTJweDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLnBvcHVwLW1lbnUtb3ZlcmxheSB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIHotaW5kZXg6IDk1MDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4ucG9wdXAtbWVudSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIHotaW5kZXg6IDEwMDA7XFxuICBtYXgtd2lkdGg6IDEwMHZ3O1xcbiAgbWF4LWhlaWdodDogMTAwdmg7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLnBvcHVwLW1lbnUtaXRlbSB7XFxuICBwYWRkaW5nOiA4cHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnBvcHVwLW1lbnUtaXRlbSArIC5wb3B1cC1tZW51LWl0ZW0ge1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLWl0ZW0tc2VwYXJhdG9yLWNvbG9yKTtcXG59XFxuXFxuLnBvcHVwLW1lbnUtaXRlbS5hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0taXRlbS1zZWxlY3Rpb24tY29sb3IpO1xcbn1cXG5cXG4ucG9wdXAtbWVudS1pdGVtLWljb24ge1xcbiAgd2lkdGg6IDI0cHg7XFxuICBoZWlnaHQ6IDI0cHg7XFxufVxcblxcbi5wb3B1cC1tZW51LWl0ZW0tbGFiZWwge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgZmxleDogMTtcXG4gIG1hcmdpbi1sZWZ0OiA4cHg7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvcG9wdXBNZW51LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGVBQWU7RUFDZixNQUFNO0VBQ04sT0FBTztFQUNQLFlBQVk7RUFDWixhQUFhO0VBQ2IsWUFBWTtFQUNaLDZCQUE2QjtBQUMvQjs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixNQUFNO0VBQ04sT0FBTztFQUNQLHVCQUF1QjtFQUN2Qix1QkFBdUI7RUFDdkIsYUFBYTtFQUNiLGdCQUFnQjtFQUNoQixpQkFBaUI7RUFDakIsY0FBYztBQUNoQjs7QUFFQTtFQUNFLFlBQVk7RUFDWixhQUFhO0VBQ2IsbUJBQW1CO0VBQ25CLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxpREFBaUQ7QUFDbkQ7O0FBRUE7RUFDRSw2Q0FBNkM7QUFDL0M7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsWUFBWTtBQUNkOztBQUVBO0VBQ0UsOEJBQThCO0VBQzlCLGVBQWU7RUFDZixPQUFPO0VBQ1AsZ0JBQWdCO0FBQ2xCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5wb3B1cC1tZW51LW92ZXJsYXkge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxuICB6LWluZGV4OiA5NTA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLnBvcHVwLW1lbnUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICB6LWluZGV4OiAxMDAwO1xcbiAgbWF4LXdpZHRoOiAxMDB2dztcXG4gIG1heC1oZWlnaHQ6IDEwMHZoO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbi5wb3B1cC1tZW51LWl0ZW0ge1xcbiAgcGFkZGluZzogOHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5wb3B1cC1tZW51LWl0ZW0gKyAucG9wdXAtbWVudS1pdGVtIHtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1pdGVtLXNlcGFyYXRvci1jb2xvcik7XFxufVxcblxcbi5wb3B1cC1tZW51LWl0ZW0uYWN0aXZlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWl0ZW0tc2VsZWN0aW9uLWNvbG9yKTtcXG59XFxuXFxuLnBvcHVwLW1lbnUtaXRlbS1pY29uIHtcXG4gIHdpZHRoOiAyNHB4O1xcbiAgaGVpZ2h0OiAyNHB4O1xcbn1cXG5cXG4ucG9wdXAtbWVudS1pdGVtLWxhYmVsIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGZsZXg6IDE7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIudGFzay1wYW5lbCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1pdGVtLXNlcGFyYXRvci1jb2xvcik7XFxuICBmbGV4OiAxO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbi50YXNrLXBhbmVsLWNvbnRlbnQge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXgtd2lkdGg6IHZhcigtLW1haW4tY29udGVudC13aWR0aCk7XFxuICBwYWRkaW5nOiAxMnB4O1xcbiAgbWFyZ2luOiBhdXRvO1xcbn1cXG5cXG4udGFzay1saXN0LWhlYWRpbmcge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBtYXJnaW4tdG9wOiAyOHB4O1xcbiAgcGFkZGluZzogMCA4cHg7XFxufVxcblxcbi50YXNrLWxpc3QtaXRlbSB7XFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICBwYWRkaW5nOiAxMnB4IDhweDtcXG59XFxuXFxuLnRhc2stbGlzdC1pdGVtICsgLnRhc2stbGlzdC1pdGVtIHtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1pdGVtLXNlcGFyYXRvci1jb2xvcik7XFxufVxcblxcbi50YXNrLWxpc3QtaXRlbTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1pdGVtLXNlbGVjdGlvbi1jb2xvcik7XFxuICBib3JkZXItcmFkaXVzOiA4cHg7XFxufVxcblxcbi50YXNrLWxpc3QtaXRlbS1jaGVja2JveCB7XFxuICBtYXJnaW46IDJweCAxMnB4IDRweCAwO1xcbn1cXG5cXG4udGFzay1saXN0LWl0ZW0taW5mby1jb250YWluZXIge1xcbiAgZmxleDogMTtcXG59XFxuXFxuLnRhc2stbGlzdC1pdGVtLW5hbWUge1xcbiAgZm9udC1zaXplOiAxOHB4O1xcbiAgbWFyZ2luOiA2cHggMDtcXG59XFxuXFxuLnRhc2stbGlzdC1pdGVtLWRlc2NyaXB0aW9uIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIG1hcmdpbjogNnB4IDA7XFxuICBjb2xvcjogIzUwNTA1MDtcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG59XFxuXFxuLnRhc2stbGlzdC1pdGVtLWRldGFpbHMge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG5cXG4udGFzay1saXN0LWl0ZW0gLmljb24tY29udGFpbmVyIHtcXG4gIG1hcmdpbi1sZWZ0OiAxMnB4O1xcbn1cXG5cXG4udGFzay1saXN0LWVtcHR5IHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMThweDtcXG4gIGNvbG9yOiAjNTA1MDUwO1xcbiAgcGFkZGluZzogMCA4cHg7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvdGFza1BhbmVsLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLFdBQVc7RUFDWCxpREFBaUQ7RUFDakQsT0FBTztFQUNQLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsb0NBQW9DO0VBQ3BDLGFBQWE7RUFDYixZQUFZO0FBQ2Q7O0FBRUE7RUFDRSw4QkFBOEI7RUFDOUIsZUFBZTtFQUNmLGlCQUFpQjtFQUNqQixnQkFBZ0I7RUFDaEIsY0FBYztBQUNoQjs7QUFFQTtFQUNFLDhCQUE4QjtFQUM5QixhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLGlEQUFpRDtBQUNuRDs7QUFFQTtFQUNFLDZDQUE2QztFQUM3QyxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSxPQUFPO0FBQ1Q7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsYUFBYTtBQUNmOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGFBQWE7RUFDYixjQUFjO0VBQ2QscUJBQXFCO0FBQ3ZCOztBQUVBO0VBQ0UsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLDhCQUE4QjtFQUM5QixlQUFlO0VBQ2YsY0FBYztFQUNkLGNBQWM7QUFDaEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnRhc2stcGFuZWwge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0taXRlbS1zZXBhcmF0b3ItY29sb3IpO1xcbiAgZmxleDogMTtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbn1cXG5cXG4udGFzay1wYW5lbC1jb250ZW50IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiB2YXIoLS1tYWluLWNvbnRlbnQtd2lkdGgpO1xcbiAgcGFkZGluZzogMTJweDtcXG4gIG1hcmdpbjogYXV0bztcXG59XFxuXFxuLnRhc2stbGlzdC1oZWFkaW5nIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1sYWJlbC1mb250KTtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgbWFyZ2luLXRvcDogMjhweDtcXG4gIHBhZGRpbmc6IDAgOHB4O1xcbn1cXG5cXG4udGFzay1saXN0LWl0ZW0ge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWxhYmVsLWZvbnQpO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgcGFkZGluZzogMTJweCA4cHg7XFxufVxcblxcbi50YXNrLWxpc3QtaXRlbSArIC50YXNrLWxpc3QtaXRlbSB7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0taXRlbS1zZXBhcmF0b3ItY29sb3IpO1xcbn1cXG5cXG4udGFzay1saXN0LWl0ZW06aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0taXRlbS1zZWxlY3Rpb24tY29sb3IpO1xcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcbn1cXG5cXG4udGFzay1saXN0LWl0ZW0tY2hlY2tib3gge1xcbiAgbWFyZ2luOiAycHggMTJweCA0cHggMDtcXG59XFxuXFxuLnRhc2stbGlzdC1pdGVtLWluZm8tY29udGFpbmVyIHtcXG4gIGZsZXg6IDE7XFxufVxcblxcbi50YXNrLWxpc3QtaXRlbS1uYW1lIHtcXG4gIGZvbnQtc2l6ZTogMThweDtcXG4gIG1hcmdpbjogNnB4IDA7XFxufVxcblxcbi50YXNrLWxpc3QtaXRlbS1kZXNjcmlwdGlvbiB7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBtYXJnaW46IDZweCAwO1xcbiAgY29sb3I6ICM1MDUwNTA7XFxuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxufVxcblxcbi50YXNrLWxpc3QtaXRlbS1kZXRhaWxzIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuXFxuLnRhc2stbGlzdC1pdGVtIC5pY29uLWNvbnRhaW5lciB7XFxuICBtYXJnaW4tbGVmdDogMTJweDtcXG59XFxuXFxuLnRhc2stbGlzdC1lbXB0eSB7XFxuICBmb250LWZhbWlseTogdmFyKC0tbGFiZWwtZm9udCk7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBjb2xvcjogIzUwNTA1MDtcXG4gIHBhZGRpbmc6IDAgOHB4O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCI6cm9vdCB7XFxuICAtLWxhYmVsLWZvbnQ6IFZlcmRhbmEsIEdlbmV2YSwgVGFob21hLCBzYW5zLXNlcmlmO1xcbiAgLS1jb250ZW50LWZvbnQ6ICdUaW1lcyBOZXcgUm9tYW4nLCBUaW1lcywgc2VyaWY7XFxuICAtLWhlYWRlci1oZWlnaHQ6IDU2cHg7XFxuICAtLWZvb3Rlci1oZWlnaHQ6IDQ0cHg7XFxuICAtLXNpZGUtcGFuZWwtYmctY29sb3I6ICNmNGY0ZjQ7XFxuICAtLW1vZGFsLWFjY2VudC1jb2xvcjogI2Q0ZDRkNDtcXG4gIC0taW5wdXQtZGlzYWJsZWQtY29sb3I6ICM3MDcwNzA7XFxuICAtLWlucHV0LWRpc2FibGVkLWJnLWNvbG9yOiAjZTJlMmUyO1xcbiAgLS1pdGVtLXNlcGFyYXRvci1jb2xvcjogI2YwZjBmMDtcXG4gIC0taXRlbS1zZWxlY3Rpb24tY29sb3I6ICNmMGYwZjA7XFxuICAtLW1haW4tY29udGVudC13aWR0aDogODAwcHg7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvdmFyaWFibGVzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGlEQUFpRDtFQUNqRCwrQ0FBK0M7RUFDL0MscUJBQXFCO0VBQ3JCLHFCQUFxQjtFQUNyQiw4QkFBOEI7RUFDOUIsNkJBQTZCO0VBQzdCLCtCQUErQjtFQUMvQixrQ0FBa0M7RUFDbEMsK0JBQStCO0VBQy9CLCtCQUErQjtFQUMvQiwyQkFBMkI7QUFDN0JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiOnJvb3Qge1xcbiAgLS1sYWJlbC1mb250OiBWZXJkYW5hLCBHZW5ldmEsIFRhaG9tYSwgc2Fucy1zZXJpZjtcXG4gIC0tY29udGVudC1mb250OiAnVGltZXMgTmV3IFJvbWFuJywgVGltZXMsIHNlcmlmO1xcbiAgLS1oZWFkZXItaGVpZ2h0OiA1NnB4O1xcbiAgLS1mb290ZXItaGVpZ2h0OiA0NHB4O1xcbiAgLS1zaWRlLXBhbmVsLWJnLWNvbG9yOiAjZjRmNGY0O1xcbiAgLS1tb2RhbC1hY2NlbnQtY29sb3I6ICNkNGQ0ZDQ7XFxuICAtLWlucHV0LWRpc2FibGVkLWNvbG9yOiAjNzA3MDcwO1xcbiAgLS1pbnB1dC1kaXNhYmxlZC1iZy1jb2xvcjogI2UyZTJlMjtcXG4gIC0taXRlbS1zZXBhcmF0b3ItY29sb3I6ICNmMGYwZjA7XFxuICAtLWl0ZW0tc2VsZWN0aW9uLWNvbG9yOiAjZjBmMGYwO1xcbiAgLS1tYWluLWNvbnRlbnQtd2lkdGg6IDgwMHB4O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0udXNlWzJdIS4vbWFpbi5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0udXNlWzJdIS4vbWFpbi5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS51c2VbMl0hLi9yZXNldC5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0udXNlWzJdIS4vcmVzZXQuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcblxuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG5cbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cblxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG5cbiAgY3NzICs9IG9iai5jc3M7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGU7IH07XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCJpbXBvcnQgQXBwIGZyb20gJy4vbW9kdWxlcy9hcHAnO1xuXG5jb25zdCBhcHAgPSBuZXcgQXBwKGRvY3VtZW50LmJvZHkpO1xuYXBwLnJ1bigpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwibGlzdCIsInRvU3RyaW5nIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJuZWVkTGF5ZXIiLCJjb25jYXQiLCJsZW5ndGgiLCJqb2luIiwiaSIsIm1vZHVsZXMiLCJtZWRpYSIsImRlZHVwZSIsInN1cHBvcnRzIiwibGF5ZXIiLCJ1bmRlZmluZWQiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwiayIsImlkIiwiX2siLCJwdXNoIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwic291cmNlTWFwcGluZyIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsImFkZExlYWRpbmdaZXJvcyIsIm51bWJlciIsInRhcmdldExlbmd0aCIsInNpZ24iLCJvdXRwdXQiLCJNYXRoIiwiYWJzIiwiYXNzaWduIiwidGFyZ2V0IiwiZGlydHlPYmplY3QiLCJUeXBlRXJyb3IiLCJwcm9wZXJ0eSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldFVUQ0RheU9mWWVhciIsImdldFVUQ0lTT1dlZWsiLCJnZXRVVENJU09XZWVrWWVhciIsImdldFVUQ1dlZWsiLCJnZXRVVENXZWVrWWVhciIsImxpZ2h0Rm9ybWF0dGVycyIsImRheVBlcmlvZEVudW0iLCJhbSIsInBtIiwibWlkbmlnaHQiLCJub29uIiwibW9ybmluZyIsImFmdGVybm9vbiIsImV2ZW5pbmciLCJuaWdodCIsImZvcm1hdHRlcnMiLCJHIiwiZGF0ZSIsInRva2VuIiwibG9jYWxpemUiLCJlcmEiLCJnZXRVVENGdWxsWWVhciIsIndpZHRoIiwieSIsInNpZ25lZFllYXIiLCJ5ZWFyIiwib3JkaW5hbE51bWJlciIsInVuaXQiLCJZIiwib3B0aW9ucyIsInNpZ25lZFdlZWtZZWFyIiwid2Vla1llYXIiLCJ0d29EaWdpdFllYXIiLCJSIiwiaXNvV2Vla1llYXIiLCJ1IiwiUSIsInF1YXJ0ZXIiLCJjZWlsIiwiZ2V0VVRDTW9udGgiLCJTdHJpbmciLCJjb250ZXh0IiwicSIsIk0iLCJtb250aCIsIkwiLCJ3Iiwid2VlayIsIkkiLCJpc29XZWVrIiwiZCIsImdldFVUQ0RhdGUiLCJEIiwiZGF5T2ZZZWFyIiwiRSIsImRheU9mV2VlayIsImdldFVUQ0RheSIsImRheSIsImUiLCJsb2NhbERheU9mV2VlayIsIndlZWtTdGFydHNPbiIsImMiLCJpc29EYXlPZldlZWsiLCJhIiwiaG91cnMiLCJnZXRVVENIb3VycyIsImRheVBlcmlvZEVudW1WYWx1ZSIsImRheVBlcmlvZCIsInRvTG93ZXJDYXNlIiwiYiIsIkIiLCJoIiwiSCIsIksiLCJtIiwiZ2V0VVRDTWludXRlcyIsInMiLCJnZXRVVENTZWNvbmRzIiwiUyIsIlgiLCJfbG9jYWxpemUiLCJvcmlnaW5hbERhdGUiLCJfb3JpZ2luYWxEYXRlIiwidGltZXpvbmVPZmZzZXQiLCJnZXRUaW1lem9uZU9mZnNldCIsImZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyIsImZvcm1hdFRpbWV6b25lIiwieCIsIk8iLCJmb3JtYXRUaW1lem9uZVNob3J0IiwieiIsInQiLCJ0aW1lc3RhbXAiLCJmbG9vciIsImdldFRpbWUiLCJUIiwib2Zmc2V0IiwiZGlydHlEZWxpbWl0ZXIiLCJhYnNPZmZzZXQiLCJtaW51dGVzIiwiZGVsaW1pdGVyIiwidG9VcHBlckNhc2UiLCJudW1iZXJPZkRpZ2l0cyIsIm1pbGxpc2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsImZyYWN0aW9uYWxTZWNvbmRzIiwicG93IiwiZGF0ZUxvbmdGb3JtYXR0ZXIiLCJwYXR0ZXJuIiwiZm9ybWF0TG9uZyIsInRpbWVMb25nRm9ybWF0dGVyIiwidGltZSIsImRhdGVUaW1lTG9uZ0Zvcm1hdHRlciIsIm1hdGNoUmVzdWx0IiwibWF0Y2giLCJkYXRlUGF0dGVybiIsInRpbWVQYXR0ZXJuIiwiZGF0ZVRpbWVGb3JtYXQiLCJkYXRlVGltZSIsInJlcGxhY2UiLCJsb25nRm9ybWF0dGVycyIsInAiLCJQIiwiZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyIsInV0Y0RhdGUiLCJEYXRlIiwiVVRDIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwic2V0VVRDRnVsbFllYXIiLCJ0b0RhdGUiLCJyZXF1aXJlZEFyZ3MiLCJNSUxMSVNFQ09ORFNfSU5fREFZIiwiZGlydHlEYXRlIiwiYXJndW1lbnRzIiwic2V0VVRDTW9udGgiLCJzZXRVVENIb3VycyIsInN0YXJ0T2ZZZWFyVGltZXN0YW1wIiwiZGlmZmVyZW5jZSIsInN0YXJ0T2ZVVENJU09XZWVrIiwic3RhcnRPZlVUQ0lTT1dlZWtZZWFyIiwiTUlMTElTRUNPTkRTX0lOX1dFRUsiLCJkaWZmIiwicm91bmQiLCJmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyIiwic3RhcnRPZk5leHRZZWFyIiwiZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhciIsInN0YXJ0T2ZUaGlzWWVhciIsInN0YXJ0T2ZVVENXZWVrIiwic3RhcnRPZlVUQ1dlZWtZZWFyIiwidG9JbnRlZ2VyIiwiZGlydHlPcHRpb25zIiwibG9jYWxlIiwibG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlIiwiZmlyc3RXZWVrQ29udGFpbnNEYXRlIiwiZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSIsIlJhbmdlRXJyb3IiLCJmaXJzdFdlZWtPZk5leHRZZWFyIiwiZmlyc3RXZWVrT2ZUaGlzWWVhciIsInByb3RlY3RlZERheU9mWWVhclRva2VucyIsInByb3RlY3RlZFdlZWtZZWFyVG9rZW5zIiwiaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbiIsImluZGV4T2YiLCJpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4iLCJ0aHJvd1Byb3RlY3RlZEVycm9yIiwiZm9ybWF0IiwiaW5wdXQiLCJyZXF1aXJlZCIsImFyZ3MiLCJzZXRVVENEYXkiLCJkaXJ0eURheSIsImxvY2FsZVdlZWtTdGFydHNPbiIsImRlZmF1bHRXZWVrU3RhcnRzT24iLCJjdXJyZW50RGF5IiwicmVtYWluZGVyIiwiZGF5SW5kZXgiLCJzZXRVVENEYXRlIiwic2V0VVRDSVNPRGF5Iiwic2V0VVRDSVNPV2VlayIsImRpcnR5SVNPV2VlayIsInNldFVUQ1dlZWsiLCJkaXJ0eVdlZWsiLCJmb3VydGhPZkphbnVhcnkiLCJmaXJzdFdlZWsiLCJkaXJ0eU51bWJlciIsIk5hTiIsIk51bWJlciIsImlzTmFOIiwiYWRkRGF5cyIsImFkZE1vbnRocyIsImFkZCIsImR1cmF0aW9uIiwieWVhcnMiLCJtb250aHMiLCJ3ZWVrcyIsImRheXMiLCJzZWNvbmRzIiwiZGF0ZVdpdGhNb250aHMiLCJkYXRlV2l0aERheXMiLCJtaW51dGVzVG9BZGQiLCJzZWNvbmRzVG9BZGQiLCJtc1RvQWRkIiwiZmluYWxEYXRlIiwiZGlydHlBbW91bnQiLCJhbW91bnQiLCJzZXREYXRlIiwiYWRkTWlsbGlzZWNvbmRzIiwiZGF5T2ZNb250aCIsImVuZE9mRGVzaXJlZE1vbnRoIiwic2V0TW9udGgiLCJkYXlzSW5Nb250aCIsInNldEZ1bGxZZWFyIiwiZGF5c0luV2VlayIsIm1heFRpbWUiLCJtaWxsaXNlY29uZHNJbk1pbnV0ZSIsIm1pbGxpc2Vjb25kc0luSG91ciIsIm1pbGxpc2Vjb25kc0luU2Vjb25kIiwibWluVGltZSIsIm1pbnV0ZXNJbkhvdXIiLCJtb250aHNJblF1YXJ0ZXIiLCJtb250aHNJblllYXIiLCJxdWFydGVyc0luWWVhciIsInNlY29uZHNJbkhvdXIiLCJzZWNvbmRzSW5NaW51dGUiLCJlbmRPZkRheSIsInNldEhvdXJzIiwiaXNWYWxpZCIsImRlZmF1bHRMb2NhbGUiLCJzdWJNaWxsaXNlY29uZHMiLCJmb3JtYXR0aW5nVG9rZW5zUmVnRXhwIiwibG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAiLCJlc2NhcGVkU3RyaW5nUmVnRXhwIiwiZG91YmxlUXVvdGVSZWdFeHAiLCJ1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCIsImRpcnR5Rm9ybWF0U3RyIiwiZm9ybWF0U3RyIiwiZm9ybWF0dGVyT3B0aW9ucyIsInJlc3VsdCIsInN1YnN0cmluZyIsImZpcnN0Q2hhcmFjdGVyIiwibG9uZ0Zvcm1hdHRlciIsImNsZWFuRXNjYXBlZFN0cmluZyIsImZvcm1hdHRlciIsInVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VucyIsInVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnMiLCJmb3JtYXRJU08iLCJyZXByZXNlbnRhdGlvbiIsInR6T2Zmc2V0IiwiZGF0ZURlbGltaXRlciIsInRpbWVEZWxpbWl0ZXIiLCJhYnNvbHV0ZU9mZnNldCIsImhvdXJPZmZzZXQiLCJtaW51dGVPZmZzZXQiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwic2VwYXJhdG9yIiwiZ2V0RGF5IiwiZ2V0RGF5c0luTW9udGgiLCJtb250aEluZGV4IiwibGFzdERheU9mTW9udGgiLCJpc0JlZm9yZSIsImRpcnR5RGF0ZVRvQ29tcGFyZSIsImRhdGVUb0NvbXBhcmUiLCJpc0RhdGUiLCJ2YWx1ZSIsInN0YXJ0T2ZEYXkiLCJpc1NhbWVEYXkiLCJkaXJ0eURhdGVMZWZ0IiwiZGlydHlEYXRlUmlnaHQiLCJkYXRlTGVmdFN0YXJ0T2ZEYXkiLCJkYXRlUmlnaHRTdGFydE9mRGF5IiwiaXNTYW1lTW9udGgiLCJkYXRlTGVmdCIsImRhdGVSaWdodCIsImlzVG9kYXkiLCJub3ciLCJpc1dlZWtlbmQiLCJidWlsZEZvcm1hdExvbmdGbiIsImRlZmF1bHRXaWR0aCIsImZvcm1hdHMiLCJidWlsZExvY2FsaXplRm4iLCJkaXJ0eUluZGV4IiwidmFsdWVzQXJyYXkiLCJmb3JtYXR0aW5nVmFsdWVzIiwiZGVmYXVsdEZvcm1hdHRpbmdXaWR0aCIsIl9kZWZhdWx0V2lkdGgiLCJfd2lkdGgiLCJ2YWx1ZXMiLCJpbmRleCIsImFyZ3VtZW50Q2FsbGJhY2siLCJidWlsZE1hdGNoRm4iLCJzdHJpbmciLCJtYXRjaFBhdHRlcm4iLCJtYXRjaFBhdHRlcm5zIiwiZGVmYXVsdE1hdGNoV2lkdGgiLCJtYXRjaGVkU3RyaW5nIiwicGFyc2VQYXR0ZXJucyIsImRlZmF1bHRQYXJzZVdpZHRoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiZmluZEluZGV4IiwidGVzdCIsImZpbmRLZXkiLCJ2YWx1ZUNhbGxiYWNrIiwicmVzdCIsInNsaWNlIiwib2JqZWN0IiwicHJlZGljYXRlIiwiYXJyYXkiLCJidWlsZE1hdGNoUGF0dGVybkZuIiwicGFyc2VSZXN1bHQiLCJwYXJzZVBhdHRlcm4iLCJmb3JtYXREaXN0YW5jZUxvY2FsZSIsImxlc3NUaGFuWFNlY29uZHMiLCJvbmUiLCJvdGhlciIsInhTZWNvbmRzIiwiaGFsZkFNaW51dGUiLCJsZXNzVGhhblhNaW51dGVzIiwieE1pbnV0ZXMiLCJhYm91dFhIb3VycyIsInhIb3VycyIsInhEYXlzIiwiYWJvdXRYV2Vla3MiLCJ4V2Vla3MiLCJhYm91dFhNb250aHMiLCJ4TW9udGhzIiwiYWJvdXRYWWVhcnMiLCJ4WWVhcnMiLCJvdmVyWFllYXJzIiwiYWxtb3N0WFllYXJzIiwiZm9ybWF0RGlzdGFuY2UiLCJjb3VudCIsInRva2VuVmFsdWUiLCJhZGRTdWZmaXgiLCJjb21wYXJpc29uIiwiZGF0ZUZvcm1hdHMiLCJmdWxsIiwibG9uZyIsIm1lZGl1bSIsInNob3J0IiwidGltZUZvcm1hdHMiLCJkYXRlVGltZUZvcm1hdHMiLCJmb3JtYXRSZWxhdGl2ZUxvY2FsZSIsImxhc3RXZWVrIiwieWVzdGVyZGF5IiwidG9kYXkiLCJ0b21vcnJvdyIsIm5leHRXZWVrIiwiZm9ybWF0UmVsYXRpdmUiLCJfZGF0ZSIsIl9iYXNlRGF0ZSIsIl9vcHRpb25zIiwiZXJhVmFsdWVzIiwibmFycm93IiwiYWJicmV2aWF0ZWQiLCJ3aWRlIiwicXVhcnRlclZhbHVlcyIsIm1vbnRoVmFsdWVzIiwiZGF5VmFsdWVzIiwiZGF5UGVyaW9kVmFsdWVzIiwiZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyIsInJlbTEwMCIsIm1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4iLCJwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuIiwibWF0Y2hFcmFQYXR0ZXJucyIsInBhcnNlRXJhUGF0dGVybnMiLCJhbnkiLCJtYXRjaFF1YXJ0ZXJQYXR0ZXJucyIsInBhcnNlUXVhcnRlclBhdHRlcm5zIiwibWF0Y2hNb250aFBhdHRlcm5zIiwicGFyc2VNb250aFBhdHRlcm5zIiwibWF0Y2hEYXlQYXR0ZXJucyIsInBhcnNlRGF5UGF0dGVybnMiLCJtYXRjaERheVBlcmlvZFBhdHRlcm5zIiwicGFyc2VEYXlQZXJpb2RQYXR0ZXJucyIsInBhcnNlSW50IiwiY29kZSIsIm5leHREYXkiLCJkZWx0YSIsIk1JTExJU0VDT05EU19JTl9IT1VSIiwiTUlMTElTRUNPTkRTX0lOX01JTlVURSIsIk1JTExJU0VDT05EU19JTl9TRUNPTkQiLCJudW1lcmljUGF0dGVybnMiLCJob3VyMjNoIiwiaG91cjI0aCIsImhvdXIxMWgiLCJob3VyMTJoIiwic2luZ2xlRGlnaXQiLCJ0d29EaWdpdHMiLCJ0aHJlZURpZ2l0cyIsImZvdXJEaWdpdHMiLCJhbnlEaWdpdHNTaWduZWQiLCJzaW5nbGVEaWdpdFNpZ25lZCIsInR3b0RpZ2l0c1NpZ25lZCIsInRocmVlRGlnaXRzU2lnbmVkIiwiZm91ckRpZ2l0c1NpZ25lZCIsInRpbWV6b25lUGF0dGVybnMiLCJiYXNpY09wdGlvbmFsTWludXRlcyIsImJhc2ljIiwiYmFzaWNPcHRpb25hbFNlY29uZHMiLCJleHRlbmRlZCIsImV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzIiwicGFyc2VOdW1lcmljUGF0dGVybiIsInBhcnNlVGltZXpvbmVQYXR0ZXJuIiwicGFyc2VBbnlEaWdpdHNTaWduZWQiLCJwYXJzZU5EaWdpdHMiLCJuIiwiUmVnRXhwIiwicGFyc2VORGlnaXRzU2lnbmVkIiwiZGF5UGVyaW9kRW51bVRvSG91cnMiLCJlbnVtVmFsdWUiLCJub3JtYWxpemVUd29EaWdpdFllYXIiLCJjdXJyZW50WWVhciIsImlzQ29tbW9uRXJhIiwiYWJzQ3VycmVudFllYXIiLCJyYW5nZUVuZCIsInJhbmdlRW5kQ2VudHVyeSIsImlzUHJldmlvdXNDZW50dXJ5IiwiREFZU19JTl9NT05USCIsIkRBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSIiwiaXNMZWFwWWVhckluZGV4IiwicGFyc2VycyIsInByaW9yaXR5IiwicGFyc2UiLCJzZXQiLCJmbGFncyIsImluY29tcGF0aWJsZVRva2VucyIsImlzVHdvRGlnaXRZZWFyIiwidmFsaWRhdGUiLCJub3JtYWxpemVkVHdvRGlnaXRZZWFyIiwiX21hdGNoIiwiX2ZsYWdzIiwiZmlyc3RXZWVrT2ZZZWFyIiwic3ViUHJpb3JpdHkiLCJpc0xlYXBZZWFyIiwid2hvbGVXZWVrRGF5cyIsImlzUE0iLCJzZXRVVENNaW51dGVzIiwic2V0VVRDU2Vjb25kcyIsInNldFVUQ01pbGxpc2Vjb25kcyIsInRpbWVzdGFtcElzU2V0IiwiX3Rva2VuIiwiVElNRVpPTkVfVU5JVF9QUklPUklUWSIsIm5vdFdoaXRlc3BhY2VSZWdFeHAiLCJkaXJ0eURhdGVTdHJpbmciLCJkaXJ0eUZvcm1hdFN0cmluZyIsImRpcnR5UmVmZXJlbmNlRGF0ZSIsImRhdGVTdHJpbmciLCJmb3JtYXRTdHJpbmciLCJzdWJGbk9wdGlvbnMiLCJzZXR0ZXJzIiwiZGF0ZVRvU3lzdGVtVGltZXpvbmUiLCJ0b2tlbnMiLCJ1c2VkVG9rZW5zIiwicGFyc2VyIiwiaW5jb21wYXRpYmxlVG9rZW4iLCJfaSIsInVzZWRUb2tlbiIsImZ1bGxUb2tlbiIsInVuaXF1ZVByaW9yaXR5U2V0dGVycyIsInNldHRlciIsInNvcnQiLCJmaWx0ZXIiLCJzZXR0ZXJBcnJheSIsImNvbnZlcnRlZERhdGUiLCJwYXJzZUlTTyIsImFyZ3VtZW50IiwiYWRkaXRpb25hbERpZ2l0cyIsImRhdGVTdHJpbmdzIiwic3BsaXREYXRlU3RyaW5nIiwicGFyc2VZZWFyUmVzdWx0IiwicGFyc2VZZWFyIiwicGFyc2VEYXRlIiwicmVzdERhdGVTdHJpbmciLCJwYXJzZVRpbWUiLCJ0aW1lem9uZSIsInBhcnNlVGltZXpvbmUiLCJwYXR0ZXJucyIsImRhdGVUaW1lRGVsaW1pdGVyIiwidGltZVpvbmVEZWxpbWl0ZXIiLCJkYXRlUmVnZXgiLCJ0aW1lUmVnZXgiLCJ0aW1lem9uZVJlZ2V4Iiwic3BsaXQiLCJ0aW1lU3RyaW5nIiwic3Vic3RyIiwiZXhlYyIsInJlZ2V4IiwiY2FwdHVyZXMiLCJjZW50dXJ5IiwiaXNXZWVrRGF0ZSIsInBhcnNlRGF0ZVVuaXQiLCJ2YWxpZGF0ZVdlZWtEYXRlIiwiZGF5T2ZJU09XZWVrWWVhciIsInZhbGlkYXRlRGF0ZSIsInZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSIsIm1heCIsInBhcnNlVGltZVVuaXQiLCJ2YWxpZGF0ZVRpbWUiLCJwYXJzZUZsb2F0IiwidGltZXpvbmVTdHJpbmciLCJ2YWxpZGF0ZVRpbWV6b25lIiwiZm91cnRoT2ZKYW51YXJ5RGF5IiwiZGF5c0luTW9udGhzIiwiX3llYXIiLCJfaG91cnMiLCJzdWJEYXlzIiwicHJldmlvdXNEYXkiLCJzdGFydE9mTW9udGgiLCJzdGFydE9mV2VlayIsImFyZ1N0ciIsImNvbnNvbGUiLCJ3YXJuIiwiRXJyb3IiLCJzdGFjayIsIlJlZmxlY3QiLCJSZWZsZWN0QXBwbHkiLCJhcHBseSIsInJlY2VpdmVyIiwiRnVuY3Rpb24iLCJSZWZsZWN0T3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIk51bWJlcklzTmFOIiwiRXZlbnRFbWl0dGVyIiwiaW5pdCIsIm9uY2UiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJjaGVja0xpc3RlbmVyIiwibGlzdGVuZXIiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJhcmciLCJnZXRQcm90b3R5cGVPZiIsImNyZWF0ZSIsInNldE1heExpc3RlbmVycyIsIl9nZXRNYXhMaXN0ZW5lcnMiLCJ0aGF0IiwiZ2V0TWF4TGlzdGVuZXJzIiwiZW1pdCIsInR5cGUiLCJkb0Vycm9yIiwiZXZlbnRzIiwiZXJyb3IiLCJlciIsImVyciIsIm1lc3NhZ2UiLCJoYW5kbGVyIiwibGVuIiwibGlzdGVuZXJzIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsIm5hbWUiLCJlbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJvbiIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJyZW1vdmVMaXN0ZW5lciIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwid3JhcHBlZCIsImJpbmQiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwicG9zaXRpb24iLCJvcmlnaW5hbExpc3RlbmVyIiwic2hpZnQiLCJzcGxpY2VPbmUiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJrZXlzIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsImFyciIsImNvcHkiLCJwb3AiLCJyZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciIsImFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndyYXBMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnZXROYXRpdmUiLCJyZXF1aXJlIiwicm9vdCIsIkRhdGFWaWV3IiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsImhhcyIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiTWFwIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJTZXQiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJfX2RhdGFfXyIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsIlN0YWNrIiwic2l6ZSIsIlN5bWJvbCIsIlVpbnQ4QXJyYXkiLCJXZWFrTWFwIiwiYXJyYXlFYWNoIiwiaXRlcmF0ZWUiLCJhcnJheUZpbHRlciIsInJlc0luZGV4IiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzIiwiYXJyYXlJbmNsdWRlc1dpdGgiLCJjb21wYXJhdG9yIiwiYmFzZVRpbWVzIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzSW5kZXgiLCJpc1R5cGVkQXJyYXkiLCJvYmplY3RQcm90byIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJhcnJheU1hcCIsImFycmF5UHVzaCIsImFycmF5U29tZSIsImJhc2VBc3NpZ25WYWx1ZSIsImVxIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImFzc29jSW5kZXhPZiIsImNvcHlPYmplY3QiLCJiYXNlQXNzaWduIiwia2V5c0luIiwiYmFzZUFzc2lnbkluIiwiY2xvbmVCdWZmZXIiLCJjb3B5QXJyYXkiLCJjb3B5U3ltYm9scyIsImNvcHlTeW1ib2xzSW4iLCJnZXRBbGxLZXlzIiwiZ2V0QWxsS2V5c0luIiwiZ2V0VGFnIiwiaW5pdENsb25lQXJyYXkiLCJpbml0Q2xvbmVCeVRhZyIsImluaXRDbG9uZU9iamVjdCIsImlzTWFwIiwiaXNPYmplY3QiLCJpc1NldCIsIkNMT05FX0RFRVBfRkxBRyIsIkNMT05FX0ZMQVRfRkxBRyIsIkNMT05FX1NZTUJPTFNfRkxBRyIsImFyZ3NUYWciLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJjbG9uZWFibGVUYWdzIiwiYmFzZUNsb25lIiwiYml0bWFzayIsImN1c3RvbWl6ZXIiLCJpc0RlZXAiLCJpc0ZsYXQiLCJpc0Z1bGwiLCJ0YWciLCJpc0Z1bmMiLCJzdGFja2VkIiwiZm9yRWFjaCIsInN1YlZhbHVlIiwia2V5c0Z1bmMiLCJwcm9wcyIsIm9iamVjdENyZWF0ZSIsImJhc2VDcmVhdGUiLCJwcm90byIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldCIsInBhdGgiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJiYXNlSGFzSW4iLCJiYXNlSXNOYU4iLCJzdHJpY3RJbmRleE9mIiwiaXNPYmplY3RMaWtlIiwiYmFzZUlzQXJndW1lbnRzIiwiYmFzZUlzRXF1YWxEZWVwIiwiYmFzZUlzRXF1YWwiLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJlcXVhbE9iamVjdHMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsImVxdWFsRnVuYyIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiYmFzZUlzTWFwIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImJhc2VJc01hdGNoIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwic3JjVmFsdWUiLCJpc0Z1bmN0aW9uIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJiYXNlSXNOYXRpdmUiLCJiYXNlSXNTZXQiLCJpc0xlbmd0aCIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VNYXRjaGVzIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImlkZW50aXR5IiwiYmFzZUl0ZXJhdGVlIiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJuYXRpdmVLZXlzSW4iLCJiYXNlS2V5c0luIiwiaXNQcm90byIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJpc0tleSIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImJhc2VQcm9wZXJ0eSIsImJhc2VQcm9wZXJ0eURlZXAiLCJuYXRpdmVDZWlsIiwibmF0aXZlTWF4IiwiYmFzZVJhbmdlIiwic3RhcnQiLCJlbmQiLCJzdGVwIiwiYmFzZVNvcnRlZEluZGV4QnkiLCJpc1N5bWJvbCIsIk1BWF9BUlJBWV9MRU5HVEgiLCJIQUxGX01BWF9BUlJBWV9MRU5HVEgiLCJiYXNlU29ydGVkSW5kZXgiLCJyZXRIaWdoZXN0IiwibG93IiwiaGlnaCIsIm1pZCIsImNvbXB1dGVkIiwiTUFYX0FSUkFZX0lOREVYIiwibmF0aXZlRmxvb3IiLCJuYXRpdmVNaW4iLCJtaW4iLCJ2YWxJc05hTiIsInZhbElzTnVsbCIsInZhbElzU3ltYm9sIiwidmFsSXNVbmRlZmluZWQiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwic2V0TG93IiwiSU5GSU5JVFkiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwidHJpbW1lZEVuZEluZGV4IiwicmVUcmltU3RhcnQiLCJiYXNlVHJpbSIsImJhc2VVbmFyeSIsImZ1bmMiLCJjYWNoZUhhcyIsImNyZWF0ZVNldCIsInNldFRvQXJyYXkiLCJMQVJHRV9BUlJBWV9TSVpFIiwiYmFzZVVuaXEiLCJpbmNsdWRlcyIsImlzQ29tbW9uIiwic2VlbiIsIm91dGVyIiwic2VlbkluZGV4IiwiY2FjaGUiLCJzdHJpbmdUb1BhdGgiLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJjb25zdHJ1Y3RvciIsImJ5dGVMZW5ndGgiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImJ1ZmZlciIsImNsb25lRGF0YVZpZXciLCJkYXRhVmlldyIsImJ5dGVPZmZzZXQiLCJyZUZsYWdzIiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJsYXN0SW5kZXgiLCJzeW1ib2xWYWx1ZU9mIiwidmFsdWVPZiIsImNsb25lU3ltYm9sIiwic3ltYm9sIiwiY2xvbmVUeXBlZEFycmF5IiwidHlwZWRBcnJheSIsImlzTmV3IiwibmV3VmFsdWUiLCJnZXRTeW1ib2xzIiwiZ2V0U3ltYm9sc0luIiwiY29yZUpzRGF0YSIsImlzSXRlcmF0ZWVDYWxsIiwidG9GaW5pdGUiLCJjcmVhdGVSYW5nZSIsIm5vb3AiLCJpc1BhcnRpYWwiLCJhcnJMZW5ndGgiLCJvdGhMZW5ndGgiLCJhcnJTdGFja2VkIiwib3RoU3RhY2tlZCIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsIm90aEluZGV4IiwibWFwVG9BcnJheSIsImNvbnZlcnQiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwib2JqU3RhY2tlZCIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsImdldFZhbHVlIiwib3ZlckFyZyIsImdldFByb3RvdHlwZSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsInN0dWJBcnJheSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwibmF0aXZlR2V0U3ltYm9scyIsInByb21pc2VUYWciLCJkYXRhVmlld0N0b3JTdHJpbmciLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJBcnJheUJ1ZmZlciIsIkN0b3IiLCJjdG9yU3RyaW5nIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJuYXRpdmVDcmVhdGUiLCJIQVNIX1VOREVGSU5FRCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZUlzVWludCIsImlzQXJyYXlMaWtlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJJRV9QUk9UTyIsImFycmF5UHJvdG8iLCJzcGxpY2UiLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwiYmluZGluZyIsInRyYW5zZm9ybSIsImZyZWVTZWxmIiwic2VsZiIsInBhaXJzIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsImNoYXJDb2RlQXQiLCJxdW90ZSIsInN1YlN0cmluZyIsInJlV2hpdGVzcGFjZSIsImNoYXJBdCIsImNsb25lRGVlcCIsImRlZmF1bHRWYWx1ZSIsInN0dWJGYWxzZSIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNFbXB0eSIsImlzRXF1YWwiLCJhc3luY1RhZyIsInByb3h5VGFnIiwibm9kZUlzTWFwIiwibm9kZUlzU2V0Iiwibm9kZUlzVHlwZWRBcnJheSIsIkZVTkNfRVJST1JfVEVYVCIsIm1lbW9pemVkIiwiQ2FjaGUiLCJyYW5nZSIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZExhc3RJbmRleCIsInRvTnVtYmVyIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsImlzQmluYXJ5IiwidW5pcSIsInVuaXFXaXRoIiwiWWFsbGlzdCIsIk1BWCIsIkxFTkdUSCIsIkxFTkdUSF9DQUxDVUxBVE9SIiwiQUxMT1dfU1RBTEUiLCJNQVhfQUdFIiwiRElTUE9TRSIsIk5PX0RJU1BPU0VfT05fU0VUIiwiTFJVX0xJU1QiLCJDQUNIRSIsIlVQREFURV9BR0VfT05fR0VUIiwibmFpdmVMZW5ndGgiLCJMUlVDYWNoZSIsIkluZmluaXR5IiwibGMiLCJzdGFsZSIsIm1heEFnZSIsImRpc3Bvc2UiLCJub0Rpc3Bvc2VPblNldCIsInVwZGF0ZUFnZU9uR2V0IiwicmVzZXQiLCJtTCIsInRyaW0iLCJhbGxvd1N0YWxlIiwibUEiLCJsQyIsImhpdCIsImZuIiwidGhpc3AiLCJ3YWxrZXIiLCJ0YWlsIiwicHJldiIsImZvckVhY2hTdGVwIiwiaGVhZCIsIm5leHQiLCJ0b0FycmF5IiwiaXNTdGFsZSIsInYiLCJkZWwiLCJub2RlIiwiRW50cnkiLCJsIiwiZXhwaXJlc0F0IiwiZG9Vc2UiLCJ1bnNoaWZ0Tm9kZSIsImRlbGV0ZSIsInJlbW92ZU5vZGUiLCJpbmRpY2F0b3IiLCJvcmRpbmFsIiwiaXNGaW5pdGUiLCJjZW50IiwiZGVjIiwiQU5ZIiwiQ29tcGFyYXRvciIsImNvbXAiLCJwYXJzZU9wdGlvbnMiLCJsb29zZSIsImRlYnVnIiwic2VtdmVyIiwib3BlcmF0b3IiLCJ2ZXJzaW9uIiwiciIsInJlIiwiQ09NUEFSQVRPUkxPT1NFIiwiQ09NUEFSQVRPUiIsIlNlbVZlciIsImNtcCIsImluY2x1ZGVQcmVyZWxlYXNlIiwiUmFuZ2UiLCJzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyIsInNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIiwic2FtZVNlbVZlciIsImRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUiLCJvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiIsIm9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuIiwicmF3IiwicGFyc2VSYW5nZSIsImZpcnN0IiwiaXNOdWxsU2V0IiwiaXNBbnkiLCJjb21wcyIsIm1lbW9PcHRzIiwibWVtb0tleSIsImNhY2hlZCIsImhyIiwiSFlQSEVOUkFOR0VMT09TRSIsIkhZUEhFTlJBTkdFIiwiaHlwaGVuUmVwbGFjZSIsIkNPTVBBUkFUT1JUUklNIiwiY29tcGFyYXRvclRyaW1SZXBsYWNlIiwiVElMREVUUklNIiwidGlsZGVUcmltUmVwbGFjZSIsIkNBUkVUVFJJTSIsImNhcmV0VHJpbVJlcGxhY2UiLCJyYW5nZUxpc3QiLCJwYXJzZUNvbXBhcmF0b3IiLCJyZXBsYWNlR1RFMCIsInJhbmdlTWFwIiwiY29tcGFyYXRvcnMiLCJzb21lIiwidGhpc0NvbXBhcmF0b3JzIiwiaXNTYXRpc2ZpYWJsZSIsInJhbmdlQ29tcGFyYXRvcnMiLCJldmVyeSIsInRoaXNDb21wYXJhdG9yIiwicmFuZ2VDb21wYXJhdG9yIiwiaW50ZXJzZWN0cyIsInRlc3RTZXQiLCJMUlUiLCJyZW1haW5pbmdDb21wYXJhdG9ycyIsInRlc3RDb21wYXJhdG9yIiwib3RoZXJDb21wYXJhdG9yIiwicmVwbGFjZUNhcmV0cyIsInJlcGxhY2VUaWxkZXMiLCJyZXBsYWNlWFJhbmdlcyIsInJlcGxhY2VTdGFycyIsImlzWCIsInJlcGxhY2VUaWxkZSIsIlRJTERFTE9PU0UiLCJUSUxERSIsIl8iLCJwciIsInJlcGxhY2VDYXJldCIsIkNBUkVUTE9PU0UiLCJDQVJFVCIsInJlcGxhY2VYUmFuZ2UiLCJYUkFOR0VMT09TRSIsIlhSQU5HRSIsImd0bHQiLCJ4TSIsInhtIiwieHAiLCJhbnlYIiwiU1RBUiIsIkdURTBQUkUiLCJHVEUwIiwiaW5jUHIiLCIkMCIsImZyb20iLCJmTSIsImZtIiwiZnAiLCJmcHIiLCJmYiIsInRvIiwidE0iLCJ0bSIsInRwIiwidHByIiwidGIiLCJwcmVyZWxlYXNlIiwiYWxsb3dlZCIsIm1ham9yIiwibWlub3IiLCJwYXRjaCIsIk1BWF9MRU5HVEgiLCJjb21wYXJlSWRlbnRpZmllcnMiLCJMT09TRSIsIkZVTEwiLCJudW0iLCJidWlsZCIsImNvbXBhcmVNYWluIiwiY29tcGFyZVByZSIsInJlbGVhc2UiLCJpZGVudGlmaWVyIiwiaW5jIiwiY2xlYW4iLCJuZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwib3AiLCJjb2VyY2UiLCJydGwiLCJDT0VSQ0UiLCJDT0VSQ0VSVEwiLCJjb21wYXJlQnVpbGQiLCJ2ZXJzaW9uQSIsInZlcnNpb25CIiwiY29tcGFyZSIsImNvbXBhcmVMb29zZSIsInZlcnNpb24xIiwidmVyc2lvbjIiLCJ2MSIsInYyIiwiaGFzUHJlIiwicHJlZml4IiwiZGVmYXVsdFJlc3VsdCIsInBhcnNlZCIsInJjb21wYXJlIiwicnNvcnQiLCJzYXRpc2ZpZXMiLCJ2YWxpZCIsImludGVybmFsUmUiLCJzcmMiLCJTRU1WRVJfU1BFQ19WRVJTSU9OIiwicmNvbXBhcmVJZGVudGlmaWVycyIsInRvQ29tcGFyYXRvcnMiLCJtYXhTYXRpc2Z5aW5nIiwibWluU2F0aXNmeWluZyIsIm1pblZlcnNpb24iLCJ2YWxpZFJhbmdlIiwib3V0c2lkZSIsImd0ciIsImx0ciIsInNpbXBsaWZ5UmFuZ2UiLCJzdWJzZXQiLCJNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIIiwiZW52IiwiTk9ERV9ERUJVRyIsIm51bWVyaWMiLCJhbnVtIiwiYm51bSIsIm9wdHMiLCJyZWR1Y2UiLCJvIiwiY3JlYXRlVG9rZW4iLCJpc0dsb2JhbCIsIk5VTUVSSUNJREVOVElGSUVSIiwiTlVNRVJJQ0lERU5USUZJRVJMT09TRSIsIk5PTk5VTUVSSUNJREVOVElGSUVSIiwiUFJFUkVMRUFTRUlERU5USUZJRVIiLCJQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFIiwiQlVJTERJREVOVElGSUVSIiwiTUFJTlZFUlNJT04iLCJQUkVSRUxFQVNFIiwiQlVJTEQiLCJGVUxMUExBSU4iLCJNQUlOVkVSU0lPTkxPT1NFIiwiUFJFUkVMRUFTRUxPT1NFIiwiTE9PU0VQTEFJTiIsIlhSQU5HRUlERU5USUZJRVIiLCJYUkFOR0VJREVOVElGSUVSTE9PU0UiLCJHVExUIiwiWFJBTkdFUExBSU4iLCJYUkFOR0VQTEFJTkxPT1NFIiwiTE9ORVRJTERFIiwiTE9ORUNBUkVUIiwicjEiLCJyMiIsInZlcnNpb25zIiwibWF4U1YiLCJyYW5nZU9iaiIsIm1pblNWIiwibWludmVyIiwic2V0TWluIiwiY29tcHZlciIsImhpbG8iLCJndGZuIiwibHRlZm4iLCJsdGZuIiwiZWNvbXAiLCJpbmNsdWRlZCIsInJhbmdlcyIsInNpbXBsaWZpZWQiLCJvcmlnaW5hbCIsInN1YiIsImRvbSIsInNhd05vbk51bGwiLCJPVVRFUiIsInNpbXBsZVN1YiIsInNpbXBsZURvbSIsImlzU3ViIiwic2ltcGxlU3Vic2V0IiwiZXFTZXQiLCJoaWdoZXJHVCIsImxvd2VyTFQiLCJndGx0Q29tcCIsImhpZ2hlciIsImxvd2VyIiwiaGFzRG9tTFQiLCJoYXNEb21HVCIsIm5lZWREb21MVFByZSIsIm5lZWREb21HVFByZSIsImdldFJhbmRvbVZhbHVlcyIsInJuZHM4Iiwicm5nIiwiY3J5cHRvIiwibXNDcnlwdG8iLCJieXRlVG9IZXgiLCJ1dWlkIiwidjQiLCJidWYiLCJybmRzIiwicmFuZG9tIiwiUkVHRVgiLCJpdGVyYXRvciIsIk5vZGUiLCJwdXNoTm9kZSIsInJlcyIsImZvckVhY2hSZXZlcnNlIiwiZ2V0UmV2ZXJzZSIsIm1hcFJldmVyc2UiLCJpbml0aWFsIiwiYWNjIiwicmVkdWNlUmV2ZXJzZSIsInRvQXJyYXlSZXZlcnNlIiwic2xpY2VSZXZlcnNlIiwiZGVsZXRlQ291bnQiLCJpbnNlcnQiLCJyZXZlcnNlIiwiaW5zZXJ0ZWQiLCJhZGRUb0RhdGUiLCJBZGRQcm9qZWN0TW9kYWwiLCJBZGRUYXNrTW9kYWwiLCJDb25maXJtTW9kYWwiLCJEYXRhTW9kYWwiLCJGaWx0ZXJNZW51IiwiSW5mb01vZGFsIiwiTW9kYWxTdGFjayIsIlBvcHVwTWVudSIsIlByb2plY3QiLCJQcm9qZWN0TGlzdCIsIlJlY3VycmluZ0RhdGUiLCJTZXR0aW5ncyIsIlNldHRpbmdzTW9kYWwiLCJUYXNrIiwiVGFza0Rpc3BsYXkiLCJUYXNrTGlzdCIsImZvcm1hdERhdGUiLCJjcmVhdGVJY29uQnV0dG9uIiwiY2xlYXJEYXRhIiwiZm9yRWFjaERhdGFJdGVtIiwiZ2VuZXJhdGVGaWxlIiwiZ2V0RmlsZUV4dGVuc2lvbiIsInBhcnNlQ3N2IiwicmVtb3ZlRGF0YSIsInJldHJpZXZlRGF0YSIsInN0b3JlRGF0YSIsIkFQUF9OQU1FIiwiQVBQX0FVVEhPUiIsIlBBQ0tBR0VfQVVUSE9SX05BTUUiLCJBUFBfQVVUSE9SX1dFQlNJVEUiLCJQQUNLQUdFX0FVVEhPUl9XRUJTSVRFIiwiQVBQX0NPUFlSSUdIVF9ZRUFSUyIsIkFQUF9WRVJTSU9OIiwiUEFDS0FHRV9WRVJTSU9OIiwiQVBQX1NUT1JBR0VfUFJFRklYIiwiUEFDS0FHRV9OQU1FIiwiTkFSUk9XX0xBWU9VVF9DVVRPRkYiLCJwcml2YXRlTWVtYmVycyIsImFkZFJhbmRvbURhdGEiLCJpbnN0YW5jZSIsInRhc2tDb3VudCIsInByb2pDb3VudCIsImdldFJhbmRvbSIsInBhc3NDaGVjayIsInByb2JhYmlsaXR5Iiwic2VudGVuY2VzIiwicmFuZG9tU2VudGVuY2UiLCJyYW5kb21EYXRlIiwicmFuZG9tUmVjdXJyZW5jZSIsImludGVydmFsTGVuZ3RoIiwic3RhcnREYXRlIiwiYmFzZU9uQ29tcGxldGlvbiIsInByaXZhdGVzIiwicHJvamVjdHMiLCJwcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJhZGRQcm9qZWN0IiwicmFuZG9tUHJvamVjdCIsInRhc2siLCJkdWVEYXRlIiwiY29tcGxldGlvbkRhdGUiLCJyZWN1cnJpbmdEYXRlIiwidGFza3MiLCJhZGRUYXNrIiwib3BlblNpZGVQYW5lbCIsInNpZGVQYW5lbCIsImNsYXNzTGlzdCIsInJlbW92ZSIsInJlc2l6ZXIiLCJjbG9zZVNpZGVQYW5lbCIsInRvZ2dsZVNpZGVQYW5lbCIsImNsb3NlZCIsInRvZ2dsZSIsInVwZGF0ZU1haW5QYW5lbE1lbnUiLCJjdXJyZW50RmlsdGVyIiwiZ3JvdXAiLCJmaWx0ZXJPcHRpb25zIiwic2V0dGluZ3MiLCJnZXRGaWx0ZXJPcHRpb25zIiwiR1JPVVBfSUNPTiIsIlNPUlRfSUNPTiIsImdyb3VwQnkiLCJzb3J0QnkiLCJzb3J0RGVzY2VuZGluZyIsInNob3dDb21wbGV0ZWQiLCJvcHRpb25JdGVtcyIsImxhYmVsIiwiaWNvblR5cGUiLCJncm91cEJ5SXRlbXMiLCJzb3J0QnlJdGVtcyIsIm1lbnVJdGVtcyIsIm1haW5QYW5lbE1lbnUiLCJzZXRNZW51SXRlbXMiLCJ1cGRhdGVNYWluSGVhZGluZyIsImhlYWRpbmciLCJzdWJoZWFkaW5nIiwiaGVhZGluZ0VsZW0iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3ViaGVhZGluZ0VsZW0iLCJ0ZXh0Q29udGVudCIsInN0eWxlIiwiZGlzcGxheSIsInVwZGF0ZU1haW5QYW5lbCIsImRpc3BsYXlPcHRpb25zIiwicmVzZXRTY3JvbGwiLCJkYXRlRm9ybWF0IiwidG9kYXlFbmQiLCJyZXF1aXJlRHVlRGF0ZSIsImVuZERhdGUiLCJvdXRwdXRQYXR0ZXJuIiwic3RhcnRTdHIiLCJlbmRTdHIiLCJnZXRQcm9qZWN0IiwiY29udmVydFN0cmluZ1RvUHJpb3JpdHkiLCJjb252ZXJ0UHJpb3JpdHlUb1ByZXR0eVN0cmluZyIsImNvbXBsZXRlZCIsInRhc2tEaXNwbGF5IiwidXBkYXRlIiwidXBkYXRlUHJvamVjdEZpbHRlcnMiLCJzZWxlY3Rpb24iLCJmaWx0ZXJNZW51IiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsRmlsdGVycyIsImFkZEZpbHRlciIsImhhc0ZpbHRlciIsInNlbGVjdEZpbHRlciIsImV4cG9ydFRvSnNvbiIsIm5ld2xpbmVTZXF1ZW5jZSIsImV4cG9ydFRvQ3N2IiwidG9Dc3YiLCJwcm9qZWN0TGlzdCIsImltcG9ydEZyb21Kc29uIiwidGFza0NvdW50cyIsImFkZGVkIiwidXBkYXRlZCIsImZhaWxlZCIsInRvdGFsIiwicHJvamVjdENvdW50cyIsImVycm9ycyIsImFwcCIsInN1Y2Nlc3NmdWwiLCJTeW50YXhFcnJvciIsImltcG9ydEZyb21Dc3YiLCJwYXJzZWREYXRhIiwiaW1wb3J0RnJvbUZpbGUiLCJmaWxlRXh0IiwiY291bnRzIiwiZGVsZXRlQWxsRGF0YSIsInJlc2V0VG9EZWZhdWx0IiwiZGVsZXRlQWxsIiwic2hvd0NvbmZpcm1hdGlvbiIsIm9uQ29uZmlybSIsIm9uQ2FuY2VsIiwibW9kYWwiLCJjb25maXJtIiwiY2FuY2VsIiwibW9kYWxTdGFjayIsInNob3dNb2RhbCIsInNob3dBZGRUYXNrTW9kYWwiLCJ0YXNrSWQiLCJwcm9qZWN0SWQiLCJuZXdQcm9qZWN0Iiwic2hvd0FkZFByb2plY3RNb2RhbCIsInByb2plY3RUb1VwZGF0ZSIsIm5ld0lkIiwidXBkYXRlUHJvamVjdCIsInNob3dTZXR0aW5nc01vZGFsIiwic2hvd0RhdGFNb2RhbCIsImltcG9ydERhdGEiLCJjb250YWluZXIiLCJjcmVhdGVFbGVtZW50Iiwic3RhdHVzTXNnIiwiYXBwZW5kQ2hpbGQiLCJlcnJvckxpc3QiLCJsaXN0SXRlbSIsImluZm9Nb2RhbCIsInRpdGxlIiwiZXhwb3J0RGF0YSIsImZpbGVUeXBlIiwiZmlsZU9wdGlvbnMiLCJoYW5kbGVNYWluUGFuZWxNZW51U2VsZWN0aW9uIiwiaXRlbUlkIiwibmVlZFBhbmVsVXBkYXRlIiwibmVlZEZpbHRlck9wdGlvblVwZGF0ZSIsIm1vZGFsT3B0aW9ucyIsImNsZWFyUHJvamVjdCIsImRlbGV0ZVByb2plY3QiLCJzZXRGaWx0ZXJPcHRpb25zIiwiY29tcGxldGVUYXNrIiwidGFza0xpc3QiLCJnZXRUYXNrIiwiYmFzZURhdGUiLCJuZXdEdWVEYXRlIiwiZ2V0TmV4dE9jY3VycmVuY2UiLCJtYXJrQ29tcGxldGUiLCJtYXJrSW5jb21wbGV0ZSIsImFkdmFuY2UiLCJ1cGRhdGVUYXNrIiwiaGFuZGxlVGFza1VwZGF0ZSIsIm5lZWRVcGRhdGUiLCJkZWxldGVUYXNrIiwiaGFuZGxlRmlsdGVyQ2hhbmdlIiwiZXZlbnQiLCJncm91cElkIiwiZmlsdGVySWQiLCJoYW5kbGVVc2VyTWVudVNlbGVjdGlvbiIsImluaXRpYWxpemVTdG9yYWdlIiwic3RvcmFnZU1ldGhvZCIsImxvYWRBbGxTdG9yYWdlRGF0YSIsImRvdEluZGV4IiwiYWRkT3JVcGRhdGVUYXNrIiwiZnJvbUpzb24iLCJhZGRPclVwZGF0ZVByb2plY3QiLCJzZXRTZXR0aW5nIiwic3RvcmVBbGxEYXRhIiwidXBkYXRlU3RvcmFnZSIsImV2ZW50RGF0YSIsImV2ZW50VHlwZSIsImNyZWF0ZUZpbHRlck1lbnUiLCJmaWx0ZXJHcm91cHMiLCJmaWx0ZXJzIiwiYWRkR3JvdXBJY29uQnV0dG9uIiwiY2FsbGJhY2siLCJjcmVhdGVIZWFkZXIiLCJwYXJlbnQiLCJoZWFkZXIiLCJ0aXRsZUNvbnRhaW5lciIsInRvb2xDb250YWluZXIiLCJjcmVhdGVTaWRlUGFuZWwiLCJjcmVhdGVSZXNpemVyIiwicHJldmVudERlZmF1bHQiLCJidXR0b24iLCJjcmVhdGVNYWluUGFuZWwiLCJtYWluUGFuZWwiLCJoZWFkaW5nQ29udGFpbmVyIiwibWVudSIsImNsb3NlSWZTY3JvbGxlZCIsImljb25Db250YWluZXIiLCJ0YXNrRGlzcGxheU9wdGlvbnMiLCJ0YXNrQ2FsbGJhY2siLCJjcmVhdGVGb290ZXIiLCJmb290ZXIiLCJjb3B5cmlnaHQiLCJpbm5lckhUTUwiLCJjcmVhdGVQYWdlRWxlbWVudHMiLCJhcHBDb250YWluZXIiLCJtaWRkbGVDb250YWluZXIiLCJBcHAiLCJuYXJyb3dTY3JlZW4iLCJ3aW5kb3ciLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImV4cGFuZEdyb3VwIiwibWVudVNlbGVjdG9yIiwibWVudUljb24iLCJxdWVyeVNlbGVjdG9yIiwidXNlck1lbnUiLCJ1c2VySWNvbiIsIm9wZW4iLCJyZWZlcmVuY2VFbGVtZW50IiwibWFpblBhbmVsSGVhZGVyIiwiYWRkVGFza0ljb24iLCJtb3JlSWNvbiIsInByb2pDYWxsYmFjayIsInNldHRpbmdzQ2FsbGJhY2siLCJGT0NVU0FCTEVfU0VMRUNUT1IiLCJDb2xsYXBzaWJsZSIsInJlZmVyZW5jZU5vZGUiLCJpbm5lckNvbnRhaW5lciIsImluc2VydEJlZm9yZSIsImNvbGxhcHNlZCIsImNvbGxhcHNlIiwiZXhwYW5kIiwicmVtb3ZlQXR0cmlidXRlIiwicXVlcnlTZWxlY3RvckFsbCIsImVsZW0iLCJzZXRBdHRyaWJ1dGUiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJjcmVhdGVGb3JtQ29udHJvbCIsIk1PTlRIUyIsInVwZGF0ZURheUdyaWQiLCJkYXlHcmlkIiwiZGlzcGxheWVkWWVhciIsImRpc3BsYXllZE1vbnRoIiwic2VsZWN0ZWQiLCJtb250aFN0YXJ0IiwiZGF5TGFiZWwiLCJkYXlFbGVtIiwiZGF0YXNldCIsInVwZGF0ZUlucHV0cyIsIm1vbnRoSW5wdXQiLCJ5ZWFySW5wdXQiLCJjcmVhdGVGb3JtRWxlbWVudHMiLCJtb250aFllYXJDb250YWluZXIiLCJzcGFjZXIiLCJidXR0b25Db250YWluZXIiLCJiYWNrQnV0dG9uIiwidG9kYXlCdXR0b24iLCJmb3J3YXJkQnV0dG9uIiwiZ3JpZCIsImdvVG9QcmV2aW91c01vbnRoIiwiZ29Ub1RoaXNNb250aCIsImdvVG9OZXh0TW9udGgiLCJ5ZWFyTGlzdGVuZXIiLCJpc0ludGVnZXIiLCJjb250YWlucyIsIkRhdGVQaWNrZXIiLCJJQ09OX0VYUEFOREVEIiwiSUNPTl9DT0xMQVBTRUQiLCJnZXRHcm91cEVsZW1lbnRzIiwiZWxlbWVudHMiLCJncm91cEVsZW1lbnRzIiwiZ2V0RmlsdGVySXRlbUVsZW1lbnQiLCJmaWx0ZXJJdGVtcyIsInNpbGVudENsZWFyU2VsZWN0aW9uIiwic2VsZWN0ZWRGaWx0ZXIiLCJncm91cHMiLCJldmVudEVtaXR0ZXIiLCJhZGRHcm91cCIsImdyb3VwQ29udGFpbmVyIiwiYXJyb3ciLCJ0ZXh0IiwiY29sbGFwc2libGUiLCJsaXN0Q29udGFpbmVyIiwiZXhwYW5kSWNvbiIsImZpbHRlckxpc3QiLCJ0b2dnbGVHcm91cCIsImZpbHRlckxhYmVsIiwibGFiZWxFbGVtIiwiY291bnRFbGVtIiwiY2xlYXJTZWxlY3Rpb24iLCJyZW1vdmVDaGlsZCIsImNvbGxhcHNlR3JvdXAiLCJaX0lOREVYX1NUQVJUIiwiWl9JTkRFWF9TVEVQIiwiWl9JTkRFWF9PVkVSTEFZX1NURVAiLCJnZXRaSW5kZXgiLCJ1cGRhdGVPdmVybGF5IiwibW9kYWxzIiwiekluZGV4Iiwib3ZlcmxheSIsImhpZGVCYWNrZ3JvdW5kIiwidG9IaWRlIiwiYmFja2dyb3VuZCIsIndyYXBwZXIiLCJvbGRUYWJJbmRleCIsInRhYkluZGV4IiwiaGFzQXR0cmlidXRlIiwiZWxlbWVudCIsInJlc3RvcmVCYWNrZ3JvdW5kIiwidG9SZXN0b3JlIiwiYm9keSIsImNhbmNlbE1vZGFsIiwib2xkQWN0aXZlIiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJ0aXRsZUJhciIsInRpdGxlVGV4dCIsImNsb3NlSWNvbiIsImFkZENvbnRlbnQiLCJjYW5jZWxCdXR0b24iLCJub0NhbmNlbEJ1dHRvbiIsImNhbmNlbExhYmVsIiwib2theUJ1dHRvbiIsImNvbmZpcm1MYWJlbCIsImNvbmZpcm1Nb2RhbCIsIm1vZGFsSW5mbyIsImluaXRGb2N1cyIsImZvY3VzIiwiY2xvc2VNb2RhbCIsImluaXRGb3JtVmFsdWVzIiwiY29udHJvbHMiLCJtb2RlIiwiY2FsbGJhY2tzIiwiY29udGFpbmVyVHlwZSIsImxhYmVsVHlwZSIsInJvd3MiLCJjb2xzIiwicmVwb3J0VmFsaWRpdHkiLCJEYXRlUGlja2VyTW9kYWwiLCJSZWN1cnJlbmNlTW9kYWwiLCJjcmVhdGVEYXRlSW5wdXRGaWVsZCIsInVwZGF0ZVByb2plY3RzIiwicHJvamVjdEl0ZW1zIiwic2VsZWN0Qm94Iiwib3B0RWxlbSIsImlzRGVmYXVsdCIsImludGVydmFsVW5pdCIsImN1c3RvbVJlY3VycmVuY2UiLCJwcmlvcml0eVN0cmluZyIsImNvbnZlcnRQcmlvcml0eVRvU3RyaW5nIiwicGlja0R1ZURhdGUiLCJpbnB1dFBhdHRlcm5zIiwic2V0Q3VzdG9tVmFsaWRpdHkiLCJhZGRMaXN0ZW5lcnMiLCJyZWN1cnJlbmNlVmFsdWUiLCJwcm9jZXNzUmVjdXJyZW5jZSIsInJlY3VycmVuY2UiLCJzZWxlY3RvciIsImxhc3RDaGlsZCIsImRhdGVGb3JtYXRTdHIiLCJ0b1N0cmluZ1ZlcmJvc2UiLCJjYW5jZWxSZWN1cnJlbmNlIiwiZGF0ZUlucHV0IiwicHJvamVjdFZhbHVlIiwidmlzdWFsUGF0dGVybiIsImxvb2t1cERhdGVGb3JtYXQiLCJkYXRlQ29udGFpbmVyIiwiZGF0ZUxhYmVsIiwiaHRtbEZvciIsInBsYWNlaG9sZGVyIiwiY3JlYXRpb25EYXRlIiwiaW5pdEZvcm1Db250cm9scyIsImNvbmZpcm1Cb3giLCJlcnJvck1lc3NhZ2UiLCJFeHBvcnRNb2RhbCIsInJlYWRGaWxlIiwiZG9JbXBvcnQiLCJmaWxlIiwiZmlsZUluZm8iLCJkb0V4cG9ydCIsInNldFRpbWVvdXQiLCJkb0RlbGV0ZSIsImltcG9ydEJ1dHRvbiIsImZpbGVTZWxlY3RvciIsImNsaWNrIiwiZXhwb3J0QnV0dG9uIiwiZGVsZXRlQnV0dG9uIiwiZmlsZXMiLCJjbG9zZSIsImFkZENvbnRhaW5lciIsImFkZEhlYWRpbmciLCJhZGRCdXR0b24iLCJhY2NlcHQiLCJwaWNrZXIiLCJleHBvcnRKc29uIiwiZXhwb3J0Q3N2IiwicmFkaW9MYWJlbCIsImNoZWNrZWQiLCJwYXJhZ3JhcGhzIiwicGFyYWdyYXBoIiwicEVsZW0iLCJnZXRXZWVrZGF5TmFtZSIsImdldE1vbnRoTmFtZSIsImNyZWF0ZVRvZ2dsZUJ1dHRvbiIsIlVOSVRTIiwic2luZ3VsYXIiLCJwbHVyYWwiLCJjcmVhdGVXZWVrQ29udGV4dEZvcm0iLCJvcHRpb25Db250YWluZXIiLCJjcmVhdGVNb250aENvbnRleHRGb3JtIiwic2VsZWN0SXRlbXMiLCJjcmVhdGVZZWFyQ29udGV4dEZvcm0iLCJnZXRDb250cm9sIiwiaWRTdWZmaXgiLCJjb250YWluZXJzIiwid2Vla09wdGlvbnMiLCJtb250aE9wdGlvbnMiLCJ5ZWFyT3B0aW9ucyIsImluaXRpYWxSZWN1cnJlbmNlIiwiZGF5c09mV2VlayIsIndlZWtOdW1iZXIiLCJ3ZWVrU2VsZWN0IiwiZGF5U2VsZWN0IiwibW9udGhTZWxlY3QiLCJtYXhDb3VudCIsIm9uV2Vla2VuZCIsImRheUJ1dHRvbiIsIm1vbnRoRGF5U2VsZWN0IiwibW9udGhXZWVrTnVtU2VsZWN0IiwibW9udGhXZWVrRGF5U2VsZWN0IiwieWVhck1vbnRoU2VsZWN0IiwieWVhckRheVNlbGVjdCIsInBpY2tEYXRlIiwiZmllbGQiLCJ1cGRhdGVDb250ZXh0Q29udGFpbmVyIiwiY29udGV4dENvbnRhaW5lciIsImZpcnN0Q2hpbGQiLCJmaXJlRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJsZW5ndGhTZWxlY3QiLCJ1bml0U2VsZWN0Iiwib3B0aW9uIiwicmFkaW9TZWxlY3RvciIsIndlZWtUeXBlTGlzdGVuZXIiLCJidXR0b25zIiwiZW5hYmxlIiwiZGlzYWJsZWQiLCJyYWRpbyIsIm1vbnRoVHlwZUxpc3RlbmVyIiwid2Vla051bWJlclNlbGVjdCIsIndlZWtEYXlTZWxlY3QiLCJ5ZWFyVHlwZUxpc3RlbmVyIiwic2VsZWN0Qm94ZXMiLCJzZWxlY3QiLCJ5ZWFyTW9udGhMaXN0ZW5lciIsIm9sZFZhbHVlIiwibWF4RGF5cyIsIm9wdCIsImVuZENvdW50IiwiZW5kUmFkaW9TZWxlY3RvciIsImVuZFR5cGVMaXN0ZW5lciIsImRhdGVCdXR0b24iLCJjb3VudElucHV0IiwidXNlRGF0ZUNoZWNrYm94Iiwibm9XZWVrZW5kQ2hlY2tib3giLCJkYXRlTGlzdGVuZXIiLCJpbmxpbmUiLCJsZW5ndGhJbnB1dCIsImdldERheUluZGV4IiwiaXNMb2NhbFN0b3JhZ2VTdXBwb3J0ZWQiLCJjb25maXJtTm9TdG9yYWdlIiwic2F2ZU5ldmVyIiwic2F2ZUxvY2FsIiwiZGVsZXRlT2xkIiwiZGVsZXRlQWZ0ZXIiLCJkZWxldGVBZnRlckxhYmVsIiwic2V0RGF0ZUZvcm1hdCIsInBvc2l0aW9uTWVudSIsIm9mZnNldFdpZHRoIiwibGVmdCIsInRvcCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJNQVJHSU4iLCJib2R5V2lkdGgiLCJib2R5SGVpZ2h0Iiwic2VsZWN0SXRlbSIsImdldEl0ZW0iLCJmb2N1c0l0ZW0iLCJhY3RpdmVJdGVtIiwiaGFuZGxlRXZlbnQiLCJhY3RpdmUiLCJpdGVtQ291bnQiLCJzY3JvbGxUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2Nyb2xsVGFyZ2V0IiwiZXZlbnRMaXN0ZW5lciIsImljb24iLCJpc09wZW4iLCJnZW5lcmF0ZVV1aWQiLCJnZXRKc29uVHlwZSIsImlzVXVpZFZhbGlkIiwidmFsaWRhdGVWYWx1ZSIsIm5lZWRTb3J0IiwiaW5zZXJ0QXQiLCJoYXNQcm9qZWN0IiwiaGFuZGxlRXJyb3IiLCJlcnJvclR5cGUiLCJtc2dQcmVmaXgiLCJtc2ciLCJleHBlY3RlZFR5cGUiLCJ2YWx1ZU5hbWUiLCJwcm9qZWN0T3B0aW9ucyIsImVycm9yQ2FsbGJhY2siLCJyZXF1aXJlVXVpZCIsImNvbHVtbnMiLCJjc3ZSZWNvcmQiLCJjc3ZJbmRleCIsImlzRW50cnlFcXVhbCIsInJpZ2h0IiwiaXNEYXRlQmVmb3JlIiwicGFyc2VJc29EYXRlVGltZSIsIm5leHREYXlPZldlZWsiLCJkYXlzVG9BZGQiLCJjdXJyZW50IiwibmV4dERheU9mTW9udGgiLCJjdXJyZW50TW9udGgiLCJuZXh0TW9udGgiLCJuZXh0V2Vla09mTW9udGgiLCJ3ZWVrRGF5IiwiZmluZERheSIsIm5leHREYXlPZlllYXIiLCJkYXRlT2ZDdXJyZW50WWVhciIsImRhdGVPZk5leHRZZWFyIiwicmVmZXJlbmNlIiwiaXNCZWZvcmVTdGFydCIsImZvcndhcmQiLCJkZWYiLCJzdHJWYWx1ZSIsIndlZWtTdHIiLCJkYXlTdHIiLCJtb250aFN0ciIsImRhdGVTdHIiLCJjb252ZXJ0RGF0ZSIsImdldERhdGVGb3JtYXQiLCJzdGFydHNXaXRoIiwidmFsaWRTZXR0aW5nIiwic2V0dGluZ0xpc3QiLCJncm91cEtleXMiLCJzZXR0aW5nIiwiZ2V0U2V0dGluZyIsIm1ldGhvZCIsImZpbHRlckdyb3VwIiwib2xkT3B0aW9ucyIsIm5ld09wdGlvbnMiLCJleHBlY3RlZFZhbHVlcyIsInJlcXVpcmVJbnRlZ2VyIiwicHJvY2Vzc0dyb3VwIiwiZm9ybWF0T3B0cyIsInRva2VuU3R5bGUiLCJmdWxsWWVhciIsInBhZE1vbnRocyIsInBhZERheXMiLCJCb29sZWFuIiwicHJpb3JpdHlTdHIiLCJDSEVDS0VEX0lDT04iLCJVTkNIRUNLRURfSUNPTiIsIlNUQU5EQVJEX01FTlVfSVRFTVMiLCJQUk9KRUNUX01FTlVfSVRFTVMiLCJpc1NhbWVHcm91cCIsInRhc2sxIiwidGFzazIiLCJjcmVhdGVMaXN0IiwiaXRlbUVsZW0iLCJpc0NvbXBsZXRlIiwiY2hlY2tCdXR0b24iLCJpbmZvQ29udGFpbmVyIiwibmFtZUVsZW0iLCJkZXNjRWxlbSIsImRldGFpbHNDb250YWluZXIiLCJhZGREZXRhaWwiLCJzdHlsZUNsYXNzIiwiaGFzQ2hpbGROb2RlcyIsImNvbW1hIiwiZGV0YWlsIiwicmVjdXJyZW5jZVN0ciIsImVkaXRCdXR0b24iLCJtb3JlQnV0dG9uIiwidGFza01lbnUiLCJnZXRHcm91cEhlYWRpbmciLCJwYW5lbCIsImxpc3RPcHRpb25zIiwiZGVzY2VuZGluZyIsImNhc2VTZW5zaXRpdmUiLCJtaXNzaW5nTGFzdCIsInB1c2hTb3J0RmllbGQiLCJwcmV2VGFzayIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJhZGRUb01hcEFycmF5IiwiZmluZEluTWFwQXJyYXkiLCJyZW1vdmVGcm9tTWFwQXJyYXlCeSIsImZvcm1hdElzb0RhdGUiLCJnZXRNb250aEluZGV4IiwiZ2V0V2Vla2RheUluZGV4IiwiYXJyYXlUb0NzdlJlY29yZCIsInRhc2tzQnlEdWVEYXRlIiwidGFza3NCeVByb2plY3QiLCJ0YXNrc0J5UHJpb3JpdHkiLCJvbGRUYXNrIiwidXBkYXRlSW5kZXgiLCJvbGRLZXkiLCJuZXdLZXkiLCJwcm9qZWN0U3RyIiwidXBkYXRlZFRhc2tzIiwibG9va3VwVHlwZSIsImNvcHlUYXNrcyIsImRhdGVzIiwic3RhcnRLZXkiLCJlbmRLZXkiLCJsb3dJbmRleCIsImhpZ2hJbmRleCIsImxlZnRUYXNrIiwicmlnaHRUYXNrIiwiTEVTUyIsIk1PUkUiLCJsZWZ0TmFtZSIsInJpZ2h0TmFtZSIsImxlZnREYXRlIiwicmlnaHREYXRlIiwibGVmdFByb2oiLCJyaWdodFByb2oiLCJwcm9qZWN0RmllbGRzIiwiY3N2T3B0aW9ucyIsInRvSlNPTiIsImxpbmVzIiwiZmllbGRzIiwiYWxsb3dDb252ZXJzaW9uIiwidGFza09wdGlvbnMiLCJzdWNjZXNzQ2FsbGJhY2siLCJzZXRQcmlvcml0eSIsInJlY09wdGlvbnMiLCJjdXN0b21QcmVkaWNhdGUiLCJoYXNUYXNrIiwibmV3VGFzayIsImJlaGF2aW9yIiwidmFsaWRhdGVVdWlkIiwidXVpZFZlcnNpb24iLCJpc0RhdGVWYWxpZCIsImZpbmQiLCJyZW1vdmVGcm9tTWFwQXJyYXkiLCJmYWlsIiwiY29udmVydGVkVmFsdWUiLCJkZkZvcm1hdCIsImRmUGFyc2UiLCJXRUVLREFZUyIsIlJFRkVSRU5DRV9EQVRFIiwiZGF0ZVN0eWxlIiwidGltZVN0eWxlIiwiaG91clN5c3RlbSIsImhvdXIxMiIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsInBhcnRzIiwiZGF0ZVBhcnRzIiwidGltZVBhcnRzIiwicmVzb2x2ZWRPcHRpb25zIiwiaGFzRGF0ZSIsImhhc1RpbWUiLCJmb3JtYXRUb1BhcnRzIiwicGFkSG91cnMiLCJwYWRNaW51dGVzIiwicGFkU2Vjb25kcyIsInJlcGVhdCIsImZvcm1hdElzb0RhdGVUaW1lIiwiZGF5TG93ZXIiLCJtb250aExvd2VyIiwiY29udGFpbmVyVGFnIiwiZGVmYXVsdFNlbGVjdGVkIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwiY2hlY2thYmxlIiwiZGVmYXVsdENoZWNrZWQiLCJwbGFjZW1lbnQiLCJhY3RpdmVDbGFzcyIsImRlZmF1bHRBY3RpdmUiLCJzdG9yYWdlU3VwcG9ydGVkIiwic3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsInRlc3RJdGVtIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJET01FeGNlcHRpb24iLCJmdWxsS2V5IiwibG9jYWxLZXkiLCJpbmNsdWRlUHJlZml4Iiwibm9WYWx1ZSIsImZpbGVuYW1lIiwiQmxvYiIsInVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImxpbmtFbGVtIiwiaHJlZiIsImRvd25sb2FkIiwicmV2b2tlT2JqZWN0VVJMIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc1RleHQiLCJuZWVkUXVvdGVzIiwiY3VycmVudFJvdyIsImN1cnJlbnRGaWVsZCIsImNvbW1pdEZpZWxkIiwiY29tbWl0Um93IiwicXVvdGVkIiwicG9zIiwibGFzdENoYXIiLCJsYXN0SW5kZXhPZiIsInJ1biJdLCJzb3VyY2VSb290IjoiIn0=